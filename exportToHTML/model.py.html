<html>
<head>
<title>model.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
model.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">types</span>
<span class="s0">import </span><span class="s1">weakref</span>

<span class="s0">from </span><span class="s1">.lock </span><span class="s0">import </span><span class="s1">allocate_lock</span>
<span class="s0">from </span><span class="s1">.error </span><span class="s0">import </span><span class="s1">CDefError</span><span class="s0">, </span><span class="s1">VerificationError</span><span class="s0">, </span><span class="s1">VerificationMissing</span>

<span class="s2"># type qualifiers</span>
<span class="s1">Q_CONST    = </span><span class="s3">0x01</span>
<span class="s1">Q_RESTRICT = </span><span class="s3">0x02</span>
<span class="s1">Q_VOLATILE = </span><span class="s3">0x04</span>

<span class="s0">def </span><span class="s1">qualify(quals</span><span class="s0">, </span><span class="s1">replace_with):</span>
    <span class="s0">if </span><span class="s1">quals &amp; Q_CONST:</span>
        <span class="s1">replace_with = </span><span class="s4">' const ' </span><span class="s1">+ replace_with.lstrip()</span>
    <span class="s0">if </span><span class="s1">quals &amp; Q_VOLATILE:</span>
        <span class="s1">replace_with = </span><span class="s4">' volatile ' </span><span class="s1">+ replace_with.lstrip()</span>
    <span class="s0">if </span><span class="s1">quals &amp; Q_RESTRICT:</span>
        <span class="s2"># It seems that __restrict is supported by gcc and msvc.</span>
        <span class="s2"># If you hit some different compiler, add a #define in</span>
        <span class="s2"># _cffi_include.h for it (and in its copies, documented there)</span>
        <span class="s1">replace_with = </span><span class="s4">' __restrict ' </span><span class="s1">+ replace_with.lstrip()</span>
    <span class="s0">return </span><span class="s1">replace_with</span>


<span class="s0">class </span><span class="s1">BaseTypeByIdentity(object):</span>
    <span class="s1">is_array_type = </span><span class="s0">False</span>
    <span class="s1">is_raw_function = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">get_c_name(self</span><span class="s0">, </span><span class="s1">replace_with=</span><span class="s4">''</span><span class="s0">, </span><span class="s1">context=</span><span class="s4">'a C file'</span><span class="s0">, </span><span class="s1">quals=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s1">result = self.c_name_with_marker</span>
        <span class="s0">assert </span><span class="s1">result.count(</span><span class="s4">'&amp;'</span><span class="s1">) == </span><span class="s3">1</span>
        <span class="s2"># some logic duplication with ffi.getctype()... :-(</span>
        <span class="s1">replace_with = replace_with.strip()</span>
        <span class="s0">if </span><span class="s1">replace_with:</span>
            <span class="s0">if </span><span class="s1">replace_with.startswith(</span><span class="s4">'*'</span><span class="s1">) </span><span class="s0">and </span><span class="s4">'&amp;[' </span><span class="s0">in </span><span class="s1">result:</span>
                <span class="s1">replace_with = </span><span class="s4">'(%s)' </span><span class="s1">% replace_with</span>
            <span class="s0">elif not </span><span class="s1">replace_with[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">in </span><span class="s4">'[('</span><span class="s1">:</span>
                <span class="s1">replace_with = </span><span class="s4">' ' </span><span class="s1">+ replace_with</span>
        <span class="s1">replace_with = qualify(quals</span><span class="s0">, </span><span class="s1">replace_with)</span>
        <span class="s1">result = result.replace(</span><span class="s4">'&amp;'</span><span class="s0">, </span><span class="s1">replace_with)</span>
        <span class="s0">if </span><span class="s4">'$' </span><span class="s0">in </span><span class="s1">result:</span>
            <span class="s0">raise </span><span class="s1">VerificationError(</span>
                <span class="s4">&quot;cannot generate '%s' in %s: unknown type name&quot;</span>
                <span class="s1">% (self._get_c_name()</span><span class="s0">, </span><span class="s1">context))</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_get_c_name(self):</span>
        <span class="s0">return </span><span class="s1">self.c_name_with_marker.replace(</span><span class="s4">'&amp;'</span><span class="s0">, </span><span class="s4">''</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">has_c_name(self):</span>
        <span class="s0">return </span><span class="s4">'$' </span><span class="s0">not in </span><span class="s1">self._get_c_name()</span>

    <span class="s0">def </span><span class="s1">is_integer_type(self):</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">get_cached_btype(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist</span><span class="s0">, </span><span class="s1">can_delay=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">BType = ffi._cached_btypes[self]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s1">BType = self.build_backend_type(ffi</span><span class="s0">, </span><span class="s1">finishlist)</span>
            <span class="s1">BType2 = ffi._cached_btypes.setdefault(self</span><span class="s0">, </span><span class="s1">BType)</span>
            <span class="s0">assert </span><span class="s1">BType2 </span><span class="s0">is </span><span class="s1">BType</span>
        <span class="s0">return </span><span class="s1">BType</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s4">'&lt;%s&gt;' </span><span class="s1">% (self._get_c_name()</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_get_items(self):</span>
        <span class="s0">return </span><span class="s1">[(name</span><span class="s0">, </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s1">name)) </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self._attrs_]</span>


<span class="s0">class </span><span class="s1">BaseType(BaseTypeByIdentity):</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">return </span><span class="s1">(self.__class__ == other.__class__ </span><span class="s0">and</span>
                <span class="s1">self._get_items() == other._get_items())</span>

    <span class="s0">def </span><span class="s1">__ne__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">return not </span><span class="s1">self == other</span>

    <span class="s0">def </span><span class="s1">__hash__(self):</span>
        <span class="s0">return </span><span class="s1">hash((self.__class__</span><span class="s0">, </span><span class="s1">tuple(self._get_items())))</span>


<span class="s0">class </span><span class="s1">VoidType(BaseType):</span>
    <span class="s1">_attrs_ = ()</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.c_name_with_marker = </span><span class="s4">'void&amp;'</span>

    <span class="s0">def </span><span class="s1">build_backend_type(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist):</span>
        <span class="s0">return </span><span class="s1">global_cache(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s4">'new_void_type'</span><span class="s1">)</span>

<span class="s1">void_type = VoidType()</span>


<span class="s0">class </span><span class="s1">BasePrimitiveType(BaseType):</span>
    <span class="s0">def </span><span class="s1">is_complex_type(self):</span>
        <span class="s0">return False</span>


<span class="s0">class </span><span class="s1">PrimitiveType(BasePrimitiveType):</span>
    <span class="s1">_attrs_ = (</span><span class="s4">'name'</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">ALL_PRIMITIVE_TYPES = {</span>
        <span class="s4">'char'</span><span class="s1">:               </span><span class="s4">'c'</span><span class="s0">,</span>
        <span class="s4">'short'</span><span class="s1">:              </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'int'</span><span class="s1">:                </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'long'</span><span class="s1">:               </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'long long'</span><span class="s1">:          </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'signed char'</span><span class="s1">:        </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'unsigned char'</span><span class="s1">:      </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'unsigned short'</span><span class="s1">:     </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'unsigned int'</span><span class="s1">:       </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'unsigned long'</span><span class="s1">:      </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'unsigned long long'</span><span class="s1">: </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'float'</span><span class="s1">:              </span><span class="s4">'f'</span><span class="s0">,</span>
        <span class="s4">'double'</span><span class="s1">:             </span><span class="s4">'f'</span><span class="s0">,</span>
        <span class="s4">'long double'</span><span class="s1">:        </span><span class="s4">'f'</span><span class="s0">,</span>
        <span class="s4">'float _Complex'</span><span class="s1">:     </span><span class="s4">'j'</span><span class="s0">,</span>
        <span class="s4">'double _Complex'</span><span class="s1">:    </span><span class="s4">'j'</span><span class="s0">,</span>
        <span class="s4">'_Bool'</span><span class="s1">:              </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s2"># the following types are not primitive in the C sense</span>
        <span class="s4">'wchar_t'</span><span class="s1">:            </span><span class="s4">'c'</span><span class="s0">,</span>
        <span class="s4">'char16_t'</span><span class="s1">:           </span><span class="s4">'c'</span><span class="s0">,</span>
        <span class="s4">'char32_t'</span><span class="s1">:           </span><span class="s4">'c'</span><span class="s0">,</span>
        <span class="s4">'int8_t'</span><span class="s1">:             </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uint8_t'</span><span class="s1">:            </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'int16_t'</span><span class="s1">:            </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uint16_t'</span><span class="s1">:           </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'int32_t'</span><span class="s1">:            </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uint32_t'</span><span class="s1">:           </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'int64_t'</span><span class="s1">:            </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uint64_t'</span><span class="s1">:           </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'int_least8_t'</span><span class="s1">:       </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uint_least8_t'</span><span class="s1">:      </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'int_least16_t'</span><span class="s1">:      </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uint_least16_t'</span><span class="s1">:     </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'int_least32_t'</span><span class="s1">:      </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uint_least32_t'</span><span class="s1">:     </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'int_least64_t'</span><span class="s1">:      </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uint_least64_t'</span><span class="s1">:     </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'int_fast8_t'</span><span class="s1">:        </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uint_fast8_t'</span><span class="s1">:       </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'int_fast16_t'</span><span class="s1">:       </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uint_fast16_t'</span><span class="s1">:      </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'int_fast32_t'</span><span class="s1">:       </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uint_fast32_t'</span><span class="s1">:      </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'int_fast64_t'</span><span class="s1">:       </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uint_fast64_t'</span><span class="s1">:      </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'intptr_t'</span><span class="s1">:           </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uintptr_t'</span><span class="s1">:          </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'intmax_t'</span><span class="s1">:           </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'uintmax_t'</span><span class="s1">:          </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'ptrdiff_t'</span><span class="s1">:          </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'size_t'</span><span class="s1">:             </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s4">'ssize_t'</span><span class="s1">:            </span><span class="s4">'i'</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s0">assert </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.ALL_PRIMITIVE_TYPES</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.c_name_with_marker = name + </span><span class="s4">'&amp;'</span>

    <span class="s0">def </span><span class="s1">is_char_type(self):</span>
        <span class="s0">return </span><span class="s1">self.ALL_PRIMITIVE_TYPES[self.name] == </span><span class="s4">'c'</span>
    <span class="s0">def </span><span class="s1">is_integer_type(self):</span>
        <span class="s0">return </span><span class="s1">self.ALL_PRIMITIVE_TYPES[self.name] == </span><span class="s4">'i'</span>
    <span class="s0">def </span><span class="s1">is_float_type(self):</span>
        <span class="s0">return </span><span class="s1">self.ALL_PRIMITIVE_TYPES[self.name] == </span><span class="s4">'f'</span>
    <span class="s0">def </span><span class="s1">is_complex_type(self):</span>
        <span class="s0">return </span><span class="s1">self.ALL_PRIMITIVE_TYPES[self.name] == </span><span class="s4">'j'</span>

    <span class="s0">def </span><span class="s1">build_backend_type(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist):</span>
        <span class="s0">return </span><span class="s1">global_cache(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s4">'new_primitive_type'</span><span class="s0">, </span><span class="s1">self.name)</span>


<span class="s0">class </span><span class="s1">UnknownIntegerType(BasePrimitiveType):</span>
    <span class="s1">_attrs_ = (</span><span class="s4">'name'</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.c_name_with_marker = name + </span><span class="s4">'&amp;'</span>

    <span class="s0">def </span><span class="s1">is_integer_type(self):</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">build_backend_type(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;integer type '%s' can only be used after &quot;</span>
                                  <span class="s4">&quot;compilation&quot; </span><span class="s1">% self.name)</span>

<span class="s0">class </span><span class="s1">UnknownFloatType(BasePrimitiveType):</span>
    <span class="s1">_attrs_ = (</span><span class="s4">'name'</span><span class="s0">, </span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.c_name_with_marker = name + </span><span class="s4">'&amp;'</span>

    <span class="s0">def </span><span class="s1">build_backend_type(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;float type '%s' can only be used after &quot;</span>
                                  <span class="s4">&quot;compilation&quot; </span><span class="s1">% self.name)</span>


<span class="s0">class </span><span class="s1">BaseFunctionType(BaseType):</span>
    <span class="s1">_attrs_ = (</span><span class="s4">'args'</span><span class="s0">, </span><span class="s4">'result'</span><span class="s0">, </span><span class="s4">'ellipsis'</span><span class="s0">, </span><span class="s4">'abi'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">ellipsis</span><span class="s0">, </span><span class="s1">abi=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.args = args</span>
        <span class="s1">self.result = result</span>
        <span class="s1">self.ellipsis = ellipsis</span>
        <span class="s1">self.abi = abi</span>
        <span class="s2">#</span>
        <span class="s1">reprargs = [arg._get_c_name() </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">self.args]</span>
        <span class="s0">if </span><span class="s1">self.ellipsis:</span>
            <span class="s1">reprargs.append(</span><span class="s4">'...'</span><span class="s1">)</span>
        <span class="s1">reprargs = reprargs </span><span class="s0">or </span><span class="s1">[</span><span class="s4">'void'</span><span class="s1">]</span>
        <span class="s1">replace_with = self._base_pattern % (</span><span class="s4">', '</span><span class="s1">.join(reprargs)</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">abi </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">replace_with = replace_with[:</span><span class="s3">1</span><span class="s1">] + abi + </span><span class="s4">' ' </span><span class="s1">+ replace_with[</span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s1">self.c_name_with_marker = (</span>
            <span class="s1">self.result.c_name_with_marker.replace(</span><span class="s4">'&amp;'</span><span class="s0">, </span><span class="s1">replace_with))</span>


<span class="s0">class </span><span class="s1">RawFunctionType(BaseFunctionType):</span>
    <span class="s2"># Corresponds to a C type like 'int(int)', which is the C type of</span>
    <span class="s2"># a function, but not a pointer-to-function.  The backend has no</span>
    <span class="s2"># notion of such a type; it's used temporarily by parsing.</span>
    <span class="s1">_base_pattern = </span><span class="s4">'(&amp;)(%s)'</span>
    <span class="s1">is_raw_function = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">build_backend_type(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist):</span>
        <span class="s0">raise </span><span class="s1">CDefError(</span><span class="s4">&quot;cannot render the type %r: it is a function &quot;</span>
                        <span class="s4">&quot;type, not a pointer-to-function type&quot; </span><span class="s1">% (self</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">as_function_pointer(self):</span>
        <span class="s0">return </span><span class="s1">FunctionPtrType(self.args</span><span class="s0">, </span><span class="s1">self.result</span><span class="s0">, </span><span class="s1">self.ellipsis</span><span class="s0">, </span><span class="s1">self.abi)</span>


<span class="s0">class </span><span class="s1">FunctionPtrType(BaseFunctionType):</span>
    <span class="s1">_base_pattern = </span><span class="s4">'(*&amp;)(%s)'</span>

    <span class="s0">def </span><span class="s1">build_backend_type(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist):</span>
        <span class="s1">result = self.result.get_cached_btype(ffi</span><span class="s0">, </span><span class="s1">finishlist)</span>
        <span class="s1">args = []</span>
        <span class="s0">for </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">self.args:</span>
            <span class="s1">args.append(tp.get_cached_btype(ffi</span><span class="s0">, </span><span class="s1">finishlist))</span>
        <span class="s1">abi_args = ()</span>
        <span class="s0">if </span><span class="s1">self.abi == </span><span class="s4">&quot;__stdcall&quot;</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">self.ellipsis:    </span><span class="s2"># __stdcall ignored for variadic funcs</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">abi_args = (ffi._backend.FFI_STDCALL</span><span class="s0">,</span><span class="s1">)</span>
                <span class="s0">except </span><span class="s1">AttributeError:</span>
                    <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">global_cache(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s4">'new_function_type'</span><span class="s0">,</span>
                            <span class="s1">tuple(args)</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">self.ellipsis</span><span class="s0">, </span><span class="s1">*abi_args)</span>

    <span class="s0">def </span><span class="s1">as_raw_function(self):</span>
        <span class="s0">return </span><span class="s1">RawFunctionType(self.args</span><span class="s0">, </span><span class="s1">self.result</span><span class="s0">, </span><span class="s1">self.ellipsis</span><span class="s0">, </span><span class="s1">self.abi)</span>


<span class="s0">class </span><span class="s1">PointerType(BaseType):</span>
    <span class="s1">_attrs_ = (</span><span class="s4">'totype'</span><span class="s0">, </span><span class="s4">'quals'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">totype</span><span class="s0">, </span><span class="s1">quals=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s1">self.totype = totype</span>
        <span class="s1">self.quals = quals</span>
        <span class="s1">extra = qualify(quals</span><span class="s0">, </span><span class="s4">&quot; *&amp;&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">totype.is_array_type:</span>
            <span class="s1">extra = </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% (extra.lstrip()</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">self.c_name_with_marker = totype.c_name_with_marker.replace(</span><span class="s4">'&amp;'</span><span class="s0">, </span><span class="s1">extra)</span>

    <span class="s0">def </span><span class="s1">build_backend_type(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist):</span>
        <span class="s1">BItem = self.totype.get_cached_btype(ffi</span><span class="s0">, </span><span class="s1">finishlist</span><span class="s0">, </span><span class="s1">can_delay=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">global_cache(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s4">'new_pointer_type'</span><span class="s0">, </span><span class="s1">BItem)</span>

<span class="s1">voidp_type = PointerType(void_type)</span>

<span class="s0">def </span><span class="s1">ConstPointerType(totype):</span>
    <span class="s0">return </span><span class="s1">PointerType(totype</span><span class="s0">, </span><span class="s1">Q_CONST)</span>

<span class="s1">const_voidp_type = ConstPointerType(void_type)</span>


<span class="s0">class </span><span class="s1">NamedPointerType(PointerType):</span>
    <span class="s1">_attrs_ = (</span><span class="s4">'totype'</span><span class="s0">, </span><span class="s4">'name'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">totype</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">quals=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s1">PointerType.__init__(self</span><span class="s0">, </span><span class="s1">totype</span><span class="s0">, </span><span class="s1">quals)</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.c_name_with_marker = name + </span><span class="s4">'&amp;'</span>


<span class="s0">class </span><span class="s1">ArrayType(BaseType):</span>
    <span class="s1">_attrs_ = (</span><span class="s4">'item'</span><span class="s0">, </span><span class="s4">'length'</span><span class="s1">)</span>
    <span class="s1">is_array_type = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">item</span><span class="s0">, </span><span class="s1">length):</span>
        <span class="s1">self.item = item</span>
        <span class="s1">self.length = length</span>
        <span class="s2">#</span>
        <span class="s0">if </span><span class="s1">length </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">brackets = </span><span class="s4">'&amp;[]'</span>
        <span class="s0">elif </span><span class="s1">length == </span><span class="s4">'...'</span><span class="s1">:</span>
            <span class="s1">brackets = </span><span class="s4">'&amp;[/*...*/]'</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">brackets = </span><span class="s4">'&amp;[%s]' </span><span class="s1">% length</span>
        <span class="s1">self.c_name_with_marker = (</span>
            <span class="s1">self.item.c_name_with_marker.replace(</span><span class="s4">'&amp;'</span><span class="s0">, </span><span class="s1">brackets))</span>

    <span class="s0">def </span><span class="s1">length_is_unknown(self):</span>
        <span class="s0">return </span><span class="s1">isinstance(self.length</span><span class="s0">, </span><span class="s1">str)</span>

    <span class="s0">def </span><span class="s1">resolve_length(self</span><span class="s0">, </span><span class="s1">newlength):</span>
        <span class="s0">return </span><span class="s1">ArrayType(self.item</span><span class="s0">, </span><span class="s1">newlength)</span>

    <span class="s0">def </span><span class="s1">build_backend_type(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist):</span>
        <span class="s0">if </span><span class="s1">self.length_is_unknown():</span>
            <span class="s0">raise </span><span class="s1">CDefError(</span><span class="s4">&quot;cannot render the type %r: unknown length&quot; </span><span class="s1">%</span>
                            <span class="s1">(self</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">self.item.get_cached_btype(ffi</span><span class="s0">, </span><span class="s1">finishlist)   </span><span class="s2"># force the item BType</span>
        <span class="s1">BPtrItem = PointerType(self.item).get_cached_btype(ffi</span><span class="s0">, </span><span class="s1">finishlist)</span>
        <span class="s0">return </span><span class="s1">global_cache(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s4">'new_array_type'</span><span class="s0">, </span><span class="s1">BPtrItem</span><span class="s0">, </span><span class="s1">self.length)</span>

<span class="s1">char_array_type = ArrayType(PrimitiveType(</span><span class="s4">'char'</span><span class="s1">)</span><span class="s0">, None</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">StructOrUnionOrEnum(BaseTypeByIdentity):</span>
    <span class="s1">_attrs_ = (</span><span class="s4">'name'</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">forcename = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">build_c_name_with_marker(self):</span>
        <span class="s1">name = self.forcename </span><span class="s0">or </span><span class="s4">'%s %s' </span><span class="s1">% (self.kind</span><span class="s0">, </span><span class="s1">self.name)</span>
        <span class="s1">self.c_name_with_marker = name + </span><span class="s4">'&amp;'</span>

    <span class="s0">def </span><span class="s1">force_the_name(self</span><span class="s0">, </span><span class="s1">forcename):</span>
        <span class="s1">self.forcename = forcename</span>
        <span class="s1">self.build_c_name_with_marker()</span>

    <span class="s0">def </span><span class="s1">get_official_name(self):</span>
        <span class="s0">assert </span><span class="s1">self.c_name_with_marker.endswith(</span><span class="s4">'&amp;'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self.c_name_with_marker[:-</span><span class="s3">1</span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">StructOrUnion(StructOrUnionOrEnum):</span>
    <span class="s1">fixedlayout = </span><span class="s0">None</span>
    <span class="s1">completed = </span><span class="s3">0</span>
    <span class="s1">partial = </span><span class="s0">False</span>
    <span class="s1">packed = </span><span class="s3">0</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">fldnames</span><span class="s0">, </span><span class="s1">fldtypes</span><span class="s0">, </span><span class="s1">fldbitsize</span><span class="s0">, </span><span class="s1">fldquals=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.fldnames = fldnames</span>
        <span class="s1">self.fldtypes = fldtypes</span>
        <span class="s1">self.fldbitsize = fldbitsize</span>
        <span class="s1">self.fldquals = fldquals</span>
        <span class="s1">self.build_c_name_with_marker()</span>

    <span class="s0">def </span><span class="s1">anonymous_struct_fields(self):</span>
        <span class="s0">if </span><span class="s1">self.fldtypes </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">type </span><span class="s0">in </span><span class="s1">zip(self.fldnames</span><span class="s0">, </span><span class="s1">self.fldtypes):</span>
                <span class="s0">if </span><span class="s1">name == </span><span class="s4">'' </span><span class="s0">and </span><span class="s1">isinstance(type</span><span class="s0">, </span><span class="s1">StructOrUnion):</span>
                    <span class="s0">yield </span><span class="s1">type</span>

    <span class="s0">def </span><span class="s1">enumfields(self</span><span class="s0">, </span><span class="s1">expand_anonymous_struct_union=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">fldquals = self.fldquals</span>
        <span class="s0">if </span><span class="s1">fldquals </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">fldquals = (</span><span class="s3">0</span><span class="s0">,</span><span class="s1">) * len(self.fldnames)</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">bitsize</span><span class="s0">, </span><span class="s1">quals </span><span class="s0">in </span><span class="s1">zip(self.fldnames</span><span class="s0">, </span><span class="s1">self.fldtypes</span><span class="s0">,</span>
                                              <span class="s1">self.fldbitsize</span><span class="s0">, </span><span class="s1">fldquals):</span>
            <span class="s0">if </span><span class="s1">(name == </span><span class="s4">'' </span><span class="s0">and </span><span class="s1">isinstance(type</span><span class="s0">, </span><span class="s1">StructOrUnion)</span>
                    <span class="s0">and </span><span class="s1">expand_anonymous_struct_union):</span>
                <span class="s2"># nested anonymous struct/union</span>
                <span class="s0">for </span><span class="s1">result </span><span class="s0">in </span><span class="s1">type.enumfields():</span>
                    <span class="s0">yield </span><span class="s1">result</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">(name</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">bitsize</span><span class="s0">, </span><span class="s1">quals)</span>

    <span class="s0">def </span><span class="s1">force_flatten(self):</span>
        <span class="s2"># force the struct or union to have a declaration that lists</span>
        <span class="s2"># directly all fields returned by enumfields(), flattening</span>
        <span class="s2"># nested anonymous structs/unions.</span>
        <span class="s1">names = []</span>
        <span class="s1">types = []</span>
        <span class="s1">bitsizes = []</span>
        <span class="s1">fldquals = []</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">bitsize</span><span class="s0">, </span><span class="s1">quals </span><span class="s0">in </span><span class="s1">self.enumfields():</span>
            <span class="s1">names.append(name)</span>
            <span class="s1">types.append(type)</span>
            <span class="s1">bitsizes.append(bitsize)</span>
            <span class="s1">fldquals.append(quals)</span>
        <span class="s1">self.fldnames = tuple(names)</span>
        <span class="s1">self.fldtypes = tuple(types)</span>
        <span class="s1">self.fldbitsize = tuple(bitsizes)</span>
        <span class="s1">self.fldquals = tuple(fldquals)</span>

    <span class="s0">def </span><span class="s1">get_cached_btype(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist</span><span class="s0">, </span><span class="s1">can_delay=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">BType = StructOrUnionOrEnum.get_cached_btype(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist</span><span class="s0">,</span>
                                                     <span class="s1">can_delay)</span>
        <span class="s0">if not </span><span class="s1">can_delay:</span>
            <span class="s1">self.finish_backend_type(ffi</span><span class="s0">, </span><span class="s1">finishlist)</span>
        <span class="s0">return </span><span class="s1">BType</span>

    <span class="s0">def </span><span class="s1">finish_backend_type(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist):</span>
        <span class="s0">if </span><span class="s1">self.completed:</span>
            <span class="s0">if </span><span class="s1">self.completed != </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;recursive structure declaration &quot;</span>
                                          <span class="s4">&quot;for '%s'&quot; </span><span class="s1">% (self.name</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s0">return</span>
        <span class="s1">BType = ffi._cached_btypes[self]</span>
        <span class="s2">#</span>
        <span class="s1">self.completed = </span><span class="s3">1</span>
        <span class="s2">#</span>
        <span class="s0">if </span><span class="s1">self.fldtypes </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">pass    </span><span class="s2"># not completing it: it's an opaque struct</span>
            <span class="s2">#</span>
        <span class="s0">elif </span><span class="s1">self.fixedlayout </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">fldtypes = [tp.get_cached_btype(ffi</span><span class="s0">, </span><span class="s1">finishlist)</span>
                        <span class="s0">for </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">self.fldtypes]</span>
            <span class="s1">lst = list(zip(self.fldnames</span><span class="s0">, </span><span class="s1">fldtypes</span><span class="s0">, </span><span class="s1">self.fldbitsize))</span>
            <span class="s1">extra_flags = ()</span>
            <span class="s0">if </span><span class="s1">self.packed:</span>
                <span class="s0">if </span><span class="s1">self.packed == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">extra_flags = (</span><span class="s3">8</span><span class="s0">,</span><span class="s1">)    </span><span class="s2"># SF_PACKED</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">extra_flags = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">self.packed)</span>
            <span class="s1">ffi._backend.complete_struct_or_union(BType</span><span class="s0">, </span><span class="s1">lst</span><span class="s0">, </span><span class="s1">self</span><span class="s0">,</span>
                                                  <span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">*extra_flags)</span>
            <span class="s2">#</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fldtypes = []</span>
            <span class="s1">fieldofs</span><span class="s0">, </span><span class="s1">fieldsize</span><span class="s0">, </span><span class="s1">totalsize</span><span class="s0">, </span><span class="s1">totalalignment = self.fixedlayout</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(self.fldnames)):</span>
                <span class="s1">fsize = fieldsize[i]</span>
                <span class="s1">ftype = self.fldtypes[i]</span>
                <span class="s2">#</span>
                <span class="s0">if </span><span class="s1">isinstance(ftype</span><span class="s0">, </span><span class="s1">ArrayType) </span><span class="s0">and </span><span class="s1">ftype.length_is_unknown():</span>
                    <span class="s2"># fix the length to match the total size</span>
                    <span class="s1">BItemType = ftype.item.get_cached_btype(ffi</span><span class="s0">, </span><span class="s1">finishlist)</span>
                    <span class="s1">nlen</span><span class="s0">, </span><span class="s1">nrest = divmod(fsize</span><span class="s0">, </span><span class="s1">ffi.sizeof(BItemType))</span>
                    <span class="s0">if </span><span class="s1">nrest != </span><span class="s3">0</span><span class="s1">:</span>
                        <span class="s1">self._verification_error(</span>
                            <span class="s4">&quot;field '%s.%s' has a bogus size?&quot; </span><span class="s1">% (</span>
                            <span class="s1">self.name</span><span class="s0">, </span><span class="s1">self.fldnames[i] </span><span class="s0">or </span><span class="s4">'{}'</span><span class="s1">))</span>
                    <span class="s1">ftype = ftype.resolve_length(nlen)</span>
                    <span class="s1">self.fldtypes = (self.fldtypes[:i] + (ftype</span><span class="s0">,</span><span class="s1">) +</span>
                                     <span class="s1">self.fldtypes[i+</span><span class="s3">1</span><span class="s1">:])</span>
                <span class="s2">#</span>
                <span class="s1">BFieldType = ftype.get_cached_btype(ffi</span><span class="s0">, </span><span class="s1">finishlist)</span>
                <span class="s0">if </span><span class="s1">isinstance(ftype</span><span class="s0">, </span><span class="s1">ArrayType) </span><span class="s0">and </span><span class="s1">ftype.length </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s0">assert </span><span class="s1">fsize == </span><span class="s3">0</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">bitemsize = ffi.sizeof(BFieldType)</span>
                    <span class="s0">if </span><span class="s1">bitemsize != fsize:</span>
                        <span class="s1">self._verification_error(</span>
                            <span class="s4">&quot;field '%s.%s' is declared as %d bytes, but is &quot;</span>
                            <span class="s4">&quot;really %d bytes&quot; </span><span class="s1">% (self.name</span><span class="s0">,</span>
                                                 <span class="s1">self.fldnames[i] </span><span class="s0">or </span><span class="s4">'{}'</span><span class="s0">,</span>
                                                 <span class="s1">bitemsize</span><span class="s0">, </span><span class="s1">fsize))</span>
                <span class="s1">fldtypes.append(BFieldType)</span>
            <span class="s2">#</span>
            <span class="s1">lst = list(zip(self.fldnames</span><span class="s0">, </span><span class="s1">fldtypes</span><span class="s0">, </span><span class="s1">self.fldbitsize</span><span class="s0">, </span><span class="s1">fieldofs))</span>
            <span class="s1">ffi._backend.complete_struct_or_union(BType</span><span class="s0">, </span><span class="s1">lst</span><span class="s0">, </span><span class="s1">self</span><span class="s0">,</span>
                                                  <span class="s1">totalsize</span><span class="s0">, </span><span class="s1">totalalignment)</span>
        <span class="s1">self.completed = </span><span class="s3">2</span>

    <span class="s0">def </span><span class="s1">_verification_error(self</span><span class="s0">, </span><span class="s1">msg):</span>
        <span class="s0">raise </span><span class="s1">VerificationError(msg)</span>

    <span class="s0">def </span><span class="s1">check_not_partial(self):</span>
        <span class="s0">if </span><span class="s1">self.partial </span><span class="s0">and </span><span class="s1">self.fixedlayout </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">VerificationMissing(self._get_c_name())</span>

    <span class="s0">def </span><span class="s1">build_backend_type(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist):</span>
        <span class="s1">self.check_not_partial()</span>
        <span class="s1">finishlist.append(self)</span>
        <span class="s2">#</span>
        <span class="s0">return </span><span class="s1">global_cache(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s4">'new_%s_type' </span><span class="s1">% self.kind</span><span class="s0">,</span>
                            <span class="s1">self.get_official_name()</span><span class="s0">, </span><span class="s1">key=self)</span>


<span class="s0">class </span><span class="s1">StructType(StructOrUnion):</span>
    <span class="s1">kind = </span><span class="s4">'struct'</span>


<span class="s0">class </span><span class="s1">UnionType(StructOrUnion):</span>
    <span class="s1">kind = </span><span class="s4">'union'</span>


<span class="s0">class </span><span class="s1">EnumType(StructOrUnionOrEnum):</span>
    <span class="s1">kind = </span><span class="s4">'enum'</span>
    <span class="s1">partial = </span><span class="s0">False</span>
    <span class="s1">partial_resolved = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">enumerators</span><span class="s0">, </span><span class="s1">enumvalues</span><span class="s0">, </span><span class="s1">baseinttype=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.enumerators = enumerators</span>
        <span class="s1">self.enumvalues = enumvalues</span>
        <span class="s1">self.baseinttype = baseinttype</span>
        <span class="s1">self.build_c_name_with_marker()</span>

    <span class="s0">def </span><span class="s1">force_the_name(self</span><span class="s0">, </span><span class="s1">forcename):</span>
        <span class="s1">StructOrUnionOrEnum.force_the_name(self</span><span class="s0">, </span><span class="s1">forcename)</span>
        <span class="s0">if </span><span class="s1">self.forcename </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">name = self.get_official_name()</span>
            <span class="s1">self.forcename = </span><span class="s4">'$' </span><span class="s1">+ name.replace(</span><span class="s4">' '</span><span class="s0">, </span><span class="s4">'_'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">check_not_partial(self):</span>
        <span class="s0">if </span><span class="s1">self.partial </span><span class="s0">and not </span><span class="s1">self.partial_resolved:</span>
            <span class="s0">raise </span><span class="s1">VerificationMissing(self._get_c_name())</span>

    <span class="s0">def </span><span class="s1">build_backend_type(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist):</span>
        <span class="s1">self.check_not_partial()</span>
        <span class="s1">base_btype = self.build_baseinttype(ffi</span><span class="s0">, </span><span class="s1">finishlist)</span>
        <span class="s0">return </span><span class="s1">global_cache(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s4">'new_enum_type'</span><span class="s0">,</span>
                            <span class="s1">self.get_official_name()</span><span class="s0">,</span>
                            <span class="s1">self.enumerators</span><span class="s0">, </span><span class="s1">self.enumvalues</span><span class="s0">,</span>
                            <span class="s1">base_btype</span><span class="s0">, </span><span class="s1">key=self)</span>

    <span class="s0">def </span><span class="s1">build_baseinttype(self</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">finishlist):</span>
        <span class="s0">if </span><span class="s1">self.baseinttype </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.baseinttype.get_cached_btype(ffi</span><span class="s0">, </span><span class="s1">finishlist)</span>
        <span class="s2">#</span>
        <span class="s0">if </span><span class="s1">self.enumvalues:</span>
            <span class="s1">smallest_value = min(self.enumvalues)</span>
            <span class="s1">largest_value = max(self.enumvalues)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">import </span><span class="s1">warnings</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s2"># XXX!  The goal is to ensure that the warnings.warn()</span>
                <span class="s2"># will not suppress the warning.  We want to get it</span>
                <span class="s2"># several times if we reach this point several times.</span>
                <span class="s1">__warningregistry__.clear()</span>
            <span class="s0">except </span><span class="s1">NameError:</span>
                <span class="s0">pass</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;%r has no values explicitly defined; &quot;</span>
                          <span class="s4">&quot;guessing that it is equivalent to 'unsigned int'&quot;</span>
                          <span class="s1">% self._get_c_name())</span>
            <span class="s1">smallest_value = largest_value = </span><span class="s3">0</span>
        <span class="s0">if </span><span class="s1">smallest_value &lt; </span><span class="s3">0</span><span class="s1">:   </span><span class="s2"># needs a signed type</span>
            <span class="s1">sign = </span><span class="s3">1</span>
            <span class="s1">candidate1 = PrimitiveType(</span><span class="s4">&quot;int&quot;</span><span class="s1">)</span>
            <span class="s1">candidate2 = PrimitiveType(</span><span class="s4">&quot;long&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">sign = </span><span class="s3">0</span>
            <span class="s1">candidate1 = PrimitiveType(</span><span class="s4">&quot;unsigned int&quot;</span><span class="s1">)</span>
            <span class="s1">candidate2 = PrimitiveType(</span><span class="s4">&quot;unsigned long&quot;</span><span class="s1">)</span>
        <span class="s1">btype1 = candidate1.get_cached_btype(ffi</span><span class="s0">, </span><span class="s1">finishlist)</span>
        <span class="s1">btype2 = candidate2.get_cached_btype(ffi</span><span class="s0">, </span><span class="s1">finishlist)</span>
        <span class="s1">size1 = ffi.sizeof(btype1)</span>
        <span class="s1">size2 = ffi.sizeof(btype2)</span>
        <span class="s0">if </span><span class="s1">(smallest_value &gt;= ((-</span><span class="s3">1</span><span class="s1">) &lt;&lt; (</span><span class="s3">8</span><span class="s1">*size1-</span><span class="s3">1</span><span class="s1">)) </span><span class="s0">and</span>
            <span class="s1">largest_value &lt; (</span><span class="s3">1 </span><span class="s1">&lt;&lt; (</span><span class="s3">8</span><span class="s1">*size1-sign))):</span>
            <span class="s0">return </span><span class="s1">btype1</span>
        <span class="s0">if </span><span class="s1">(smallest_value &gt;= ((-</span><span class="s3">1</span><span class="s1">) &lt;&lt; (</span><span class="s3">8</span><span class="s1">*size2-</span><span class="s3">1</span><span class="s1">)) </span><span class="s0">and</span>
            <span class="s1">largest_value &lt; (</span><span class="s3">1 </span><span class="s1">&lt;&lt; (</span><span class="s3">8</span><span class="s1">*size2-sign))):</span>
            <span class="s0">return </span><span class="s1">btype2</span>
        <span class="s0">raise </span><span class="s1">CDefError(</span><span class="s4">&quot;%s values don't all fit into either 'long' &quot;</span>
                        <span class="s4">&quot;or 'unsigned long'&quot; </span><span class="s1">% self._get_c_name())</span>

<span class="s0">def </span><span class="s1">unknown_type(name</span><span class="s0">, </span><span class="s1">structname=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">structname </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">structname = </span><span class="s4">'$%s' </span><span class="s1">% name</span>
    <span class="s1">tp = StructType(structname</span><span class="s0">, None, None, None</span><span class="s1">)</span>
    <span class="s1">tp.force_the_name(name)</span>
    <span class="s1">tp.origin = </span><span class="s4">&quot;unknown_type&quot;</span>
    <span class="s0">return </span><span class="s1">tp</span>

<span class="s0">def </span><span class="s1">unknown_ptr_type(name</span><span class="s0">, </span><span class="s1">structname=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">structname </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">structname = </span><span class="s4">'$$%s' </span><span class="s1">% name</span>
    <span class="s1">tp = StructType(structname</span><span class="s0">, None, None, None</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">NamedPointerType(tp</span><span class="s0">, </span><span class="s1">name)</span>


<span class="s1">global_lock = allocate_lock()</span>
<span class="s1">_typecache_cffi_backend = weakref.WeakValueDictionary()</span>

<span class="s0">def </span><span class="s1">get_typecache(backend):</span>
    <span class="s2"># returns _typecache_cffi_backend if backend is the _cffi_backend</span>
    <span class="s2"># module, or type(backend).__typecache if backend is an instance of</span>
    <span class="s2"># CTypesBackend (or some FakeBackend class during tests)</span>
    <span class="s0">if </span><span class="s1">isinstance(backend</span><span class="s0">, </span><span class="s1">types.ModuleType):</span>
        <span class="s0">return </span><span class="s1">_typecache_cffi_backend</span>
    <span class="s0">with </span><span class="s1">global_lock:</span>
        <span class="s0">if not </span><span class="s1">hasattr(type(backend)</span><span class="s0">, </span><span class="s4">'__typecache'</span><span class="s1">):</span>
            <span class="s1">type(backend).__typecache = weakref.WeakValueDictionary()</span>
        <span class="s0">return </span><span class="s1">type(backend).__typecache</span>

<span class="s0">def </span><span class="s1">global_cache(srctype</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s1">funcname</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
    <span class="s1">key = kwds.pop(</span><span class="s4">'key'</span><span class="s0">, </span><span class="s1">(funcname</span><span class="s0">, </span><span class="s1">args))</span>
    <span class="s0">assert not </span><span class="s1">kwds</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">ffi._typecache[key]</span>
    <span class="s0">except </span><span class="s1">KeyError:</span>
        <span class="s0">pass</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">res = getattr(ffi._backend</span><span class="s0">, </span><span class="s1">funcname)(*args)</span>
    <span class="s0">except </span><span class="s1">NotImplementedError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;%s: %r: %s&quot; </span><span class="s1">% (funcname</span><span class="s0">, </span><span class="s1">srctype</span><span class="s0">, </span><span class="s1">e))</span>
    <span class="s2"># note that setdefault() on WeakValueDictionary is not atomic</span>
    <span class="s2"># and contains a rare bug (http://bugs.python.org/issue19542);</span>
    <span class="s2"># we have to use a lock and do it ourselves</span>
    <span class="s1">cache = ffi._typecache</span>
    <span class="s0">with </span><span class="s1">global_lock:</span>
        <span class="s1">res1 = cache.get(key)</span>
        <span class="s0">if </span><span class="s1">res1 </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">cache[key] = res</span>
            <span class="s0">return </span><span class="s1">res</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">res1</span>

<span class="s0">def </span><span class="s1">pointer_cache(ffi</span><span class="s0">, </span><span class="s1">BType):</span>
    <span class="s0">return </span><span class="s1">global_cache(</span><span class="s4">'?'</span><span class="s0">, </span><span class="s1">ffi</span><span class="s0">, </span><span class="s4">'new_pointer_type'</span><span class="s0">, </span><span class="s1">BType)</span>

<span class="s0">def </span><span class="s1">attach_exception_info(e</span><span class="s0">, </span><span class="s1">name):</span>
    <span class="s0">if </span><span class="s1">e.args </span><span class="s0">and </span><span class="s1">type(e.args[</span><span class="s3">0</span><span class="s1">]) </span><span class="s0">is </span><span class="s1">str:</span>
        <span class="s1">e.args = (</span><span class="s4">'%s: %s' </span><span class="s1">% (name</span><span class="s0">, </span><span class="s1">e.args[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">,</span><span class="s1">) + e.args[</span><span class="s3">1</span><span class="s1">:]</span>
</pre>
</body>
</html>