<html>
<head>
<title>qt.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
qt.py</font>
</center></td></tr></table>
<pre><span class="s0"># ----------------------------------------------------------------------------</span>
<span class="s0"># Copyright (c) 2005-2021, PyInstaller Development Team.</span>
<span class="s0">#</span>
<span class="s0"># Distributed under the terms of the GNU General Public License (version 2</span>
<span class="s0"># or later) with exception for distributing the bootloader.</span>
<span class="s0">#</span>
<span class="s0"># The full license is in the file COPYING.txt, distributed with this software.</span>
<span class="s0">#</span>
<span class="s0"># SPDX-License-Identifier: (GPL-2.0-or-later WITH Bootloader-exception)</span>
<span class="s0">#-----------------------------------------------------------------------------</span>

<span class="s2">import </span><span class="s1">glob</span>
<span class="s2">import </span><span class="s1">json</span>
<span class="s2">import </span><span class="s1">os</span>

<span class="s2">from </span><span class="s1">PyInstaller </span><span class="s2">import </span><span class="s1">compat</span>
<span class="s2">from </span><span class="s1">PyInstaller </span><span class="s2">import </span><span class="s1">log </span><span class="s2">as </span><span class="s1">logging</span>
<span class="s2">from </span><span class="s1">PyInstaller.depend </span><span class="s2">import </span><span class="s1">bindepend</span>
<span class="s2">from </span><span class="s1">PyInstaller.utils </span><span class="s2">import </span><span class="s1">hooks</span><span class="s2">, </span><span class="s1">misc</span>

<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s0"># QtLibraryInfo</span>
<span class="s0"># --------------</span>
<span class="s0"># This class uses introspection to determine the location of Qt files. This is essential to deal with the many variants</span>
<span class="s0"># of the PyQt5/6 and PySide2/6 package, each of which places files in a different location. Therefore, this class</span>
<span class="s0"># provides all location-related members of `QLibraryInfo &lt;http://doc.qt.io/qt-5/qlibraryinfo.html&gt;`_.</span>
<span class="s2">class </span><span class="s1">QtLibraryInfo:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">namespace):</span>
        <span class="s2">if </span><span class="s1">namespace </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">'PyQt5'</span><span class="s2">, </span><span class="s3">'PyQt6'</span><span class="s2">, </span><span class="s3">'PySide2'</span><span class="s2">, </span><span class="s3">'PySide6'</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">Exception(</span><span class="s3">'Invalid namespace: {0}'</span><span class="s1">.format(namespace))</span>
        <span class="s1">self.namespace = namespace</span>
        <span class="s0"># Distinction between PyQt5/6 and PySide2/6</span>
        <span class="s1">self.is_pyqt = namespace </span><span class="s2">in </span><span class="s1">{</span><span class="s3">'PyQt5'</span><span class="s2">, </span><span class="s3">'PyQt6'</span><span class="s1">}</span>
        <span class="s0"># Distinction between Qt5 and Qt6</span>
        <span class="s1">self.qt_major = </span><span class="s4">6 </span><span class="s2">if </span><span class="s1">namespace </span><span class="s2">in </span><span class="s1">{</span><span class="s3">'PyQt6'</span><span class="s2">, </span><span class="s3">'PySide6'</span><span class="s1">} </span><span class="s2">else </span><span class="s4">5</span>
        <span class="s0"># Determine relative path where Qt libraries and data need to be collected in the frozen application. This</span>
        <span class="s0"># varies between PyQt5/PyQt6/PySide2/PySide6, their versions, and platforms. NOTE: it is tempting to consider</span>
        <span class="s0"># deriving this path as simply the value of QLibraryInfo.PrefixPath, taken relative to the package's root</span>
        <span class="s0"># directory. However, we also need to support non-wheel deployments (e.g., with Qt installed in custom path on</span>
        <span class="s0"># Windows, or with Qt and PyQt5 installed on linux using native package manager), and in those, the Qt</span>
        <span class="s0"># PrefixPath does not reflect the required relative target path for the frozen application.</span>
        <span class="s2">if </span><span class="s1">namespace == </span><span class="s3">'PyQt5'</span><span class="s1">:</span>
            <span class="s0"># PyQt5 uses PyQt5/Qt on all platforms, or PyQt5/Qt5 from version 5.15.4 on</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s0"># The call below might fail with AttributeError on some PyQt5 versions (e.g., 5.9.2 from conda's main</span>
                <span class="s0"># channel); missing dist information forces a fallback codepath that tries to check for __version__</span>
                <span class="s0"># attribute that does not exist, either. So handle the error gracefully and assume old layout.</span>
                <span class="s1">new_layout = hooks.is_module_satisfies(</span><span class="s3">&quot;PyQt5 &gt;= 5.15.4&quot;</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s1">new_layout = </span><span class="s2">False</span>
            <span class="s2">if </span><span class="s1">new_layout:</span>
                <span class="s1">self.qt_rel_dir = os.path.join(</span><span class="s3">'PyQt5'</span><span class="s2">, </span><span class="s3">'Qt5'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.qt_rel_dir = os.path.join(</span><span class="s3">'PyQt5'</span><span class="s2">, </span><span class="s3">'Qt'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">namespace == </span><span class="s3">'PyQt6'</span><span class="s1">:</span>
            <span class="s0"># Similarly to PyQt5, PyQt6 switched from PyQt6/Qt to PyQt6/Qt6 in 6.0.3</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s0"># The call below might fail with AttributeError in case of a partial PyQt6 installation. For example,</span>
                <span class="s0"># user installs PyQt6 via pip, which also installs PyQt6-Qt6 and PyQt6-sip. Then they naively uninstall</span>
                <span class="s0"># PyQt6 package, which leaves the other two behind. PyQt6 now becomes a namespace package and there is</span>
                <span class="s0"># no dist metadata, so a fallback codepath in is_module_satisfies tries to check for __version__</span>
                <span class="s0"># attribute that does not exist, either. Handle such errors gracefully and assume new layout (with</span>
                <span class="s0"># PyQt6, the new layout is more likely); it does not really matter what layout we assume, as library is</span>
                <span class="s0"># not usable anyway, but we do neeed to be able to return an instance of QtLibraryInfo with &quot;version&quot;</span>
                <span class="s0"># attribute set to a falsey value.</span>
                <span class="s1">new_layout = hooks.is_module_satisfies(</span><span class="s3">&quot;PyQt6 &gt;= 6.0.3&quot;</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s1">new_layout = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">new_layout:</span>
                <span class="s1">self.qt_rel_dir = os.path.join(</span><span class="s3">'PyQt6'</span><span class="s2">, </span><span class="s3">'Qt6'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.qt_rel_dir = os.path.join(</span><span class="s3">'PyQt6'</span><span class="s2">, </span><span class="s3">'Qt'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">namespace == </span><span class="s3">'PySide2'</span><span class="s1">:</span>
            <span class="s0"># PySide2 uses PySide2/Qt on linux and macOS, and PySide2 on Windows</span>
            <span class="s2">if </span><span class="s1">compat.is_win:</span>
                <span class="s1">self.qt_rel_dir = </span><span class="s3">'PySide2'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.qt_rel_dir = os.path.join(</span><span class="s3">'PySide2'</span><span class="s2">, </span><span class="s3">'Qt'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># PySide6 follows the same logic as PySide2</span>
            <span class="s2">if </span><span class="s1">compat.is_win:</span>
                <span class="s1">self.qt_rel_dir = </span><span class="s3">'PySide6'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.qt_rel_dir = os.path.join(</span><span class="s3">'PySide6'</span><span class="s2">, </span><span class="s3">'Qt'</span><span class="s1">)</span>

    <span class="s0"># Initialize most of this class only when values are first requested from it.</span>
    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s3">'version' </span><span class="s2">in </span><span class="s1">self.__dict__:</span>
            <span class="s0"># Initialization was already done, but requested attribute is not availiable.</span>
            <span class="s2">raise </span><span class="s1">AttributeError(name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Ensure self.version exists, even if PyQt{5,6}/PySide{2,6} cannot be imported. Hooks and util functions use</span>
            <span class="s0"># `if .version` to check whether package was imported and other attributes are expected to be available.</span>
            <span class="s0"># This also serves as a marker that initialization was already done.</span>
            <span class="s1">self.version = </span><span class="s2">None</span>
            <span class="s0"># Get library path information from Qt. See QLibraryInfo_.</span>
            <span class="s1">json_str = hooks.exec_statement(</span>
                <span class="s3">&quot;&quot;&quot; 
                import sys 
 
                # exec_statement only captures stdout. If there are errors, capture them to stdout so they can be 
                # displayed to the user. Do this early, in case package imports produce stderr output. 
                sys.stderr = sys.stdout 
 
                import json 
                try: 
                    from %s.QtCore import QLibraryInfo, QCoreApplication 
                except Exception: 
                    print('False') 
                    raise SystemExit(0) 
 
                # QLibraryInfo is not always valid until a QCoreApplication is instantiated. 
                app = QCoreApplication(sys.argv) 
                # Qt6 deprecated QLibraryInfo.location() in favor of QLibraryInfo.path(), and 
                # QLibraryInfo.LibraryLocation enum was replaced by QLibraryInfo.LibraryPath. 
                if hasattr(QLibraryInfo, 'path'): 
                    # Qt6; enumerate path enum values directly from the QLibraryInfo.LibraryPath enum. 
                    path_names = [x for x in dir(QLibraryInfo.LibraryPath) if x.endswith('Path')] 
                    location = {x: QLibraryInfo.path(getattr(QLibraryInfo.LibraryPath, x)) for x in path_names} 
                else: 
                    # Qt5; in recent versions, location enum values can be enumeratd from QLibraryInfo.LibraryLocation. 
                    # However, in older versions of Qt5 and its python bindings, that is unavailable. Hence the 
                    # enumeration of &quot;*Path&quot;-named members of QLibraryInfo. 
                    path_names = [x for x in dir(QLibraryInfo) if x.endswith('Path')] 
                    location = {x: QLibraryInfo.location(getattr(QLibraryInfo, x)) for x in path_names} 
 
                # Determine Qt version. Works for Qt 5.8 and later, where QLibraryInfo.version() was introduced. 
                try: 
                    version = QLibraryInfo.version().segments() 
                except AttributeError: 
                    version = [] 
                print(json.dumps({ 
                    'isDebugBuild': QLibraryInfo.isDebugBuild(), 
                    'version': version, 
                    'location': location, 
                })) 
                &quot;&quot;&quot; </span><span class="s1">% self.namespace</span>
            <span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">qli = json.loads(json_str)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">logger.warning(</span><span class="s3">'Cannot read QLibraryInfo output: raised %s when decoding:</span><span class="s2">\n</span><span class="s3">%s'</span><span class="s2">, </span><span class="s1">str(e)</span><span class="s2">, </span><span class="s1">json_str)</span>
                <span class="s1">qli = {}</span>

            <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">qli.items():</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v)</span>

            <span class="s2">return </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">name)</span>


<span class="s0"># Provide single instances of this class to avoid each hook constructing its own.</span>
<span class="s1">pyqt5_library_info = QtLibraryInfo(</span><span class="s3">'PyQt5'</span><span class="s1">)</span>
<span class="s1">pyqt6_library_info = QtLibraryInfo(</span><span class="s3">'PyQt6'</span><span class="s1">)</span>
<span class="s1">pyside2_library_info = QtLibraryInfo(</span><span class="s3">'PySide2'</span><span class="s1">)</span>
<span class="s1">pyside6_library_info = QtLibraryInfo(</span><span class="s3">'PySide6'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_qt_library_info(namespace):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return Qt5LibraryInfo instance for the given namespace. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">namespace == </span><span class="s3">'PyQt5'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pyqt5_library_info</span>
    <span class="s2">if </span><span class="s1">namespace == </span><span class="s3">'PyQt6'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pyqt6_library_info</span>
    <span class="s2">elif </span><span class="s1">namespace == </span><span class="s3">'PySide2'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pyside2_library_info</span>
    <span class="s2">elif </span><span class="s1">namespace == </span><span class="s3">'PySide6'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">pyside6_library_info</span>

    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'Invalid namespace: </span><span class="s2">{</span><span class="s1">namespace</span><span class="s2">}</span><span class="s3">!'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">qt_plugins_dir(namespace):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return list of paths searched for plugins. 
 
    :param namespace: Import namespace (PyQt5, PyQt6, PySide2, or PySide6). 
 
    :return: Plugin directory paths 
    &quot;&quot;&quot;</span>
    <span class="s1">qt_info = get_qt_library_info(namespace)</span>
    <span class="s1">paths = [qt_info.location[</span><span class="s3">'PluginsPath'</span><span class="s1">]]</span>
    <span class="s2">if not </span><span class="s1">paths:</span>
        <span class="s2">raise </span><span class="s1">Exception(</span><span class="s3">'Cannot find {0} plugin directories'</span><span class="s1">.format(namespace))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">valid_paths = []</span>
        <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">paths:</span>
            <span class="s2">if </span><span class="s1">os.path.isdir(path):</span>
                <span class="s1">valid_paths.append(str(path))  </span><span class="s0"># must be 8-bit chars for one-file builds</span>
        <span class="s1">qt_plugin_paths = valid_paths</span>
    <span class="s2">if not </span><span class="s1">qt_plugin_paths:</span>
        <span class="s2">raise </span><span class="s1">Exception(</span>
            <span class="s3">&quot;Cannot find existing {0} plugin directories. Paths checked: {1}&quot;</span><span class="s1">.format(namespace</span><span class="s2">, </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(paths))</span>
        <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">qt_plugin_paths</span>


<span class="s2">def </span><span class="s1">_qt_filter_release_plugins(plugin_files):</span>
    <span class="s5">&quot;&quot;&quot; 
    Filter the provided list of Qt plugin files and remove the debug variants, under the assumption that both the 
    release version of a plugin (qtplugin.dll) and its debug variant (qtplugind.dll) appear in the list. 
    &quot;&quot;&quot;</span>
    <span class="s0"># All basenames for lookup</span>
    <span class="s1">plugin_basenames = {os.path.normcase(os.path.basename(f)) </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">plugin_files}</span>
    <span class="s0"># Process all given filenames</span>
    <span class="s1">release_plugin_files = []</span>
    <span class="s2">for </span><span class="s1">plugin_filename </span><span class="s2">in </span><span class="s1">plugin_files:</span>
        <span class="s1">plugin_basename = os.path.normcase(os.path.basename(plugin_filename))</span>
        <span class="s2">if </span><span class="s1">plugin_basename.endswith(</span><span class="s3">'d.dll'</span><span class="s1">):</span>
            <span class="s0"># If we can find a variant without trailing 'd' in the plugin list, then the DLL we are dealing with is a</span>
            <span class="s0"># debug variant and needs to be excluded.</span>
            <span class="s1">release_name = os.path.splitext(plugin_basename)[</span><span class="s4">0</span><span class="s1">][:-</span><span class="s4">1</span><span class="s1">] + </span><span class="s3">'.dll'</span>
            <span class="s2">if </span><span class="s1">release_name </span><span class="s2">in </span><span class="s1">plugin_basenames:</span>
                <span class="s2">continue</span>
        <span class="s1">release_plugin_files.append(plugin_filename)</span>
    <span class="s2">return </span><span class="s1">release_plugin_files</span>


<span class="s2">def </span><span class="s1">qt_plugins_binaries(plugin_type</span><span class="s2">, </span><span class="s1">namespace):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return list of dynamic libraries formatted for mod.binaries. 
 
    :param plugin_type: Plugin to look for 
    :param namespace: Import namespace (PyQt5, PyQt6, PySide2, or PySide6) 
 
    :return: Plugin directory path corresponding to the given plugin_type 
    &quot;&quot;&quot;</span>
    <span class="s1">qt_info = get_qt_library_info(namespace)</span>
    <span class="s1">pdir = qt_plugins_dir(namespace)</span>
    <span class="s1">files = []</span>
    <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">pdir:</span>
        <span class="s1">files.extend(misc.dlls_in_dir(os.path.join(path</span><span class="s2">, </span><span class="s1">plugin_type)))</span>

    <span class="s0"># Windows:</span>
    <span class="s0">#</span>
    <span class="s0"># dlls_in_dir() grabs all files ending with ``*.dll``, ``*.so`` and ``*.dylib`` in a certain directory. On Windows</span>
    <span class="s0"># this would grab debug copies of Qt plugins, which then causes PyInstaller to add a dependency on the Debug CRT</span>
    <span class="s0"># *in addition* to the release CRT.</span>
    <span class="s2">if </span><span class="s1">compat.is_win:</span>
        <span class="s1">files = _qt_filter_release_plugins(files)</span>

    <span class="s1">logger.debug(</span><span class="s3">&quot;Found plugin files %s for plugin %s&quot;</span><span class="s2">, </span><span class="s1">files</span><span class="s2">, </span><span class="s1">plugin_type)</span>
    <span class="s1">dest_dir = os.path.join(qt_info.qt_rel_dir</span><span class="s2">, </span><span class="s3">'plugins'</span><span class="s2">, </span><span class="s1">plugin_type)</span>
    <span class="s1">binaries = [(f</span><span class="s2">, </span><span class="s1">dest_dir) </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">files]</span>
    <span class="s2">return </span><span class="s1">binaries</span>


<span class="s0"># Qt deployment approach</span>
<span class="s0"># ----------------------</span>
<span class="s0"># This is the core of PyInstaller's approach to Qt deployment. It's based on:</span>
<span class="s0">#</span>
<span class="s0"># - Discovering the location of Qt libraries by introspection, using QtLibraryInfo_. This provides compatibility with</span>
<span class="s0">#   many variants of Qt5/6 (conda, self-compiled, provided by a Linux distro, etc.) and many versions of Qt5/6, all of</span>
<span class="s0">#   which vary in the location of Qt files.</span>

<span class="s0"># - Placing all frozen PyQt5/6 or PySide2/6 Qt files in a standard subdirectory layout, which matches the layout of the</span>
<span class="s0">#   corresponding wheel on PyPI. This is necessary to support Qt installs which are not in a subdirectory of the PyQt5/6</span>
<span class="s0">#   or PySide2/6 wrappers. See ``hooks/rthooks/pyi_rth_qt5.py`` for the use of environment variables to establish this</span>
<span class="s0">#   layout.</span>

<span class="s0"># - Emitting warnings on missing QML and translation files which some installations don't have.</span>

<span class="s0"># - Determining additional files needed for deployment by following the Qt deployment process using</span>
<span class="s0">#   _qt_dynamic_dependencies_dict`_ and add_qt_dependencies_.</span>
<span class="s0">#</span>
<span class="s0"># _qt_dynamic_dependencies_dict</span>
<span class="s0"># -----------------------------</span>
<span class="s0"># This dictionary provides dynamics dependencies (plugins and translations) that cannot be discovered using</span>
<span class="s0"># ``getImports``. It was built by combining information from:</span>
<span class="s0">#</span>
<span class="s0"># - Qt `deployment &lt;http://doc.qt.io/qt-5/deployment.html&gt;`_ docs. Specifically:</span>
<span class="s0">#</span>
<span class="s0">#   -   The `deploying Qt for Linux/X11 &lt;http://doc.qt.io/qt-5/linux-deployment.html#qt-plugins&gt;`_ page specifies</span>
<span class="s0">#       including the Qt Platform Abstraction (QPA) plugin, ``libqxcb.so``. There's little other guidance provided.</span>
<span class="s0">#   -   The `Qt for Windows - Deployment</span>
<span class="s0">#       &lt;http://doc.qt.io/qt-5/windows-deployment.html#creating-the-application-package&gt;`_ page likewise specifies</span>
<span class="s0">#       the ``qwindows.dll`` QPA. This is found by the dependency walker, so it does not need to explicitly specified.</span>
<span class="s0">#</span>
<span class="s0">#       -   For dynamic OpenGL applications, the ``libEGL.dll``, ``libGLESv2.dll``, ``d3dcompiler_XX.dll`` (the XX is a</span>
<span class="s0">#           version number), and ``opengl32sw.dll`` libraries are also needed.</span>
<span class="s0">#       -   If Qt was configured to use ICU, the ``icudtXX.dll``, ``icuinXX.dll``, and ``icuucXX.dll`` libraries are</span>
<span class="s0">#           needed.</span>
<span class="s0">#</span>
<span class="s0">#       These are included by ``hook-PyQt5.py``.</span>
<span class="s0">#</span>
<span class="s0">#   -   The `Qt for macOS - Deployment &lt;http://doc.qt.io/qt-5/osx-deployment.html#qt-plugins&gt;`_ page specifies the</span>
<span class="s0">#       ``libqcocoa.dylib`` QPA, but little else. The `Mac deployment tool</span>
<span class="s0">#       &lt;http://doc.qt.io/qt-5/osx-deployment.html#the-mac-deployment-tool&gt;`_ provides the following rules:</span>
<span class="s0">#</span>
<span class="s0">#       -   The platform plugin is always deployed.</span>
<span class="s0">#       -   The image format plugins are always deployed.</span>
<span class="s0">#       -   The print support plugin is always deployed.</span>
<span class="s0">#       -   SQL driver plugins are deployed if the application uses the Qt SQL module.</span>
<span class="s0">#       -   Script plugins are deployed if the application uses the Qt Script module.</span>
<span class="s0">#       -   The SVG icon plugin is deployed if the application uses the Qt SVG module.</span>
<span class="s0">#       -   The accessibility plugin is always deployed.</span>
<span class="s0">#</span>
<span class="s0">#   -   Per the `Deploying QML Applications &lt;http://doc.qt.io/qt-5/qtquick-deployment.html&gt;`_ page, QML-based</span>
<span class="s0">#       applications need the ``qml/`` directory available.</span>
<span class="s0">#</span>
<span class="s0">#       This is handled by ``hook-PyQt5.QtQuick.py``.</span>
<span class="s0">#</span>
<span class="s0">#   -   Per the `Deploying Qt WebEngine Applications &lt;https://doc.qt.io/qt-5.10/qtwebengine-deploying.html&gt;`_</span>
<span class="s0">#       page, deployment may include:</span>
<span class="s0">#</span>
<span class="s0">#       -   Libraries (handled when PyInstaller following dependencies).</span>
<span class="s0">#       -   QML imports (if Qt Quick integration is used).</span>
<span class="s0">#       -   Qt WebEngine process, which should be located at</span>
<span class="s0">#           ``QLibraryInfo::location(QLibraryInfo::LibraryExecutablesPath)``</span>
<span class="s0">#           for Windows and Linux, and in ``.app/Helpers/QtWebEngineProcess`` for Mac.</span>
<span class="s0">#       -   Resources: the files listed in deployWebEngineCore_.</span>
<span class="s0">#       -   Translations: on macOS: ``.app/Content/Resources``; on Linux and Windows: ``qtwebengine_locales``</span>
<span class="s0">#           directory in the directory specified by ``QLibraryInfo::location(QLibraryInfo::TranslationsPath)``.</span>
<span class="s0">#       -   Audio and video codecs: Probably covered if Qt5Multimedia is referenced?</span>
<span class="s0">#</span>
<span class="s0">#       This is handled by ``hook-PyQt5.QtWebEngineWidgets.py``.</span>
<span class="s0">#</span>
<span class="s0">#   -   Since `QAxContainer &lt;http://doc.qt.io/qt-5/activeqt-index.html&gt;`_ is a statically-linked library, it</span>
<span class="s0">#       does not need any special handling.</span>
<span class="s0">#</span>
<span class="s0"># - Sources for the `Windows Deployment Tool</span>
<span class="s0">#   &lt;http://doc.qt.io/qt-5/windows-deployment.html#the-windows-deployment-tool&gt;`_ show more detail:</span>
<span class="s0">#</span>
<span class="s0">#   -   The `PluginModuleMapping struct</span>
<span class="s0">#       &lt;https://code.woboq.org/qt5/qttools/src/windeployqt/main.cpp.html#PluginModuleMapping&gt;`_ and the following</span>
<span class="s0">#       ``pluginModuleMappings`` global provide a mapping between a plugin directory name and an `enum of Qt plugin</span>
<span class="s0">#       names &lt;https://code.woboq.org/qt5/qttools/src/windeployqt/main.cpp.html#QtModule&gt;`_.</span>
<span class="s0">#   -   The `QtModuleEntry struct &lt;https://code.woboq.org/qt5/qttools/src/windeployqt/main.cpp.html#QtModuleEntry&gt;`_</span>
<span class="s0">#       and ``qtModuleEntries`` global connect this enum to the name of the Qt5 library it represents and to the</span>
<span class="s0">#       translation files this library requires. (Ignore the ``option`` member -- it's just for command-line parsing.)</span>
<span class="s0">#</span>
<span class="s0">#   Manually combining these two provides a mapping of Qt library names to the translation and plugin(s) needed by the</span>
<span class="s0">#   library. The process is: take the key of the dict below from ``QtModuleEntry.libraryName``, but make it lowercase</span>
<span class="s0">#   (since Windows files will be normalized to lowercase). The ``QtModuleEntry.translation`` provides the</span>
<span class="s0">#   ``translation_base``. Match the ``QtModuleEntry.module`` with ``PluginModuleMapping.module`` to find the</span>
<span class="s0">#   ``PluginModuleMapping.directoryName`` for the required plugin(s).</span>
<span class="s0">#</span>
<span class="s0">#   -   The `deployWebEngineCore</span>
<span class="s0">#       &lt;https://code.woboq.org/qt5/qttools/src/windeployqt/main.cpp.html#_ZL19deployWebEngineCoreRK4QMapI7QStringS0_ERK7OptionsbPS0_&gt;`_</span>
<span class="s0">#       function copies the following files from ``resources/``, and also copies the web engine process executable.</span>
<span class="s0">#</span>
<span class="s0">#       -   ``icudtl.dat``</span>
<span class="s0">#       -   ``qtwebengine_devtools_resources.pak``</span>
<span class="s0">#       -   ``qtwebengine_resources.pak``</span>
<span class="s0">#       -   ``qtwebengine_resources_100p.pak``</span>
<span class="s0">#       -   ``qtwebengine_resources_200p.pak``</span>
<span class="s0">#</span>
<span class="s0"># - Sources for the `Mac deployment tool`_ are less helpful. The `deployPlugins</span>
<span class="s0">#   &lt;https://code.woboq.org/qt5/qttools/src/macdeployqt/shared/shared.cpp.html#_Z13deployPluginsRK21ApplicationBundleInfoRK7QStringS2_14DeploymentInfob&gt;`_</span>
<span class="s0">#   function seems to:</span>
<span class="s0">#</span>
<span class="s0">#   -   Always include ``platforms/libqcocoa.dylib``.</span>
<span class="s0">#   -   Always include ``printsupport/libcocoaprintersupport.dylib``</span>
<span class="s0">#   -   Include ``bearer/`` if ``QtNetwork`` is included (and some other condition I didn't look up).</span>
<span class="s0">#   -   Always include ``imageformats/``, except for ``qsvg``.</span>
<span class="s0">#   -   Include ``imageformats/qsvg`` if ``QtSvg`` is included.</span>
<span class="s0">#   -   Always include ``iconengines/``.</span>
<span class="s0">#   -   Include ``sqldrivers/`` if ``QtSql`` is included.</span>
<span class="s0">#   -   Include ``mediaservice/`` and ``audio/`` if ``QtMultimedia`` is included.</span>
<span class="s0">#</span>
<span class="s0">#   The always includes will be handled by ``hook-PyQt5.py`` or ``hook-PySide2.py``; optional includes are already</span>
<span class="s0">#   covered by the dict below.</span>
<span class="s0">#</span>
<span class="s1">_qt5_dynamic_dependencies_dict = {</span>
    <span class="s0">#- &quot;lib_name&quot;:              (.hiddenimports,           translations_base,  zero or more plugins...)</span>
    <span class="s3">&quot;qt53dcore&quot;</span><span class="s1">:                (</span><span class="s2">None,                     None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt53dinput&quot;</span><span class="s1">:               (</span><span class="s2">None,                     None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt53dquick&quot;</span><span class="s1">:               (</span><span class="s2">None,                     None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt53dquickrender&quot;</span><span class="s1">:         (</span><span class="s2">None,                     None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt53drender&quot;</span><span class="s1">:              (</span><span class="s2">None,                     None,               </span><span class="s3">&quot;sceneparsers&quot;</span><span class="s2">, </span><span class="s3">&quot;renderplugins&quot;</span><span class="s2">, </span><span class="s3">&quot;geometryloaders&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5bluetooth&quot;</span><span class="s1">:             (</span><span class="s3">&quot;.QtBluetooth&quot;</span><span class="s2">,           None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5concurrent&quot;</span><span class="s1">:            (</span><span class="s2">None,                     </span><span class="s3">&quot;qtbase&quot;</span><span class="s2">,           </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5core&quot;</span><span class="s1">:                  (</span><span class="s3">&quot;.QtCore&quot;</span><span class="s2">,                </span><span class="s3">&quot;qtbase&quot;</span><span class="s2">,           </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5dbus&quot;</span><span class="s1">:                  (</span><span class="s3">&quot;.QtDBus&quot;</span><span class="s2">,                None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5declarative&quot;</span><span class="s1">:           (</span><span class="s2">None,                     </span><span class="s3">&quot;qtquick1&quot;</span><span class="s2">,         </span><span class="s3">&quot;qml1tooling&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5designer&quot;</span><span class="s1">:              (</span><span class="s3">&quot;.QtDesigner&quot;</span><span class="s2">,            None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5designercomponents&quot;</span><span class="s1">:    (</span><span class="s2">None,                     None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5gamepad&quot;</span><span class="s1">:               (</span><span class="s2">None,                     None,               </span><span class="s3">&quot;gamepads&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s0"># Qt5Gui:</span>
    <span class="s0"># The ``platformthemes`` plugins are available only on Linux.</span>
    <span class="s0"># Same goes for ``xcbglintegrations`` and ``egldeviceintegrations`` plugins.</span>
    <span class="s0"># The ``wayland-decoration-client``, ``wayland-graphics-integration-client``, and ``wayland-shell-integration``</span>
    <span class="s0"># plugins are part of Qt5WaylandClient Qt module, whose shared library (e.g., libQt5WaylandClient.so) is linked</span>
    <span class="s0"># by the wayland-related ``platforms`` plugins. Ideally, we would collect these plugins based on the</span>
    <span class="s0"># Qt5WaylandClient shared library entry, but as our Qt hook utilities do not scan the plugins using this dictionary,</span>
    <span class="s0"># that would not work. So instead we list these plugins under Qt5Gui to achieve pretty much the same end result.</span>
    <span class="s3">&quot;qt5gui&quot;</span><span class="s1">:                   (</span><span class="s3">&quot;.QtGui&quot;</span><span class="s2">,                 </span><span class="s3">&quot;qtbase&quot;</span><span class="s2">,           </span><span class="s3">&quot;accessible&quot;</span><span class="s2">, </span><span class="s3">&quot;iconengines&quot;</span><span class="s2">, </span><span class="s3">&quot;imageformats&quot;</span><span class="s2">, </span><span class="s3">&quot;platforms&quot;</span><span class="s2">, </span><span class="s3">&quot;platforminputcontexts&quot;</span><span class="s2">, </span><span class="s3">&quot;platformthemes&quot;</span><span class="s2">, </span><span class="s3">&quot;xcbglintegrations&quot;</span><span class="s2">, </span><span class="s3">&quot;egldeviceintegrations&quot;</span><span class="s2">, </span><span class="s3">&quot;wayland-decoration-client&quot;</span><span class="s2">, </span><span class="s3">&quot;wayland-graphics-integration-client&quot;</span><span class="s2">, </span><span class="s3">&quot;wayland-shell-integration&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5help&quot;</span><span class="s1">:                  (</span><span class="s3">&quot;.QtHelp&quot;</span><span class="s2">,                </span><span class="s3">&quot;qt_help&quot;</span><span class="s2">,          </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5location&quot;</span><span class="s1">:              (</span><span class="s3">&quot;.QtLocation&quot;</span><span class="s2">,            None,               </span><span class="s3">&quot;geoservices&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5macextras&quot;</span><span class="s1">:             (</span><span class="s3">&quot;.QtMacExtras&quot;</span><span class="s2">,           None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5multimedia&quot;</span><span class="s1">:            (</span><span class="s3">&quot;.QtMultimedia&quot;</span><span class="s2">,          </span><span class="s3">&quot;qtmultimedia&quot;</span><span class="s2">,     </span><span class="s3">&quot;audio&quot;</span><span class="s2">, </span><span class="s3">&quot;mediaservice&quot;</span><span class="s2">, </span><span class="s3">&quot;playlistformats&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5multimediaquick&quot;</span><span class="s1">:       (</span><span class="s2">None,                     </span><span class="s3">&quot;qtmultimedia&quot;</span><span class="s2">,     </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5multimediawidgets&quot;</span><span class="s1">:     (</span><span class="s3">&quot;.QtMultimediaWidgets&quot;</span><span class="s2">,   </span><span class="s3">&quot;qtmultimedia&quot;</span><span class="s2">,     </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5network&quot;</span><span class="s1">:               (</span><span class="s3">&quot;.QtNetwork&quot;</span><span class="s2">,             </span><span class="s3">&quot;qtbase&quot;</span><span class="s2">,           </span><span class="s3">&quot;bearer&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5nfc&quot;</span><span class="s1">:                   (</span><span class="s3">&quot;.QtNfc&quot;</span><span class="s2">,                 None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5opengl&quot;</span><span class="s1">:                (</span><span class="s3">&quot;.QtOpenGL&quot;</span><span class="s2">,              None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5positioning&quot;</span><span class="s1">:           (</span><span class="s3">&quot;.QtPositioning&quot;</span><span class="s2">,         None,               </span><span class="s3">&quot;position&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5printsupport&quot;</span><span class="s1">:          (</span><span class="s3">&quot;.QtPrintSupport&quot;</span><span class="s2">,        None,               </span><span class="s3">&quot;printsupport&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5qml&quot;</span><span class="s1">:                   (</span><span class="s3">&quot;.QtQml&quot;</span><span class="s2">,                 </span><span class="s3">&quot;qtdeclarative&quot;</span><span class="s2">,    </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5quick&quot;</span><span class="s1">:                 (</span><span class="s3">&quot;.QtQuick&quot;</span><span class="s2">,               </span><span class="s3">&quot;qtdeclarative&quot;</span><span class="s2">,    </span><span class="s3">&quot;scenegraph&quot;</span><span class="s2">, </span><span class="s3">&quot;qmltooling&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5quickparticles&quot;</span><span class="s1">:        (</span><span class="s2">None,                     None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5quickwidgets&quot;</span><span class="s1">:          (</span><span class="s3">&quot;.QtQuickWidgets&quot;</span><span class="s2">,        None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5script&quot;</span><span class="s1">:                (</span><span class="s2">None,                     </span><span class="s3">&quot;qtscript&quot;</span><span class="s2">,         </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5scripttools&quot;</span><span class="s1">:           (</span><span class="s2">None,                     </span><span class="s3">&quot;qtscript&quot;</span><span class="s2">,         </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5sensors&quot;</span><span class="s1">:               (</span><span class="s3">&quot;.QtSensors&quot;</span><span class="s2">,             None,               </span><span class="s3">&quot;sensors&quot;</span><span class="s2">, </span><span class="s3">&quot;sensorgestures&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5serialbus&quot;</span><span class="s1">:             (</span><span class="s2">None,                     None,               </span><span class="s3">&quot;canbus&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5serialport&quot;</span><span class="s1">:            (</span><span class="s3">&quot;.QtSerialPort&quot;</span><span class="s2">,          </span><span class="s3">&quot;qtserialport&quot;</span><span class="s2">,     </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5sql&quot;</span><span class="s1">:                   (</span><span class="s3">&quot;.QtSql&quot;</span><span class="s2">,                 </span><span class="s3">&quot;qtbase&quot;</span><span class="s2">,           </span><span class="s3">&quot;sqldrivers&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5svg&quot;</span><span class="s1">:                   (</span><span class="s3">&quot;.QtSvg&quot;</span><span class="s2">,                 None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5test&quot;</span><span class="s1">:                  (</span><span class="s3">&quot;.QtTest&quot;</span><span class="s2">,                </span><span class="s3">&quot;qtbase&quot;</span><span class="s2">,           </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5texttospeech&quot;</span><span class="s1">:          (</span><span class="s2">None,                     None,               </span><span class="s3">&quot;texttospeech&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5webchannel&quot;</span><span class="s1">:            (</span><span class="s3">&quot;.QtWebChannel&quot;</span><span class="s2">,          None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5webengine&quot;</span><span class="s1">:             (</span><span class="s3">&quot;.QtWebEngine&quot;</span><span class="s2">,           </span><span class="s3">&quot;qtwebengine&quot;</span><span class="s2">,      </span><span class="s3">&quot;qtwebengine&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5webenginecore&quot;</span><span class="s1">:         (</span><span class="s3">&quot;.QtWebEngineCore&quot;</span><span class="s2">,       None,               </span><span class="s3">&quot;qtwebengine&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5webenginewidgets&quot;</span><span class="s1">:      (</span><span class="s3">&quot;.QtWebEngineWidgets&quot;</span><span class="s2">,    None,               </span><span class="s3">&quot;qtwebengine&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5webkit&quot;</span><span class="s1">:                (</span><span class="s2">None,                     None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5webkitwidgets&quot;</span><span class="s1">:         (</span><span class="s2">None,                     None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5websockets&quot;</span><span class="s1">:            (</span><span class="s3">&quot;.QtWebSockets&quot;</span><span class="s2">,          None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5widgets&quot;</span><span class="s1">:               (</span><span class="s3">&quot;.QtWidgets&quot;</span><span class="s2">,             </span><span class="s3">&quot;qtbase&quot;</span><span class="s2">,           </span><span class="s3">&quot;styles&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5winextras&quot;</span><span class="s1">:             (</span><span class="s3">&quot;.QtWinExtras&quot;</span><span class="s2">,           None,               </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5xml&quot;</span><span class="s1">:                   (</span><span class="s3">&quot;.QtXml&quot;</span><span class="s2">,                 </span><span class="s3">&quot;qtbase&quot;</span><span class="s2">,           </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt5xmlpatterns&quot;</span><span class="s1">:           (</span><span class="s3">&quot;.QXmlPatterns&quot;</span><span class="s2">,          </span><span class="s3">&quot;qtxmlpatterns&quot;</span><span class="s2">,    </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
<span class="s1">}  </span><span class="s0"># yapf: disable</span>

<span class="s0"># The dynamic dependency dictionary for Qt6 is constructed automatically from its Qt5 counterpart, by copying the</span>
<span class="s0"># entries and substituting qt5 in the name with qt6. If the entry already exists in the dictionary, it is not</span>
<span class="s0"># copied, which allows us to provide Qt6-specific overrides, should they prove necessary.</span>
<span class="s1">_qt6_dynamic_dependencies_dict = {</span>
    <span class="s0"># Qt6Network:</span>
    <span class="s0"># networkinformationbackends plugins were introduced in Qt 6.1, and renamed to networkinformation in Qt 6.2</span>
    <span class="s0"># tls plugins were introduced in Qt 6.2</span>
    <span class="s3">&quot;qt6network&quot;</span><span class="s1">:               (</span><span class="s3">&quot;.QtNetwork&quot;</span><span class="s2">,             </span><span class="s3">&quot;qtbase&quot;</span><span class="s2">,           </span><span class="s3">&quot;networkinformationbackend&quot;</span><span class="s2">, </span><span class="s3">&quot;networkinformation&quot;</span><span class="s2">, </span><span class="s3">&quot;tls&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
    <span class="s3">&quot;qt6openglwidgets&quot;</span><span class="s1">:         (</span><span class="s3">&quot;.QtOpenGLWidgets&quot;</span><span class="s2">,       </span><span class="s3">&quot;qtbase&quot;</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># noqa</span>
<span class="s1">}  </span><span class="s0"># yapf: disable</span>

<span class="s2">for </span><span class="s1">lib_name</span><span class="s2">, </span><span class="s1">content </span><span class="s2">in </span><span class="s1">_qt5_dynamic_dependencies_dict.items():</span>
    <span class="s2">if </span><span class="s1">lib_name.startswith(</span><span class="s3">'qt5'</span><span class="s1">):</span>
        <span class="s1">lib_name = </span><span class="s3">'qt6' </span><span class="s1">+ lib_name[</span><span class="s4">3</span><span class="s1">:]</span>
    <span class="s2">if </span><span class="s1">lib_name </span><span class="s2">not in </span><span class="s1">_qt6_dynamic_dependencies_dict:</span>
        <span class="s1">_qt6_dynamic_dependencies_dict[lib_name] = content</span>
<span class="s2">del </span><span class="s1">lib_name</span><span class="s2">, </span><span class="s1">content</span>


<span class="s0"># add_qt_dependencies</span>
<span class="s0"># --------------------</span>
<span class="s0"># Generic implemnentation that finds the Qt 5/6 dependencies based on the hook name of a PyQt5/PyQt6/PySide2/PySide6</span>
<span class="s0"># hook. Returns (hiddenimports, binaries, datas). Typical usage:</span>
<span class="s0"># ``hiddenimports, binaries, datas = add_qt5_dependencies(__file__)``.</span>
<span class="s2">def </span><span class="s1">add_qt_dependencies(hook_file):</span>
    <span class="s0"># Accumulate all dependencies in a set to avoid duplicates.</span>
    <span class="s1">hiddenimports = set()</span>
    <span class="s1">translations_base = set()</span>
    <span class="s1">plugins = set()</span>

    <span class="s0"># Find the module underlying this Qt hook: change ``/path/to/hook-PyQt5.blah.py`` to ``PyQt5.blah``.</span>
    <span class="s1">hook_name</span><span class="s2">, </span><span class="s1">hook_ext = os.path.splitext(os.path.basename(hook_file))</span>
    <span class="s2">assert </span><span class="s1">hook_ext.startswith(</span><span class="s3">'.py'</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">hook_name.startswith(</span><span class="s3">'hook-'</span><span class="s1">)</span>
    <span class="s1">module_name = hook_name[</span><span class="s4">5</span><span class="s1">:]</span>
    <span class="s1">namespace = module_name.split(</span><span class="s3">'.'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0"># Retrieve Qt library info structure.</span>
    <span class="s1">qt_info = get_qt_library_info(namespace)</span>

    <span class="s0"># Exit if the requested library cannot be imported.</span>
    <span class="s0"># NOTE: qt_info.version can be empty list on older Qt5 versions (#5381).</span>
    <span class="s2">if </span><span class="s1">qt_info.version </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span>

    <span class="s0"># Look up the module returned by this import.</span>
    <span class="s1">module = hooks.get_module_file_attribute(module_name)</span>
    <span class="s1">logger.debug(</span><span class="s3">'add_qt%d_dependencies: Examining %s, based on hook of %s.'</span><span class="s2">, </span><span class="s1">qt_info.qt_major</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">hook_file)</span>

    <span class="s0"># Walk through all the static dependencies of a dynamically-linked library (``.so``/``.dll``/``.dylib``).</span>
    <span class="s1">imports = set(bindepend.getImports(module))</span>
    <span class="s2">while </span><span class="s1">imports:</span>
        <span class="s1">imp = imports.pop()</span>

        <span class="s0"># On Windows, find this library; other platforms already provide the full path.</span>
        <span class="s2">if </span><span class="s1">compat.is_win:</span>
            <span class="s0"># First, look for Qt binaries in the local Qt install.</span>
            <span class="s1">imp = bindepend.getfullnameof(imp</span><span class="s2">, </span><span class="s1">qt_info.location[</span><span class="s3">'BinariesPath'</span><span class="s1">])</span>

        <span class="s0"># Strip off the extension and ``lib`` prefix (Linux/Mac) to give the raw name.</span>
        <span class="s0"># Lowercase (since Windows always normalizes names to lowercase).</span>
        <span class="s1">lib_name = os.path.splitext(os.path.basename(imp))[</span><span class="s4">0</span><span class="s1">].lower()</span>
        <span class="s0"># Linux libraries sometimes have a dotted version number -- ``libfoo.so.3``. It is now ''libfoo.so``,</span>
        <span class="s0"># but the ``.so`` must also be removed.</span>
        <span class="s2">if </span><span class="s1">compat.is_linux </span><span class="s2">and </span><span class="s1">os.path.splitext(lib_name)[</span><span class="s4">1</span><span class="s1">] == </span><span class="s3">'.so'</span><span class="s1">:</span>
            <span class="s1">lib_name = os.path.splitext(lib_name)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">lib_name.startswith(</span><span class="s3">'lib'</span><span class="s1">):</span>
            <span class="s1">lib_name = lib_name[</span><span class="s4">3</span><span class="s1">:]</span>
        <span class="s0"># Mac OS: handle different naming schemes. PyPI wheels ship framework-enabled Qt builds, where shared libraries</span>
        <span class="s0"># are part of .framework bundles (e.g., ``PyQt5/Qt5/lib/QtCore.framework/Versions/5/QtCore``). In Anaconda</span>
        <span class="s0"># (Py)Qt installations, the shared libraries are installed in environment's library directory, and contain</span>
        <span class="s0"># versioned extensions, e.g., ``libQt5Core.5.dylib``.</span>
        <span class="s2">if </span><span class="s1">compat.is_darwin:</span>
            <span class="s2">if </span><span class="s1">lib_name.startswith(</span><span class="s3">'qt'</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">lib_name.startswith(</span><span class="s3">'qt' </span><span class="s1">+ str(qt_info.qt_major)):</span>
                <span class="s0"># Qt library from a framework bundle (e.g., ``QtCore``); change prefix from ``qt`` to ``qt5`` or ``qt6``</span>
                <span class="s0"># to match names in Windows/Linux.</span>
                <span class="s1">lib_name = </span><span class="s3">'qt' </span><span class="s1">+ str(qt_info.qt_major) + lib_name[</span><span class="s4">2</span><span class="s1">:]</span>
            <span class="s2">if </span><span class="s1">lib_name.endswith(</span><span class="s3">'.' </span><span class="s1">+ str(qt_info.qt_major)):</span>
                <span class="s0"># Qt library from Anaconda, which originally had versioned extension, e.g., ``libfoo.5.dynlib``.</span>
                <span class="s0"># The above processing turned it into ``foo.5``, so we need to remove the last two characters.</span>
                <span class="s1">lib_name = lib_name[:-</span><span class="s4">2</span><span class="s1">]</span>

        <span class="s0"># Match libs with QT_LIBINFIX set to '_conda', i.e. conda-forge builds.</span>
        <span class="s2">if </span><span class="s1">lib_name.endswith(</span><span class="s3">'_conda'</span><span class="s1">):</span>
            <span class="s1">lib_name = lib_name[:-</span><span class="s4">6</span><span class="s1">]</span>

        <span class="s1">logger.debug(</span><span class="s3">'add_qt%d_dependencies: raw lib %s -&gt; parsed lib %s'</span><span class="s2">, </span><span class="s1">qt_info.qt_major</span><span class="s2">, </span><span class="s1">imp</span><span class="s2">, </span><span class="s1">lib_name)</span>

        <span class="s0"># PySide2 and PySide6 on linux seem to link all extension modules against libQt5Core, libQt5Network, and</span>
        <span class="s0"># libQt5Qml (or their libQt6* equivalents). While the first two are reasonable, the libQt5Qml dependency pulls</span>
        <span class="s0"># in whole QtQml module, along with its data and plugins, which in turn pull in several other Qt libraries,</span>
        <span class="s0"># greatly inflating the bundle size (see #6447).</span>
        <span class="s0">#</span>
        <span class="s0"># Similarly, some extension modules (QtWebChannel, QtWebEngine*) seem to be also linked against libQt5Qml,</span>
        <span class="s0"># even when the module can be used without having the whole QtQml module collected.</span>
        <span class="s0">#</span>
        <span class="s0"># Therefore, we explicitly prevent inclusion of QtQml based on the dynamic library dependency, except for</span>
        <span class="s0"># QtQml* and QtQuick* modules, whose use directly implies the use of QtQml.</span>
        <span class="s2">if </span><span class="s1">lib_name </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;qt5qml&quot;</span><span class="s2">, </span><span class="s3">&quot;qt6qml&quot;</span><span class="s1">):</span>
            <span class="s1">short_module_name = module_name.split(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)[-</span><span class="s4">1</span><span class="s1">]  </span><span class="s0"># PySide2.QtModule -&gt; QtModule</span>
            <span class="s2">if not </span><span class="s1">short_module_name.startswith((</span><span class="s3">'QtQml'</span><span class="s2">, </span><span class="s3">'QtQuick'</span><span class="s1">)):</span>
                <span class="s1">logger.debug(</span><span class="s3">'add_qt%d_dependencies: Ignoring import of %s.'</span><span class="s2">, </span><span class="s1">qt_info.qt_major</span><span class="s2">, </span><span class="s1">imp)</span>
                <span class="s2">continue</span>

        <span class="s0"># Follow only Qt dependencies.</span>
        <span class="s1">_qt_dynamic_dependencies_dict = (</span>
            <span class="s1">_qt5_dynamic_dependencies_dict </span><span class="s2">if </span><span class="s1">qt_info.qt_major == </span><span class="s4">5 </span><span class="s2">else </span><span class="s1">_qt6_dynamic_dependencies_dict</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">lib_name </span><span class="s2">in </span><span class="s1">_qt_dynamic_dependencies_dict:</span>
            <span class="s0"># Follow these to find additional dependencies.</span>
            <span class="s1">logger.debug(</span><span class="s3">'add_qt%d_dependencies: Import of %s.'</span><span class="s2">, </span><span class="s1">qt_info.qt_major</span><span class="s2">, </span><span class="s1">imp)</span>
            <span class="s1">imports.update(bindepend.getImports(imp))</span>
            <span class="s0"># Look up which plugins and translations are needed.</span>
            <span class="s1">dd = _qt_dynamic_dependencies_dict[lib_name]</span>
            <span class="s1">lib_name_hiddenimports</span><span class="s2">, </span><span class="s1">lib_name_translations_base = dd[:</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">lib_name_plugins = dd[</span><span class="s4">2</span><span class="s1">:]</span>
            <span class="s0"># Add them in.</span>
            <span class="s2">if </span><span class="s1">lib_name_hiddenimports:</span>
                <span class="s1">hiddenimports.update([namespace + lib_name_hiddenimports])</span>
            <span class="s1">plugins.update(lib_name_plugins)</span>
            <span class="s2">if </span><span class="s1">lib_name_translations_base:</span>
                <span class="s1">translations_base.update([lib_name_translations_base])</span>

    <span class="s0"># Change plugins into binaries.</span>
    <span class="s1">binaries = []</span>
    <span class="s2">for </span><span class="s1">plugin </span><span class="s2">in </span><span class="s1">plugins:</span>
        <span class="s1">more_binaries = qt_plugins_binaries(plugin</span><span class="s2">, </span><span class="s1">namespace=namespace)</span>
        <span class="s1">binaries.extend(more_binaries)</span>
    <span class="s0"># Change translation_base to datas.</span>
    <span class="s1">tp = qt_info.location[</span><span class="s3">'TranslationsPath'</span><span class="s1">]</span>
    <span class="s1">tp_dst = os.path.join(qt_info.qt_rel_dir</span><span class="s2">, </span><span class="s3">'translations'</span><span class="s1">)</span>
    <span class="s1">datas = []</span>
    <span class="s2">for </span><span class="s1">tb </span><span class="s2">in </span><span class="s1">translations_base:</span>
        <span class="s1">src = os.path.join(tp</span><span class="s2">, </span><span class="s1">tb + </span><span class="s3">'_*.qm'</span><span class="s1">)</span>
        <span class="s0"># Not all PyQt5 installations include translations. See</span>
        <span class="s0"># https://github.com/pyinstaller/pyinstaller/pull/3229#issuecomment-359479893</span>
        <span class="s0"># and</span>
        <span class="s0"># https://github.com/pyinstaller/pyinstaller/issues/2857#issuecomment-368744341.</span>
        <span class="s2">if </span><span class="s1">glob.glob(src):</span>
            <span class="s1">datas.append((src</span><span class="s2">, </span><span class="s1">tp_dst))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">logger.warning(</span>
                <span class="s3">'Unable to find Qt%d translations %s. These translations were not packaged.'</span><span class="s2">, </span><span class="s1">qt_info.qt_major</span><span class="s2">, </span><span class="s1">src</span>
            <span class="s1">)</span>
    <span class="s0"># Change hiddenimports to a list.</span>
    <span class="s1">hiddenimports = list(hiddenimports)</span>

    <span class="s1">logger.debug(</span>
        <span class="s3">'add_qt%d_dependencies: imports from %s:</span><span class="s2">\n</span><span class="s3">'</span>
        <span class="s3">'  hiddenimports = %s</span><span class="s2">\n</span><span class="s3">'</span>
        <span class="s3">'  binaries = %s</span><span class="s2">\n</span><span class="s3">'</span>
        <span class="s3">'  datas = %s'</span><span class="s2">, </span><span class="s1">qt_info.qt_major</span><span class="s2">, </span><span class="s1">hook_name</span><span class="s2">, </span><span class="s1">hiddenimports</span><span class="s2">, </span><span class="s1">binaries</span><span class="s2">, </span><span class="s1">datas</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">hiddenimports</span><span class="s2">, </span><span class="s1">binaries</span><span class="s2">, </span><span class="s1">datas</span>


<span class="s0"># add_qt5_dependencies</span>
<span class="s0"># --------------------</span>
<span class="s0"># Find the Qt5 dependencies based on the hook name of a PySide2/PyQt5 hook. Returns (hiddenimports, binaries, datas).</span>
<span class="s0"># Typical usage: ``hiddenimports, binaries, datas = add_qt5_dependencies(__file__)``.</span>
<span class="s1">add_qt5_dependencies = add_qt_dependencies  </span><span class="s0"># Use generic implementation</span>

<span class="s0"># add_qt6_dependencies</span>
<span class="s0"># --------------------</span>
<span class="s0"># Find the Qt6 dependencies based on the hook name of a PySide6/PyQt6 hook. Returns (hiddenimports, binaries, datas).</span>
<span class="s0"># Typical usage: ``hiddenimports, binaries, datas = add_qt6_dependencies(__file__)``.</span>
<span class="s1">add_qt6_dependencies = add_qt_dependencies  </span><span class="s0"># Use generic implementation</span>


<span class="s2">def </span><span class="s1">_find_all_or_none(globs_to_include</span><span class="s2">, </span><span class="s1">num_files</span><span class="s2">, </span><span class="s1">qt_library_info):</span>
    <span class="s5">&quot;&quot;&quot; 
    globs_to_include is a list of file name globs. 
    If the number of found files does not match num_files, no files will be included. 
    &quot;&quot;&quot;</span>
    <span class="s0"># This function is required because CI is failing to include libEGL.</span>
    <span class="s0"># The error in AppVeyor is::</span>
    <span class="s0">#</span>
    <span class="s0">#   [2312] LOADER: Running pyi_lib_PyQt5-uic.py</span>
    <span class="s0">#   Failed to load libEGL (Access is denied.)</span>
    <span class="s0">#   More info: https://github.com/pyinstaller/pyinstaller/pull/3568</span>
    <span class="s0">#</span>
    <span class="s0"># Since old PyQt5 wheels do not include d3dcompiler_4?.dll, libEGL.dll and libGLESv2.dll will not be included</span>
    <span class="s0"># for PyQt5 builds during CI.</span>
    <span class="s1">to_include = []</span>
    <span class="s1">dst_dll_path = </span><span class="s3">'.'</span>
    <span class="s2">for </span><span class="s1">dll </span><span class="s2">in </span><span class="s1">globs_to_include:</span>
        <span class="s0"># In PyQt5/PyQt6, the DLLs we are looking for are located in location['BinariesPath'], whereas in</span>
        <span class="s0"># PySide2/PySide6, they are located in location['PrefixPath'].</span>
        <span class="s1">dll_path = os.path.join(</span>
            <span class="s1">qt_library_info.location[</span><span class="s3">'BinariesPath' </span><span class="s2">if </span><span class="s1">qt_library_info.is_pyqt </span><span class="s2">else </span><span class="s3">'PrefixPath'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dll</span>
        <span class="s1">)</span>
        <span class="s1">dll_file_paths = glob.glob(dll_path)</span>
        <span class="s2">for </span><span class="s1">dll_file_path </span><span class="s2">in </span><span class="s1">dll_file_paths:</span>
            <span class="s1">to_include.append((dll_file_path</span><span class="s2">, </span><span class="s1">dst_dll_path))</span>
    <span class="s2">if </span><span class="s1">len(to_include) == num_files:</span>
        <span class="s2">return </span><span class="s1">to_include</span>
    <span class="s2">return </span><span class="s1">[]</span>


<span class="s0"># Collect required Qt binaries, but only if all binaries in a group exist.</span>
<span class="s2">def </span><span class="s1">get_qt_binaries(qt_library_info):</span>
    <span class="s1">binaries = []</span>
    <span class="s1">angle_files = [</span><span class="s3">'libEGL.dll'</span><span class="s2">, </span><span class="s3">'libGLESv2.dll'</span><span class="s2">, </span><span class="s3">'d3dcompiler_??.dll'</span><span class="s1">]</span>
    <span class="s1">binaries += _find_all_or_none(angle_files</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">qt_library_info)</span>

    <span class="s1">opengl_software_renderer = [</span><span class="s3">'opengl32sw.dll'</span><span class="s1">]</span>
    <span class="s1">binaries += _find_all_or_none(opengl_software_renderer</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">qt_library_info)</span>

    <span class="s0"># Include ICU files, if they exist.</span>
    <span class="s0"># See the &quot;Deployment approach&quot; section in ``PyInstaller/utils/hooks/qt.py``.</span>
    <span class="s1">icu_files = [</span><span class="s3">'icudt??.dll'</span><span class="s2">, </span><span class="s3">'icuin??.dll'</span><span class="s2">, </span><span class="s3">'icuuc??.dll'</span><span class="s1">]</span>
    <span class="s1">binaries += _find_all_or_none(icu_files</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">qt_library_info)</span>

    <span class="s2">return </span><span class="s1">binaries</span>


<span class="s0"># Collect additional shared libraries required for SSL support in QtNetwork, if they are available.</span>
<span class="s0"># Applicable only to Windows. See issue #3520, #4048.</span>
<span class="s2">def </span><span class="s1">get_qt_network_ssl_binaries(qt_library_info):</span>
    <span class="s0"># No-op if requested Qt-based package is not available.</span>
    <span class="s2">if </span><span class="s1">qt_library_info.version </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s0"># Applicable only to Windows.</span>
    <span class="s2">if not </span><span class="s1">compat.is_win:</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s0"># Check if QtNetwork supports SSL.</span>
    <span class="s1">ssl_enabled = hooks.eval_statement(</span>
        <span class="s3">&quot;&quot;&quot; 
        from {}.QtNetwork import QSslSocket 
        print(QSslSocket.supportsSsl()) 
        &quot;&quot;&quot;</span><span class="s1">.format(qt_library_info.namespace)</span>
    <span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">ssl_enabled:</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s0"># PyPI version of PySide2 requires user to manually install SSL libraries into the PrefixPath. Other versions</span>
    <span class="s0"># (e.g., the one provided by Conda) put the libraries into the BinariesPath. PyQt5 also uses BinariesPath.</span>
    <span class="s0"># Accommodate both options by searching both locations...</span>
    <span class="s1">locations = (qt_library_info.location[</span><span class="s3">'BinariesPath'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">qt_library_info.location[</span><span class="s3">'PrefixPath'</span><span class="s1">])</span>
    <span class="s1">dll_names = (</span><span class="s3">'libeay32.dll'</span><span class="s2">, </span><span class="s3">'ssleay32.dll'</span><span class="s2">, </span><span class="s3">'libssl-1_1-x64.dll'</span><span class="s2">, </span><span class="s3">'libcrypto-1_1-x64.dll'</span><span class="s1">)</span>
    <span class="s1">binaries = []</span>
    <span class="s2">for </span><span class="s1">location </span><span class="s2">in </span><span class="s1">locations:</span>
        <span class="s2">for </span><span class="s1">dll </span><span class="s2">in </span><span class="s1">dll_names:</span>
            <span class="s1">dll_path = os.path.join(location</span><span class="s2">, </span><span class="s1">dll)</span>
            <span class="s2">if </span><span class="s1">os.path.exists(dll_path):</span>
                <span class="s1">binaries.append((dll_path</span><span class="s2">, </span><span class="s3">'.'</span><span class="s1">))</span>
    <span class="s2">return </span><span class="s1">binaries</span>


<span class="s0"># Collect additional binaries and data for QtQml module.</span>
<span class="s2">def </span><span class="s1">get_qt_qml_files(qt_library_info):</span>
    <span class="s0"># No-op if requested Qt-based package is not available.</span>
    <span class="s2">if </span><span class="s1">qt_library_info.version </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span>

    <span class="s0"># Not all PyQt5/PySide2 installs have QML files. In this case, location['Qml2ImportsPath'] is empty.</span>
    <span class="s0"># Furthermore, even if location path is provided, the directory itself may not exist.</span>
    <span class="s0">#</span>
    <span class="s0"># https://github.com/pyinstaller/pyinstaller/pull/3229#issuecomment-359735031</span>
    <span class="s0"># https://github.com/pyinstaller/pyinstaller/issues/3864</span>
    <span class="s1">qmldir = qt_library_info.location[</span><span class="s3">'Qml2ImportsPath'</span><span class="s1">]</span>
    <span class="s2">if not </span><span class="s1">qmldir </span><span class="s2">or not </span><span class="s1">os.path.exists(qmldir):</span>
        <span class="s1">logger.warning(</span>
            <span class="s3">'QML directory for %s, %r, does not exist. QML files not packaged.'</span><span class="s2">, </span><span class="s1">qt_library_info.namespace</span><span class="s2">, </span><span class="s1">qmldir</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span>

    <span class="s1">qml_rel_dir = os.path.join(qt_library_info.qt_rel_dir</span><span class="s2">, </span><span class="s3">'qml'</span><span class="s1">)</span>
    <span class="s1">datas = [(qmldir</span><span class="s2">, </span><span class="s1">qml_rel_dir)]</span>
    <span class="s1">binaries = [</span>
        <span class="s0"># Produce ``/path/to/Qt/Qml/path_to_qml_binary/qml_binary, PyQt5/Qt/Qml/path_to_qml_binary``.</span>
        <span class="s1">(f</span><span class="s2">, </span><span class="s1">os.path.join(qml_rel_dir</span><span class="s2">, </span><span class="s1">os.path.dirname(os.path.relpath(f</span><span class="s2">, </span><span class="s1">qmldir))))</span>
        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">misc.dlls_in_subdirs(qmldir)</span>
    <span class="s1">]</span>

    <span class="s2">return </span><span class="s1">binaries</span><span class="s2">, </span><span class="s1">datas</span>


<span class="s0"># Collect the ``qt.conf`` file.</span>
<span class="s2">def </span><span class="s1">get_qt_conf_file(qt_library_info):</span>
    <span class="s0"># No-op if requested Qt-based package is not available.</span>
    <span class="s2">if </span><span class="s1">qt_library_info.version </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">[]</span>
    <span class="s0"># Find ``qt.conf`` in location['PrefixPath'].</span>
    <span class="s1">datas = [</span>
        <span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">hooks.collect_system_data_files(qt_library_info.location[</span><span class="s3">'PrefixPath'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">qt_library_info.qt_rel_dir)</span>
        <span class="s2">if </span><span class="s1">os.path.basename(x[</span><span class="s4">0</span><span class="s1">]) == </span><span class="s3">'qt.conf'</span>
    <span class="s1">]</span>
    <span class="s2">return </span><span class="s1">datas</span>


<span class="s0"># Collect QtWebEngine helper process executable, translations, and resources.</span>
<span class="s2">def </span><span class="s1">get_qt_webengine_binaries_and_data_files(qt_library_info):</span>
    <span class="s1">binaries = []</span>
    <span class="s1">datas = []</span>

    <span class="s0"># Output directory (varies between PyQt and PySide and among OSes; the difference is abstracted by</span>
    <span class="s0"># qt_library_info.qt_rel_dir)</span>
    <span class="s1">rel_data_path = qt_library_info.qt_rel_dir</span>

    <span class="s1">is_macos_framework = </span><span class="s2">False</span>
    <span class="s2">if </span><span class="s1">compat.is_darwin:</span>
        <span class="s0"># Determine if we are dealing with a framework-based Qt build (e.g., PyPI wheels) or a dylib-based one</span>
        <span class="s0"># (e.g., Anaconda). The former requires special handling, while the latter is handled in the same way as</span>
        <span class="s0"># Windows and Linux builds.</span>
        <span class="s1">is_macos_framework = os.path.exists(</span>
            <span class="s1">os.path.join(qt_library_info.location[</span><span class="s3">'LibrariesPath'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'QtWebEngineCore.framework'</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">is_macos_framework:</span>
        <span class="s0"># On macOS, Qt shared libraries are provided in form of .framework bundles. However, PyInstaller collects shared</span>
        <span class="s0"># library from the bundle into top-level application directory, breaking the bundle structure.</span>
        <span class="s0">#</span>
        <span class="s0"># QtWebEngine and its underlying Chromium engine, however, have very strict data file layout requirements due to</span>
        <span class="s0"># sandboxing, and does not work if the helper process executable does not load the shared library from</span>
        <span class="s0"># QtWebEngineCore.framework (which also needs to contain all resources).</span>
        <span class="s0">#</span>
        <span class="s0"># Therefore, we collect the QtWebEngineCore.framework manually, in order to obtain a working QtWebEngineProcess</span>
        <span class="s0"># helper executable. But because that bypasses our dependency scanner, we need to collect the dependent</span>
        <span class="s0"># .framework bundles as well. And we need to override QTWEBENGINEPROCESS_PATH in rthook, because the</span>
        <span class="s0"># QtWebEngineWidgets python extension actually loads up the copy of shared library that is located in</span>
        <span class="s0"># sys._MEIPASS (as opposed to the manually-copied one in .framework bundle). Furthermore, because the extension</span>
        <span class="s0"># modules use Qt shared libraries in sys._MEIPASS, we also copy all contents of</span>
        <span class="s0"># QtWebEngineCore.framework/Resources into sys._MEIPASS to make resource loading in the main process work.</span>
        <span class="s0">#</span>
        <span class="s0"># Besides being ugly, this approach has three main ramifications:</span>
        <span class="s0"># 1. we bundle two copies of each Qt shared library involved: the copy used by main process, picked up by</span>
        <span class="s0">#    dependency scanner; and a copy in manually-collected .framework bundle that is used by the helper process.</span>
        <span class="s0"># 2. the trick with copying contents of Resource directory of QtWebEngineCore.framework does not work in onefile</span>
        <span class="s0">#    mode, and consequently QtWebEngine does not work in onefile mode.</span>
        <span class="s0"># 3. copying contents of QtWebEngineCore.framework/Resource means that its Info.plist ends up in sys._MEIPASS,</span>
        <span class="s0">#    causing the main process in onedir mode to be mis-identified as &quot;QtWebEngineProcess&quot;.</span>
        <span class="s0">#</span>
        <span class="s0"># In the near future, this quagmire will hopefully be properly sorted out, but in the mean time, we have to live</span>
        <span class="s0"># with what we have been given.</span>
        <span class="s1">data_path = qt_library_info.location[</span><span class="s3">'DataPath'</span><span class="s1">]</span>
        <span class="s1">libraries = [</span>
            <span class="s3">'QtCore'</span><span class="s2">, </span><span class="s3">'QtWebEngineCore'</span><span class="s2">, </span><span class="s3">'QtQuick'</span><span class="s2">, </span><span class="s3">'QtQml'</span><span class="s2">, </span><span class="s3">'QtQmlModels'</span><span class="s2">, </span><span class="s3">'QtNetwork'</span><span class="s2">, </span><span class="s3">'QtGui'</span><span class="s2">, </span><span class="s3">'QtWebChannel'</span><span class="s2">,</span>
            <span class="s3">'QtPositioning'</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">libraries:</span>
            <span class="s1">framework_dir = i + </span><span class="s3">'.framework'</span>
            <span class="s1">datas += hooks.collect_system_data_files(</span>
                <span class="s1">os.path.join(data_path</span><span class="s2">, </span><span class="s3">'lib'</span><span class="s2">, </span><span class="s1">framework_dir)</span><span class="s2">, </span><span class="s1">os.path.join(rel_data_path</span><span class="s2">, </span><span class="s3">'lib'</span><span class="s2">, </span><span class="s1">framework_dir)</span><span class="s2">, True</span>
            <span class="s1">)</span>
        <span class="s1">datas += [(os.path.join(data_path</span><span class="s2">, </span><span class="s3">'lib'</span><span class="s2">, </span><span class="s3">'QtWebEngineCore.framework'</span><span class="s2">, </span><span class="s3">'Resources'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">os.curdir)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># Windows and linux (or Anaconda on macOS)</span>
        <span class="s1">locales = </span><span class="s3">'qtwebengine_locales'</span>
        <span class="s1">resources = </span><span class="s3">'resources'</span>

        <span class="s0"># Translations</span>
        <span class="s1">datas.append((</span>
            <span class="s1">os.path.join(qt_library_info.location[</span><span class="s3">'TranslationsPath'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">locales)</span><span class="s2">,</span>
            <span class="s1">os.path.join(rel_data_path</span><span class="s2">, </span><span class="s3">'translations'</span><span class="s2">, </span><span class="s1">locales)</span><span class="s2">,</span>
        <span class="s1">))</span>

        <span class="s0"># Resources; ``DataPath`` is the base directory for ``resources``, as per the</span>
        <span class="s0"># `docs &lt;https://doc.qt.io/qt-5.10/qtwebengine-deploying.html#deploying-resources&gt;`_.</span>
        <span class="s1">datas.append(</span>
            <span class="s1">(os.path.join(qt_library_info.location[</span><span class="s3">'DataPath'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">resources)</span><span class="s2">, </span><span class="s1">os.path.join(rel_data_path</span><span class="s2">, </span><span class="s1">resources))</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s0"># Helper process executable (QtWebEngineProcess), located in ``LibraryExecutablesPath``.</span>
        <span class="s1">dest = os.path.join(</span>
            <span class="s1">rel_data_path</span><span class="s2">,</span>
            <span class="s1">os.path.relpath(qt_library_info.location[</span><span class="s3">'LibraryExecutablesPath'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">qt_library_info.location[</span><span class="s3">'PrefixPath'</span><span class="s1">])</span>
        <span class="s1">)</span>
        <span class="s1">binaries.append((os.path.join(qt_library_info.location[</span><span class="s3">'LibraryExecutablesPath'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'QtWebEngineProcess*'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dest))</span>

    <span class="s0"># Add Linux-specific libraries.</span>
    <span class="s2">if </span><span class="s1">compat.is_linux:</span>
        <span class="s0"># The automatic library detection fails for `NSS &lt;https://packages.ubuntu.com/search?keywords=libnss3&gt;`_, which</span>
        <span class="s0"># is used by QtWebEngine. In some distributions, the ``libnss`` supporting libraries are stored in a</span>
        <span class="s0"># subdirectory ``nss``. Since ``libnss`` is not statically linked to these, but dynamically loads them, we need</span>
        <span class="s0"># to search for and add them.</span>

        <span class="s0"># First, get all libraries linked to ``QtWebEngineWidgets`` extension module.</span>
        <span class="s1">module_file = hooks.get_module_file_attribute(qt_library_info.namespace + </span><span class="s3">'.QtWebEngineWidgets'</span><span class="s1">)</span>
        <span class="s1">module_imports = bindepend.getImports(module_file)</span>
        <span class="s2">for </span><span class="s1">imp </span><span class="s2">in </span><span class="s1">module_imports:</span>
            <span class="s0"># Look for ``libnss3.so``.</span>
            <span class="s2">if </span><span class="s1">os.path.basename(imp).startswith(</span><span class="s3">'libnss3.so'</span><span class="s1">):</span>
                <span class="s0"># Find the location of NSS: given a ``/path/to/libnss.so``, add ``/path/to/nss/*.so`` to get the</span>
                <span class="s0"># missing NSS libraries.</span>
                <span class="s1">nss_glob = os.path.join(os.path.dirname(imp)</span><span class="s2">, </span><span class="s3">'nss'</span><span class="s2">, </span><span class="s3">'*.so'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">glob.glob(nss_glob):</span>
                    <span class="s1">binaries.append((nss_glob</span><span class="s2">, </span><span class="s3">'nss'</span><span class="s1">))</span>

    <span class="s2">return </span><span class="s1">binaries</span><span class="s2">, </span><span class="s1">datas</span>
</pre>
</body>
</html>