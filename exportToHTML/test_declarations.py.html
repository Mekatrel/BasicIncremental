<html>
<head>
<title>test_declarations.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_declarations.py</font>
</center></td></tr></table>
<pre><span class="s0">##############################################################################</span>
<span class="s0">#</span>
<span class="s0"># Copyright (c) 2003 Zope Foundation and Contributors.</span>
<span class="s0"># All Rights Reserved.</span>
<span class="s0">#</span>
<span class="s0"># This software is subject to the provisions of the Zope Public License,</span>
<span class="s0"># Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY AND ALL EXPRESS OR IMPLIED</span>
<span class="s0"># WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="s0"># WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS</span>
<span class="s0"># FOR A PARTICULAR PURPOSE.</span>
<span class="s0">#</span>
<span class="s0">##############################################################################</span>
<span class="s2">&quot;&quot;&quot;Test the new API for making and checking interface declarations 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">unittest</span>

<span class="s3">from </span><span class="s1">zope.interface._compat </span><span class="s3">import </span><span class="s1">_skip_under_py3k</span>
<span class="s3">from </span><span class="s1">zope.interface._compat </span><span class="s3">import </span><span class="s1">PYTHON3</span>
<span class="s3">from </span><span class="s1">zope.interface.tests </span><span class="s3">import </span><span class="s1">OptimizationTestMixin</span>
<span class="s3">from </span><span class="s1">zope.interface.tests </span><span class="s3">import </span><span class="s1">MissingSomeAttrs</span>
<span class="s3">from </span><span class="s1">zope.interface.tests.test_interface </span><span class="s3">import </span><span class="s1">NameAndModuleComparisonTestsMixin</span>

<span class="s0"># pylint:disable=inherit-non-class,too-many-lines,protected-access</span>
<span class="s0"># pylint:disable=blacklisted-name,attribute-defined-outside-init</span>

<span class="s3">class </span><span class="s1">_Py3ClassAdvice(object):</span>

    <span class="s3">def </span><span class="s1">_run_generated_code(self</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs</span><span class="s3">,</span>
                            <span class="s1">fails_under_py3k=</span><span class="s3">True,</span>
                           <span class="s1">):</span>
        <span class="s0"># pylint:disable=exec-used,no-member</span>
        <span class="s3">import </span><span class="s1">warnings</span>
        <span class="s3">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s3">True</span><span class="s1">) </span><span class="s3">as </span><span class="s1">log:</span>
            <span class="s1">warnings.resetwarnings()</span>
            <span class="s3">if not </span><span class="s1">PYTHON3:</span>
                <span class="s1">exec(code</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs)</span>
                <span class="s1">self.assertEqual(len(log)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">) </span><span class="s0"># no longer warn</span>
                <span class="s3">return True</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">exec(code</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs)</span>
            <span class="s3">except </span><span class="s1">TypeError:</span>
                <span class="s3">return False</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">fails_under_py3k:</span>
                    <span class="s1">self.fail(</span><span class="s5">&quot;Didn't raise TypeError&quot;</span><span class="s1">)</span>
            <span class="s3">return None</span>


<span class="s3">class </span><span class="s1">NamedTests(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">test_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">named</span>

        <span class="s1">@named(</span><span class="s5">u'foo'</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>

        <span class="s1">self.assertEqual(Foo.__component_name__</span><span class="s3">, </span><span class="s5">u'foo'</span><span class="s1">) </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s3">def </span><span class="s1">test_function(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">named</span>

        <span class="s1">@named(</span><span class="s5">u'foo'</span><span class="s1">)</span>
        <span class="s3">def </span><span class="s1">doFoo(o):</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

        <span class="s1">self.assertEqual(doFoo.__component_name__</span><span class="s3">, </span><span class="s5">u'foo'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_instance(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">named</span>

        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">named(</span><span class="s5">u'foo'</span><span class="s1">)(foo)</span>

        <span class="s1">self.assertEqual(foo.__component_name__</span><span class="s3">, </span><span class="s5">u'foo'</span><span class="s1">) </span><span class="s0"># pylint:disable=no-member</span>


<span class="s3">class </span><span class="s1">EmptyDeclarationTests(unittest.TestCase):</span>
    <span class="s0"># Tests that should pass for all objects that are empty</span>
    <span class="s0"># declarations. This includes a Declaration explicitly created</span>
    <span class="s0"># that way, and the empty ImmutableDeclaration.</span>
    <span class="s3">def </span><span class="s1">_getEmpty(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Declaration</span>
        <span class="s3">return </span><span class="s1">Declaration()</span>

    <span class="s3">def </span><span class="s1">test___iter___empty(self):</span>
        <span class="s1">decl = self._getEmpty()</span>
        <span class="s1">self.assertEqual(list(decl)</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_flattened_empty(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s1">decl = self._getEmpty()</span>
        <span class="s1">self.assertEqual(list(decl.flattened())</span><span class="s3">, </span><span class="s1">[Interface])</span>

    <span class="s3">def </span><span class="s1">test___contains___empty(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s1">decl = self._getEmpty()</span>
        <span class="s1">self.assertNotIn(Interface</span><span class="s3">, </span><span class="s1">decl)</span>

    <span class="s3">def </span><span class="s1">test_extends_empty(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s1">decl = self._getEmpty()</span>
        <span class="s1">self.assertTrue(decl.extends(Interface))</span>
        <span class="s1">self.assertTrue(decl.extends(Interface</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_interfaces_empty(self):</span>
        <span class="s1">decl = self._getEmpty()</span>
        <span class="s1">l = list(decl.interfaces())</span>
        <span class="s1">self.assertEqual(l</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test___sro___(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s1">decl = self._getEmpty()</span>
        <span class="s1">self.assertEqual(decl.__sro__</span><span class="s3">, </span><span class="s1">(decl</span><span class="s3">, </span><span class="s1">Interface</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test___iro___(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s1">decl = self._getEmpty()</span>
        <span class="s1">self.assertEqual(decl.__iro__</span><span class="s3">, </span><span class="s1">(Interface</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_get(self):</span>
        <span class="s1">decl = self._getEmpty()</span>
        <span class="s1">self.assertIsNone(decl.get(</span><span class="s5">'attr'</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(decl.get(</span><span class="s5">'abc'</span><span class="s3">, </span><span class="s5">'def'</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'def'</span><span class="s1">)</span>
        <span class="s0"># It's a positive cache only (when it even exists)</span>
        <span class="s0"># so this added nothing.</span>
        <span class="s1">self.assertFalse(decl._v_attrs)</span>

    <span class="s3">def </span><span class="s1">test_changed_w_existing__v_attrs(self):</span>
        <span class="s1">decl = self._getEmpty()</span>
        <span class="s1">decl._v_attrs = object()</span>
        <span class="s1">decl.changed(decl)</span>
        <span class="s1">self.assertFalse(decl._v_attrs)</span>


<span class="s3">class </span><span class="s1">DeclarationTests(EmptyDeclarationTests):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Declaration</span>
        <span class="s3">return </span><span class="s1">Declaration</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_ctor_no_bases(self):</span>
        <span class="s1">decl = self._makeOne()</span>
        <span class="s1">self.assertEqual(list(decl.__bases__)</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_ctor_w_interface_in_bases(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">decl = self._makeOne(IFoo)</span>
        <span class="s1">self.assertEqual(list(decl.__bases__)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test_ctor_w_implements_in_bases(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Implements</span>
        <span class="s1">impl = Implements()</span>
        <span class="s1">decl = self._makeOne(impl)</span>
        <span class="s1">self.assertEqual(list(decl.__bases__)</span><span class="s3">, </span><span class="s1">[impl])</span>

    <span class="s3">def </span><span class="s1">test_changed_wo_existing__v_attrs(self):</span>
        <span class="s1">decl = self._makeOne()</span>
        <span class="s1">decl.changed(decl) </span><span class="s0"># doesn't raise</span>
        <span class="s1">self.assertIsNone(decl._v_attrs)</span>

    <span class="s3">def </span><span class="s1">test___contains__w_self(self):</span>
        <span class="s1">decl = self._makeOne()</span>
        <span class="s1">self.assertNotIn(decl</span><span class="s3">, </span><span class="s1">decl)</span>

    <span class="s3">def </span><span class="s1">test___contains__w_unrelated_iface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">decl = self._makeOne()</span>
        <span class="s1">self.assertNotIn(IFoo</span><span class="s3">, </span><span class="s1">decl)</span>

    <span class="s3">def </span><span class="s1">test___contains__w_base_interface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">decl = self._makeOne(IFoo)</span>
        <span class="s1">self.assertIn(IFoo</span><span class="s3">, </span><span class="s1">decl)</span>

    <span class="s3">def </span><span class="s1">test___iter___single_base(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">decl = self._makeOne(IFoo)</span>
        <span class="s1">self.assertEqual(list(decl)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test___iter___multiple_bases(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s1">)</span>
        <span class="s1">decl = self._makeOne(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(list(decl)</span><span class="s3">, </span><span class="s1">[IFoo</span><span class="s3">, </span><span class="s1">IBar])</span>

    <span class="s3">def </span><span class="s1">test___iter___inheritance(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">decl = self._makeOne(IBar)</span>
        <span class="s1">self.assertEqual(list(decl)</span><span class="s3">, </span><span class="s1">[IBar]) </span><span class="s0">#IBar.interfaces() omits bases</span>

    <span class="s3">def </span><span class="s1">test___iter___w_nested_sequence_overlap(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s1">)</span>
        <span class="s1">decl = self._makeOne(IBar</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">, </span><span class="s1">IBar))</span>
        <span class="s1">self.assertEqual(list(decl)</span><span class="s3">, </span><span class="s1">[IBar</span><span class="s3">, </span><span class="s1">IFoo])</span>

    <span class="s3">def </span><span class="s1">test_flattened_single_base(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">decl = self._makeOne(IFoo)</span>
        <span class="s1">self.assertEqual(list(decl.flattened())</span><span class="s3">, </span><span class="s1">[IFoo</span><span class="s3">, </span><span class="s1">Interface])</span>

    <span class="s3">def </span><span class="s1">test_flattened_multiple_bases(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s1">)</span>
        <span class="s1">decl = self._makeOne(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(list(decl.flattened())</span><span class="s3">, </span><span class="s1">[IFoo</span><span class="s3">, </span><span class="s1">IBar</span><span class="s3">, </span><span class="s1">Interface])</span>

    <span class="s3">def </span><span class="s1">test_flattened_inheritance(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">decl = self._makeOne(IBar)</span>
        <span class="s1">self.assertEqual(list(decl.flattened())</span><span class="s3">, </span><span class="s1">[IBar</span><span class="s3">, </span><span class="s1">IFoo</span><span class="s3">, </span><span class="s1">Interface])</span>

    <span class="s3">def </span><span class="s1">test_flattened_w_nested_sequence_overlap(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s1">)</span>
        <span class="s0"># This is the same as calling ``Declaration(IBar, IFoo, IBar)``</span>
        <span class="s0"># which doesn't make much sense, but here it is. In older</span>
        <span class="s0"># versions of zope.interface, the __iro__ would have been</span>
        <span class="s0"># IFoo, IBar, Interface, which especially makes no sense.</span>
        <span class="s1">decl = self._makeOne(IBar</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">, </span><span class="s1">IBar))</span>
        <span class="s0"># Note that decl.__iro__ has IFoo first.</span>
        <span class="s1">self.assertEqual(list(decl.flattened())</span><span class="s3">, </span><span class="s1">[IBar</span><span class="s3">, </span><span class="s1">IFoo</span><span class="s3">, </span><span class="s1">Interface])</span>

    <span class="s3">def </span><span class="s1">test___sub___unrelated_interface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s1">)</span>
        <span class="s1">before = self._makeOne(IFoo)</span>
        <span class="s1">after = before - IBar</span>
        <span class="s1">self.assertIsInstance(after</span><span class="s3">, </span><span class="s1">self._getTargetClass())</span>
        <span class="s1">self.assertEqual(list(after)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test___sub___related_interface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">before = self._makeOne(IFoo)</span>
        <span class="s1">after = before - IFoo</span>
        <span class="s1">self.assertEqual(list(after)</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test___sub___related_interface_by_inheritance(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">before = self._makeOne(IBar)</span>
        <span class="s1">after = before - IBar</span>
        <span class="s1">self.assertEqual(list(after)</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test___add___unrelated_interface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s1">)</span>
        <span class="s1">before = self._makeOne(IFoo)</span>
        <span class="s1">after = before + IBar</span>
        <span class="s1">self.assertIsInstance(after</span><span class="s3">, </span><span class="s1">self._getTargetClass())</span>
        <span class="s1">self.assertEqual(list(after)</span><span class="s3">, </span><span class="s1">[IFoo</span><span class="s3">, </span><span class="s1">IBar])</span>

    <span class="s3">def </span><span class="s1">test___add___related_interface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s1">)</span>
        <span class="s1">IBaz = InterfaceClass(</span><span class="s5">'IBaz'</span><span class="s1">)</span>
        <span class="s1">before = self._makeOne(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">other = self._makeOne(IBar</span><span class="s3">, </span><span class="s1">IBaz)</span>
        <span class="s1">after = before + other</span>
        <span class="s1">self.assertEqual(list(after)</span><span class="s3">, </span><span class="s1">[IFoo</span><span class="s3">, </span><span class="s1">IBar</span><span class="s3">, </span><span class="s1">IBaz])</span>

    <span class="s3">def </span><span class="s1">test___add___overlapping_interface(self):</span>
        <span class="s0"># The derived interfaces end up with higher priority, and</span>
        <span class="s0"># don't produce a C3 resolution order violation. This</span>
        <span class="s0"># example produced a C3 error, and the resulting legacy order</span>
        <span class="s0"># used to be wrong ([IBase, IDerived] instead of</span>
        <span class="s0"># the other way).</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s3">from </span><span class="s1">zope.interface.tests.test_ro </span><span class="s3">import </span><span class="s1">C3Setting</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">ro</span>

        <span class="s1">IBase = InterfaceClass(</span><span class="s5">'IBase'</span><span class="s1">)</span>
        <span class="s1">IDerived = InterfaceClass(</span><span class="s5">'IDerived'</span><span class="s3">, </span><span class="s1">(IBase</span><span class="s3">,</span><span class="s1">))</span>

        <span class="s3">with </span><span class="s1">C3Setting(ro.C3.STRICT_IRO</span><span class="s3">, True</span><span class="s1">):</span>
            <span class="s1">base = self._makeOne(IBase)</span>
            <span class="s1">after = base + IDerived</span>

        <span class="s1">self.assertEqual(after.__iro__</span><span class="s3">, </span><span class="s1">(IDerived</span><span class="s3">, </span><span class="s1">IBase</span><span class="s3">, </span><span class="s1">Interface))</span>
        <span class="s1">self.assertEqual(after.__bases__</span><span class="s3">, </span><span class="s1">(IDerived</span><span class="s3">, </span><span class="s1">IBase))</span>
        <span class="s1">self.assertEqual(list(after)</span><span class="s3">, </span><span class="s1">[IDerived</span><span class="s3">, </span><span class="s1">IBase])</span>

    <span class="s3">def </span><span class="s1">test___add___overlapping_interface_implementedBy(self):</span>
        <span class="s0"># Like test___add___overlapping_interface, but pulling</span>
        <span class="s0"># in a realistic example. This one previously produced a</span>
        <span class="s0"># C3 error, but the resulting legacy order was (somehow)</span>
        <span class="s0"># correct.</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">implementedBy</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.tests.test_ro </span><span class="s3">import </span><span class="s1">C3Setting</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">ro</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IDerived(IBase):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IBase)</span>
        <span class="s3">class </span><span class="s1">Base(object):</span>
            <span class="s3">pass</span>

        <span class="s3">with </span><span class="s1">C3Setting(ro.C3.STRICT_IRO</span><span class="s3">, True</span><span class="s1">):</span>
            <span class="s1">after = implementedBy(Base) + IDerived</span>

        <span class="s1">self.assertEqual(after.__sro__</span><span class="s3">, </span><span class="s1">(after</span><span class="s3">, </span><span class="s1">IDerived</span><span class="s3">, </span><span class="s1">IBase</span><span class="s3">, </span><span class="s1">Interface))</span>
        <span class="s1">self.assertEqual(after.__bases__</span><span class="s3">, </span><span class="s1">(IDerived</span><span class="s3">, </span><span class="s1">IBase))</span>
        <span class="s1">self.assertEqual(list(after)</span><span class="s3">, </span><span class="s1">[IDerived</span><span class="s3">, </span><span class="s1">IBase])</span>


<span class="s3">class </span><span class="s1">TestImmutableDeclaration(EmptyDeclarationTests):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">_ImmutableDeclaration</span>
        <span class="s3">return </span><span class="s1">_ImmutableDeclaration</span>

    <span class="s3">def </span><span class="s1">_getEmpty(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">_empty</span>
        <span class="s3">return </span><span class="s1">_empty</span>

    <span class="s3">def </span><span class="s1">test_pickle(self):</span>
        <span class="s3">import </span><span class="s1">pickle</span>
        <span class="s1">copied = pickle.loads(pickle.dumps(self._getEmpty()))</span>
        <span class="s1">self.assertIs(copied</span><span class="s3">, </span><span class="s1">self._getEmpty())</span>

    <span class="s3">def </span><span class="s1">test_singleton(self):</span>
        <span class="s1">self.assertIs(</span>
            <span class="s1">self._getTargetClass()()</span><span class="s3">,</span>
            <span class="s1">self._getEmpty()</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__bases__(self):</span>
        <span class="s1">self.assertEqual(self._getEmpty().__bases__</span><span class="s3">, </span><span class="s1">())</span>

    <span class="s3">def </span><span class="s1">test_change__bases__(self):</span>
        <span class="s1">empty = self._getEmpty()</span>
        <span class="s1">empty.__bases__ = ()</span>
        <span class="s1">self.assertEqual(self._getEmpty().__bases__</span><span class="s3">, </span><span class="s1">())</span>

        <span class="s3">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">empty.__bases__ = (</span><span class="s4">1</span><span class="s3">,</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_dependents(self):</span>
        <span class="s1">empty = self._getEmpty()</span>
        <span class="s1">deps = empty.dependents</span>
        <span class="s1">self.assertEqual({}</span><span class="s3">, </span><span class="s1">deps)</span>
        <span class="s0"># Doesn't change the return.</span>
        <span class="s1">deps[</span><span class="s4">1</span><span class="s1">] = </span><span class="s4">2</span>
        <span class="s1">self.assertEqual({}</span><span class="s3">, </span><span class="s1">empty.dependents)</span>

    <span class="s3">def </span><span class="s1">test_changed(self):</span>
        <span class="s0"># Does nothing, has no visible side-effects</span>
        <span class="s1">self._getEmpty().changed(</span><span class="s3">None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_extends_always_false(self):</span>
        <span class="s1">self.assertFalse(self._getEmpty().extends(self))</span>
        <span class="s1">self.assertFalse(self._getEmpty().extends(self</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">))</span>
        <span class="s1">self.assertFalse(self._getEmpty().extends(self</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">False</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_get_always_default(self):</span>
        <span class="s1">self.assertIsNone(self._getEmpty().get(</span><span class="s5">'name'</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(self._getEmpty().get(</span><span class="s5">'name'</span><span class="s3">, </span><span class="s4">42</span><span class="s1">)</span><span class="s3">, </span><span class="s4">42</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_v_attrs(self):</span>
        <span class="s1">decl = self._getEmpty()</span>
        <span class="s1">self.assertEqual(decl._v_attrs</span><span class="s3">, </span><span class="s1">{})</span>

        <span class="s1">decl._v_attrs[</span><span class="s5">'attr'</span><span class="s1">] = </span><span class="s4">42</span>
        <span class="s1">self.assertEqual(decl._v_attrs</span><span class="s3">, </span><span class="s1">{})</span>
        <span class="s1">self.assertIsNone(decl.get(</span><span class="s5">'attr'</span><span class="s1">))</span>

        <span class="s1">attrs = decl._v_attrs = {}</span>
        <span class="s1">attrs[</span><span class="s5">'attr'</span><span class="s1">] = </span><span class="s4">42</span>
        <span class="s1">self.assertEqual(decl._v_attrs</span><span class="s3">, </span><span class="s1">{})</span>
        <span class="s1">self.assertIsNone(decl.get(</span><span class="s5">'attr'</span><span class="s1">))</span>


<span class="s3">class </span><span class="s1">TestImplements(NameAndModuleComparisonTestsMixin</span><span class="s3">,</span>
                     <span class="s1">unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Implements</span>
        <span class="s3">return </span><span class="s1">Implements</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">_makeOneToCompare(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementedBy</span>
        <span class="s3">class </span><span class="s1">A(object):</span>
            <span class="s3">pass</span>

        <span class="s3">return </span><span class="s1">implementedBy(A)</span>

    <span class="s3">def </span><span class="s1">test_ctor_no_bases(self):</span>
        <span class="s1">impl = self._makeOne()</span>
        <span class="s1">self.assertEqual(impl.inherit</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(impl.declared</span><span class="s3">, </span><span class="s1">())</span>
        <span class="s1">self.assertEqual(impl.__name__</span><span class="s3">, </span><span class="s5">'?'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(list(impl.__bases__)</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test___repr__(self):</span>
        <span class="s1">impl = self._makeOne()</span>
        <span class="s1">impl.__name__ = </span><span class="s5">'Testing'</span>
        <span class="s1">self.assertEqual(repr(impl)</span><span class="s3">, </span><span class="s5">'classImplements(Testing)'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test___reduce__(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementedBy</span>
        <span class="s1">impl = self._makeOne()</span>
        <span class="s1">self.assertEqual(impl.__reduce__()</span><span class="s3">, </span><span class="s1">(implementedBy</span><span class="s3">, </span><span class="s1">(</span><span class="s3">None,</span><span class="s1">)))</span>

    <span class="s3">def </span><span class="s1">test_sort(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementedBy</span>
        <span class="s3">class </span><span class="s1">A(object):</span>
            <span class="s3">pass</span>
        <span class="s3">class </span><span class="s1">B(object):</span>
            <span class="s3">pass</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(implementedBy(A)</span><span class="s3">, </span><span class="s1">implementedBy(A))</span>
        <span class="s1">self.assertEqual(hash(implementedBy(A))</span><span class="s3">, </span><span class="s1">hash(implementedBy(A)))</span>
        <span class="s1">self.assertTrue(implementedBy(A) &lt; </span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(</span><span class="s3">None </span><span class="s1">&gt; implementedBy(A)) </span><span class="s0"># pylint:disable=misplaced-comparison-constant</span>
        <span class="s1">self.assertTrue(implementedBy(A) &lt; implementedBy(B))</span>
        <span class="s1">self.assertTrue(implementedBy(A) &gt; IFoo)</span>
        <span class="s1">self.assertTrue(implementedBy(A) &lt;= implementedBy(B))</span>
        <span class="s1">self.assertTrue(implementedBy(A) &gt;= IFoo)</span>
        <span class="s1">self.assertTrue(implementedBy(A) != IFoo)</span>

    <span class="s3">def </span><span class="s1">test_proxy_equality(self):</span>
        <span class="s0"># https://github.com/zopefoundation/zope.interface/issues/55</span>
        <span class="s3">class </span><span class="s1">Proxy(object):</span>
            <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">wrapped):</span>
                <span class="s1">self._wrapped = wrapped</span>

            <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">name):</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

            <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
                <span class="s3">return </span><span class="s1">self._wrapped == other</span>

            <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
                <span class="s3">return </span><span class="s1">self._wrapped != other</span>

        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementedBy</span>
        <span class="s3">class </span><span class="s1">A(object):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">B(object):</span>
            <span class="s3">pass</span>

        <span class="s1">implementedByA = implementedBy(A)</span>
        <span class="s1">implementedByB = implementedBy(B)</span>
        <span class="s1">proxy = Proxy(implementedByA)</span>

        <span class="s0"># The order of arguments to the operators matters,</span>
        <span class="s0"># test both</span>
        <span class="s1">self.assertTrue(implementedByA == implementedByA) </span><span class="s0"># pylint:disable=comparison-with-itself</span>
        <span class="s1">self.assertTrue(implementedByA != implementedByB)</span>
        <span class="s1">self.assertTrue(implementedByB != implementedByA)</span>

        <span class="s1">self.assertTrue(proxy == implementedByA)</span>
        <span class="s1">self.assertTrue(implementedByA == proxy)</span>
        <span class="s1">self.assertFalse(proxy != implementedByA)</span>
        <span class="s1">self.assertFalse(implementedByA != proxy)</span>

        <span class="s1">self.assertTrue(proxy != implementedByB)</span>
        <span class="s1">self.assertTrue(implementedByB != proxy)</span>

    <span class="s3">def </span><span class="s1">test_changed_deletes_super_cache(self):</span>
        <span class="s1">impl = self._makeOne()</span>
        <span class="s1">self.assertIsNone(impl._super_cache)</span>
        <span class="s1">self.assertNotIn(</span><span class="s5">'_super_cache'</span><span class="s3">, </span><span class="s1">impl.__dict__)</span>

        <span class="s1">impl._super_cache = </span><span class="s4">42</span>
        <span class="s1">self.assertIn(</span><span class="s5">'_super_cache'</span><span class="s3">, </span><span class="s1">impl.__dict__)</span>

        <span class="s1">impl.changed(</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">self.assertIsNone(impl._super_cache)</span>
        <span class="s1">self.assertNotIn(</span><span class="s5">'_super_cache'</span><span class="s3">, </span><span class="s1">impl.__dict__)</span>

    <span class="s3">def </span><span class="s1">test_changed_does_not_add_super_cache(self):</span>
        <span class="s1">impl = self._makeOne()</span>
        <span class="s1">self.assertIsNone(impl._super_cache)</span>
        <span class="s1">self.assertNotIn(</span><span class="s5">'_super_cache'</span><span class="s3">, </span><span class="s1">impl.__dict__)</span>

        <span class="s1">impl.changed(</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">self.assertIsNone(impl._super_cache)</span>
        <span class="s1">self.assertNotIn(</span><span class="s5">'_super_cache'</span><span class="s3">, </span><span class="s1">impl.__dict__)</span>


<span class="s3">class </span><span class="s1">Test_implementedByFallback(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s0"># pylint:disable=no-name-in-module</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementedByFallback</span>
        <span class="s3">return </span><span class="s1">implementedByFallback</span>

    <span class="s1">_getFallbackClass = _getTargetClass</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_dictless_wo_existing_Implements_wo_registrations(self):</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__slots__ = (</span><span class="s5">'__implemented__'</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">foo.__implemented__ = </span><span class="s3">None</span>
        <span class="s1">self.assertEqual(list(self._callFUT(foo))</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_dictless_wo_existing_Implements_cant_assign___implemented__(self):</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">def </span><span class="s1">_get_impl(self):</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError()</span>
            <span class="s3">def </span><span class="s1">_set_impl(self</span><span class="s3">, </span><span class="s1">val):</span>
                <span class="s3">raise </span><span class="s1">TypeError</span>
            <span class="s1">__implemented__ = property(_get_impl</span><span class="s3">, </span><span class="s1">_set_impl)</span>
            <span class="s3">def </span><span class="s1">__call__(self):</span>
                <span class="s0"># act like a factory</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError()</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s3">, </span><span class="s1">self._callFUT</span><span class="s3">, </span><span class="s1">foo)</span>

    <span class="s3">def </span><span class="s1">test_dictless_wo_existing_Implements_w_registrations(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">declarations</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__slots__ = (</span><span class="s5">'__implemented__'</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">foo.__implemented__ = </span><span class="s3">None</span>
        <span class="s1">reg = object()</span>
        <span class="s3">with </span><span class="s1">_MonkeyDict(declarations</span><span class="s3">,</span>
                         <span class="s5">'BuiltinImplementationSpecifications'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">specs:</span>
            <span class="s1">specs[foo] = reg</span>
            <span class="s1">self.assertTrue(self._callFUT(foo) </span><span class="s3">is </span><span class="s1">reg)</span>

    <span class="s3">def </span><span class="s1">test_dictless_w_existing_Implements(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Implements</span>
        <span class="s1">impl = Implements()</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__slots__ = (</span><span class="s5">'__implemented__'</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">foo.__implemented__ = impl</span>
        <span class="s1">self.assertTrue(self._callFUT(foo) </span><span class="s3">is </span><span class="s1">impl)</span>

    <span class="s3">def </span><span class="s1">test_dictless_w_existing_not_Implements(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__slots__ = (</span><span class="s5">'__implemented__'</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">foo.__implemented__ = (IFoo</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(list(self._callFUT(foo))</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test_w_existing_attr_as_Implements(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Implements</span>
        <span class="s1">impl = Implements()</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__implemented__ = impl</span>
        <span class="s1">self.assertTrue(self._callFUT(Foo) </span><span class="s3">is </span><span class="s1">impl)</span>

    <span class="s3">def </span><span class="s1">test_builtins_added_to_cache(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">declarations</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Implements</span>
        <span class="s3">with </span><span class="s1">_MonkeyDict(declarations</span><span class="s3">,</span>
                         <span class="s5">'BuiltinImplementationSpecifications'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">specs:</span>
            <span class="s1">self.assertEqual(list(self._callFUT(tuple))</span><span class="s3">, </span><span class="s1">[])</span>
            <span class="s1">self.assertEqual(list(self._callFUT(list))</span><span class="s3">, </span><span class="s1">[])</span>
            <span class="s1">self.assertEqual(list(self._callFUT(dict))</span><span class="s3">, </span><span class="s1">[])</span>
            <span class="s3">for </span><span class="s1">typ </span><span class="s3">in </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">dict):</span>
                <span class="s1">spec = specs[typ]</span>
                <span class="s1">self.assertIsInstance(spec</span><span class="s3">, </span><span class="s1">Implements)</span>
                <span class="s1">self.assertEqual(repr(spec)</span><span class="s3">,</span>
                                 <span class="s5">'classImplements(%s)'</span>
                                 <span class="s1">% (typ.__name__</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_builtins_w_existing_cache(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">declarations</span>
        <span class="s1">t_spec</span><span class="s3">, </span><span class="s1">l_spec</span><span class="s3">, </span><span class="s1">d_spec = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s3">with </span><span class="s1">_MonkeyDict(declarations</span><span class="s3">,</span>
                         <span class="s5">'BuiltinImplementationSpecifications'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">specs:</span>
            <span class="s1">specs[tuple] = t_spec</span>
            <span class="s1">specs[list] = l_spec</span>
            <span class="s1">specs[dict] = d_spec</span>
            <span class="s1">self.assertTrue(self._callFUT(tuple) </span><span class="s3">is </span><span class="s1">t_spec)</span>
            <span class="s1">self.assertTrue(self._callFUT(list) </span><span class="s3">is </span><span class="s1">l_spec)</span>
            <span class="s1">self.assertTrue(self._callFUT(dict) </span><span class="s3">is </span><span class="s1">d_spec)</span>

    <span class="s3">def </span><span class="s1">test_oldstyle_class_no_assertions(self):</span>
        <span class="s0"># TODO: Figure out P3 story</span>
        <span class="s3">class </span><span class="s1">Foo:</span>
            <span class="s3">pass</span>
        <span class="s1">self.assertEqual(list(self._callFUT(Foo))</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_no_assertions(self):</span>
        <span class="s0"># TODO: Figure out P3 story</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">self.assertEqual(list(self._callFUT(Foo))</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_w_None_no_bases_not_factory(self):</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__implemented__ = </span><span class="s3">None</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s3">, </span><span class="s1">self._callFUT</span><span class="s3">, </span><span class="s1">foo)</span>

    <span class="s3">def </span><span class="s1">test_w_None_no_bases_w_factory(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">objectSpecificationDescriptor</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__implemented__ = </span><span class="s3">None</span>
            <span class="s3">def </span><span class="s1">__call__(self):</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

        <span class="s1">foo = Foo()</span>
        <span class="s1">foo.__name__ = </span><span class="s5">'foo'</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertEqual(spec.__name__</span><span class="s3">,</span>
                         <span class="s5">'zope.interface.tests.test_declarations.foo'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(spec.inherit</span><span class="s3">, </span><span class="s1">foo)</span>
        <span class="s1">self.assertIs(foo.__implemented__</span><span class="s3">, </span><span class="s1">spec)</span>
        <span class="s1">self.assertIs(foo.__providedBy__</span><span class="s3">, </span><span class="s1">objectSpecificationDescriptor) </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">self.assertNotIn(</span><span class="s5">'__provides__'</span><span class="s3">, </span><span class="s1">foo.__dict__)</span>

    <span class="s3">def </span><span class="s1">test_w_None_no_bases_w_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ClassProvides</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__implemented__ = </span><span class="s3">None</span>
        <span class="s1">spec = self._callFUT(Foo)</span>
        <span class="s1">self.assertEqual(spec.__name__</span><span class="s3">,</span>
                         <span class="s5">'zope.interface.tests.test_declarations.Foo'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(spec.inherit</span><span class="s3">, </span><span class="s1">Foo)</span>
        <span class="s1">self.assertIs(Foo.__implemented__</span><span class="s3">, </span><span class="s1">spec)</span>
        <span class="s1">self.assertIsInstance(Foo.__providedBy__</span><span class="s3">, </span><span class="s1">ClassProvides) </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">self.assertIsInstance(Foo.__provides__</span><span class="s3">, </span><span class="s1">ClassProvides) </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">self.assertEqual(Foo.__provides__</span><span class="s3">, </span><span class="s1">Foo.__providedBy__) </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s3">def </span><span class="s1">test_w_existing_Implements(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Implements</span>
        <span class="s1">impl = Implements()</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__implemented__ = impl</span>
        <span class="s1">self.assertTrue(self._callFUT(Foo) </span><span class="s3">is </span><span class="s1">impl)</span>

    <span class="s3">def </span><span class="s1">test_super_when_base_implements_interface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IDerived(IBase):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IBase)</span>
        <span class="s3">class </span><span class="s1">Base(object):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IDerived)</span>
        <span class="s3">class </span><span class="s1">Derived(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">self.assertEqual(list(self._callFUT(Derived))</span><span class="s3">, </span><span class="s1">[IDerived</span><span class="s3">, </span><span class="s1">IBase])</span>
        <span class="s1">sup = super(Derived</span><span class="s3">, </span><span class="s1">Derived)</span>
        <span class="s1">self.assertEqual(list(self._callFUT(sup))</span><span class="s3">, </span><span class="s1">[IBase])</span>

    <span class="s3">def </span><span class="s1">test_super_when_base_implements_interface_diamond(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IDerived(IBase):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IBase)</span>
        <span class="s3">class </span><span class="s1">Base(object):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">Child1(Base):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">Child2(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IDerived)</span>
        <span class="s3">class </span><span class="s1">Derived(Child1</span><span class="s3">, </span><span class="s1">Child2):</span>
            <span class="s3">pass</span>

        <span class="s1">self.assertEqual(list(self._callFUT(Derived))</span><span class="s3">, </span><span class="s1">[IDerived</span><span class="s3">, </span><span class="s1">IBase])</span>
        <span class="s1">sup = super(Derived</span><span class="s3">, </span><span class="s1">Derived)</span>
        <span class="s1">self.assertEqual(list(self._callFUT(sup))</span><span class="s3">, </span><span class="s1">[IBase])</span>

    <span class="s3">def </span><span class="s1">test_super_when_parent_implements_interface_diamond(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IDerived(IBase):</span>
            <span class="s3">pass</span>


        <span class="s3">class </span><span class="s1">Base(object):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">Child1(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IBase)</span>
        <span class="s3">class </span><span class="s1">Child2(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IDerived)</span>
        <span class="s3">class </span><span class="s1">Derived(Child1</span><span class="s3">, </span><span class="s1">Child2):</span>
            <span class="s3">pass</span>

        <span class="s1">self.assertEqual(Derived.__mro__</span><span class="s3">, </span><span class="s1">(Derived</span><span class="s3">, </span><span class="s1">Child1</span><span class="s3">, </span><span class="s1">Child2</span><span class="s3">, </span><span class="s1">Base</span><span class="s3">, </span><span class="s1">object))</span>
        <span class="s1">self.assertEqual(list(self._callFUT(Derived))</span><span class="s3">, </span><span class="s1">[IDerived</span><span class="s3">, </span><span class="s1">IBase])</span>
        <span class="s1">sup = super(Derived</span><span class="s3">, </span><span class="s1">Derived)</span>
        <span class="s1">fut = self._callFUT(sup)</span>
        <span class="s1">self.assertEqual(list(fut)</span><span class="s3">, </span><span class="s1">[IBase])</span>
        <span class="s1">self.assertIsNone(fut._dependents)</span>

    <span class="s3">def </span><span class="s1">test_super_when_base_doesnt_implement_interface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IDerived(IBase):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">Base(object):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IDerived)</span>
        <span class="s3">class </span><span class="s1">Derived(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">self.assertEqual(list(self._callFUT(Derived))</span><span class="s3">, </span><span class="s1">[IDerived])</span>

        <span class="s1">sup = super(Derived</span><span class="s3">, </span><span class="s1">Derived)</span>
        <span class="s1">self.assertEqual(list(self._callFUT(sup))</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_super_when_base_is_object(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IDerived(IBase):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IDerived)</span>
        <span class="s3">class </span><span class="s1">Derived(object):</span>
            <span class="s3">pass</span>

        <span class="s1">self.assertEqual(list(self._callFUT(Derived))</span><span class="s3">, </span><span class="s1">[IDerived])</span>

        <span class="s1">sup = super(Derived</span><span class="s3">, </span><span class="s1">Derived)</span>
        <span class="s1">self.assertEqual(list(self._callFUT(sup))</span><span class="s3">, </span><span class="s1">[])</span>
    <span class="s3">def </span><span class="s1">test_super_multi_level_multi_inheritance(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IM1(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IM2(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IDerived(IBase):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IUnrelated(Interface):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IBase)</span>
        <span class="s3">class </span><span class="s1">Base(object):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IM1)</span>
        <span class="s3">class </span><span class="s1">M1(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IM2)</span>
        <span class="s3">class </span><span class="s1">M2(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IDerived</span><span class="s3">, </span><span class="s1">IUnrelated)</span>
        <span class="s3">class </span><span class="s1">Derived(M1</span><span class="s3">, </span><span class="s1">M2):</span>
            <span class="s3">pass</span>

        <span class="s1">d = Derived</span>
        <span class="s1">sd = super(Derived</span><span class="s3">, </span><span class="s1">Derived)</span>
        <span class="s1">sm1 = super(M1</span><span class="s3">, </span><span class="s1">Derived)</span>
        <span class="s1">sm2 = super(M2</span><span class="s3">, </span><span class="s1">Derived)</span>

        <span class="s1">self.assertEqual(list(self._callFUT(d))</span><span class="s3">,</span>
                         <span class="s1">[IDerived</span><span class="s3">, </span><span class="s1">IUnrelated</span><span class="s3">, </span><span class="s1">IM1</span><span class="s3">, </span><span class="s1">IBase</span><span class="s3">, </span><span class="s1">IM2])</span>
        <span class="s1">self.assertEqual(list(self._callFUT(sd))</span><span class="s3">,</span>
                         <span class="s1">[IM1</span><span class="s3">, </span><span class="s1">IBase</span><span class="s3">, </span><span class="s1">IM2])</span>
        <span class="s1">self.assertEqual(list(self._callFUT(sm1))</span><span class="s3">,</span>
                         <span class="s1">[IM2</span><span class="s3">, </span><span class="s1">IBase])</span>
        <span class="s1">self.assertEqual(list(self._callFUT(sm2))</span><span class="s3">,</span>
                         <span class="s1">[IBase])</span>


<span class="s3">class </span><span class="s1">Test_implementedBy(Test_implementedByFallback</span><span class="s3">,</span>
                         <span class="s1">OptimizationTestMixin):</span>
    <span class="s0"># Repeat tests for C optimizations</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementedBy</span>
        <span class="s3">return </span><span class="s1">implementedBy</span>


<span class="s3">class </span><span class="s1">_ImplementsTestMixin(object):</span>
    <span class="s1">FUT_SETS_PROVIDED_BY = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">iface):</span>
        <span class="s0"># Declare that *cls* implements *iface*; return *cls*</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">_check_implementer(self</span><span class="s3">, </span><span class="s1">Foo</span><span class="s3">,</span>
                           <span class="s1">orig_spec=</span><span class="s3">None,</span>
                           <span class="s1">spec_name=__name__ + </span><span class="s5">'.Foo'</span><span class="s3">,</span>
                           <span class="s1">inherit=</span><span class="s5">&quot;not given&quot;</span><span class="s1">):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ClassProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>

        <span class="s1">returned = self._callFUT(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>

        <span class="s1">self.assertIs(returned</span><span class="s3">, </span><span class="s1">Foo)</span>
        <span class="s1">spec = Foo.__implemented__</span>
        <span class="s3">if </span><span class="s1">orig_spec </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.assertIs(spec</span><span class="s3">, </span><span class="s1">orig_spec)</span>

        <span class="s1">self.assertEqual(spec.__name__</span><span class="s3">,</span>
                         <span class="s1">spec_name)</span>
        <span class="s1">inherit = Foo </span><span class="s3">if </span><span class="s1">inherit == </span><span class="s5">&quot;not given&quot; </span><span class="s3">else </span><span class="s1">inherit</span>
        <span class="s1">self.assertIs(spec.inherit</span><span class="s3">, </span><span class="s1">inherit)</span>
        <span class="s1">self.assertIs(Foo.__implemented__</span><span class="s3">, </span><span class="s1">spec)</span>
        <span class="s3">if </span><span class="s1">self.FUT_SETS_PROVIDED_BY:</span>
            <span class="s1">self.assertIsInstance(Foo.__providedBy__</span><span class="s3">, </span><span class="s1">ClassProvides)</span>
            <span class="s1">self.assertIsInstance(Foo.__provides__</span><span class="s3">, </span><span class="s1">ClassProvides)</span>
            <span class="s1">self.assertEqual(Foo.__provides__</span><span class="s3">, </span><span class="s1">Foo.__providedBy__)</span>

        <span class="s3">return </span><span class="s1">Foo</span><span class="s3">, </span><span class="s1">IFoo</span>

    <span class="s3">def </span><span class="s1">test_oldstyle_class(self):</span>
        <span class="s0"># This only matters on Python 2</span>
        <span class="s3">class </span><span class="s1">Foo:</span>
            <span class="s3">pass</span>
        <span class="s1">self._check_implementer(Foo)</span>

    <span class="s3">def </span><span class="s1">test_newstyle_class(self):</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">self._check_implementer(Foo)</span>

<span class="s3">class </span><span class="s1">Test_classImplementsOnly(_ImplementsTestMixin</span><span class="s3">, </span><span class="s1">unittest.TestCase):</span>
    <span class="s1">FUT_SETS_PROVIDED_BY = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">iface):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">classImplementsOnly</span>
        <span class="s1">classImplementsOnly(cls</span><span class="s3">, </span><span class="s1">iface)</span>
        <span class="s3">return </span><span class="s1">cls</span>

    <span class="s3">def </span><span class="s1">test_w_existing_Implements(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Implements</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s1">)</span>
        <span class="s1">impl = Implements(IFoo)</span>
        <span class="s1">impl.declared = (IFoo</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__implemented__ = impl</span>
        <span class="s1">impl.inherit = Foo</span>
        <span class="s1">self._callFUT(Foo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s0"># Same spec, now different values</span>
        <span class="s1">self.assertTrue(Foo.__implemented__ </span><span class="s3">is </span><span class="s1">impl)</span>
        <span class="s1">self.assertEqual(impl.inherit</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(impl.declared</span><span class="s3">, </span><span class="s1">(IBar</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_oldstyle_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Implements</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s1">)</span>
        <span class="s1">old_spec = Implements(IBar)</span>

        <span class="s3">class </span><span class="s1">Foo:</span>
            <span class="s1">__implemented__ = old_spec</span>
        <span class="s1">self._check_implementer(Foo</span><span class="s3">, </span><span class="s1">old_spec</span><span class="s3">, </span><span class="s5">'?'</span><span class="s3">, </span><span class="s1">inherit=</span><span class="s3">None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_newstyle_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Implements</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s1">)</span>
        <span class="s1">old_spec = Implements(IBar)</span>

        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__implemented__ = old_spec</span>
        <span class="s1">self._check_implementer(Foo</span><span class="s3">, </span><span class="s1">old_spec</span><span class="s3">, </span><span class="s5">'?'</span><span class="s3">, </span><span class="s1">inherit=</span><span class="s3">None</span><span class="s1">)</span>


    <span class="s3">def </span><span class="s1">test_redundant_with_super_still_implements(self):</span>
        <span class="s1">Base</span><span class="s3">, </span><span class="s1">IBase = self._check_implementer(</span>
            <span class="s1">type(</span><span class="s5">'Foo'</span><span class="s3">, </span><span class="s1">(object</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">{})</span><span class="s3">,</span>
            <span class="s1">inherit=</span><span class="s3">None,</span>
        <span class="s1">)</span>

        <span class="s3">class </span><span class="s1">Child(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">self._callFUT(Child</span><span class="s3">, </span><span class="s1">IBase)</span>
        <span class="s1">self.assertTrue(IBase.implementedBy(Child))</span>


<span class="s3">class </span><span class="s1">Test_classImplements(_ImplementsTestMixin</span><span class="s3">, </span><span class="s1">unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">iface):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">classImplements</span>
        <span class="s1">result = classImplements(cls</span><span class="s3">, </span><span class="s1">iface) </span><span class="s0"># pylint:disable=assignment-from-no-return</span>
        <span class="s1">self.assertIsNone(result)</span>
        <span class="s3">return </span><span class="s1">cls</span>

    <span class="s3">def </span><span class="s1">__check_implementer_redundant(self</span><span class="s3">, </span><span class="s1">Base):</span>
        <span class="s0"># If we @implementer exactly what was already present, we write</span>
        <span class="s0"># no declared attributes on the parent (we still set everything, though)</span>
        <span class="s1">Base</span><span class="s3">, </span><span class="s1">IBase = self._check_implementer(Base)</span>

        <span class="s3">class </span><span class="s1">Child(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">returned = self._callFUT(Child</span><span class="s3">, </span><span class="s1">IBase)</span>
        <span class="s1">self.assertIn(</span><span class="s5">'__implemented__'</span><span class="s3">, </span><span class="s1">returned.__dict__)</span>
        <span class="s1">self.assertNotIn(</span><span class="s5">'__providedBy__'</span><span class="s3">, </span><span class="s1">returned.__dict__)</span>
        <span class="s1">self.assertIn(</span><span class="s5">'__provides__'</span><span class="s3">, </span><span class="s1">returned.__dict__)</span>

        <span class="s1">spec = Child.__implemented__</span>
        <span class="s1">self.assertEqual(spec.declared</span><span class="s3">, </span><span class="s1">())</span>
        <span class="s1">self.assertEqual(spec.inherit</span><span class="s3">, </span><span class="s1">Child)</span>

        <span class="s1">self.assertTrue(IBase.providedBy(Child()))</span>

    <span class="s3">def </span><span class="s1">test_redundant_implementer_empty_class_declarations_newstyle(self):</span>
        <span class="s1">self.__check_implementer_redundant(type(</span><span class="s5">'Foo'</span><span class="s3">, </span><span class="s1">(object</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">{}))</span>

    <span class="s3">def </span><span class="s1">test_redundant_implementer_empty_class_declarations_oldstyle(self):</span>
        <span class="s0"># This only matters on Python 2</span>
        <span class="s3">class </span><span class="s1">Foo:</span>
            <span class="s3">pass</span>
        <span class="s1">self.__check_implementer_redundant(Foo)</span>

    <span class="s3">def </span><span class="s1">test_redundant_implementer_Interface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">implementedBy</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">ro</span>
        <span class="s3">from </span><span class="s1">zope.interface.tests.test_ro </span><span class="s3">import </span><span class="s1">C3Setting</span>

        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>

        <span class="s3">with </span><span class="s1">C3Setting(ro.C3.STRICT_IRO</span><span class="s3">, False</span><span class="s1">):</span>
            <span class="s1">self._callFUT(Foo</span><span class="s3">, </span><span class="s1">Interface)</span>
            <span class="s1">self.assertEqual(list(implementedBy(Foo))</span><span class="s3">, </span><span class="s1">[Interface])</span>

            <span class="s3">class </span><span class="s1">Baz(Foo):</span>
                <span class="s3">pass</span>

            <span class="s1">self._callFUT(Baz</span><span class="s3">, </span><span class="s1">Interface)</span>
            <span class="s1">self.assertEqual(list(implementedBy(Baz))</span><span class="s3">, </span><span class="s1">[Interface])</span>

    <span class="s3">def </span><span class="s1">_order_for_two(self</span><span class="s3">, </span><span class="s1">applied_first</span><span class="s3">, </span><span class="s1">applied_second):</span>
        <span class="s3">return </span><span class="s1">(applied_first</span><span class="s3">, </span><span class="s1">applied_second)</span>

    <span class="s3">def </span><span class="s1">test_w_existing_Implements(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Implements</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s1">)</span>
        <span class="s1">impl = Implements(IFoo)</span>
        <span class="s1">impl.declared = (IFoo</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__implemented__ = impl</span>
        <span class="s1">impl.inherit = Foo</span>
        <span class="s1">self._callFUT(Foo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s0"># Same spec, now different values</span>
        <span class="s1">self.assertIs(Foo.__implemented__</span><span class="s3">, </span><span class="s1">impl)</span>
        <span class="s1">self.assertEqual(impl.inherit</span><span class="s3">, </span><span class="s1">Foo)</span>
        <span class="s1">self.assertEqual(impl.declared</span><span class="s3">,</span>
                         <span class="s1">self._order_for_two(IFoo</span><span class="s3">, </span><span class="s1">IBar))</span>

    <span class="s3">def </span><span class="s1">test_w_existing_Implements_w_bases(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Implements</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IRoot = InterfaceClass(</span><span class="s5">'IRoot'</span><span class="s1">)</span>
        <span class="s1">ISecondRoot = InterfaceClass(</span><span class="s5">'ISecondRoot'</span><span class="s1">)</span>
        <span class="s1">IExtendsRoot = InterfaceClass(</span><span class="s5">'IExtendsRoot'</span><span class="s3">, </span><span class="s1">(IRoot</span><span class="s3">,</span><span class="s1">))</span>

        <span class="s1">impl_root = Implements.named(</span><span class="s5">'Root'</span><span class="s3">, </span><span class="s1">IRoot)</span>
        <span class="s1">impl_root.declared = (IRoot</span><span class="s3">,</span><span class="s1">)</span>

        <span class="s3">class </span><span class="s1">Root1(object):</span>
            <span class="s1">__implemented__ = impl_root</span>
        <span class="s3">class </span><span class="s1">Root2(object):</span>
            <span class="s1">__implemented__ = impl_root</span>

        <span class="s1">impl_extends_root = Implements.named(</span><span class="s5">'ExtendsRoot1'</span><span class="s3">, </span><span class="s1">IExtendsRoot)</span>
        <span class="s1">impl_extends_root.declared = (IExtendsRoot</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">ExtendsRoot(Root1</span><span class="s3">, </span><span class="s1">Root2):</span>
            <span class="s1">__implemented__ = impl_extends_root</span>
        <span class="s1">impl_extends_root.inherit = ExtendsRoot</span>

        <span class="s1">self._callFUT(ExtendsRoot</span><span class="s3">, </span><span class="s1">ISecondRoot)</span>
        <span class="s0"># Same spec, now different values</span>
        <span class="s1">self.assertIs(ExtendsRoot.__implemented__</span><span class="s3">, </span><span class="s1">impl_extends_root)</span>
        <span class="s1">self.assertEqual(impl_extends_root.inherit</span><span class="s3">, </span><span class="s1">ExtendsRoot)</span>
        <span class="s1">self.assertEqual(impl_extends_root.declared</span><span class="s3">,</span>
                         <span class="s1">self._order_for_two(IExtendsRoot</span><span class="s3">, </span><span class="s1">ISecondRoot</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(impl_extends_root.__bases__</span><span class="s3">,</span>
                         <span class="s1">self._order_for_two(IExtendsRoot</span><span class="s3">, </span><span class="s1">ISecondRoot) + (impl_root</span><span class="s3">,</span><span class="s1">))</span>


<span class="s3">class </span><span class="s1">Test_classImplementsFirst(Test_classImplements):</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">iface):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">classImplementsFirst</span>
        <span class="s1">result = classImplementsFirst(cls</span><span class="s3">, </span><span class="s1">iface) </span><span class="s0"># pylint:disable=assignment-from-no-return</span>
        <span class="s1">self.assertIsNone(result)</span>
        <span class="s3">return </span><span class="s1">cls</span>

    <span class="s3">def </span><span class="s1">_order_for_two(self</span><span class="s3">, </span><span class="s1">applied_first</span><span class="s3">, </span><span class="s1">applied_second):</span>
        <span class="s3">return </span><span class="s1">(applied_second</span><span class="s3">, </span><span class="s1">applied_first)</span>


<span class="s3">class </span><span class="s1">Test__implements_advice(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">_implements_advice</span>
        <span class="s3">return </span><span class="s1">_implements_advice(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_no_existing_implements(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">classImplements</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Implements</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__implements_advice_data__ = ((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">classImplements)</span>
        <span class="s1">self._callFUT(Foo)</span>
        <span class="s1">self.assertNotIn(</span><span class="s5">'__implements_advice_data__'</span><span class="s3">, </span><span class="s1">Foo.__dict__)</span>
        <span class="s1">self.assertIsInstance(Foo.__implemented__</span><span class="s3">, </span><span class="s1">Implements) </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">self.assertEqual(list(Foo.__implemented__)</span><span class="s3">, </span><span class="s1">[IFoo]) </span><span class="s0"># pylint:disable=no-member</span>


<span class="s3">class </span><span class="s1">Test_implementer(Test_classImplements):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">return </span><span class="s1">implementer</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">*ifaces):</span>
        <span class="s1">decorator = self._makeOne(*ifaces)</span>
        <span class="s3">return </span><span class="s1">decorator(cls)</span>

    <span class="s3">def </span><span class="s1">test_nonclass_cannot_assign_attr(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">decorator = self._makeOne(IFoo)</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s3">, </span><span class="s1">decorator</span><span class="s3">, </span><span class="s1">object())</span>

    <span class="s3">def </span><span class="s1">test_nonclass_can_assign_attr(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">decorator = self._makeOne(IFoo)</span>
        <span class="s1">returned = decorator(foo)</span>
        <span class="s1">self.assertTrue(returned </span><span class="s3">is </span><span class="s1">foo)</span>
        <span class="s1">spec = foo.__implemented__ </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">self.assertEqual(spec.__name__</span><span class="s3">, </span><span class="s5">'zope.interface.tests.test_declarations.?'</span><span class="s1">)</span>
        <span class="s1">self.assertIsNone(spec.inherit</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">self.assertIs(foo.__implemented__</span><span class="s3">, </span><span class="s1">spec) </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s3">def </span><span class="s1">test_does_not_leak_on_unique_classes(self):</span>
        <span class="s0"># Make sure nothing is hanging on to the class or Implements</span>
        <span class="s0"># object after they go out of scope. There was briefly a bug</span>
        <span class="s0"># in 5.x that caused SpecificationBase._bases (in C) to not be</span>
        <span class="s0"># traversed or cleared.</span>
        <span class="s0"># https://github.com/zopefoundation/zope.interface/issues/216</span>
        <span class="s3">import </span><span class="s1">gc</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>

        <span class="s1">begin_count = len(gc.get_objects())</span>

        <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1900</span><span class="s1">):</span>
            <span class="s3">class </span><span class="s1">TestClass(object):</span>
                <span class="s3">pass</span>

            <span class="s1">self._callFUT(TestClass</span><span class="s3">, </span><span class="s1">IFoo)</span>

        <span class="s1">gc.collect()</span>

        <span class="s1">end_count = len(gc.get_objects())</span>

        <span class="s0"># How many new objects might still be around? In all currently</span>
        <span class="s0"># tested interpreters, there aren't any, so our counts should</span>
        <span class="s0"># match exactly. When the bug existed, in a steady state, the loop</span>
        <span class="s0"># would grow by two objects each iteration</span>
        <span class="s1">fudge_factor = </span><span class="s4">0</span>
        <span class="s1">self.assertLessEqual(end_count</span><span class="s3">, </span><span class="s1">begin_count + fudge_factor)</span>



<span class="s3">class </span><span class="s1">Test_implementer_only(Test_classImplementsOnly):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer_only</span>
        <span class="s3">return </span><span class="s1">implementer_only</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">iface):</span>
        <span class="s1">decorator = self._makeOne(iface)</span>
        <span class="s3">return </span><span class="s1">decorator(cls)</span>

    <span class="s3">def </span><span class="s1">test_function(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">decorator = self._makeOne(IFoo)</span>
        <span class="s3">def </span><span class="s1">_function():</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError()</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">decorator</span><span class="s3">, </span><span class="s1">_function)</span>

    <span class="s3">def </span><span class="s1">test_method(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">decorator = self._makeOne(IFoo)</span>
        <span class="s3">class </span><span class="s1">Bar:</span>
            <span class="s3">def </span><span class="s1">_method(self):</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError()</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">decorator</span><span class="s3">, </span><span class="s1">Bar._method)</span>



<span class="s0"># Test '_implements' by way of 'implements{,Only}', its only callers.</span>

<span class="s3">class </span><span class="s1">Test_implementsOnly(unittest.TestCase</span><span class="s3">, </span><span class="s1">_Py3ClassAdvice):</span>

    <span class="s3">def </span><span class="s1">test_simple(self):</span>
        <span class="s3">import </span><span class="s1">warnings</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementsOnly</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">globs = {</span><span class="s5">'implementsOnly'</span><span class="s1">: implementsOnly</span><span class="s3">,</span>
                 <span class="s5">'IFoo'</span><span class="s1">: IFoo</span><span class="s3">,</span>
                <span class="s1">}</span>
        <span class="s1">locs = {}</span>
        <span class="s1">CODE = </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">'class Foo(object):'</span>
            <span class="s5">'    implementsOnly(IFoo)'</span><span class="s3">,</span>
            <span class="s1">])</span>
        <span class="s3">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s3">True</span><span class="s1">) </span><span class="s3">as </span><span class="s1">log:</span>
            <span class="s1">warnings.resetwarnings()</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">exec(CODE</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs)  </span><span class="s0"># pylint:disable=exec-used</span>
            <span class="s3">except </span><span class="s1">TypeError:</span>
                <span class="s1">self.assertTrue(PYTHON3</span><span class="s3">, </span><span class="s5">&quot;Must be Python 3&quot;</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">PYTHON3:</span>
                    <span class="s1">self.fail(</span><span class="s5">&quot;Didn't raise TypeError&quot;</span><span class="s1">)</span>
                <span class="s1">Foo = locs[</span><span class="s5">'Foo'</span><span class="s1">]</span>
                <span class="s1">spec = Foo.__implemented__</span>
                <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[IFoo])</span>
                <span class="s1">self.assertEqual(len(log)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">) </span><span class="s0"># no longer warn</span>

    <span class="s3">def </span><span class="s1">test_called_once_from_class_w_bases(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implements</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementsOnly</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">&quot;IBar&quot;</span><span class="s1">)</span>
        <span class="s1">globs = {</span><span class="s5">'implements'</span><span class="s1">: implements</span><span class="s3">,</span>
                 <span class="s5">'implementsOnly'</span><span class="s1">: implementsOnly</span><span class="s3">,</span>
                 <span class="s5">'IFoo'</span><span class="s1">: IFoo</span><span class="s3">,</span>
                 <span class="s5">'IBar'</span><span class="s1">: IBar</span><span class="s3">,</span>
                <span class="s1">}</span>
        <span class="s1">locs = {}</span>
        <span class="s1">CODE = </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">'class Foo(object):'</span><span class="s3">,</span>
            <span class="s5">'    implements(IFoo)'</span><span class="s3">,</span>
            <span class="s5">'class Bar(Foo):'</span>
            <span class="s5">'    implementsOnly(IBar)'</span><span class="s3">,</span>
            <span class="s1">])</span>
        <span class="s3">if </span><span class="s1">self._run_generated_code(CODE</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs):</span>
            <span class="s1">Bar = locs[</span><span class="s5">'Bar'</span><span class="s1">]</span>
            <span class="s1">spec = Bar.__implemented__</span>
            <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[IBar])</span>


<span class="s3">class </span><span class="s1">Test_implements(unittest.TestCase</span><span class="s3">, </span><span class="s1">_Py3ClassAdvice):</span>

    <span class="s3">def </span><span class="s1">test_called_from_function(self):</span>
        <span class="s3">import </span><span class="s1">warnings</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implements</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">globs = {</span><span class="s5">'implements'</span><span class="s1">: implements</span><span class="s3">, </span><span class="s5">'IFoo'</span><span class="s1">: IFoo}</span>
        <span class="s1">locs = {}</span>
        <span class="s1">CODE = </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">'def foo():'</span><span class="s3">,</span>
            <span class="s5">'    implements(IFoo)'</span>
            <span class="s1">])</span>
        <span class="s3">if </span><span class="s1">self._run_generated_code(CODE</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs</span><span class="s3">, False</span><span class="s1">):</span>
            <span class="s1">foo = locs[</span><span class="s5">'foo'</span><span class="s1">]</span>
            <span class="s3">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s3">True</span><span class="s1">) </span><span class="s3">as </span><span class="s1">log:</span>
                <span class="s1">warnings.resetwarnings()</span>
                <span class="s1">self.assertRaises(TypeError</span><span class="s3">, </span><span class="s1">foo)</span>
                <span class="s1">self.assertEqual(len(log)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">) </span><span class="s0"># no longer warn</span>

    <span class="s3">def </span><span class="s1">test_called_twice_from_class(self):</span>
        <span class="s3">import </span><span class="s1">warnings</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implements</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">&quot;IBar&quot;</span><span class="s1">)</span>
        <span class="s1">globs = {</span><span class="s5">'implements'</span><span class="s1">: implements</span><span class="s3">, </span><span class="s5">'IFoo'</span><span class="s1">: IFoo</span><span class="s3">, </span><span class="s5">'IBar'</span><span class="s1">: IBar}</span>
        <span class="s1">locs = {}</span>
        <span class="s1">CODE = </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">'class Foo(object):'</span><span class="s3">,</span>
            <span class="s5">'    implements(IFoo)'</span><span class="s3">,</span>
            <span class="s5">'    implements(IBar)'</span><span class="s3">,</span>
            <span class="s1">])</span>
        <span class="s3">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s3">True</span><span class="s1">) </span><span class="s3">as </span><span class="s1">log:</span>
            <span class="s1">warnings.resetwarnings()</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">exec(CODE</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs)  </span><span class="s0"># pylint:disable=exec-used</span>
            <span class="s3">except </span><span class="s1">TypeError:</span>
                <span class="s3">if not </span><span class="s1">PYTHON3:</span>
                    <span class="s1">self.assertEqual(len(log)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">) </span><span class="s0"># no longer warn</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.fail(</span><span class="s5">&quot;Didn't raise TypeError&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_called_once_from_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implements</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">globs = {</span><span class="s5">'implements'</span><span class="s1">: implements</span><span class="s3">, </span><span class="s5">'IFoo'</span><span class="s1">: IFoo}</span>
        <span class="s1">locs = {}</span>
        <span class="s1">CODE = </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">'class Foo(object):'</span><span class="s3">,</span>
            <span class="s5">'    implements(IFoo)'</span><span class="s3">,</span>
            <span class="s1">])</span>
        <span class="s3">if </span><span class="s1">self._run_generated_code(CODE</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs):</span>
            <span class="s1">Foo = locs[</span><span class="s5">'Foo'</span><span class="s1">]</span>
            <span class="s1">spec = Foo.__implemented__</span>
            <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[IFoo])</span>


<span class="s3">class </span><span class="s1">ProvidesClassTests(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ProvidesClass</span>
        <span class="s3">return </span><span class="s1">ProvidesClass</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_simple_class_one_interface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">spec = self._makeOne(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test___reduce__(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Provides </span><span class="s0"># the function</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">spec = self._makeOne(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">klass</span><span class="s3">, </span><span class="s1">args = spec.__reduce__()</span>
        <span class="s1">self.assertIs(klass</span><span class="s3">, </span><span class="s1">Provides)</span>
        <span class="s1">self.assertEqual(args</span><span class="s3">, </span><span class="s1">(Foo</span><span class="s3">, </span><span class="s1">IFoo))</span>

    <span class="s3">def </span><span class="s1">test___get___class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">spec = self._makeOne(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">Foo.__provides__ = spec</span>
        <span class="s1">self.assertIs(Foo.__provides__</span><span class="s3">, </span><span class="s1">spec)</span>

    <span class="s3">def </span><span class="s1">test___get___instance(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">spec = self._makeOne(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">Foo.__provides__ = spec</span>
        <span class="s3">def </span><span class="s1">_test():</span>
            <span class="s1">foo = Foo()</span>
            <span class="s3">return </span><span class="s1">foo.__provides__</span>
        <span class="s1">self.assertRaises(AttributeError</span><span class="s3">, </span><span class="s1">_test)</span>


<span class="s3">class </span><span class="s1">ProvidesClassStrictTests(ProvidesClassTests):</span>
    <span class="s0"># Tests that require the strict C3 resolution order.</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s1">ProvidesClass = super(ProvidesClassStrictTests</span><span class="s3">, </span><span class="s1">self)._getTargetClass()</span>
        <span class="s3">class </span><span class="s1">StrictProvides(ProvidesClass):</span>
            <span class="s3">def </span><span class="s1">_do_calculate_ro(self</span><span class="s3">, </span><span class="s1">base_mros):</span>
                <span class="s3">return </span><span class="s1">ProvidesClass._do_calculate_ro(self</span><span class="s3">, </span><span class="s1">base_mros=base_mros</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">StrictProvides</span>

    <span class="s3">def </span><span class="s1">test_overlapping_interfaces_corrected(self):</span>
        <span class="s0"># Giving Provides(cls, IFace), where IFace is already</span>
        <span class="s0"># provided by cls, doesn't produce invalid resolution orders.</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">implementedBy</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">implementer</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IBase)</span>
        <span class="s3">class </span><span class="s1">Base(object):</span>
            <span class="s3">pass</span>

        <span class="s1">spec = self._makeOne(Base</span><span class="s3">, </span><span class="s1">IBase)</span>
        <span class="s1">self.assertEqual(spec.__sro__</span><span class="s3">, </span><span class="s1">(</span>
            <span class="s1">spec</span><span class="s3">,</span>
            <span class="s1">implementedBy(Base)</span><span class="s3">,</span>
            <span class="s1">IBase</span><span class="s3">,</span>
            <span class="s1">implementedBy(object)</span><span class="s3">,</span>
            <span class="s1">Interface</span>
        <span class="s1">))</span>


<span class="s3">class </span><span class="s1">TestProvidesClassRepr(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ProvidesClass</span>
        <span class="s3">return </span><span class="s1">ProvidesClass</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test__repr__(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">assert </span><span class="s1">IFoo.__name__ == </span><span class="s5">'IFoo'</span>
        <span class="s3">assert </span><span class="s1">IFoo.__module__ == __name__</span>
        <span class="s3">assert </span><span class="s1">repr(IFoo) == </span><span class="s5">'&lt;InterfaceClass %s.IFoo&gt;' </span><span class="s1">% (__name__</span><span class="s3">,</span><span class="s1">)</span>

        <span class="s1">IBar = InterfaceClass(</span><span class="s5">&quot;IBar&quot;</span><span class="s1">)</span>

        <span class="s1">inst = self._makeOne(type(self)</span><span class="s3">, </span><span class="s1">IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">&quot;directlyProvides(TestProvidesClassRepr, IFoo, IBar)&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__module_provides_typical_use(self):</span>
        <span class="s0"># as created through a ``moduleProvides()`` statement</span>
        <span class="s0"># in a module body</span>
        <span class="s3">from </span><span class="s1">zope.interface.tests </span><span class="s3">import </span><span class="s1">dummy</span>
        <span class="s1">provides = dummy.__provides__ </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(provides)</span><span class="s3">,</span>
            <span class="s5">&quot;directlyProvides(sys.modules['zope.interface.tests.dummy'], IDummyModule)&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__module_after_pickle(self):</span>
        <span class="s0"># It doesn't matter, these objects can't be pickled.</span>
        <span class="s3">import </span><span class="s1">pickle</span>
        <span class="s3">from </span><span class="s1">zope.interface.tests </span><span class="s3">import </span><span class="s1">dummy</span>
        <span class="s1">provides = dummy.__provides__ </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s3">for </span><span class="s1">proto </span><span class="s3">in </span><span class="s1">range(pickle.HIGHEST_PROTOCOL + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s3">with </span><span class="s1">self.assertRaises(pickle.PicklingError):</span>
                <span class="s1">pickle.dumps(provides</span><span class="s3">, </span><span class="s1">proto)</span>

    <span class="s3">def </span><span class="s1">test__repr__directlyProvides_module(self):</span>
        <span class="s3">import </span><span class="s1">sys</span>
        <span class="s3">from </span><span class="s1">zope.interface.tests </span><span class="s3">import </span><span class="s1">dummy</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">directlyProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">alsoProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>

        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s1">)</span>

        <span class="s1">orig_provides = dummy.__provides__ </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s3">del </span><span class="s1">dummy.__provides__ </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">self.addCleanup(setattr</span><span class="s3">, </span><span class="s1">dummy</span><span class="s3">, </span><span class="s5">'__provides__'</span><span class="s3">, </span><span class="s1">orig_provides)</span>

        <span class="s1">directlyProvides(dummy</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">provides = dummy.__provides__ </span><span class="s0"># pylint:disable=no-member</span>

        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(provides)</span><span class="s3">,</span>
            <span class="s5">&quot;directlyProvides(sys.modules['zope.interface.tests.dummy'], IFoo)&quot;</span>
        <span class="s1">)</span>

        <span class="s1">alsoProvides(dummy</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">provides = dummy.__provides__ </span><span class="s0"># pylint:disable=no-member</span>

        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(provides)</span><span class="s3">,</span>
            <span class="s5">&quot;directlyProvides(sys.modules['zope.interface.tests.dummy'], IFoo, IBar)&quot;</span>
        <span class="s1">)</span>

        <span class="s0"># If we make this module also provide IFoo and IBar, then the repr</span>
        <span class="s0"># lists both names.</span>
        <span class="s1">my_module = sys.modules[__name__]</span>
        <span class="s3">assert not </span><span class="s1">hasattr(my_module</span><span class="s3">, </span><span class="s5">'__provides__'</span><span class="s1">)</span>

        <span class="s1">directlyProvides(my_module</span><span class="s3">, </span><span class="s1">IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.addCleanup(delattr</span><span class="s3">, </span><span class="s1">my_module</span><span class="s3">, </span><span class="s5">'__provides__'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(my_module.__provides__</span><span class="s3">, </span><span class="s1">provides)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(provides)</span><span class="s3">,</span>
            <span class="s5">&quot;directlyProvides(('zope.interface.tests.dummy', &quot;</span>
            <span class="s5">&quot;'zope.interface.tests.test_declarations'), &quot;</span>
            <span class="s5">&quot;IFoo, IBar)&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__module_provides_cached_shared(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ModuleType</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>

        <span class="s1">inst = self._makeOne(ModuleType</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">inst._v_module_names += (</span><span class="s5">'some.module'</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">inst._v_module_names += (</span><span class="s5">'another.module'</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">&quot;directlyProvides(('some.module', 'another.module'), IFoo)&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__duplicate_names(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s3">, </span><span class="s1">__module__=</span><span class="s5">'mod1'</span><span class="s1">)</span>
        <span class="s1">IFoo2 = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s3">, </span><span class="s1">__module__=</span><span class="s5">'mod2'</span><span class="s1">)</span>
        <span class="s1">IBaz = InterfaceClass(</span><span class="s5">&quot;IBaz&quot;</span><span class="s1">)</span>

        <span class="s1">inst = self._makeOne(type(self)</span><span class="s3">, </span><span class="s1">IFoo</span><span class="s3">, </span><span class="s1">IBaz</span><span class="s3">, </span><span class="s1">IFoo2)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">&quot;directlyProvides(TestProvidesClassRepr, IFoo, IBaz, mod2.IFoo)&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__implementedBy_in_interfaces(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">implementedBy</span>
        <span class="s3">class </span><span class="s1">IFoo(Interface):</span>
            <span class="s2">&quot;Does nothing&quot;</span>

        <span class="s3">class </span><span class="s1">Bar(object):</span>
            <span class="s2">&quot;Does nothing&quot;</span>

        <span class="s1">impl = implementedBy(type(self))</span>

        <span class="s1">inst = self._makeOne(Bar</span><span class="s3">, </span><span class="s1">IFoo</span><span class="s3">, </span><span class="s1">impl)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">'directlyProvides(Bar, IFoo, classImplements(TestProvidesClassRepr))'</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__empty_interfaces(self):</span>
        <span class="s1">inst = self._makeOne(type(self))</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">'directlyProvides(TestProvidesClassRepr)'</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__non_class(self):</span>
        <span class="s3">class </span><span class="s1">Object(object):</span>
            <span class="s1">__bases__ = ()</span>
            <span class="s1">__str__ = </span><span class="s3">lambda </span><span class="s1">_: self.fail(</span><span class="s5">&quot;Should not call str&quot;</span><span class="s1">)</span>

            <span class="s3">def </span><span class="s1">__repr__(self):</span>
                <span class="s3">return </span><span class="s5">'&lt;Object&gt;'</span>
        <span class="s1">inst = self._makeOne(Object())</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">'directlyProvides(&lt;Object&gt;)'</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__providedBy_from_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">providedBy</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>

        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>

        <span class="s1">inst = providedBy(Foo())</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">'classImplements(Foo, IFoo)'</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__providedBy_alsoProvides(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">providedBy</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">alsoProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">&quot;IBar&quot;</span><span class="s1">)</span>

        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>

        <span class="s1">foo = Foo()</span>
        <span class="s1">alsoProvides(foo</span><span class="s3">, </span><span class="s1">IBar)</span>

        <span class="s1">inst = providedBy(foo)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">&quot;directlyProvides(Foo, IBar, classImplements(Foo, IFoo))&quot;</span>
        <span class="s1">)</span>



<span class="s3">class </span><span class="s1">Test_Provides(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Provides</span>
        <span class="s3">return </span><span class="s1">Provides(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_no_cached_spec(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">declarations</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">cache = {}</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s3">with </span><span class="s1">_Monkey(declarations</span><span class="s3">, </span><span class="s1">InstanceDeclarations=cache):</span>
            <span class="s1">spec = self._callFUT(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[IFoo])</span>
        <span class="s1">self.assertTrue(cache[(Foo</span><span class="s3">, </span><span class="s1">IFoo)] </span><span class="s3">is </span><span class="s1">spec)</span>

    <span class="s3">def </span><span class="s1">test_w_cached_spec(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">declarations</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">prior = object()</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">cache = {(Foo</span><span class="s3">, </span><span class="s1">IFoo): prior}</span>
        <span class="s3">with </span><span class="s1">_Monkey(declarations</span><span class="s3">, </span><span class="s1">InstanceDeclarations=cache):</span>
            <span class="s1">spec = self._callFUT(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertTrue(spec </span><span class="s3">is </span><span class="s1">prior)</span>


<span class="s3">class </span><span class="s1">Test_directlyProvides(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">directlyProvides</span>
        <span class="s3">return </span><span class="s1">directlyProvides(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_w_normal_object(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ProvidesClass</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">obj = Foo()</span>
        <span class="s1">self._callFUT(obj</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertIsInstance(obj.__provides__</span><span class="s3">, </span><span class="s1">ProvidesClass) </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">self.assertEqual(list(obj.__provides__)</span><span class="s3">, </span><span class="s1">[IFoo]) </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s3">def </span><span class="s1">test_w_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ClassProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">self._callFUT(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertIsInstance(Foo.__provides__</span><span class="s3">, </span><span class="s1">ClassProvides) </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">self.assertEqual(list(Foo.__provides__)</span><span class="s3">, </span><span class="s1">[IFoo]) </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s1">@_skip_under_py3k</span>
    <span class="s3">def </span><span class="s1">test_w_non_descriptor_aware_metaclass(self):</span>
        <span class="s0"># There are no non-descriptor-aware types in Py3k</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">MetaClass(type):</span>
            <span class="s3">def </span><span class="s1">__getattribute__(cls</span><span class="s3">, </span><span class="s1">name):</span>
                <span class="s0"># Emulate metaclass whose base is not the type object.</span>
                <span class="s3">if </span><span class="s1">name == </span><span class="s5">'__class__'</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">cls</span>
                <span class="s0"># Under certain circumstances, the implementedByFallback</span>
                <span class="s0"># can get here for __dict__</span>
                <span class="s3">return </span><span class="s1">type.__getattribute__(cls</span><span class="s3">, </span><span class="s1">name) </span><span class="s0"># pragma: no cover</span>

        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__metaclass__ = MetaClass</span>
        <span class="s1">obj = Foo()</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s3">, </span><span class="s1">self._callFUT</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">IFoo)</span>

    <span class="s3">def </span><span class="s1">test_w_classless_object(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ProvidesClass</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">the_dict = {}</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">def </span><span class="s1">__getattribute__(self</span><span class="s3">, </span><span class="s1">name):</span>
                <span class="s0"># Emulate object w/o any class</span>
                <span class="s3">if </span><span class="s1">name == </span><span class="s5">'__class__'</span><span class="s1">:</span>
                    <span class="s3">return None</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError(name)</span>
            <span class="s3">def </span><span class="s1">__setattr__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value):</span>
                <span class="s1">the_dict[name] = value</span>
        <span class="s1">obj = Foo()</span>
        <span class="s1">self._callFUT(obj</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertIsInstance(the_dict[</span><span class="s5">'__provides__'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ProvidesClass)</span>
        <span class="s1">self.assertEqual(list(the_dict[</span><span class="s5">'__provides__'</span><span class="s1">])</span><span class="s3">, </span><span class="s1">[IFoo])</span>


<span class="s3">class </span><span class="s1">Test_alsoProvides(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">alsoProvides</span>
        <span class="s3">return </span><span class="s1">alsoProvides(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_wo_existing_provides(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ProvidesClass</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">obj = Foo()</span>
        <span class="s1">self._callFUT(obj</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertIsInstance(obj.__provides__</span><span class="s3">, </span><span class="s1">ProvidesClass) </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">self.assertEqual(list(obj.__provides__)</span><span class="s3">, </span><span class="s1">[IFoo]) </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s3">def </span><span class="s1">test_w_existing_provides(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">directlyProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ProvidesClass</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">&quot;IBar&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">obj = Foo()</span>
        <span class="s1">directlyProvides(obj</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self._callFUT(obj</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertIsInstance(obj.__provides__</span><span class="s3">, </span><span class="s1">ProvidesClass) </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">self.assertEqual(list(obj.__provides__)</span><span class="s3">, </span><span class="s1">[IFoo</span><span class="s3">, </span><span class="s1">IBar]) </span><span class="s0"># pylint:disable=no-member</span>


<span class="s3">class </span><span class="s1">Test_noLongerProvides(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">noLongerProvides</span>
        <span class="s3">return </span><span class="s1">noLongerProvides(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_wo_existing_provides(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">obj = Foo()</span>
        <span class="s1">self._callFUT(obj</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertEqual(list(obj.__provides__)</span><span class="s3">, </span><span class="s1">[]) </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s3">def </span><span class="s1">test_w_existing_provides_hit(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">directlyProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">obj = Foo()</span>
        <span class="s1">directlyProvides(obj</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self._callFUT(obj</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertEqual(list(obj.__provides__)</span><span class="s3">, </span><span class="s1">[]) </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s3">def </span><span class="s1">test_w_existing_provides_miss(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">directlyProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">&quot;IBar&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">obj = Foo()</span>
        <span class="s1">directlyProvides(obj</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self._callFUT(obj</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(list(obj.__provides__)</span><span class="s3">, </span><span class="s1">[IFoo]) </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s3">def </span><span class="s1">test_w_iface_implemented_by_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">obj = Foo()</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">self._callFUT</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">IFoo)</span>


<span class="s3">class </span><span class="s1">ClassProvidesBaseFallbackTests(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s0"># pylint:disable=no-name-in-module</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ClassProvidesBaseFallback</span>
        <span class="s3">return </span><span class="s1">ClassProvidesBaseFallback</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">klass</span><span class="s3">, </span><span class="s1">implements):</span>
        <span class="s0"># Don't instantiate directly:  the C version can't have attributes</span>
        <span class="s0"># assigned.</span>
        <span class="s3">class </span><span class="s1">Derived(self._getTargetClass()):</span>
            <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">i):</span>
                <span class="s1">self._cls = k</span>
                <span class="s1">self._implements = i</span>
        <span class="s3">return </span><span class="s1">Derived(klass</span><span class="s3">, </span><span class="s1">implements)</span>

    <span class="s3">def </span><span class="s1">test_w_same_class_via_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">cpbp = Foo.__provides__ = self._makeOne(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertTrue(Foo.__provides__ </span><span class="s3">is </span><span class="s1">cpbp)</span>

    <span class="s3">def </span><span class="s1">test_w_same_class_via_instance(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">Foo.__provides__ = self._makeOne(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertIs(foo.__provides__</span><span class="s3">, </span><span class="s1">IFoo)</span>

    <span class="s3">def </span><span class="s1">test_w_different_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s3">class </span><span class="s1">Bar(Foo):</span>
            <span class="s3">pass</span>
        <span class="s1">bar = Bar()</span>
        <span class="s1">Foo.__provides__ = self._makeOne(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertRaises(AttributeError</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">, </span><span class="s1">Bar</span><span class="s3">, </span><span class="s5">'__provides__'</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(AttributeError</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">, </span><span class="s1">bar</span><span class="s3">, </span><span class="s5">'__provides__'</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">ClassProvidesBaseTests(OptimizationTestMixin</span><span class="s3">,</span>
                             <span class="s1">ClassProvidesBaseFallbackTests):</span>
    <span class="s0"># Repeat tests for C optimizations</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ClassProvidesBase</span>
        <span class="s3">return </span><span class="s1">ClassProvidesBase</span>

    <span class="s3">def </span><span class="s1">_getFallbackClass(self):</span>
        <span class="s0"># pylint:disable=no-name-in-module</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ClassProvidesBaseFallback</span>
        <span class="s3">return </span><span class="s1">ClassProvidesBaseFallback</span>


<span class="s3">class </span><span class="s1">ClassProvidesTests(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ClassProvides</span>
        <span class="s3">return </span><span class="s1">ClassProvides</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_w_simple_metaclass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">&quot;IBar&quot;</span><span class="s1">)</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">cp = Foo.__provides__ = self._makeOne(Foo</span><span class="s3">, </span><span class="s1">type(Foo)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertTrue(Foo.__provides__ </span><span class="s3">is </span><span class="s1">cp)</span>
        <span class="s1">self.assertEqual(list(Foo().__provides__)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test___reduce__(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">&quot;IBar&quot;</span><span class="s1">)</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">cp = Foo.__provides__ = self._makeOne(Foo</span><span class="s3">, </span><span class="s1">type(Foo)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(cp.__reduce__()</span><span class="s3">,</span>
                         <span class="s1">(type(cp)</span><span class="s3">, </span><span class="s1">(Foo</span><span class="s3">, </span><span class="s1">type(Foo)</span><span class="s3">, </span><span class="s1">IBar)))</span>


<span class="s3">class </span><span class="s1">ClassProvidesStrictTests(ClassProvidesTests):</span>
    <span class="s0"># Tests that require the strict C3 resolution order.</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s1">ClassProvides = super(ClassProvidesStrictTests</span><span class="s3">, </span><span class="s1">self)._getTargetClass()</span>
        <span class="s3">class </span><span class="s1">StrictClassProvides(ClassProvides):</span>
            <span class="s3">def </span><span class="s1">_do_calculate_ro(self</span><span class="s3">, </span><span class="s1">base_mros):</span>
                <span class="s3">return </span><span class="s1">ClassProvides._do_calculate_ro(self</span><span class="s3">, </span><span class="s1">base_mros=base_mros</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">StrictClassProvides</span>

    <span class="s3">def </span><span class="s1">test_overlapping_interfaces_corrected(self):</span>
        <span class="s0"># Giving ClassProvides(cls, metaclass, IFace), where IFace is already</span>
        <span class="s0"># provided by metacls, doesn't produce invalid resolution orders.</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">implementedBy</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">implementer</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IBase)</span>
        <span class="s3">class </span><span class="s1">metaclass(type):</span>
            <span class="s3">pass</span>

        <span class="s1">cls = metaclass(</span>
            <span class="s5">'cls'</span><span class="s3">,</span>
            <span class="s1">(object</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">{}</span>
        <span class="s1">)</span>

        <span class="s1">spec = self._makeOne(cls</span><span class="s3">, </span><span class="s1">metaclass</span><span class="s3">, </span><span class="s1">IBase)</span>
        <span class="s1">self.assertEqual(spec.__sro__</span><span class="s3">, </span><span class="s1">(</span>
            <span class="s1">spec</span><span class="s3">,</span>
            <span class="s1">implementedBy(metaclass)</span><span class="s3">,</span>
            <span class="s1">IBase</span><span class="s3">,</span>
            <span class="s1">implementedBy(type)</span><span class="s3">,</span>
            <span class="s1">implementedBy(object)</span><span class="s3">,</span>
            <span class="s1">Interface</span>
        <span class="s1">))</span>


<span class="s3">class </span><span class="s1">TestClassProvidesRepr(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ClassProvides</span>
        <span class="s3">return </span><span class="s1">ClassProvides</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test__repr__empty(self):</span>
        <span class="s1">inst = self._makeOne(type(self)</span><span class="s3">, </span><span class="s1">type)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">&quot;directlyProvides(TestClassProvidesRepr)&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__providing_one(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">class </span><span class="s1">IFoo(Interface):</span>
            <span class="s2">&quot;Does nothing&quot;</span>

        <span class="s1">inst = self._makeOne(type(self)</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">&quot;directlyProvides(TestClassProvidesRepr, IFoo)&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__duplicate_names(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s3">, </span><span class="s1">__module__=</span><span class="s5">'mod1'</span><span class="s1">)</span>
        <span class="s1">IFoo2 = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s3">, </span><span class="s1">__module__=</span><span class="s5">'mod2'</span><span class="s1">)</span>
        <span class="s1">IBaz = InterfaceClass(</span><span class="s5">&quot;IBaz&quot;</span><span class="s1">)</span>

        <span class="s1">inst = self._makeOne(type(self)</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">IFoo</span><span class="s3">, </span><span class="s1">IBaz</span><span class="s3">, </span><span class="s1">IFoo2)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">&quot;directlyProvides(TestClassProvidesRepr, IFoo, IBaz, mod2.IFoo)&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__implementedBy(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementedBy</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>

        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>

        <span class="s1">inst = implementedBy(Foo)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">'classImplements(Foo, IFoo)'</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__repr__implementedBy_generic_callable(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementedBy</span>
        <span class="s0"># We can't get a __name__ by default, so we get a</span>
        <span class="s0"># module name and a question mark</span>
        <span class="s3">class </span><span class="s1">Callable(object):</span>
            <span class="s3">def </span><span class="s1">__call__(self):</span>
                <span class="s3">return </span><span class="s1">self</span>

        <span class="s1">inst = implementedBy(Callable())</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">'classImplements(%s.?)' </span><span class="s1">% (__name__</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">c = Callable()</span>
        <span class="s1">c.__name__ = </span><span class="s5">'Callable'</span>
        <span class="s1">inst = implementedBy(c)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">repr(inst)</span><span class="s3">,</span>
            <span class="s5">'classImplements(Callable)'</span>
        <span class="s1">)</span>


<span class="s3">class </span><span class="s1">Test_directlyProvidedBy(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">directlyProvidedBy</span>
        <span class="s3">return </span><span class="s1">directlyProvidedBy(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_wo_declarations_in_class_or_instance(self):</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">self.assertEqual(list(self._callFUT(foo))</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_w_declarations_in_class_but_not_instance(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">self.assertEqual(list(self._callFUT(foo))</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_w_declarations_in_instance_but_not_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">directlyProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">directlyProvides(foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">self.assertEqual(list(self._callFUT(foo))</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test_w_declarations_in_instance_and_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">directlyProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">&quot;IBar&quot;</span><span class="s1">)</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">directlyProvides(foo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(list(self._callFUT(foo))</span><span class="s3">, </span><span class="s1">[IBar])</span>


<span class="s3">class </span><span class="s1">Test_classProvides(unittest.TestCase</span><span class="s3">, </span><span class="s1">_Py3ClassAdvice):</span>
    <span class="s0"># pylint:disable=exec-used</span>

    <span class="s3">def </span><span class="s1">test_called_from_function(self):</span>
        <span class="s3">import </span><span class="s1">warnings</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">classProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">globs = {</span><span class="s5">'classProvides'</span><span class="s1">: classProvides</span><span class="s3">, </span><span class="s5">'IFoo'</span><span class="s1">: IFoo}</span>
        <span class="s1">locs = {}</span>
        <span class="s1">CODE = </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">'def foo():'</span><span class="s3">,</span>
            <span class="s5">'    classProvides(IFoo)'</span>
            <span class="s1">])</span>
        <span class="s1">exec(CODE</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs)</span>
        <span class="s1">foo = locs[</span><span class="s5">'foo'</span><span class="s1">]</span>
        <span class="s3">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s3">True</span><span class="s1">) </span><span class="s3">as </span><span class="s1">log:</span>
            <span class="s1">warnings.resetwarnings()</span>
            <span class="s1">self.assertRaises(TypeError</span><span class="s3">, </span><span class="s1">foo)</span>
            <span class="s3">if not </span><span class="s1">PYTHON3:</span>
                <span class="s1">self.assertEqual(len(log)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">) </span><span class="s0"># no longer warn</span>

    <span class="s3">def </span><span class="s1">test_called_twice_from_class(self):</span>
        <span class="s3">import </span><span class="s1">warnings</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">classProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">&quot;IBar&quot;</span><span class="s1">)</span>
        <span class="s1">globs = {</span><span class="s5">'classProvides'</span><span class="s1">: classProvides</span><span class="s3">, </span><span class="s5">'IFoo'</span><span class="s1">: IFoo</span><span class="s3">, </span><span class="s5">'IBar'</span><span class="s1">: IBar}</span>
        <span class="s1">locs = {}</span>
        <span class="s1">CODE = </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">'class Foo(object):'</span><span class="s3">,</span>
            <span class="s5">'    classProvides(IFoo)'</span><span class="s3">,</span>
            <span class="s5">'    classProvides(IBar)'</span><span class="s3">,</span>
            <span class="s1">])</span>
        <span class="s3">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s3">True</span><span class="s1">) </span><span class="s3">as </span><span class="s1">log:</span>
            <span class="s1">warnings.resetwarnings()</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">exec(CODE</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs)</span>
            <span class="s3">except </span><span class="s1">TypeError:</span>
                <span class="s3">if not </span><span class="s1">PYTHON3:</span>
                    <span class="s1">self.assertEqual(len(log)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">) </span><span class="s0"># no longer warn</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.fail(</span><span class="s5">&quot;Didn't raise TypeError&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_called_once_from_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">classProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">globs = {</span><span class="s5">'classProvides'</span><span class="s1">: classProvides</span><span class="s3">, </span><span class="s5">'IFoo'</span><span class="s1">: IFoo}</span>
        <span class="s1">locs = {}</span>
        <span class="s1">CODE = </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">'class Foo(object):'</span><span class="s3">,</span>
            <span class="s5">'    classProvides(IFoo)'</span><span class="s3">,</span>
            <span class="s1">])</span>
        <span class="s3">if </span><span class="s1">self._run_generated_code(CODE</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs):</span>
            <span class="s1">Foo = locs[</span><span class="s5">'Foo'</span><span class="s1">]</span>
            <span class="s1">spec = Foo.__providedBy__</span>
            <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

<span class="s0"># Test _classProvides_advice through classProvides, its only caller.</span>


<span class="s3">class </span><span class="s1">Test_provider(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">provider</span>
        <span class="s3">return </span><span class="s1">provider</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_w_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ClassProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">@self._makeOne(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">self.assertIsInstance(Foo.__provides__</span><span class="s3">, </span><span class="s1">ClassProvides) </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">self.assertEqual(list(Foo.__provides__)</span><span class="s3">, </span><span class="s1">[IFoo]) </span><span class="s0"># pylint:disable=no-member</span>


<span class="s3">class </span><span class="s1">Test_moduleProvides(unittest.TestCase):</span>
    <span class="s0"># pylint:disable=exec-used</span>

    <span class="s3">def </span><span class="s1">test_called_from_function(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">moduleProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">globs = {</span><span class="s5">'__name__'</span><span class="s1">: </span><span class="s5">'zope.interface.tests.foo'</span><span class="s3">,</span>
                 <span class="s5">'moduleProvides'</span><span class="s1">: moduleProvides</span><span class="s3">, </span><span class="s5">'IFoo'</span><span class="s1">: IFoo}</span>
        <span class="s1">locs = {}</span>
        <span class="s1">CODE = </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">'def foo():'</span><span class="s3">,</span>
            <span class="s5">'    moduleProvides(IFoo)'</span>
            <span class="s1">])</span>
        <span class="s1">exec(CODE</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs)</span>
        <span class="s1">foo = locs[</span><span class="s5">'foo'</span><span class="s1">]</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s3">, </span><span class="s1">foo)</span>

    <span class="s3">def </span><span class="s1">test_called_from_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">moduleProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">globs = {</span><span class="s5">'__name__'</span><span class="s1">: </span><span class="s5">'zope.interface.tests.foo'</span><span class="s3">,</span>
                 <span class="s5">'moduleProvides'</span><span class="s1">: moduleProvides</span><span class="s3">, </span><span class="s5">'IFoo'</span><span class="s1">: IFoo}</span>
        <span class="s1">locs = {}</span>
        <span class="s1">CODE = </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">'class Foo(object):'</span><span class="s3">,</span>
            <span class="s5">'    moduleProvides(IFoo)'</span><span class="s3">,</span>
            <span class="s1">])</span>
        <span class="s3">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">exec(CODE</span><span class="s3">, </span><span class="s1">globs</span><span class="s3">, </span><span class="s1">locs)</span>

    <span class="s3">def </span><span class="s1">test_called_once_from_module_scope(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">moduleProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">globs = {</span><span class="s5">'__name__'</span><span class="s1">: </span><span class="s5">'zope.interface.tests.foo'</span><span class="s3">,</span>
                 <span class="s5">'moduleProvides'</span><span class="s1">: moduleProvides</span><span class="s3">, </span><span class="s5">'IFoo'</span><span class="s1">: IFoo}</span>
        <span class="s1">CODE = </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">'moduleProvides(IFoo)'</span><span class="s3">,</span>
            <span class="s1">])</span>
        <span class="s1">exec(CODE</span><span class="s3">, </span><span class="s1">globs)</span>
        <span class="s1">spec = globs[</span><span class="s5">'__provides__'</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test_called_twice_from_module_scope(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">moduleProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">globs = {</span><span class="s5">'__name__'</span><span class="s1">: </span><span class="s5">'zope.interface.tests.foo'</span><span class="s3">,</span>
                 <span class="s5">'moduleProvides'</span><span class="s1">: moduleProvides</span><span class="s3">, </span><span class="s5">'IFoo'</span><span class="s1">: IFoo}</span>

        <span class="s1">CODE = </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s1">.join([</span>
            <span class="s5">'moduleProvides(IFoo)'</span><span class="s3">,</span>
            <span class="s5">'moduleProvides(IFoo)'</span><span class="s3">,</span>
            <span class="s1">])</span>
        <span class="s3">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">exec(CODE</span><span class="s3">, </span><span class="s1">globs)</span>


<span class="s3">class </span><span class="s1">Test_getObjectSpecificationFallback(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getFallbackClass(self):</span>
        <span class="s0"># pylint:disable=no-name-in-module</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">getObjectSpecificationFallback</span>
        <span class="s3">return </span><span class="s1">getObjectSpecificationFallback</span>

    <span class="s1">_getTargetClass = _getFallbackClass</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_wo_existing_provides_classless(self):</span>
        <span class="s1">the_dict = {}</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">def </span><span class="s1">__getattribute__(self</span><span class="s3">, </span><span class="s1">name):</span>
                <span class="s0"># Emulate object w/o any class</span>
                <span class="s3">if </span><span class="s1">name == </span><span class="s5">'__class__'</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">AttributeError(name)</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">the_dict[name]</span>
                <span class="s3">except </span><span class="s1">KeyError:</span>
                    <span class="s3">raise </span><span class="s1">AttributeError(name)</span>
            <span class="s3">def </span><span class="s1">__setattr__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value):</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError()</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_existing_provides_is_spec(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">directlyProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">def </span><span class="s1">foo():</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError()</span>
        <span class="s1">directlyProvides(foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertIs(spec</span><span class="s3">, </span><span class="s1">foo.__provides__) </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s3">def </span><span class="s1">test_existing_provides_is_not_spec(self):</span>
        <span class="s3">def </span><span class="s1">foo():</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError()</span>
        <span class="s1">foo.__provides__ = object() </span><span class="s0"># not a valid spec</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_existing_provides(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">directlyProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">directlyProvides(foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test_wo_provides_on_class_w_implements(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test_wo_provides_on_class_wo_implements(self):</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_catches_only_AttributeError_on_provides(self):</span>
        <span class="s1">MissingSomeAttrs.test_raises(self</span><span class="s3">, </span><span class="s1">self._callFUT</span><span class="s3">, </span><span class="s1">expected_missing=</span><span class="s5">'__provides__'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_catches_only_AttributeError_on_class(self):</span>
        <span class="s1">MissingSomeAttrs.test_raises(self</span><span class="s3">, </span><span class="s1">self._callFUT</span><span class="s3">, </span><span class="s1">expected_missing=</span><span class="s5">'__class__'</span><span class="s3">,</span>
                                     <span class="s1">__provides__=</span><span class="s3">None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_raises_AttributeError_when_provides_fails_type_check_AttributeError(self):</span>
        <span class="s0"># isinstance(ob.__provides__, SpecificationBase) is not</span>
        <span class="s0"># protected inside any kind of block.</span>

        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__provides__ = MissingSomeAttrs(AttributeError)</span>

        <span class="s0"># isinstance() ignores AttributeError on __class__</span>
        <span class="s1">self._callFUT(Foo())</span>

    <span class="s3">def </span><span class="s1">test_raises_AttributeError_when_provides_fails_type_check_RuntimeError(self):</span>
        <span class="s0"># isinstance(ob.__provides__, SpecificationBase) is not</span>
        <span class="s0"># protected inside any kind of block.</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__provides__ = MissingSomeAttrs(RuntimeError)</span>

        <span class="s3">if </span><span class="s1">PYTHON3:</span>
            <span class="s3">with </span><span class="s1">self.assertRaises(RuntimeError) </span><span class="s3">as </span><span class="s1">exc:</span>
                <span class="s1">self._callFUT(Foo())</span>

            <span class="s1">self.assertEqual(</span><span class="s5">'__class__'</span><span class="s3">, </span><span class="s1">exc.exception.args[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Python 2 catches everything.</span>
            <span class="s1">self._callFUT(Foo())</span>


<span class="s3">class </span><span class="s1">Test_getObjectSpecification(Test_getObjectSpecificationFallback</span><span class="s3">,</span>
                                  <span class="s1">OptimizationTestMixin):</span>
    <span class="s0"># Repeat tests for C optimizations</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">getObjectSpecification</span>
        <span class="s3">return </span><span class="s1">getObjectSpecification</span>


<span class="s3">class </span><span class="s1">Test_providedByFallback(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getFallbackClass(self):</span>
        <span class="s0"># pylint:disable=no-name-in-module</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">providedByFallback</span>
        <span class="s3">return </span><span class="s1">providedByFallback</span>

    <span class="s1">_getTargetClass = _getFallbackClass</span>

    <span class="s3">def </span><span class="s1">_callFUT(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_wo_providedBy_on_class_wo_implements(self):</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_w_providedBy_valid_spec(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Provides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">foo.__providedBy__ = Provides(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test_w_providedBy_invalid_spec(self):</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">foo.__providedBy__ = object()</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_w_providedBy_invalid_spec_class_w_implements(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">foo.__providedBy__ = object()</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test_w_providedBy_invalid_spec_w_provides_no_provides_on_class(self):</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">foo.__providedBy__ = object()</span>
        <span class="s1">expected = foo.__provides__ = object()</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertTrue(spec </span><span class="s3">is </span><span class="s1">expected)</span>

    <span class="s3">def </span><span class="s1">test_w_providedBy_invalid_spec_w_provides_diff_provides_on_class(self):</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">foo.__providedBy__ = object()</span>
        <span class="s1">expected = foo.__provides__ = object()</span>
        <span class="s1">Foo.__provides__ = object()</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertTrue(spec </span><span class="s3">is </span><span class="s1">expected)</span>

    <span class="s3">def </span><span class="s1">test_w_providedBy_invalid_spec_w_provides_same_provides_on_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">foo.__providedBy__ = object()</span>
        <span class="s1">foo.__provides__ = Foo.__provides__ = object()</span>
        <span class="s1">spec = self._callFUT(foo)</span>
        <span class="s1">self.assertEqual(list(spec)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test_super_when_base_implements_interface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IDerived(IBase):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IBase)</span>
        <span class="s3">class </span><span class="s1">Base(object):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IDerived)</span>
        <span class="s3">class </span><span class="s1">Derived(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">derived = Derived()</span>
        <span class="s1">self.assertEqual(list(self._callFUT(derived))</span><span class="s3">, </span><span class="s1">[IDerived</span><span class="s3">, </span><span class="s1">IBase])</span>

        <span class="s1">sup = super(Derived</span><span class="s3">, </span><span class="s1">derived)</span>
        <span class="s1">fut = self._callFUT(sup)</span>
        <span class="s1">self.assertIsNone(fut._dependents)</span>
        <span class="s1">self.assertEqual(list(fut)</span><span class="s3">, </span><span class="s1">[IBase])</span>

    <span class="s3">def </span><span class="s1">test_super_when_base_doesnt_implement_interface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IDerived(IBase):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">Base(object):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IDerived)</span>
        <span class="s3">class </span><span class="s1">Derived(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">derived = Derived()</span>
        <span class="s1">self.assertEqual(list(self._callFUT(derived))</span><span class="s3">, </span><span class="s1">[IDerived])</span>

        <span class="s1">sup = super(Derived</span><span class="s3">, </span><span class="s1">derived)</span>
        <span class="s1">self.assertEqual(list(self._callFUT(sup))</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_super_when_base_is_object(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IDerived(IBase):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IDerived)</span>
        <span class="s3">class </span><span class="s1">Derived(object):</span>
            <span class="s3">pass</span>

        <span class="s1">derived = Derived()</span>
        <span class="s1">self.assertEqual(list(self._callFUT(derived))</span><span class="s3">, </span><span class="s1">[IDerived])</span>

        <span class="s1">sup = super(Derived</span><span class="s3">, </span><span class="s1">derived)</span>
        <span class="s1">fut = self._callFUT(sup)</span>
        <span class="s1">self.assertIsNone(fut._dependents)</span>
        <span class="s1">self.assertEqual(list(fut)</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_super_when_object_directly_provides(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">directlyProvides</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IDerived(IBase):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IBase)</span>
        <span class="s3">class </span><span class="s1">Base(object):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">Derived(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">derived = Derived()</span>
        <span class="s1">self.assertEqual(list(self._callFUT(derived))</span><span class="s3">, </span><span class="s1">[IBase])</span>

        <span class="s1">directlyProvides(derived</span><span class="s3">, </span><span class="s1">IDerived)</span>
        <span class="s1">self.assertEqual(list(self._callFUT(derived))</span><span class="s3">, </span><span class="s1">[IDerived</span><span class="s3">, </span><span class="s1">IBase])</span>

        <span class="s1">sup = super(Derived</span><span class="s3">, </span><span class="s1">derived)</span>
        <span class="s1">fut = self._callFUT(sup)</span>
        <span class="s1">self.assertIsNone(fut._dependents)</span>
        <span class="s1">self.assertEqual(list(fut)</span><span class="s3">, </span><span class="s1">[IBase])</span>

    <span class="s3">def </span><span class="s1">test_super_multi_level_multi_inheritance(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>

        <span class="s3">class </span><span class="s1">IBase(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IM1(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IM2(Interface):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IDerived(IBase):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">IUnrelated(Interface):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IBase)</span>
        <span class="s3">class </span><span class="s1">Base(object):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IM1)</span>
        <span class="s3">class </span><span class="s1">M1(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IM2)</span>
        <span class="s3">class </span><span class="s1">M2(Base):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IDerived</span><span class="s3">, </span><span class="s1">IUnrelated)</span>
        <span class="s3">class </span><span class="s1">Derived(M1</span><span class="s3">, </span><span class="s1">M2):</span>
            <span class="s3">pass</span>

        <span class="s1">d = Derived()</span>
        <span class="s1">sd = super(Derived</span><span class="s3">, </span><span class="s1">d)</span>
        <span class="s1">sm1 = super(M1</span><span class="s3">, </span><span class="s1">d)</span>
        <span class="s1">sm2 = super(M2</span><span class="s3">, </span><span class="s1">d)</span>

        <span class="s1">self.assertEqual(list(self._callFUT(d))</span><span class="s3">,</span>
                         <span class="s1">[IDerived</span><span class="s3">, </span><span class="s1">IUnrelated</span><span class="s3">, </span><span class="s1">IM1</span><span class="s3">, </span><span class="s1">IBase</span><span class="s3">, </span><span class="s1">IM2])</span>
        <span class="s1">self.assertEqual(list(self._callFUT(sd))</span><span class="s3">,</span>
                         <span class="s1">[IM1</span><span class="s3">, </span><span class="s1">IBase</span><span class="s3">, </span><span class="s1">IM2])</span>
        <span class="s1">self.assertEqual(list(self._callFUT(sm1))</span><span class="s3">,</span>
                         <span class="s1">[IM2</span><span class="s3">, </span><span class="s1">IBase])</span>
        <span class="s1">self.assertEqual(list(self._callFUT(sm2))</span><span class="s3">,</span>
                         <span class="s1">[IBase])</span>

    <span class="s3">def </span><span class="s1">test_catches_only_AttributeError_on_providedBy(self):</span>
        <span class="s1">MissingSomeAttrs.test_raises(self</span><span class="s3">, </span><span class="s1">self._callFUT</span><span class="s3">,</span>
                                     <span class="s1">expected_missing=</span><span class="s5">'__providedBy__'</span><span class="s3">,</span>
                                     <span class="s1">__class__=object)</span>

    <span class="s3">def </span><span class="s1">test_catches_only_AttributeError_on_class(self):</span>
        <span class="s0"># isinstance() tries to get the __class__, which is non-obvious,</span>
        <span class="s0"># so it must be protected too.</span>
        <span class="s1">PY3 = str </span><span class="s3">is not </span><span class="s1">bytes</span>
        <span class="s1">MissingSomeAttrs.test_raises(self</span><span class="s3">, </span><span class="s1">self._callFUT</span><span class="s3">,</span>
                                     <span class="s1">expected_missing=</span><span class="s5">'__class__' </span><span class="s3">if </span><span class="s1">PY3 </span><span class="s3">else </span><span class="s5">'__providedBy__'</span><span class="s1">)</span>



<span class="s3">class </span><span class="s1">Test_providedBy(Test_providedByFallback</span><span class="s3">,</span>
                      <span class="s1">OptimizationTestMixin):</span>
    <span class="s0"># Repeat tests for C optimizations</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">providedBy</span>
        <span class="s3">return </span><span class="s1">providedBy</span>


<span class="s3">class </span><span class="s1">ObjectSpecificationDescriptorFallbackTests(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getFallbackClass(self):</span>
        <span class="s0"># pylint:disable=no-name-in-module</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations \</span>
            <span class="s3">import </span><span class="s1">ObjectSpecificationDescriptorFallback</span>
        <span class="s3">return </span><span class="s1">ObjectSpecificationDescriptorFallback</span>

    <span class="s1">_getTargetClass = _getFallbackClass</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_accessed_via_class(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Provides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">Foo.__provides__ = Provides(Foo</span><span class="s3">, </span><span class="s1">IFoo)</span>
        <span class="s1">Foo.__providedBy__ = self._makeOne()</span>
        <span class="s1">self.assertEqual(list(Foo.__providedBy__)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test_accessed_via_inst_wo_provides(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Provides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">&quot;IBar&quot;</span><span class="s1">)</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">Foo.__provides__ = Provides(Foo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">Foo.__providedBy__ = self._makeOne()</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">self.assertEqual(list(foo.__providedBy__)</span><span class="s3">, </span><span class="s1">[IFoo])</span>

    <span class="s3">def </span><span class="s1">test_accessed_via_inst_w_provides(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">directlyProvides</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">Provides</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">&quot;IFoo&quot;</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">&quot;IBar&quot;</span><span class="s1">)</span>
        <span class="s1">IBaz = InterfaceClass(</span><span class="s5">&quot;IBaz&quot;</span><span class="s1">)</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">Foo.__provides__ = Provides(Foo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">Foo.__providedBy__ = self._makeOne()</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">directlyProvides(foo</span><span class="s3">, </span><span class="s1">IBaz)</span>
        <span class="s1">self.assertEqual(list(foo.__providedBy__)</span><span class="s3">, </span><span class="s1">[IBaz</span><span class="s3">, </span><span class="s1">IFoo])</span>

    <span class="s3">def </span><span class="s1">test_arbitrary_exception_accessing_provides_not_caught(self):</span>

        <span class="s3">class </span><span class="s1">MyException(Exception):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__providedBy__ = self._makeOne()</span>

            <span class="s1">@property</span>
            <span class="s3">def </span><span class="s1">__provides__(self):</span>
                <span class="s3">raise </span><span class="s1">MyException</span>

        <span class="s1">foo = Foo()</span>
        <span class="s3">with </span><span class="s1">self.assertRaises(MyException):</span>
            <span class="s1">getattr(foo</span><span class="s3">, </span><span class="s5">'__providedBy__'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_AttributeError_accessing_provides_caught(self):</span>

        <span class="s3">class </span><span class="s1">MyException(Exception):</span>
            <span class="s3">pass</span>

        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s1">__providedBy__ = self._makeOne()</span>

            <span class="s1">@property</span>
            <span class="s3">def </span><span class="s1">__provides__(self):</span>
                <span class="s3">raise </span><span class="s1">AttributeError</span>

        <span class="s1">foo = Foo()</span>
        <span class="s1">provided = getattr(foo</span><span class="s3">, </span><span class="s5">'__providedBy__'</span><span class="s1">)</span>
        <span class="s1">self.assertIsNotNone(provided)</span>

    <span class="s3">def </span><span class="s1">test_None_in__provides__overrides(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">implementer</span>

        <span class="s3">class </span><span class="s1">IFoo(Interface):</span>
            <span class="s3">pass</span>

        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>

            <span class="s1">@property</span>
            <span class="s3">def </span><span class="s1">__provides__(self):</span>
                <span class="s3">return None</span>

        <span class="s1">Foo.__providedBy__ = self._makeOne()</span>

        <span class="s1">provided = getattr(Foo()</span><span class="s3">, </span><span class="s5">'__providedBy__'</span><span class="s1">)</span>
        <span class="s1">self.assertIsNone(provided)</span>

<span class="s3">class </span><span class="s1">ObjectSpecificationDescriptorTests(</span>
        <span class="s1">ObjectSpecificationDescriptorFallbackTests</span><span class="s3">,</span>
        <span class="s1">OptimizationTestMixin):</span>
    <span class="s0"># Repeat tests for C optimizations</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">ObjectSpecificationDescriptor</span>
        <span class="s3">return </span><span class="s1">ObjectSpecificationDescriptor</span>


<span class="s0"># Test _normalizeargs through its callers.</span>


<span class="s3">class </span><span class="s1">_Monkey(object):</span>
    <span class="s0"># context-manager for replacing module names in the scope of a test.</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s1">self.module = module</span>
        <span class="s1">self.to_restore = {key: getattr(module</span><span class="s3">, </span><span class="s1">key) </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">kw}</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">kw.items():</span>
            <span class="s1">setattr(module</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value)</span>

    <span class="s3">def </span><span class="s1">__enter__(self):</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__exit__(self</span><span class="s3">, </span><span class="s1">exc_type</span><span class="s3">, </span><span class="s1">exc_val</span><span class="s3">, </span><span class="s1">exc_tb):</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self.to_restore.items():</span>
            <span class="s1">setattr(self.module</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value)</span>


<span class="s3">class </span><span class="s1">_MonkeyDict(object):</span>
    <span class="s0"># context-manager for restoring a dict w/in a module in the scope of a test.</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">attrname</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s1">self.module = module</span>
        <span class="s1">self.target = getattr(module</span><span class="s3">, </span><span class="s1">attrname)</span>
        <span class="s1">self.to_restore = self.target.copy()</span>
        <span class="s1">self.target.clear()</span>
        <span class="s1">self.target.update(kw)</span>

    <span class="s3">def </span><span class="s1">__enter__(self):</span>
        <span class="s3">return </span><span class="s1">self.target</span>

    <span class="s3">def </span><span class="s1">__exit__(self</span><span class="s3">, </span><span class="s1">exc_type</span><span class="s3">, </span><span class="s1">exc_val</span><span class="s3">, </span><span class="s1">exc_tb):</span>
        <span class="s1">self.target.clear()</span>
        <span class="s1">self.target.update(self.to_restore)</span>
</pre>
</body>
</html>