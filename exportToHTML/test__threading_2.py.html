<html>
<head>
<title>test__threading_2.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test__threading_2.py</font>
</center></td></tr></table>
<pre><span class="s0"># testing gevent's Event, Lock, RLock, Semaphore, BoundedSemaphore with standard test_threading</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">print_function</span>

<span class="s2">from </span><span class="s1">gevent.testing.six </span><span class="s2">import </span><span class="s1">xrange</span>
<span class="s2">import </span><span class="s1">gevent.testing </span><span class="s2">as </span><span class="s1">greentest</span>

<span class="s1">setup_ = </span><span class="s3">'''from gevent import monkey; monkey.patch_all() 
from gevent.event import Event 
from gevent.lock import RLock, Semaphore, BoundedSemaphore 
from gevent.thread import allocate_lock as Lock 
import threading 
threading.Event = Event 
threading.Lock = Lock 
# NOTE: We're completely patching around the allocate_lock 
# patch we try to do with RLock; our monkey patch doesn't 
# behave this way, but we do it in tests to make sure that 
# our RLock implementation behaves correctly by itself. 
# However, we must test the patched version too, so make it 
# available. 
threading.NativeRLock = threading.RLock 
threading.RLock = RLock 
threading.Semaphore = Semaphore 
threading.BoundedSemaphore = BoundedSemaphore 
'''</span>

<span class="s1">exec(setup_)</span>

<span class="s1">setup_3 = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(</span><span class="s3">'            %s' </span><span class="s1">% line </span><span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">setup_.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span>
<span class="s1">setup_4 = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(</span><span class="s3">'                %s' </span><span class="s1">% line </span><span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">setup_.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span>

<span class="s2">from </span><span class="s1">gevent.testing </span><span class="s2">import </span><span class="s1">support</span>
<span class="s1">verbose = support.verbose</span>

<span class="s2">import </span><span class="s1">random</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">threading</span>
<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">thread</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s2">import </span><span class="s1">_thread </span><span class="s2">as </span><span class="s1">thread</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">unittest</span>
<span class="s2">import </span><span class="s1">weakref</span>

<span class="s2">from </span><span class="s1">gevent.tests </span><span class="s2">import </span><span class="s1">lock_tests</span>
<span class="s1">verbose = </span><span class="s2">False</span>
<span class="s0"># pylint:disable=consider-using-with</span>

<span class="s0"># A trivial mutable counter.</span>

<span class="s2">def </span><span class="s1">skipDueToHang(cls):</span>
    <span class="s2">return </span><span class="s1">unittest.skipIf(</span>
        <span class="s1">greentest.PYPY3 </span><span class="s2">and </span><span class="s1">greentest.RUNNING_ON_CI</span><span class="s2">,</span>
        <span class="s3">&quot;SKIPPED: Timeout on PyPy3 on Travis&quot;</span>
    <span class="s1">)(cls)</span>

<span class="s2">class </span><span class="s1">Counter(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.value = </span><span class="s4">0</span>

    <span class="s2">def </span><span class="s1">inc(self):</span>
        <span class="s1">self.value += </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">dec(self):</span>
        <span class="s1">self.value -= </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">get(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>


<span class="s2">class </span><span class="s1">TestThread(threading.Thread):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">testcase</span><span class="s2">, </span><span class="s1">sema</span><span class="s2">, </span><span class="s1">mutex</span><span class="s2">, </span><span class="s1">nrunning):</span>
        <span class="s1">threading.Thread.__init__(self</span><span class="s2">, </span><span class="s1">name=name)</span>
        <span class="s1">self.testcase = testcase</span>
        <span class="s1">self.sema = sema</span>
        <span class="s1">self.mutex = mutex</span>
        <span class="s1">self.nrunning = nrunning</span>

    <span class="s2">def </span><span class="s1">run(self):</span>
        <span class="s1">delay = random.random() / </span><span class="s4">10000.0</span>
        <span class="s2">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s3">'task %s will run for %.1f usec' </span><span class="s1">% (</span>
                <span class="s1">self.name</span><span class="s2">, </span><span class="s1">delay * </span><span class="s4">1e6</span><span class="s1">))</span>

        <span class="s2">with </span><span class="s1">self.sema:</span>
            <span class="s2">with </span><span class="s1">self.mutex:</span>
                <span class="s1">self.nrunning.inc()</span>
                <span class="s2">if </span><span class="s1">verbose:</span>
                    <span class="s1">print(self.nrunning.get()</span><span class="s2">, </span><span class="s3">'tasks are running'</span><span class="s1">)</span>
                <span class="s1">self.testcase.assertLessEqual(self.nrunning.get()</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>

            <span class="s1">time.sleep(delay)</span>
            <span class="s2">if </span><span class="s1">verbose:</span>
                <span class="s1">print(</span><span class="s3">'task'</span><span class="s2">, </span><span class="s1">self.name</span><span class="s2">, </span><span class="s3">'done'</span><span class="s1">)</span>

            <span class="s2">with </span><span class="s1">self.mutex:</span>
                <span class="s1">self.nrunning.dec()</span>
                <span class="s1">self.testcase.assertGreaterEqual(self.nrunning.get()</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">verbose:</span>
                    <span class="s1">print(</span><span class="s3">'%s is finished. %d tasks are running' </span><span class="s1">% (</span>
                        <span class="s1">self.name</span><span class="s2">, </span><span class="s1">self.nrunning.get()))</span>

<span class="s1">@skipDueToHang</span>
<span class="s2">class </span><span class="s1">ThreadTests(unittest.TestCase):</span>

    <span class="s0"># Create a bunch of threads, let each do some work, wait until all are</span>
    <span class="s0"># done.</span>
    <span class="s2">def </span><span class="s1">test_various_ops(self):</span>
        <span class="s0"># This takes about n/3 seconds to run (about n/3 clumps of tasks,</span>
        <span class="s0"># times about 1 second per clump).</span>
        <span class="s1">NUMTASKS = </span><span class="s4">10</span>

        <span class="s0"># no more than 3 of the 10 can run at once</span>
        <span class="s1">sema = threading.BoundedSemaphore(value=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">mutex = threading.RLock()</span>
        <span class="s1">numrunning = Counter()</span>

        <span class="s1">threads = []</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(NUMTASKS):</span>
            <span class="s1">t = TestThread(</span><span class="s3">&quot;&lt;thread %d&gt;&quot; </span><span class="s1">% i</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">sema</span><span class="s2">, </span><span class="s1">mutex</span><span class="s2">, </span><span class="s1">numrunning)</span>
            <span class="s1">threads.append(t)</span>
            <span class="s1">t.daemon = </span><span class="s2">False </span><span class="s0"># Under PYPY we get daemon by default?</span>
            <span class="s2">if </span><span class="s1">hasattr(t</span><span class="s2">, </span><span class="s3">'ident'</span><span class="s1">):</span>
                <span class="s1">self.assertIsNone(t.ident)</span>
                <span class="s1">self.assertFalse(t.daemon)</span>
                <span class="s1">self.assertTrue(re.match(</span><span class="s3">r'&lt;TestThread\(.*, initial\)&gt;'</span><span class="s2">, </span><span class="s1">repr(t)))</span>
            <span class="s1">t.start()</span>

        <span class="s2">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s3">'waiting for all tasks to complete'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">threads:</span>
            <span class="s1">t.join(NUMTASKS)</span>
            <span class="s1">self.assertFalse(t.is_alive()</span><span class="s2">, </span><span class="s1">t.__dict__)</span>
            <span class="s2">if </span><span class="s1">hasattr(t</span><span class="s2">, </span><span class="s3">'ident'</span><span class="s1">):</span>
                <span class="s1">self.assertNotEqual(t.ident</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s1">self.assertFalse(t.ident </span><span class="s2">is None</span><span class="s1">)</span>
                <span class="s1">self.assertTrue(re.match(</span><span class="s3">r'&lt;TestThread\(.*, \w+ -?\d+\)&gt;'</span><span class="s2">, </span><span class="s1">repr(t)))</span>
        <span class="s2">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s3">'all tasks done'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(numrunning.get()</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ident_of_no_threading_threads(self):</span>
        <span class="s0"># The ident still must work for the main thread and dummy threads,</span>
        <span class="s0"># as must the repr and str.</span>

        <span class="s1">t = threading.current_thread()</span>
        <span class="s1">self.assertFalse(t.ident </span><span class="s2">is None</span><span class="s1">)</span>
        <span class="s1">str(t)</span>
        <span class="s1">repr(t)</span>

        <span class="s2">def </span><span class="s1">f():</span>
            <span class="s1">t = threading.current_thread()</span>
            <span class="s1">ident.append(t.ident)</span>
            <span class="s1">str(t)</span>
            <span class="s1">repr(t)</span>
            <span class="s1">done.set()</span>

        <span class="s1">done = threading.Event()</span>
        <span class="s1">ident = []</span>
        <span class="s1">thread.start_new_thread(f</span><span class="s2">, </span><span class="s1">())</span>
        <span class="s1">done.wait()</span>
        <span class="s1">self.assertFalse(ident[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">is None</span><span class="s1">)</span>
        <span class="s0"># Kill the &quot;immortal&quot; _DummyThread</span>
        <span class="s2">del </span><span class="s1">threading._active[ident[</span><span class="s4">0</span><span class="s1">]]</span>

    <span class="s0"># run with a small(ish) thread stack size (256kB)</span>
    <span class="s2">def </span><span class="s1">test_various_ops_small_stack(self):</span>
        <span class="s2">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s3">'with 256kB thread stack size...'</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">threading.stack_size(</span><span class="s4">262144</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">thread.error:</span>
            <span class="s2">if </span><span class="s1">verbose:</span>
                <span class="s1">print(</span><span class="s3">'platform does not support changing thread stack size'</span><span class="s1">)</span>
            <span class="s2">return</span>
        <span class="s1">self.test_various_ops()</span>
        <span class="s1">threading.stack_size(</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0"># run with a large thread stack size (1MB)</span>
    <span class="s2">def </span><span class="s1">test_various_ops_large_stack(self):</span>
        <span class="s2">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s3">'with 1MB thread stack size...'</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">threading.stack_size(</span><span class="s4">0x100000</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">thread.error:</span>
            <span class="s2">if </span><span class="s1">verbose:</span>
                <span class="s1">print(</span><span class="s3">'platform does not support changing thread stack size'</span><span class="s1">)</span>
            <span class="s2">return</span>
        <span class="s1">self.test_various_ops()</span>
        <span class="s1">threading.stack_size(</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_foreign_thread(self):</span>
        <span class="s0"># Check that a &quot;foreign&quot; thread can use the threading module.</span>
        <span class="s2">def </span><span class="s1">f(mutex):</span>
            <span class="s0"># Calling current_thread() forces an entry for the foreign</span>
            <span class="s0"># thread to get made in the threading._active map.</span>
            <span class="s1">threading.current_thread()</span>
            <span class="s1">mutex.release()</span>

        <span class="s1">mutex = threading.Lock()</span>
        <span class="s1">mutex.acquire()</span>
        <span class="s1">tid = thread.start_new_thread(f</span><span class="s2">, </span><span class="s1">(mutex</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s0"># Wait for the thread to finish.</span>
        <span class="s1">mutex.acquire()</span>
        <span class="s1">self.assertIn(tid</span><span class="s2">, </span><span class="s1">threading._active)</span>
        <span class="s1">self.assertIsInstance(threading._active[tid]</span><span class="s2">,</span>
                              <span class="s1">threading._DummyThread)</span>
        <span class="s2">del </span><span class="s1">threading._active[tid]</span>
        <span class="s0"># in gevent, we actually clean up threading._active, but it's not happended there yet</span>

    <span class="s0"># PyThreadState_SetAsyncExc() is a CPython-only gimmick, not (currently)</span>
    <span class="s0"># exposed at the Python level.  This test relies on ctypes to get at it.</span>
    <span class="s2">def </span><span class="s1">SKIP_test_PyThreadState_SetAsyncExc(self):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">ctypes</span>
        <span class="s2">except </span><span class="s1">ImportError:</span>
            <span class="s2">if </span><span class="s1">verbose:</span>
                <span class="s1">print(</span><span class="s3">&quot;test_PyThreadState_SetAsyncExc can't import ctypes&quot;</span><span class="s1">)</span>
            <span class="s2">return  </span><span class="s0"># can't do anything</span>

        <span class="s1">set_async_exc = ctypes.pythonapi.PyThreadState_SetAsyncExc</span>

        <span class="s2">class </span><span class="s1">AsyncExc(Exception):</span>
            <span class="s2">pass</span>

        <span class="s1">exception = ctypes.py_object(AsyncExc)</span>

        <span class="s0"># `worker_started` is set by the thread when it's inside a try/except</span>
        <span class="s0"># block waiting to catch the asynchronously set AsyncExc exception.</span>
        <span class="s0"># `worker_saw_exception` is set by the thread upon catching that</span>
        <span class="s0"># exception.</span>
        <span class="s1">worker_started = threading.Event()</span>
        <span class="s1">worker_saw_exception = threading.Event()</span>

        <span class="s2">class </span><span class="s1">Worker(threading.Thread):</span>
            <span class="s1">id = </span><span class="s2">None</span>
            <span class="s1">finished = </span><span class="s2">False</span>

            <span class="s2">def </span><span class="s1">run(self):</span>
                <span class="s1">self.id = thread.get_ident()</span>
                <span class="s1">self.finished = </span><span class="s2">False</span>

                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">while True</span><span class="s1">:</span>
                        <span class="s1">worker_started.set()</span>
                        <span class="s1">time.sleep(</span><span class="s4">0.1</span><span class="s1">)</span>
                <span class="s2">except </span><span class="s1">AsyncExc:</span>
                    <span class="s1">self.finished = </span><span class="s2">True</span>
                    <span class="s1">worker_saw_exception.set()</span>

        <span class="s1">t = Worker()</span>
        <span class="s1">t.daemon = </span><span class="s2">True  </span><span class="s0"># so if this fails, we don't hang Python at shutdown</span>
        <span class="s1">t.start()</span>
        <span class="s2">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s3">&quot;    started worker thread&quot;</span><span class="s1">)</span>

        <span class="s0"># Try a thread id that doesn't make sense.</span>
        <span class="s2">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s3">&quot;    trying nonsensical thread id&quot;</span><span class="s1">)</span>
        <span class="s1">result = set_async_exc(ctypes.c_long(-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exception)</span>
        <span class="s1">self.assertEqual(result</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)  </span><span class="s0"># no thread states modified</span>

        <span class="s0"># Now raise an exception in the worker thread.</span>
        <span class="s2">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s3">&quot;    waiting for worker thread to get started&quot;</span><span class="s1">)</span>
        <span class="s1">worker_started.wait()</span>
        <span class="s2">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s3">&quot;    verifying worker hasn't exited&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(t.finished)</span>
        <span class="s2">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s3">&quot;    attempting to raise asynch exception in worker&quot;</span><span class="s1">)</span>
        <span class="s1">result = set_async_exc(ctypes.c_long(t.id)</span><span class="s2">, </span><span class="s1">exception)</span>
        <span class="s1">self.assertEqual(result</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)  </span><span class="s0"># one thread state modified</span>
        <span class="s2">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s3">&quot;    waiting for worker to say it caught the exception&quot;</span><span class="s1">)</span>
        <span class="s1">worker_saw_exception.wait(timeout=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(t.finished)</span>
        <span class="s2">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s3">&quot;    all OK -- joining worker&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">t.finished:</span>
            <span class="s1">t.join()</span>
        <span class="s0"># else the thread is still running, and we have no way to kill it</span>

    <span class="s2">def </span><span class="s1">test_limbo_cleanup(self):</span>
        <span class="s0"># Issue 7481: Failure to start thread should cleanup the limbo map.</span>
        <span class="s2">def </span><span class="s1">fail_new_thread(*_args):</span>
            <span class="s2">raise </span><span class="s1">thread.error()</span>
        <span class="s1">_start_new_thread = threading._start_new_thread</span>
        <span class="s1">threading._start_new_thread = fail_new_thread</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">t = threading.Thread(target=</span><span class="s2">lambda</span><span class="s1">: </span><span class="s2">None</span><span class="s1">)</span>
            <span class="s1">self.assertRaises(thread.error</span><span class="s2">, </span><span class="s1">t.start)</span>
            <span class="s1">self.assertFalse(</span>
                <span class="s1">t </span><span class="s2">in </span><span class="s1">threading._limbo</span><span class="s2">,</span>
                <span class="s3">&quot;Failed to cleanup _limbo map on failure of Thread.start().&quot;</span><span class="s1">)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">threading._start_new_thread = _start_new_thread</span>

    <span class="s2">def </span><span class="s1">test_finalize_runnning_thread(self):</span>
        <span class="s0"># Issue 1402: the PyGILState_Ensure / _Release functions may be called</span>
        <span class="s0"># very late on python exit: on deallocation of a running thread for</span>
        <span class="s0"># example.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">ctypes</span>
            <span class="s1">getattr(ctypes</span><span class="s2">, </span><span class="s3">'pythonapi'</span><span class="s1">) </span><span class="s0"># not available on PyPy</span>
            <span class="s1">getattr(ctypes.pythonapi</span><span class="s2">, </span><span class="s3">'PyGILState_Ensure'</span><span class="s1">) </span><span class="s0"># not available on PyPy3</span>
        <span class="s2">except </span><span class="s1">(ImportError</span><span class="s2">, </span><span class="s1">AttributeError):</span>
            <span class="s2">if </span><span class="s1">verbose:</span>
                <span class="s1">print(</span><span class="s3">&quot;test_finalize_with_runnning_thread can't import ctypes&quot;</span><span class="s1">)</span>
            <span class="s2">return  </span><span class="s0"># can't do anything</span>

        <span class="s2">del </span><span class="s1">ctypes  </span><span class="s0"># pyflakes fix</span>

        <span class="s2">import </span><span class="s1">subprocess</span>
        <span class="s1">rc = subprocess.call([sys.executable</span><span class="s2">, </span><span class="s3">&quot;-W&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s3">&quot;-c&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;&quot;if 1: 
%s 
            import ctypes, sys, time 
            try: 
                import thread 
            except ImportError: 
                import _thread as thread # Py3 
 
            # This lock is used as a simple event variable. 
            ready = thread.allocate_lock() 
            ready.acquire() 
 
            # Module globals are cleared before __del__ is run 
            # So we save the functions in class dict 
            class C: 
                ensure = ctypes.pythonapi.PyGILState_Ensure 
                release = ctypes.pythonapi.PyGILState_Release 
                def __del__(self): 
                    state = self.ensure() 
                    self.release(state) 
 
            def waitingThread(): 
                x = C() 
                ready.release() 
                time.sleep(100) 
 
            thread.start_new_thread(waitingThread, ()) 
            ready.acquire()  # Be sure the other thread is waiting. 
            sys.exit(42) 
            &quot;&quot;&quot; </span><span class="s1">% setup_3])</span>
        <span class="s1">self.assertEqual(rc</span><span class="s2">, </span><span class="s4">42</span><span class="s1">)</span>

    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s3">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_join_nondaemon_on_shutdown(self):</span>
        <span class="s0"># Issue 1722344</span>
        <span class="s0"># Raising SystemExit skipped threading._shutdown</span>
        <span class="s2">import </span><span class="s1">subprocess</span>
        <span class="s1">script = </span><span class="s3">&quot;&quot;&quot;if 1: 
%s 
                import threading 
                from time import sleep 
 
                def child(): 
                    sleep(0.3) 
                    # As a non-daemon thread we SHOULD wake up and nothing 
                    # should be torn down yet 
                    print(&quot;Woke up, sleep function is: %%s.%%s&quot; %% (sleep.__module__, sleep.__name__)) 
 
                threading.Thread(target=child).start() 
                raise SystemExit 
        &quot;&quot;&quot; </span><span class="s1">% setup_4</span>
        <span class="s1">p = subprocess.Popen([sys.executable</span><span class="s2">, </span><span class="s3">&quot;-W&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s3">&quot;-c&quot;</span><span class="s2">, </span><span class="s1">script]</span><span class="s2">,</span>
                             <span class="s1">stdout=subprocess.PIPE</span><span class="s2">,</span>
                             <span class="s1">stderr=subprocess.PIPE)</span>
        <span class="s1">stdout</span><span class="s2">, </span><span class="s1">stderr = p.communicate()</span>
        <span class="s1">stdout = stdout.strip()</span>
        <span class="s1">stdout = stdout.decode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
        <span class="s1">stderr = stderr.decode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>


        <span class="s1">self.assertEqual(</span>
            <span class="s3">'Woke up, sleep function is: gevent.hub.sleep'</span><span class="s2">,</span>
            <span class="s1">stdout)</span>

        <span class="s0"># On Python 2, importing pkg_resources tends to result in some 'ImportWarning'</span>
        <span class="s0"># being printed to stderr about packages missing __init__.py; the -W ignore is...</span>
        <span class="s0"># ignored.</span>
        <span class="s0"># self.assertEqual(stderr, &quot;&quot;)</span>

    <span class="s1">@greentest.skipIf(</span>
        <span class="s2">not</span><span class="s1">(hasattr(sys</span><span class="s2">, </span><span class="s3">'getcheckinterval'</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s3">&quot;Needs sys.getcheckinterval&quot;</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_enumerate_after_join(self):</span>
        <span class="s0"># Try hard to trigger #1703448: a thread is still returned in</span>
        <span class="s0"># threading.enumerate() after it has been join()ed.</span>
        <span class="s1">enum = threading.enumerate</span>
        <span class="s2">import </span><span class="s1">warnings</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">'ignore'</span><span class="s2">, </span><span class="s1">DeprecationWarning)</span>
            <span class="s0"># get/set checkinterval are deprecated in Python 3,</span>
            <span class="s0"># and removed in Python 3.9</span>
            <span class="s1">old_interval = sys.getcheckinterval() </span><span class="s0"># pylint:disable=no-member</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">xrange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">100</span><span class="s1">):</span>
                    <span class="s0"># Try a couple times at each thread-switching interval</span>
                    <span class="s0"># to get more interleavings.</span>
                    <span class="s1">sys.setcheckinterval(i // </span><span class="s4">5</span><span class="s1">) </span><span class="s0"># pylint:disable=no-member</span>
                    <span class="s1">t = threading.Thread(target=</span><span class="s2">lambda</span><span class="s1">: </span><span class="s2">None</span><span class="s1">)</span>
                    <span class="s1">t.start()</span>
                    <span class="s1">t.join()</span>
                    <span class="s1">l = enum()</span>
                    <span class="s1">self.assertFalse(t </span><span class="s2">in </span><span class="s1">l</span><span class="s2">,</span>
                                     <span class="s3">&quot;#1703448 triggered after %d trials: %s&quot; </span><span class="s1">% (i</span><span class="s2">, </span><span class="s1">l))</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">sys.setcheckinterval(old_interval) </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s2">if not </span><span class="s1">hasattr(sys</span><span class="s2">, </span><span class="s3">'pypy_version_info'</span><span class="s1">):</span>
        <span class="s2">def </span><span class="s1">test_no_refcycle_through_target(self):</span>
            <span class="s2">class </span><span class="s1">RunSelfFunction(object):</span>
                <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">should_raise):</span>
                    <span class="s0"># The links in this refcycle from Thread back to self</span>
                    <span class="s0"># should be cleaned up when the thread completes.</span>
                    <span class="s1">self.should_raise = should_raise</span>
                    <span class="s1">self.thread = threading.Thread(target=self._run</span><span class="s2">,</span>
                                                   <span class="s1">args=(self</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                                                   <span class="s1">kwargs={</span><span class="s3">'_yet_another'</span><span class="s1">: self})</span>
                    <span class="s1">self.thread.start()</span>

                <span class="s2">def </span><span class="s1">_run(self</span><span class="s2">, </span><span class="s1">_other_ref</span><span class="s2">, </span><span class="s1">_yet_another):</span>
                    <span class="s2">if </span><span class="s1">self.should_raise:</span>
                        <span class="s2">raise </span><span class="s1">SystemExit</span>

            <span class="s1">cyclic_object = RunSelfFunction(should_raise=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">weak_cyclic_object = weakref.ref(cyclic_object)</span>
            <span class="s1">cyclic_object.thread.join()</span>
            <span class="s2">del </span><span class="s1">cyclic_object</span>
            <span class="s1">self.assertIsNone(weak_cyclic_object()</span><span class="s2">,</span>
                              <span class="s1">msg=(</span><span class="s3">'%d references still around' </span><span class="s1">%</span>
                                   <span class="s1">sys.getrefcount(weak_cyclic_object())))</span>

            <span class="s1">raising_cyclic_object = RunSelfFunction(should_raise=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">weak_raising_cyclic_object = weakref.ref(raising_cyclic_object)</span>
            <span class="s1">raising_cyclic_object.thread.join()</span>
            <span class="s2">del </span><span class="s1">raising_cyclic_object</span>
            <span class="s1">self.assertIsNone(weak_raising_cyclic_object()</span><span class="s2">,</span>
                              <span class="s1">msg=(</span><span class="s3">'%d references still around' </span><span class="s1">%</span>
                                   <span class="s1">sys.getrefcount(weak_raising_cyclic_object())))</span>

<span class="s1">@skipDueToHang</span>
<span class="s2">class </span><span class="s1">ThreadJoinOnShutdown(unittest.TestCase):</span>

    <span class="s2">def </span><span class="s1">_run_and_join(self</span><span class="s2">, </span><span class="s1">script):</span>
        <span class="s1">script = </span><span class="s3">&quot;&quot;&quot;if 1: 
%s 
            import sys, os, time, threading 
            # a thread, which waits for the main program to terminate 
            def joiningfunc(mainthread): 
                mainthread.join() 
                print('end of thread') 
        </span><span class="s2">\n</span><span class="s3">&quot;&quot;&quot; </span><span class="s1">% setup_3 + script</span>

        <span class="s2">import </span><span class="s1">subprocess</span>
        <span class="s1">p = subprocess.Popen([sys.executable</span><span class="s2">, </span><span class="s3">&quot;-W&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s3">&quot;-c&quot;</span><span class="s2">, </span><span class="s1">script]</span><span class="s2">, </span><span class="s1">stdout=subprocess.PIPE)</span>
        <span class="s1">rc = p.wait()</span>
        <span class="s1">data = p.stdout.read().replace(</span><span class="s5">b'</span><span class="s2">\r</span><span class="s5">'</span><span class="s2">, </span><span class="s5">b''</span><span class="s1">)</span>
        <span class="s1">p.stdout.close()</span>
        <span class="s1">self.assertEqual(data</span><span class="s2">, </span><span class="s5">b&quot;end of main</span><span class="s2">\n</span><span class="s5">end of thread</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertNotEqual(rc</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s5">b&quot;interpreter was blocked&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(rc</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s5">b&quot;Unexpected error&quot;</span><span class="s1">)</span>

    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s3">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_1_join_on_shutdown(self):</span>
        <span class="s0"># The usual case: on exit, wait for a non-daemon thread</span>
        <span class="s1">script = </span><span class="s3">&quot;&quot;&quot;if 1: 
            import os 
            t = threading.Thread(target=joiningfunc, 
                                 args=(threading.current_thread(),)) 
            t.start() 
            time.sleep(0.2) 
            print('end of main') 
            &quot;&quot;&quot;</span>
        <span class="s1">self._run_and_join(script)</span>

    <span class="s1">@greentest.skipOnPyPy3OnCI(</span><span class="s3">&quot;Sometimes randomly times out&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_2_join_in_forked_process(self):</span>
        <span class="s0"># Like the test above, but from a forked interpreter</span>
        <span class="s2">import </span><span class="s1">os</span>
        <span class="s2">if not </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">'fork'</span><span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s1">script = </span><span class="s3">&quot;&quot;&quot;if 1: 
            childpid = os.fork() 
            if childpid != 0: 
                os.waitpid(childpid, 0) 
                sys.exit(0) 
 
            t = threading.Thread(target=joiningfunc, 
                                 args=(threading.current_thread(),)) 
            t.start() 
            print('end of main') 
            &quot;&quot;&quot;</span>
        <span class="s1">self._run_and_join(script)</span>

    <span class="s2">def </span><span class="s1">test_3_join_in_forked_from_thread(self):</span>
        <span class="s0"># Like the test above, but fork() was called from a worker thread</span>
        <span class="s0"># In the forked process, the main Thread object must be marked as stopped.</span>
        <span class="s2">import </span><span class="s1">os</span>
        <span class="s2">if not </span><span class="s1">hasattr(os</span><span class="s2">, </span><span class="s3">'fork'</span><span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s0"># Skip platforms with known problems forking from a worker thread.</span>
        <span class="s0"># See http://bugs.python.org/issue3863.</span>
        <span class="s0"># skip disable because I think the bug shouldn't apply to gevent -- denis</span>
        <span class="s0">#if sys.platform in ('freebsd4', 'freebsd5', 'freebsd6', 'os2emx'):</span>
        <span class="s0">#    print(('Skipping test_3_join_in_forked_from_thread'</span>
        <span class="s0">#          ' due to known OS bugs on'), sys.platform, file=sys.stderr)</span>
        <span class="s0">#    return</span>

        <span class="s0"># A note on CFFI: Under Python 3, using CFFI tends to initialize the GIL,</span>
        <span class="s0"># whether or not we spawn any actual threads. Now, os.fork() calls</span>
        <span class="s0"># PyEval_ReInitThreads, which only does any work of the GIL has been taken.</span>
        <span class="s0"># One of the things it does is call threading._after_fork to reset</span>
        <span class="s0"># some thread state, which causes the main thread (threading._main_thread)</span>
        <span class="s0"># to be reset to the current thread---which for Python &gt;= 3.4 happens</span>
        <span class="s0"># to be our version of thread, gevent.threading.Thread, which doesn't</span>
        <span class="s0"># initialize the _tstate_lock ivar. This causes threading._shutdown to crash</span>
        <span class="s0"># with an AssertionError and this test to fail. We hack around this by</span>
        <span class="s0"># making sure _after_fork is not called in the child process.</span>
        <span class="s0"># XXX: Figure out how to really fix that.</span>

        <span class="s1">script = </span><span class="s3">&quot;&quot;&quot;if 1: 
            main_thread = threading.current_thread() 
            def worker(): 
                threading._after_fork = lambda: None 
                childpid = os.fork() 
                if childpid != 0: 
                    os.waitpid(childpid, 0) 
                    sys.exit(0) 
 
                t = threading.Thread(target=joiningfunc, 
                                     args=(main_thread,)) 
                print('end of main') 
                t.start() 
                t.join() # Should not block: main_thread is already stopped 
 
            w = threading.Thread(target=worker) 
            w.start() 
            import sys 
            if sys.version_info[:2] &gt;= (3, 7) or (sys.version_info[:2] &gt;= (3, 5) and hasattr(sys, 'pypy_version_info') and sys.platform != 'darwin'): 
                w.join() 
            &quot;&quot;&quot;</span>
        <span class="s0"># In PyPy3 5.8.0, if we don't wait on this top-level &quot;thread&quot;, 'w',</span>
        <span class="s0"># we never see &quot;end of thread&quot;. It's not clear why, since that's being</span>
        <span class="s0"># done in a child of this process. Yet in normal CPython 3, waiting on this</span>
        <span class="s0"># causes the whole process to lock up (possibly because of some loop within</span>
        <span class="s0"># the interpreter waiting on thread locks, like the issue described in threading.py</span>
        <span class="s0"># for Python 3.4? in any case, it doesn't hang in Python 2.) This changed in</span>
        <span class="s0"># 3.7a1 and waiting on it is again necessary and doesn't hang.</span>
        <span class="s0"># PyPy3 5.10.1 is back to the &quot;old&quot; cpython behaviour, and waiting on it</span>
        <span class="s0"># causes the whole process to hang, but apparently only on OS X---linux was fine without it</span>
        <span class="s1">self._run_and_join(script)</span>


<span class="s1">@skipDueToHang</span>
<span class="s2">class </span><span class="s1">ThreadingExceptionTests(unittest.TestCase):</span>
    <span class="s0"># A RuntimeError should be raised if Thread.start() is called</span>
    <span class="s0"># multiple times.</span>
    <span class="s0"># pylint:disable=bad-thread-instantiation</span>
    <span class="s2">def </span><span class="s1">test_start_thread_again(self):</span>
        <span class="s1">thread_ = threading.Thread()</span>
        <span class="s1">thread_.start()</span>
        <span class="s1">self.assertRaises(RuntimeError</span><span class="s2">, </span><span class="s1">thread_.start)</span>

    <span class="s2">def </span><span class="s1">test_joining_current_thread(self):</span>
        <span class="s1">current_thread = threading.current_thread()</span>
        <span class="s1">self.assertRaises(RuntimeError</span><span class="s2">, </span><span class="s1">current_thread.join)</span>

    <span class="s2">def </span><span class="s1">test_joining_inactive_thread(self):</span>
        <span class="s1">thread_ = threading.Thread()</span>
        <span class="s1">self.assertRaises(RuntimeError</span><span class="s2">, </span><span class="s1">thread_.join)</span>

    <span class="s2">def </span><span class="s1">test_daemonize_active_thread(self):</span>
        <span class="s1">thread_ = threading.Thread()</span>
        <span class="s1">thread_.start()</span>
        <span class="s1">self.assertRaises(RuntimeError</span><span class="s2">, </span><span class="s1">setattr</span><span class="s2">, </span><span class="s1">thread_</span><span class="s2">, </span><span class="s3">&quot;daemon&quot;</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s1">@skipDueToHang</span>
<span class="s2">class </span><span class="s1">LockTests(lock_tests.LockTests):</span>
    <span class="s1">locktype = staticmethod(threading.Lock)</span>

<span class="s1">@skipDueToHang</span>
<span class="s2">class </span><span class="s1">RLockTests(lock_tests.RLockTests):</span>
    <span class="s1">locktype = staticmethod(threading.RLock)</span>

<span class="s1">@skipDueToHang</span>
<span class="s2">class </span><span class="s1">NativeRLockTests(lock_tests.RLockTests):</span>
    <span class="s0"># See comments at the top of the file for the difference</span>
    <span class="s0"># between this and RLockTests, and why they both matter</span>
    <span class="s1">locktype = staticmethod(threading.NativeRLock)</span>

<span class="s1">@skipDueToHang</span>
<span class="s2">class </span><span class="s1">EventTests(lock_tests.EventTests):</span>
    <span class="s1">eventtype = staticmethod(threading.Event)</span>

<span class="s1">@skipDueToHang</span>
<span class="s2">class </span><span class="s1">ConditionAsRLockTests(lock_tests.RLockTests):</span>
    <span class="s0"># An Condition uses an RLock by default and exports its API.</span>
    <span class="s1">locktype = staticmethod(threading.Condition)</span>

<span class="s1">@skipDueToHang</span>
<span class="s2">class </span><span class="s1">ConditionTests(lock_tests.ConditionTests):</span>
    <span class="s1">condtype = staticmethod(threading.Condition)</span>

<span class="s1">@skipDueToHang</span>
<span class="s2">class </span><span class="s1">SemaphoreTests(lock_tests.SemaphoreTests):</span>
    <span class="s1">semtype = staticmethod(threading.Semaphore)</span>

<span class="s1">@skipDueToHang</span>
<span class="s2">class </span><span class="s1">BoundedSemaphoreTests(lock_tests.BoundedSemaphoreTests):</span>
    <span class="s1">semtype = staticmethod(threading.BoundedSemaphore)</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s3">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s1">greentest.main()</span>
</pre>
</body>
</html>