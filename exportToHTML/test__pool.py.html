<html>
<head>
<title>test__pool.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test__pool.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">time </span><span class="s0">import </span><span class="s1">time</span>
<span class="s0">import </span><span class="s1">gevent</span>
<span class="s0">import </span><span class="s1">gevent.pool</span>
<span class="s0">from </span><span class="s1">gevent.event </span><span class="s0">import </span><span class="s1">Event</span>
<span class="s0">from </span><span class="s1">gevent.queue </span><span class="s0">import </span><span class="s1">Queue</span>

<span class="s0">import </span><span class="s1">gevent.testing </span><span class="s0">as </span><span class="s1">greentest</span>
<span class="s0">import </span><span class="s1">gevent.testing.timing</span>
<span class="s0">import </span><span class="s1">random</span>
<span class="s0">from </span><span class="s1">gevent.testing </span><span class="s0">import </span><span class="s1">ExpectedException</span>

<span class="s0">import </span><span class="s1">unittest</span>


<span class="s0">class </span><span class="s1">TestCoroutinePool(unittest.TestCase):</span>
    <span class="s1">klass = gevent.pool.Pool</span>

    <span class="s0">def </span><span class="s1">test_apply_async(self):</span>
        <span class="s1">done = Event()</span>

        <span class="s0">def </span><span class="s1">some_work(_):</span>
            <span class="s1">done.set()</span>

        <span class="s1">pool = self.klass(</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">pool.apply_async(some_work</span><span class="s0">, </span><span class="s1">(</span><span class="s3">'x'</span><span class="s0">, </span><span class="s1">))</span>
        <span class="s1">done.wait()</span>

    <span class="s0">def </span><span class="s1">test_apply(self):</span>
        <span class="s1">value = </span><span class="s3">'return value'</span>

        <span class="s0">def </span><span class="s1">some_work():</span>
            <span class="s0">return </span><span class="s1">value</span>

        <span class="s1">pool = self.klass(</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">result = pool.apply(some_work)</span>
        <span class="s1">self.assertEqual(value</span><span class="s0">, </span><span class="s1">result)</span>

    <span class="s0">def </span><span class="s1">test_apply_raises(self):</span>
        <span class="s1">pool = self.klass(</span><span class="s2">1</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">raiser():</span>
            <span class="s0">raise </span><span class="s1">ExpectedException()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">pool.apply(raiser)</span>
        <span class="s0">except </span><span class="s1">ExpectedException:</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.fail(</span><span class="s3">&quot;Should have raised ExpectedException&quot;</span><span class="s1">)</span>
    <span class="s4"># Don't let the metaclass automatically force any error</span>
    <span class="s4"># that reaches the hub from a spawned greenlet to become</span>
    <span class="s4"># fatal; that defeats the point of the test.</span>
    <span class="s1">test_apply_raises.error_fatal = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">test_multiple_coros(self):</span>
        <span class="s1">evt = Event()</span>
        <span class="s1">results = []</span>

        <span class="s0">def </span><span class="s1">producer():</span>
            <span class="s1">gevent.sleep(</span><span class="s2">0.001</span><span class="s1">)</span>
            <span class="s1">results.append(</span><span class="s3">'prod'</span><span class="s1">)</span>
            <span class="s1">evt.set()</span>

        <span class="s0">def </span><span class="s1">consumer():</span>
            <span class="s1">results.append(</span><span class="s3">'cons1'</span><span class="s1">)</span>
            <span class="s1">evt.wait()</span>
            <span class="s1">results.append(</span><span class="s3">'cons2'</span><span class="s1">)</span>

        <span class="s1">pool = self.klass(</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">done = pool.spawn(consumer)</span>
        <span class="s1">pool.apply_async(producer)</span>
        <span class="s1">done.get()</span>
        <span class="s1">self.assertEqual([</span><span class="s3">'cons1'</span><span class="s0">, </span><span class="s3">'prod'</span><span class="s0">, </span><span class="s3">'cons2'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">results)</span>

    <span class="s0">def </span><span class="s1">dont_test_timer_cancel(self):</span>
        <span class="s1">timer_fired = []</span>

        <span class="s0">def </span><span class="s1">fire_timer():</span>
            <span class="s1">timer_fired.append(</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">some_work():</span>
            <span class="s1">gevent.timer(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">fire_timer) </span><span class="s4"># pylint:disable=no-member</span>

        <span class="s1">pool = self.klass(</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">pool.apply(some_work)</span>
        <span class="s1">gevent.sleep(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(timer_fired</span><span class="s0">, </span><span class="s1">[])</span>

    <span class="s0">def </span><span class="s1">test_reentrant(self):</span>
        <span class="s1">pool = self.klass(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">result = pool.apply(pool.apply</span><span class="s0">, </span><span class="s1">(</span><span class="s0">lambda </span><span class="s1">a: a + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">)))</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">evt = Event()</span>
        <span class="s1">pool.apply_async(evt.set)</span>
        <span class="s1">evt.wait()</span>

    <span class="s1">@greentest.skipOnPyPy(</span><span class="s3">&quot;Does not work on PyPy&quot;</span><span class="s1">) </span><span class="s4"># Why?</span>
    <span class="s0">def </span><span class="s1">test_stderr_raising(self):</span>
        <span class="s4"># testing that really egregious errors in the error handling code</span>
        <span class="s4"># (that prints tracebacks to stderr) don't cause the pool to lose</span>
        <span class="s4"># any members</span>
        <span class="s0">import </span><span class="s1">sys</span>
        <span class="s1">pool = self.klass(size=</span><span class="s2">1</span><span class="s1">)</span>

        <span class="s4"># we're going to do this by causing the traceback.print_exc in</span>
        <span class="s4"># safe_apply to raise an exception and thus exit _main_loop</span>
        <span class="s1">normal_err = sys.stderr</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">sys.stderr = FakeFile()</span>
            <span class="s1">waiter = pool.spawn(crash)</span>
            <span class="s0">with </span><span class="s1">gevent.Timeout(</span><span class="s2">2</span><span class="s1">):</span>
                <span class="s1">self.assertRaises(RuntimeError</span><span class="s0">, </span><span class="s1">waiter.get)</span>
            <span class="s4"># the pool should have something free at this point since the</span>
            <span class="s4"># waiter returned</span>
            <span class="s4"># pool.Pool change: if an exception is raised during execution of a link,</span>
            <span class="s4"># the rest of the links are scheduled to be executed on the next hub iteration</span>
            <span class="s4"># this introduces a delay in updating pool.sem which makes pool.free_count() report 0</span>
            <span class="s4"># therefore, sleep:</span>
            <span class="s1">gevent.sleep(</span><span class="s2">0</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(pool.free_count()</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s4"># shouldn't block when trying to get</span>
            <span class="s0">with </span><span class="s1">gevent.Timeout.start_new(</span><span class="s2">0.1</span><span class="s1">):</span>
                <span class="s1">pool.apply(gevent.sleep</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">))</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">sys.stderr = normal_err</span>
            <span class="s1">pool.join()</span>


<span class="s0">def </span><span class="s1">crash(*_args</span><span class="s0">, </span><span class="s1">**_kw):</span>
    <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Whoa&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">FakeFile(object):</span>

    <span class="s0">def </span><span class="s1">write(self</span><span class="s0">, </span><span class="s1">*_args):</span>
        <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s3">'Whaaa'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">PoolBasicTests(greentest.TestCase):</span>
    <span class="s1">klass = gevent.pool.Pool</span>

    <span class="s0">def </span><span class="s1">test_execute_async(self):</span>
        <span class="s1">p = self.klass(size=</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(p.free_count()</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">r = []</span>

        <span class="s1">first = p.spawn(r.append</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(p.free_count()</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">first.get()</span>
        <span class="s1">self.assertEqual(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">gevent.sleep(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(p.free_count()</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

        <span class="s4">#Once the pool is exhausted, calling an execute forces a yield.</span>

        <span class="s1">p.apply_async(r.append</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s1">))</span>
        <span class="s1">self.assertEqual(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">p.free_count())</span>
        <span class="s1">self.assertEqual(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">p.apply_async(r.append</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s1">))</span>
        <span class="s1">self.assertEqual(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">p.free_count())</span>
        <span class="s1">self.assertEqual(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>

        <span class="s1">p.apply_async(r.append</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s1">))</span>
        <span class="s1">self.assertEqual(r</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">gevent.sleep(</span><span class="s2">0.01</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(sorted(r)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_discard(self):</span>
        <span class="s1">p = self.klass(size=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">first = p.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">)</span>
        <span class="s1">p.discard(first)</span>
        <span class="s1">first.kill()</span>
        <span class="s1">self.assertFalse(first)</span>
        <span class="s1">self.assertEqual(len(p)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(p._semaphore.counter</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_add_method(self):</span>
        <span class="s1">p = self.klass(size=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">first = gevent.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">second = gevent.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self.assertEqual(p.free_count()</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
                <span class="s1">self.assertEqual(len(p)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
                <span class="s1">p.add(first)</span>
                <span class="s1">self.assertEqual(p.free_count()</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
                <span class="s1">self.assertEqual(len(p)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

                <span class="s0">with </span><span class="s1">self.assertRaises(gevent.Timeout):</span>
                    <span class="s0">with </span><span class="s1">gevent.Timeout(</span><span class="s2">0.1</span><span class="s1">):</span>
                        <span class="s1">p.add(second)</span>

                <span class="s1">self.assertEqual(p.free_count()</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
                <span class="s1">self.assertEqual(len(p)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s1">second.kill()</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">first.kill()</span>

    <span class="s1">@greentest.ignores_leakcheck</span>
    <span class="s0">def </span><span class="s1">test_add_method_non_blocking(self):</span>
        <span class="s1">p = self.klass(size=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">first = gevent.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">second = gevent.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">p.add(first)</span>
                <span class="s0">with </span><span class="s1">self.assertRaises(gevent.pool.PoolFull):</span>
                    <span class="s1">p.add(second</span><span class="s0">, </span><span class="s1">blocking=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s1">second.kill()</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">first.kill()</span>

    <span class="s1">@greentest.ignores_leakcheck</span>
    <span class="s0">def </span><span class="s1">test_add_method_timeout(self):</span>
        <span class="s1">p = self.klass(size=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">first = gevent.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">second = gevent.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">p.add(first)</span>
                <span class="s0">with </span><span class="s1">self.assertRaises(gevent.pool.PoolFull):</span>
                    <span class="s1">p.add(second</span><span class="s0">, </span><span class="s1">timeout=</span><span class="s2">0.100</span><span class="s1">)</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s1">second.kill()</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">first.kill()</span>

    <span class="s1">@greentest.ignores_leakcheck</span>
    <span class="s0">def </span><span class="s1">test_start_method_timeout(self):</span>
        <span class="s1">p = self.klass(size=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">first = gevent.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">second = gevent.Greenlet(gevent.sleep</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">p.add(first)</span>
                <span class="s0">with </span><span class="s1">self.assertRaises(gevent.pool.PoolFull):</span>
                    <span class="s1">p.start(second</span><span class="s0">, </span><span class="s1">timeout=</span><span class="s2">0.100</span><span class="s1">)</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s1">second.kill()</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">first.kill()</span>

    <span class="s0">def </span><span class="s1">test_apply(self):</span>
        <span class="s1">p = self.klass()</span>
        <span class="s1">result = p.apply(</span><span class="s0">lambda </span><span class="s1">a: (</span><span class="s3">'foo'</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">))</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s1">(</span><span class="s3">'foo'</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_init_error(self):</span>
        <span class="s1">self.switch_expected = </span><span class="s0">False</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s0">, </span><span class="s1">self.klass</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span>

<span class="s4">#</span>
<span class="s4"># tests from standard library test/test_multiprocessing.py</span>


<span class="s0">class </span><span class="s1">TimingWrapper(object):</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">func):</span>
        <span class="s1">self.func = func</span>
        <span class="s1">self.elapsed = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwds):</span>
        <span class="s1">t = time()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.func(*args</span><span class="s0">, </span><span class="s1">**kwds)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">self.elapsed = time() - t</span>


<span class="s0">def </span><span class="s1">sqr(x</span><span class="s0">, </span><span class="s1">wait=</span><span class="s2">0.0</span><span class="s1">):</span>
    <span class="s1">gevent.sleep(wait)</span>
    <span class="s0">return </span><span class="s1">x * x</span>


<span class="s0">def </span><span class="s1">squared(x):</span>
    <span class="s0">return </span><span class="s1">x * x</span>


<span class="s0">def </span><span class="s1">sqr_random_sleep(x):</span>
    <span class="s1">gevent.sleep(random.random() * </span><span class="s2">0.1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">x * x</span>


<span class="s0">def </span><span class="s1">final_sleep():</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">):</span>
        <span class="s0">yield </span><span class="s1">i</span>
    <span class="s1">gevent.sleep(</span><span class="s2">0.2</span><span class="s1">)</span>


<span class="s1">TIMEOUT1</span><span class="s0">, </span><span class="s1">TIMEOUT2</span><span class="s0">, </span><span class="s1">TIMEOUT3 = </span><span class="s2">0.082</span><span class="s0">, </span><span class="s2">0.035</span><span class="s0">, </span><span class="s2">0.14</span>


<span class="s1">SMALL_RANGE = </span><span class="s2">10</span>
<span class="s1">LARGE_RANGE = </span><span class="s2">1000</span>

<span class="s0">if </span><span class="s1">(greentest.PYPY </span><span class="s0">and </span><span class="s1">greentest.WIN) </span><span class="s0">or </span><span class="s1">greentest.RUN_LEAKCHECKS </span><span class="s0">or </span><span class="s1">greentest.RUN_COVERAGE:</span>
    <span class="s4"># See comments in test__threadpool.py.</span>
    <span class="s1">LARGE_RANGE = </span><span class="s2">25</span>
<span class="s0">elif </span><span class="s1">greentest.RUNNING_ON_CI </span><span class="s0">or </span><span class="s1">greentest.EXPECT_POOR_TIMER_RESOLUTION:</span>
    <span class="s1">LARGE_RANGE = </span><span class="s2">100</span>

<span class="s0">class </span><span class="s1">TestPool(greentest.TestCase): </span><span class="s4"># pylint:disable=too-many-public-methods</span>
    <span class="s1">__timeout__ = greentest.LARGE_TIMEOUT</span>
    <span class="s1">size = </span><span class="s2">1</span>

    <span class="s0">def </span><span class="s1">setUp(self):</span>
        <span class="s1">greentest.TestCase.setUp(self)</span>
        <span class="s1">self.pool = gevent.pool.Pool(self.size)</span>

    <span class="s0">def </span><span class="s1">cleanup(self):</span>
        <span class="s1">self.pool.join()</span>

    <span class="s0">def </span><span class="s1">test_apply(self):</span>
        <span class="s1">papply = self.pool.apply</span>
        <span class="s1">self.assertEqual(papply(sqr</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">,</span><span class="s1">))</span><span class="s0">, </span><span class="s2">25</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(papply(sqr</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">{</span><span class="s3">'x'</span><span class="s1">: </span><span class="s2">3</span><span class="s1">})</span><span class="s0">, </span><span class="s2">9</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_map(self):</span>
        <span class="s1">pmap = self.pool.map</span>
        <span class="s1">self.assertEqual(pmap(sqr</span><span class="s0">, </span><span class="s1">range(SMALL_RANGE))</span><span class="s0">, </span><span class="s1">list(map(squared</span><span class="s0">, </span><span class="s1">range(SMALL_RANGE))))</span>
        <span class="s1">self.assertEqual(pmap(sqr</span><span class="s0">, </span><span class="s1">range(</span><span class="s2">100</span><span class="s1">))</span><span class="s0">, </span><span class="s1">list(map(squared</span><span class="s0">, </span><span class="s1">range(</span><span class="s2">100</span><span class="s1">))))</span>

    <span class="s0">def </span><span class="s1">test_async(self):</span>
        <span class="s1">res = self.pool.apply_async(sqr</span><span class="s0">, </span><span class="s1">(</span><span class="s2">7</span><span class="s0">, </span><span class="s1">TIMEOUT1</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">get = TimingWrapper(res.get)</span>
        <span class="s1">self.assertEqual(get()</span><span class="s0">, </span><span class="s2">49</span><span class="s1">)</span>
        <span class="s1">self.assertTimeoutAlmostEqual(get.elapsed</span><span class="s0">, </span><span class="s1">TIMEOUT1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_async_callback(self):</span>
        <span class="s1">result = []</span>
        <span class="s1">res = self.pool.apply_async(sqr</span><span class="s0">, </span><span class="s1">(</span><span class="s2">7</span><span class="s0">, </span><span class="s1">TIMEOUT1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">callback=result.append)</span>
        <span class="s1">get = TimingWrapper(res.get)</span>
        <span class="s1">self.assertEqual(get()</span><span class="s0">, </span><span class="s2">49</span><span class="s1">)</span>
        <span class="s1">self.assertTimeoutAlmostEqual(get.elapsed</span><span class="s0">, </span><span class="s1">TIMEOUT1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">gevent.sleep(</span><span class="s2">0</span><span class="s1">)  </span><span class="s4"># lets the callback run</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s1">[</span><span class="s2">49</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_async_timeout(self):</span>
        <span class="s1">res = self.pool.apply_async(sqr</span><span class="s0">, </span><span class="s1">(</span><span class="s2">6</span><span class="s0">, </span><span class="s1">TIMEOUT2 + </span><span class="s2">0.2</span><span class="s1">))</span>
        <span class="s1">get = TimingWrapper(res.get)</span>
        <span class="s1">self.assertRaises(gevent.Timeout</span><span class="s0">, </span><span class="s1">get</span><span class="s0">, </span><span class="s1">timeout=TIMEOUT2)</span>
        <span class="s1">self.assertTimeoutAlmostEqual(get.elapsed</span><span class="s0">, </span><span class="s1">TIMEOUT2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">self.pool.join()</span>

    <span class="s0">def </span><span class="s1">test_imap_list_small(self):</span>
        <span class="s1">it = self.pool.imap(sqr</span><span class="s0">, </span><span class="s1">range(SMALL_RANGE))</span>
        <span class="s1">self.assertEqual(list(it)</span><span class="s0">, </span><span class="s1">list(map(sqr</span><span class="s0">, </span><span class="s1">range(SMALL_RANGE))))</span>

    <span class="s0">def </span><span class="s1">test_imap_it_small(self):</span>
        <span class="s1">it = self.pool.imap(sqr</span><span class="s0">, </span><span class="s1">range(SMALL_RANGE))</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(SMALL_RANGE):</span>
            <span class="s1">self.assertEqual(next(it)</span><span class="s0">, </span><span class="s1">i * i)</span>
        <span class="s1">self.assertRaises(StopIteration</span><span class="s0">, </span><span class="s1">next</span><span class="s0">, </span><span class="s1">it)</span>

    <span class="s0">def </span><span class="s1">test_imap_it_large(self):</span>
        <span class="s1">it = self.pool.imap(sqr</span><span class="s0">, </span><span class="s1">range(LARGE_RANGE))</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(LARGE_RANGE):</span>
            <span class="s1">self.assertEqual(next(it)</span><span class="s0">, </span><span class="s1">i * i)</span>
        <span class="s1">self.assertRaises(StopIteration</span><span class="s0">, </span><span class="s1">next</span><span class="s0">, </span><span class="s1">it)</span>

    <span class="s0">def </span><span class="s1">test_imap_random(self):</span>
        <span class="s1">it = self.pool.imap(sqr_random_sleep</span><span class="s0">, </span><span class="s1">range(SMALL_RANGE))</span>
        <span class="s1">self.assertEqual(list(it)</span><span class="s0">, </span><span class="s1">list(map(squared</span><span class="s0">, </span><span class="s1">range(SMALL_RANGE))))</span>

    <span class="s0">def </span><span class="s1">test_imap_unordered(self):</span>
        <span class="s1">it = self.pool.imap_unordered(sqr</span><span class="s0">, </span><span class="s1">range(LARGE_RANGE))</span>
        <span class="s1">self.assertEqual(sorted(it)</span><span class="s0">, </span><span class="s1">list(map(squared</span><span class="s0">, </span><span class="s1">range(LARGE_RANGE))))</span>

        <span class="s1">it = self.pool.imap_unordered(sqr</span><span class="s0">, </span><span class="s1">range(LARGE_RANGE))</span>
        <span class="s1">self.assertEqual(sorted(it)</span><span class="s0">, </span><span class="s1">list(map(squared</span><span class="s0">, </span><span class="s1">range(LARGE_RANGE))))</span>

    <span class="s0">def </span><span class="s1">test_imap_unordered_random(self):</span>
        <span class="s1">it = self.pool.imap_unordered(sqr_random_sleep</span><span class="s0">, </span><span class="s1">range(SMALL_RANGE))</span>
        <span class="s1">self.assertEqual(sorted(it)</span><span class="s0">, </span><span class="s1">list(map(squared</span><span class="s0">, </span><span class="s1">range(SMALL_RANGE))))</span>

    <span class="s0">def </span><span class="s1">test_empty_imap_unordered(self):</span>
        <span class="s1">it = self.pool.imap_unordered(sqr</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">self.assertEqual(list(it)</span><span class="s0">, </span><span class="s1">[])</span>

    <span class="s0">def </span><span class="s1">test_empty_imap(self):</span>
        <span class="s1">it = self.pool.imap(sqr</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">self.assertEqual(list(it)</span><span class="s0">, </span><span class="s1">[])</span>

    <span class="s0">def </span><span class="s1">test_empty_map(self):</span>
        <span class="s1">self.assertEqual(self.pool.map(sqr</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">, </span><span class="s1">[])</span>

    <span class="s0">def </span><span class="s1">test_terminate(self):</span>
        <span class="s1">result = self.pool.map_async(gevent.sleep</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s1">] * ((self.size </span><span class="s0">or </span><span class="s2">10</span><span class="s1">) * </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">gevent.sleep(</span><span class="s2">0.1</span><span class="s1">)</span>
        <span class="s1">kill = TimingWrapper(self.pool.kill)</span>
        <span class="s1">kill()</span>
        <span class="s1">self.assertTimeWithinRange(kill.elapsed</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)</span>
        <span class="s1">result.join()</span>

    <span class="s0">def </span><span class="s1">sleep(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">gevent.sleep(float(x) / </span><span class="s2">10.</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">str(x)</span>

    <span class="s0">def </span><span class="s1">test_imap_unordered_sleep(self):</span>
        <span class="s4"># testing that imap_unordered returns items in competion order</span>
        <span class="s1">result = list(self.pool.imap_unordered(self.sleep</span><span class="s0">, </span><span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]))</span>
        <span class="s0">if </span><span class="s1">self.pool.size == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s1">expected = [</span><span class="s3">'10'</span><span class="s0">, </span><span class="s3">'1'</span><span class="s0">, </span><span class="s3">'2'</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = [</span><span class="s3">'1'</span><span class="s0">, </span><span class="s3">'2'</span><span class="s0">, </span><span class="s3">'10'</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s4"># https://github.com/gevent/gevent/issues/423</span>
    <span class="s0">def </span><span class="s1">test_imap_no_stop(self):</span>
        <span class="s1">q = Queue()</span>
        <span class="s1">q.put(</span><span class="s2">123</span><span class="s1">)</span>
        <span class="s1">gevent.spawn_later(</span><span class="s2">0.1</span><span class="s0">, </span><span class="s1">q.put</span><span class="s0">, </span><span class="s1">StopIteration)</span>
        <span class="s1">result = list(self.pool.imap(</span><span class="s0">lambda </span><span class="s1">_: _</span><span class="s0">, </span><span class="s1">q))</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s1">[</span><span class="s2">123</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_imap_unordered_no_stop(self):</span>
        <span class="s1">q = Queue()</span>
        <span class="s1">q.put(</span><span class="s2">1234</span><span class="s1">)</span>
        <span class="s1">gevent.spawn_later(</span><span class="s2">0.1</span><span class="s0">, </span><span class="s1">q.put</span><span class="s0">, </span><span class="s1">StopIteration)</span>
        <span class="s1">result = list(self.pool.imap_unordered(</span><span class="s0">lambda </span><span class="s1">_: _</span><span class="s0">, </span><span class="s1">q))</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1234</span><span class="s1">])</span>

    <span class="s4"># same issue, but different test: https://github.com/gevent/gevent/issues/311</span>
    <span class="s0">def </span><span class="s1">test_imap_final_sleep(self):</span>
        <span class="s1">result = list(self.pool.imap(sqr</span><span class="s0">, </span><span class="s1">final_sleep()))</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_imap_unordered_final_sleep(self):</span>
        <span class="s1">result = list(self.pool.imap_unordered(sqr</span><span class="s0">, </span><span class="s1">final_sleep()))</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>

    <span class="s4"># Issue 638</span>
    <span class="s0">def </span><span class="s1">test_imap_unordered_bounded_queue(self):</span>
        <span class="s1">iterable = list(range(</span><span class="s2">100</span><span class="s1">))</span>

        <span class="s1">running = [</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s0">def </span><span class="s1">short_running_func(i</span><span class="s0">, </span><span class="s1">_j):</span>
            <span class="s1">running[</span><span class="s2">0</span><span class="s1">] += </span><span class="s2">1</span>
            <span class="s0">return </span><span class="s1">i</span>

        <span class="s0">def </span><span class="s1">make_reader(mapping):</span>
            <span class="s4"># Simulate a long running reader. No matter how many workers</span>
            <span class="s4"># we have, we will never have a queue more than size 1</span>
            <span class="s0">def </span><span class="s1">reader():</span>
                <span class="s1">result = []</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">enumerate(mapping):</span>
                    <span class="s1">self.assertTrue(running[</span><span class="s2">0</span><span class="s1">] &lt;= i + </span><span class="s2">2</span><span class="s0">, </span><span class="s1">running[</span><span class="s2">0</span><span class="s1">])</span>
                    <span class="s1">result.append(x)</span>
                    <span class="s1">gevent.sleep(</span><span class="s2">0.01</span><span class="s1">)</span>
                    <span class="s1">self.assertTrue(len(mapping.queue) &lt;= </span><span class="s2">2</span><span class="s0">, </span><span class="s1">len(mapping.queue))</span>
                <span class="s0">return </span><span class="s1">result</span>
            <span class="s0">return </span><span class="s1">reader</span>

        <span class="s4"># Send two iterables to make sure varargs and kwargs are handled</span>
        <span class="s4"># correctly</span>
        <span class="s0">for </span><span class="s1">meth </span><span class="s0">in </span><span class="s1">self.pool.imap_unordered</span><span class="s0">, </span><span class="s1">self.pool.imap:</span>
            <span class="s1">running[</span><span class="s2">0</span><span class="s1">] = </span><span class="s2">0</span>
            <span class="s1">mapping = meth(short_running_func</span><span class="s0">, </span><span class="s1">iterable</span><span class="s0">, </span><span class="s1">iterable</span><span class="s0">,</span>
                           <span class="s1">maxsize=</span><span class="s2">1</span><span class="s1">)</span>

            <span class="s1">reader = make_reader(mapping)</span>
            <span class="s1">l = reader()</span>
            <span class="s1">self.assertEqual(sorted(l)</span><span class="s0">, </span><span class="s1">iterable)</span>

<span class="s1">@greentest.ignores_leakcheck</span>
<span class="s0">class </span><span class="s1">TestPool2(TestPool):</span>
    <span class="s1">size = </span><span class="s2">2</span>

<span class="s1">@greentest.ignores_leakcheck</span>
<span class="s0">class </span><span class="s1">TestPool3(TestPool):</span>
    <span class="s1">size = </span><span class="s2">3</span>

<span class="s1">@greentest.ignores_leakcheck</span>
<span class="s0">class </span><span class="s1">TestPool10(TestPool):</span>
    <span class="s1">size = </span><span class="s2">10</span>


<span class="s0">class </span><span class="s1">TestPoolUnlimit(TestPool):</span>
    <span class="s1">size = </span><span class="s0">None</span>


<span class="s0">class </span><span class="s1">TestPool0(greentest.TestCase):</span>
    <span class="s1">size = </span><span class="s2">0</span>

    <span class="s0">def </span><span class="s1">test_wait_full(self):</span>
        <span class="s1">p = gevent.pool.Pool(size=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">p.free_count())</span>
        <span class="s1">self.assertTrue(p.full())</span>
        <span class="s1">self.assertEqual(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">p.wait_available(timeout=</span><span class="s2">0.01</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestJoinSleep(gevent.testing.timing.AbstractGenericWaitTestCase):</span>

    <span class="s0">def </span><span class="s1">wait(self</span><span class="s0">, </span><span class="s1">timeout):</span>
        <span class="s1">p = gevent.pool.Pool()</span>
        <span class="s1">g = p.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">p.join(timeout=timeout)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">g.kill()</span>


<span class="s0">class </span><span class="s1">TestJoinSleep_raise_error(gevent.testing.timing.AbstractGenericWaitTestCase):</span>

    <span class="s0">def </span><span class="s1">wait(self</span><span class="s0">, </span><span class="s1">timeout):</span>
        <span class="s1">p = gevent.pool.Pool()</span>
        <span class="s1">g = p.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">p.join(timeout=timeout</span><span class="s0">, </span><span class="s1">raise_error=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">g.kill()</span>


<span class="s0">class </span><span class="s1">TestJoinEmpty(greentest.TestCase):</span>
    <span class="s1">switch_expected = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">test(self):</span>
        <span class="s1">p = gevent.pool.Pool()</span>
        <span class="s1">res = p.join()</span>
        <span class="s1">self.assertTrue(res</span><span class="s0">, </span><span class="s3">&quot;empty should return true&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestSpawn(greentest.TestCase):</span>
    <span class="s1">switch_expected = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">test(self):</span>
        <span class="s1">p = gevent.pool.Pool(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(p)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">p.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">0.1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(p)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">p.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">0.1</span><span class="s1">)  </span><span class="s4"># this spawn blocks until the old one finishes</span>
        <span class="s1">self.assertEqual(len(p)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">gevent.sleep(</span><span class="s2">0.19 </span><span class="s0">if not </span><span class="s1">greentest.EXPECT_POOR_TIMER_RESOLUTION </span><span class="s0">else </span><span class="s2">0.5</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(p)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">testSpawnAndWait(self):</span>
        <span class="s1">p = gevent.pool.Pool(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(p)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">p.spawn(gevent.sleep</span><span class="s0">, </span><span class="s2">0.1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(p)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">res = p.join(</span><span class="s2">0.01</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(res</span><span class="s0">, </span><span class="s3">&quot;waiting on a full pool should return false&quot;</span><span class="s1">)</span>
        <span class="s1">res = p.join()</span>
        <span class="s1">self.assertTrue(res</span><span class="s0">, </span><span class="s3">&quot;waiting to finish should be true&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(p)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

<span class="s0">def </span><span class="s1">error_iter():</span>
    <span class="s0">yield </span><span class="s2">1</span>
    <span class="s0">yield </span><span class="s2">2</span>
    <span class="s0">raise </span><span class="s1">ExpectedException</span>


<span class="s0">class </span><span class="s1">TestErrorInIterator(greentest.TestCase):</span>
    <span class="s1">error_fatal = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">test(self):</span>
        <span class="s1">p = gevent.pool.Pool(</span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(ExpectedException</span><span class="s0">, </span><span class="s1">p.map</span><span class="s0">, lambda </span><span class="s1">x: </span><span class="s0">None, </span><span class="s1">error_iter())</span>
        <span class="s1">gevent.sleep(</span><span class="s2">0.001</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_unordered(self):</span>
        <span class="s1">p = gevent.pool.Pool(</span><span class="s2">3</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">unordered():</span>
            <span class="s0">return </span><span class="s1">list(p.imap_unordered(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s0">None, </span><span class="s1">error_iter()))</span>

        <span class="s1">self.assertRaises(ExpectedException</span><span class="s0">, </span><span class="s1">unordered)</span>
        <span class="s1">gevent.sleep(</span><span class="s2">0.001</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">divide_by(x):</span>
    <span class="s0">return </span><span class="s2">1.0 </span><span class="s1">/ x</span>


<span class="s0">class </span><span class="s1">TestErrorInHandler(greentest.TestCase):</span>
    <span class="s1">error_fatal = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">test_map(self):</span>
        <span class="s1">p = gevent.pool.Pool(</span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(ZeroDivisionError</span><span class="s0">, </span><span class="s1">p.map</span><span class="s0">, </span><span class="s1">divide_by</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_imap(self):</span>
        <span class="s1">p = gevent.pool.Pool(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">it = p.imap(divide_by</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(next(it)</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(ZeroDivisionError</span><span class="s0">, </span><span class="s1">next</span><span class="s0">, </span><span class="s1">it)</span>
        <span class="s1">self.assertEqual(next(it)</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(StopIteration</span><span class="s0">, </span><span class="s1">next</span><span class="s0">, </span><span class="s1">it)</span>

    <span class="s0">def </span><span class="s1">test_imap_unordered(self):</span>
        <span class="s1">p = gevent.pool.Pool(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">it = p.imap_unordered(divide_by</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(next(it)</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(ZeroDivisionError</span><span class="s0">, </span><span class="s1">next</span><span class="s0">, </span><span class="s1">it)</span>
        <span class="s1">self.assertEqual(next(it)</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(StopIteration</span><span class="s0">, </span><span class="s1">next</span><span class="s0">, </span><span class="s1">it)</span>


<span class="s0">if </span><span class="s1">__name__ == </span><span class="s3">'__main__'</span><span class="s1">:</span>
    <span class="s1">greentest.main()</span>
</pre>
</body>
</html>