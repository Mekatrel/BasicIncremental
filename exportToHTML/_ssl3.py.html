<html>
<head>
<title>_ssl3.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_ssl3.py</font>
</center></td></tr></table>
<pre><span class="s0"># Wrapper module for _ssl. Written by Bill Janssen.</span>
<span class="s0"># Ported to gevent by Denis Bilenko.</span>
<span class="s2">&quot;&quot;&quot;SSL wrapper for socket objects on Python 3. 
 
For the documentation, refer to :mod:`ssl` module manual. 
 
This module implements cooperative SSL socket wrappers. 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">absolute_import</span>
<span class="s3">import </span><span class="s1">ssl </span><span class="s3">as </span><span class="s1">__ssl__</span>

<span class="s1">_ssl = __ssl__._ssl</span>

<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">import </span><span class="s1">sys</span>

<span class="s3">from </span><span class="s1">gevent.socket </span><span class="s3">import </span><span class="s1">socket</span><span class="s3">, </span><span class="s1">timeout_default</span>
<span class="s3">from </span><span class="s1">gevent.socket </span><span class="s3">import </span><span class="s1">error </span><span class="s3">as </span><span class="s1">socket_error</span>
<span class="s3">from </span><span class="s1">gevent.socket </span><span class="s3">import </span><span class="s1">timeout </span><span class="s3">as </span><span class="s1">_socket_timeout</span>
<span class="s3">from </span><span class="s1">gevent._util </span><span class="s3">import </span><span class="s1">copy_globals</span>
<span class="s3">from </span><span class="s1">gevent._compat </span><span class="s3">import </span><span class="s1">PY36</span>

<span class="s3">from </span><span class="s1">weakref </span><span class="s3">import </span><span class="s1">ref </span><span class="s3">as </span><span class="s1">_wref</span>

<span class="s1">__implements__ = [</span>
    <span class="s4">'SSLContext'</span><span class="s3">,</span>
    <span class="s4">'SSLSocket'</span><span class="s3">,</span>
    <span class="s4">'wrap_socket'</span><span class="s3">,</span>
    <span class="s4">'get_server_certificate'</span><span class="s3">,</span>
<span class="s1">]</span>

<span class="s0"># Manually import things we use so we get better linting.</span>
<span class="s0"># Also, in the past (adding 3.9 support) it turned out we were</span>
<span class="s0"># relying on certain global variables being defined in the ssl module</span>
<span class="s0"># that weren't required to be there, e.g., AF_INET, which should be imported</span>
<span class="s0"># from socket</span>
<span class="s3">from </span><span class="s1">socket </span><span class="s3">import </span><span class="s1">AF_INET</span>
<span class="s3">from </span><span class="s1">socket </span><span class="s3">import </span><span class="s1">SOCK_STREAM</span>
<span class="s3">from </span><span class="s1">socket </span><span class="s3">import </span><span class="s1">SO_TYPE</span>
<span class="s3">from </span><span class="s1">socket </span><span class="s3">import </span><span class="s1">SOL_SOCKET</span>

<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">SSLWantReadError</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">SSLWantWriteError</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">SSLEOFError</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">CERT_NONE</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">SSLError</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">SSL_ERROR_EOF</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">SSL_ERROR_WANT_READ</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">SSL_ERROR_WANT_WRITE</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">PROTOCOL_SSLv23</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">SSLObject</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">match_hostname</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">CHANNEL_BINDING_TYPES</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">CERT_REQUIRED</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">DER_cert_to_PEM_cert</span>
<span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">create_connection</span>

<span class="s0"># Import all symbols from Python's ssl.py, except those that we are implementing</span>
<span class="s0"># and &quot;private&quot; symbols.</span>
<span class="s1">__imports__ = copy_globals(</span>
    <span class="s1">__ssl__</span><span class="s3">, </span><span class="s1">globals()</span><span class="s3">,</span>
    <span class="s0"># SSLSocket *must* subclass gevent.socket.socket; see issue 597</span>
    <span class="s1">names_to_ignore=__implements__ + [</span><span class="s4">'socket'</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">dunder_names_to_keep=())</span>

<span class="s1">__all__ = __implements__ + __imports__</span>
<span class="s3">if </span><span class="s4">'namedtuple' </span><span class="s3">in </span><span class="s1">__all__:</span>
    <span class="s1">__all__.remove(</span><span class="s4">'namedtuple'</span><span class="s1">)</span>

<span class="s1">orig_SSLContext = __ssl__.SSLContext </span><span class="s0"># pylint:disable=no-member</span>

<span class="s0"># We have to pass the raw stdlib socket to SSLContext.wrap_socket.</span>
<span class="s0"># That method in turn can pass that object on to things like SNI callbacks.</span>
<span class="s0"># It wouldn't have access to any of the attributes on the SSLSocket, like</span>
<span class="s0"># context, that it's supposed to (see test_ssl.test_sni_callback). Previously</span>
<span class="s0"># we just delegated to the sslsocket with __getattr__, but 3.8</span>
<span class="s0"># added some new callbacks and a test that the object they get is an instance</span>
<span class="s0"># of the high-level SSLSocket class, so that doesn't work anymore. Instead,</span>
<span class="s0"># we wrap the callback and get the real socket to pass on.</span>
<span class="s3">class </span><span class="s1">_contextawaresock(socket._gevent_sock_class):</span>
    <span class="s1">__slots__ = (</span><span class="s4">'_sslsock'</span><span class="s3">,</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">family</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">proto</span><span class="s3">, </span><span class="s1">fileno</span><span class="s3">, </span><span class="s1">sslsocket_wref):</span>
        <span class="s1">super().__init__(family</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">proto</span><span class="s3">, </span><span class="s1">fileno)</span>
        <span class="s1">self._sslsock = sslsocket_wref</span>

<span class="s3">class </span><span class="s1">_Callback(object):</span>

    <span class="s1">__slots__ = (</span><span class="s4">'user_function'</span><span class="s3">,</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">user_function):</span>
        <span class="s1">self.user_function = user_function</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s1">conn = conn._sslsock()</span>
        <span class="s3">return </span><span class="s1">self.user_function(conn</span><span class="s3">, </span><span class="s1">*args)</span>

<span class="s3">class </span><span class="s1">SSLContext(orig_SSLContext):</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s0"># Added in Python 3.7</span>
    <span class="s1">sslsocket_class = </span><span class="s3">None </span><span class="s0"># SSLSocket is assigned later</span>

    <span class="s3">def </span><span class="s1">wrap_socket(self</span><span class="s3">, </span><span class="s1">sock</span><span class="s3">, </span><span class="s1">server_side=</span><span class="s3">False,</span>
                    <span class="s1">do_handshake_on_connect=</span><span class="s3">True,</span>
                    <span class="s1">suppress_ragged_eofs=</span><span class="s3">True,</span>
                    <span class="s1">server_hostname=</span><span class="s3">None,</span>
                    <span class="s1">session=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># pylint:disable=arguments-differ,not-callable</span>
        <span class="s0"># (3.6 adds session)</span>
        <span class="s0"># Sadly, using *args and **kwargs doesn't work</span>
        <span class="s3">return </span><span class="s1">self.sslsocket_class(</span>
            <span class="s1">sock=sock</span><span class="s3">, </span><span class="s1">server_side=server_side</span><span class="s3">,</span>
            <span class="s1">do_handshake_on_connect=do_handshake_on_connect</span><span class="s3">,</span>
            <span class="s1">suppress_ragged_eofs=suppress_ragged_eofs</span><span class="s3">,</span>
            <span class="s1">server_hostname=server_hostname</span><span class="s3">,</span>
            <span class="s1">_context=self</span><span class="s3">,</span>
            <span class="s1">_session=session)</span>

    <span class="s3">if </span><span class="s1">hasattr(orig_SSLContext.options</span><span class="s3">, </span><span class="s4">'setter'</span><span class="s1">):</span>
        <span class="s0"># In 3.6, these became properties. They want to access the</span>
        <span class="s0"># property __set__ method in the superclass, and they do so by using</span>
        <span class="s0"># super(SSLContext, SSLContext). But we rebind SSLContext when we monkey</span>
        <span class="s0"># patch, which causes infinite recursion.</span>
        <span class="s0"># https://github.com/python/cpython/commit/328067c468f82e4ec1b5c510a4e84509e010f296</span>
        <span class="s0"># pylint:disable=no-member</span>
        <span class="s1">@orig_SSLContext.options.setter</span>
        <span class="s3">def </span><span class="s1">options(self</span><span class="s3">, </span><span class="s1">value):</span>
            <span class="s1">super(orig_SSLContext</span><span class="s3">, </span><span class="s1">orig_SSLContext).options.__set__(self</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s1">@orig_SSLContext.verify_flags.setter</span>
        <span class="s3">def </span><span class="s1">verify_flags(self</span><span class="s3">, </span><span class="s1">value):</span>
            <span class="s1">super(orig_SSLContext</span><span class="s3">, </span><span class="s1">orig_SSLContext).verify_flags.__set__(self</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s1">@orig_SSLContext.verify_mode.setter</span>
        <span class="s3">def </span><span class="s1">verify_mode(self</span><span class="s3">, </span><span class="s1">value):</span>
            <span class="s1">super(orig_SSLContext</span><span class="s3">, </span><span class="s1">orig_SSLContext).verify_mode.__set__(self</span><span class="s3">, </span><span class="s1">value)</span>

    <span class="s3">if </span><span class="s1">hasattr(orig_SSLContext</span><span class="s3">, </span><span class="s4">'minimum_version'</span><span class="s1">):</span>
        <span class="s0"># Like the above, added in 3.7</span>
        <span class="s0"># pylint:disable=no-member</span>
        <span class="s1">@orig_SSLContext.minimum_version.setter</span>
        <span class="s3">def </span><span class="s1">minimum_version(self</span><span class="s3">, </span><span class="s1">value):</span>
            <span class="s1">super(orig_SSLContext</span><span class="s3">, </span><span class="s1">orig_SSLContext).minimum_version.__set__(self</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s1">@orig_SSLContext.maximum_version.setter</span>
        <span class="s3">def </span><span class="s1">maximum_version(self</span><span class="s3">, </span><span class="s1">value):</span>
            <span class="s1">super(orig_SSLContext</span><span class="s3">, </span><span class="s1">orig_SSLContext).maximum_version.__set__(self</span><span class="s3">, </span><span class="s1">value)</span>

    <span class="s3">if </span><span class="s1">hasattr(orig_SSLContext</span><span class="s3">, </span><span class="s4">'_msg_callback'</span><span class="s1">):</span>
        <span class="s0"># And ditto for 3.8</span>
        <span class="s0"># msg_callback is more complex because they want to actually *do* stuff</span>
        <span class="s0"># in the setter, so we need to call it. For that to work we temporarily rebind</span>
        <span class="s0"># SSLContext back. This function cannot switch, so it should be safe,</span>
        <span class="s0"># unless somehow we have multiple threads in a monkey-patched ssl module</span>
        <span class="s0"># at the same time, which doesn't make much sense.</span>
        <span class="s1">@property</span>
        <span class="s3">def </span><span class="s1">_msg_callback(self):</span>
            <span class="s1">result = super()._msg_callback</span>
            <span class="s3">if </span><span class="s1">isinstance(result</span><span class="s3">, </span><span class="s1">_Callback):</span>
                <span class="s1">result = result.user_function</span>
            <span class="s3">return </span><span class="s1">result</span>

        <span class="s1">@_msg_callback.setter</span>
        <span class="s3">def </span><span class="s1">_msg_callback(self</span><span class="s3">, </span><span class="s1">value):</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">and </span><span class="s1">callable(value):</span>
                <span class="s1">value = _Callback(value)</span>

            <span class="s1">__ssl__.SSLContext = orig_SSLContext</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">super(SSLContext</span><span class="s3">, </span><span class="s1">SSLContext)._msg_callback.__set__(self</span><span class="s3">, </span><span class="s1">value) </span><span class="s0"># pylint:disable=no-member</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s1">__ssl__.SSLContext = SSLContext</span>

    <span class="s3">if </span><span class="s1">hasattr(orig_SSLContext</span><span class="s3">, </span><span class="s4">'sni_callback'</span><span class="s1">):</span>
        <span class="s0"># Added in 3.7.</span>
        <span class="s1">@property</span>
        <span class="s3">def </span><span class="s1">sni_callback(self):</span>
            <span class="s1">result = super().sni_callback</span>
            <span class="s3">if </span><span class="s1">isinstance(result</span><span class="s3">, </span><span class="s1">_Callback):</span>
                <span class="s1">result = result.user_function </span><span class="s0"># pylint:disable=no-member</span>
            <span class="s3">return </span><span class="s1">result</span>
        <span class="s1">@sni_callback.setter</span>
        <span class="s3">def </span><span class="s1">sni_callback(self</span><span class="s3">, </span><span class="s1">value):</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">and </span><span class="s1">callable(value):</span>
                <span class="s1">value = _Callback(value)</span>
            <span class="s1">super(orig_SSLContext</span><span class="s3">, </span><span class="s1">orig_SSLContext).sni_callback.__set__(self</span><span class="s3">, </span><span class="s1">value) </span><span class="s0"># pylint:disable=no-member</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># In newer versions, this just sets sni_callback.</span>
        <span class="s3">def </span><span class="s1">set_servername_callback(self</span><span class="s3">, </span><span class="s1">server_name_callback):</span>
            <span class="s3">if </span><span class="s1">server_name_callback </span><span class="s3">and </span><span class="s1">callable(server_name_callback):</span>
                <span class="s1">server_name_callback = _Callback(server_name_callback)</span>
            <span class="s1">super().set_servername_callback(server_name_callback)</span>


<span class="s3">class </span><span class="s1">SSLSocket(socket):</span>
    <span class="s2">&quot;&quot;&quot; 
    gevent `ssl.SSLSocket 
    &lt;https://docs.python.org/3/library/ssl.html#ssl-sockets&gt;`_ for 
    Python 3. 
    &quot;&quot;&quot;</span>

    <span class="s0"># pylint:disable=too-many-instance-attributes,too-many-public-methods</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">sock=</span><span class="s3">None, </span><span class="s1">keyfile=</span><span class="s3">None, </span><span class="s1">certfile=</span><span class="s3">None,</span>
                 <span class="s1">server_side=</span><span class="s3">False, </span><span class="s1">cert_reqs=CERT_NONE</span><span class="s3">,</span>
                 <span class="s1">ssl_version=PROTOCOL_SSLv23</span><span class="s3">, </span><span class="s1">ca_certs=</span><span class="s3">None,</span>
                 <span class="s1">do_handshake_on_connect=</span><span class="s3">True,</span>
                 <span class="s1">family=AF_INET</span><span class="s3">, </span><span class="s1">type=SOCK_STREAM</span><span class="s3">, </span><span class="s1">proto=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">fileno=</span><span class="s3">None,</span>
                 <span class="s1">suppress_ragged_eofs=</span><span class="s3">True, </span><span class="s1">npn_protocols=</span><span class="s3">None, </span><span class="s1">ciphers=</span><span class="s3">None,</span>
                 <span class="s1">server_hostname=</span><span class="s3">None,</span>
                 <span class="s1">_session=</span><span class="s3">None, </span><span class="s0"># 3.6</span>
                 <span class="s1">_context=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># When a *sock* argument is passed, it is used only for its fileno()</span>
        <span class="s0"># and is immediately detach()'d *unless* we raise an error.</span>

        <span class="s0"># pylint:disable=too-many-locals,too-many-statements,too-many-branches</span>

        <span class="s3">if </span><span class="s1">_context:</span>
            <span class="s1">self._context = _context</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">server_side </span><span class="s3">and not </span><span class="s1">certfile:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;certfile must be specified for server-side &quot;</span>
                                 <span class="s4">&quot;operations&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">keyfile </span><span class="s3">and not </span><span class="s1">certfile:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;certfile must be specified&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">certfile </span><span class="s3">and not </span><span class="s1">keyfile:</span>
                <span class="s1">keyfile = certfile</span>
            <span class="s1">self._context = SSLContext(ssl_version)</span>
            <span class="s1">self._context.verify_mode = cert_reqs</span>
            <span class="s3">if </span><span class="s1">ca_certs:</span>
                <span class="s1">self._context.load_verify_locations(ca_certs)</span>
            <span class="s3">if </span><span class="s1">certfile:</span>
                <span class="s1">self._context.load_cert_chain(certfile</span><span class="s3">, </span><span class="s1">keyfile)</span>
            <span class="s3">if </span><span class="s1">npn_protocols:</span>
                <span class="s1">self._context.set_npn_protocols(npn_protocols)</span>
            <span class="s3">if </span><span class="s1">ciphers:</span>
                <span class="s1">self._context.set_ciphers(ciphers)</span>
            <span class="s1">self.keyfile = keyfile</span>
            <span class="s1">self.certfile = certfile</span>
            <span class="s1">self.cert_reqs = cert_reqs</span>
            <span class="s1">self.ssl_version = ssl_version</span>
            <span class="s1">self.ca_certs = ca_certs</span>
            <span class="s1">self.ciphers = ciphers</span>
        <span class="s0"># Can't use sock.type as other flags (such as SOCK_NONBLOCK) get</span>
        <span class="s0"># mixed in.</span>
        <span class="s3">if </span><span class="s1">sock.getsockopt(SOL_SOCKET</span><span class="s3">, </span><span class="s1">SO_TYPE) != SOCK_STREAM:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;only stream sockets are supported&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">server_side:</span>
            <span class="s3">if </span><span class="s1">server_hostname:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;server_hostname can only be specified &quot;</span>
                                 <span class="s4">&quot;in client mode&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">_session </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;session can only be specified &quot;</span>
                                 <span class="s4">&quot;in client mode&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self._context.check_hostname </span><span class="s3">and not </span><span class="s1">server_hostname:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;check_hostname requires server_hostname&quot;</span><span class="s1">)</span>
        <span class="s1">self._session = _session</span>
        <span class="s1">self.server_side = server_side</span>
        <span class="s1">self.server_hostname = server_hostname</span>
        <span class="s1">self.do_handshake_on_connect = do_handshake_on_connect</span>
        <span class="s1">self.suppress_ragged_eofs = suppress_ragged_eofs</span>
        <span class="s1">connected = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">sock </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">timeout = sock.gettimeout()</span>
            <span class="s1">socket.__init__(self</span><span class="s3">,</span>
                            <span class="s1">family=sock.family</span><span class="s3">,</span>
                            <span class="s1">type=sock.type</span><span class="s3">,</span>
                            <span class="s1">proto=sock.proto</span><span class="s3">,</span>
                            <span class="s1">fileno=sock.fileno())</span>
            <span class="s1">self.settimeout(timeout)</span>
            <span class="s0"># When Python 3 sockets are __del__, they close() themselves,</span>
            <span class="s0"># including their underlying fd, unless they have been detached.</span>
            <span class="s0"># Only detach if we succeed in taking ownership; if we raise an exception,</span>
            <span class="s0"># then the user might have no way to close us and release the resources.</span>
            <span class="s1">sock.detach()</span>
        <span class="s3">elif </span><span class="s1">fileno </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">socket.__init__(self</span><span class="s3">, </span><span class="s1">fileno=fileno)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">socket.__init__(self</span><span class="s3">, </span><span class="s1">family=family</span><span class="s3">, </span><span class="s1">type=type</span><span class="s3">, </span><span class="s1">proto=proto)</span>

        <span class="s1">self._closed = </span><span class="s3">False</span>
        <span class="s1">self._sslobj = </span><span class="s3">None</span>
        <span class="s0"># see if we're connected</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self._sock.getpeername()</span>
        <span class="s3">except </span><span class="s1">socket_error </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">if </span><span class="s1">e.errno != errno.ENOTCONN:</span>
                <span class="s0"># This file descriptor is hosed, shared or not.</span>
                <span class="s0"># Clean up.</span>
                <span class="s1">self.close()</span>
                <span class="s3">raise</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">connected = </span><span class="s3">True</span>
        <span class="s1">self._connected = connected</span>
        <span class="s3">if </span><span class="s1">connected:</span>
            <span class="s0"># create the SSL object</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self._sslobj = self.__create_sslobj(server_side</span><span class="s3">, </span><span class="s1">_session)</span>

                <span class="s3">if </span><span class="s1">do_handshake_on_connect:</span>
                    <span class="s1">timeout = self.gettimeout()</span>
                    <span class="s3">if </span><span class="s1">timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s0"># non-blocking</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;do_handshake_on_connect should not be specified for non-blocking sockets&quot;</span><span class="s1">)</span>
                    <span class="s1">self.do_handshake()</span>

            <span class="s3">except </span><span class="s1">socket_error </span><span class="s3">as </span><span class="s1">x:</span>
                <span class="s1">self.close()</span>
                <span class="s3">raise </span><span class="s1">x</span>

    <span class="s3">def </span><span class="s1">_gevent_sock_class(self</span><span class="s3">, </span><span class="s1">family</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">proto</span><span class="s3">, </span><span class="s1">fileno):</span>
        <span class="s3">return </span><span class="s1">_contextawaresock(family</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">proto</span><span class="s3">, </span><span class="s1">fileno</span><span class="s3">, </span><span class="s1">_wref(self))</span>

    <span class="s3">def </span><span class="s1">_extra_repr(self):</span>
        <span class="s3">return </span><span class="s4">' server=%s, cipher=%r' </span><span class="s1">% (</span>
            <span class="s1">self.server_side</span><span class="s3">,</span>
            <span class="s1">self._sslobj.cipher() </span><span class="s3">if </span><span class="s1">self._sslobj </span><span class="s3">is not None else </span><span class="s4">''</span>

        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">context(self):</span>
        <span class="s3">return </span><span class="s1">self._context</span>

    <span class="s1">@context.setter</span>
    <span class="s3">def </span><span class="s1">context(self</span><span class="s3">, </span><span class="s1">ctx):</span>
        <span class="s1">self._context = ctx</span>
        <span class="s1">self._sslobj.context = ctx</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">session(self):</span>
        <span class="s2">&quot;&quot;&quot;The SSLSession for client socket.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._sslobj </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._sslobj.session</span>

    <span class="s1">@session.setter</span>
    <span class="s3">def </span><span class="s1">session(self</span><span class="s3">, </span><span class="s1">session):</span>
        <span class="s1">self._session = session</span>
        <span class="s3">if </span><span class="s1">self._sslobj </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._sslobj.session = session</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">session_reused(self):</span>
        <span class="s2">&quot;&quot;&quot;Was the client session reused during handshake&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._sslobj </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._sslobj.session_reused</span>

    <span class="s3">def </span><span class="s1">dup(self):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Can't dup() %s instances&quot; </span><span class="s1">%</span>
                                  <span class="s1">self.__class__.__name__)</span>

    <span class="s3">def </span><span class="s1">_checkClosed(self</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># raise an exception here if you wish to check for spurious closes</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">_check_connected(self):</span>
        <span class="s3">if not </span><span class="s1">self._connected:</span>
            <span class="s0"># getpeername() will raise ENOTCONN if the socket is really</span>
            <span class="s0"># not connected; note that we can be connected even without</span>
            <span class="s0"># _connected being set, e.g. if connect() first returned</span>
            <span class="s0"># EAGAIN.</span>
            <span class="s1">self.getpeername()</span>

    <span class="s3">def </span><span class="s1">read(self</span><span class="s3">, </span><span class="s1">nbytes=</span><span class="s5">2014</span><span class="s3">, </span><span class="s1">buffer=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Read up to LEN bytes and return them. 
        Return zero-length string on EOF.&quot;&quot;&quot;</span>
        <span class="s0"># pylint:disable=too-many-branches</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s0"># The stdlib signature is (len=1024, buffer=None)</span>
        <span class="s0"># but that shadows the len builtin, and its hard/annoying to</span>
        <span class="s0"># get it back.</span>
        <span class="s1">initial_buf_len = len(buffer) </span><span class="s3">if </span><span class="s1">buffer </span><span class="s3">is not None else None</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">self._sslobj:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Read on closed or unwrapped SSL socket.&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">nbytes == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s6">b'' </span><span class="s3">if </span><span class="s1">buffer </span><span class="s3">is None else </span><span class="s5">0</span>
            <span class="s0"># Negative lengths are handled natively when the buffer is None</span>
            <span class="s0"># to raise a ValueError</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">buffer </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">self._sslobj.read(nbytes</span><span class="s3">, </span><span class="s1">buffer)</span>
                <span class="s3">return </span><span class="s1">self._sslobj.read(nbytes </span><span class="s3">or </span><span class="s5">1024</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">SSLWantReadError:</span>
                <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">raise</span>
                <span class="s1">self._wait(self._read_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorReadTimeout)</span>
            <span class="s3">except </span><span class="s1">SSLWantWriteError:</span>
                <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">raise</span>
                <span class="s0"># note: using _SSLErrorReadTimeout rather than _SSLErrorWriteTimeout below is intentional</span>
                <span class="s1">self._wait(self._write_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorReadTimeout)</span>
            <span class="s3">except </span><span class="s1">SSLError </span><span class="s3">as </span><span class="s1">ex:</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_EOF </span><span class="s3">and </span><span class="s1">self.suppress_ragged_eofs:</span>
                    <span class="s3">return </span><span class="s6">b'' </span><span class="s3">if </span><span class="s1">buffer </span><span class="s3">is None else </span><span class="s1">len(buffer) - initial_buf_len</span>
                <span class="s3">raise</span>
            <span class="s0"># Certain versions of Python, built against certain</span>
            <span class="s0"># versions of OpenSSL operating in certain modes, can</span>
            <span class="s0"># produce ``ConnectionResetError`` instead of</span>
            <span class="s0"># ``SSLError``. Notably, it looks like anything built</span>
            <span class="s0"># against 1.1.1c does that? gevent briefly (from support of TLS 1.3</span>
            <span class="s0"># in Sept 2019 to issue #1637 it June 2020) caught that error and treaded</span>
            <span class="s0"># it just like SSL_ERROR_EOF. But that's not what the standard library does.</span>
            <span class="s0"># So presumably errors that result from unexpected ``ConnectionResetError``</span>
            <span class="s0"># are issues in gevent tests.</span>

    <span class="s3">def </span><span class="s1">write(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s2">&quot;&quot;&quot;Write DATA to the underlying SSL channel.  Returns 
        number of bytes of DATA actually transmitted.&quot;&quot;&quot;</span>
        <span class="s1">self._checkClosed()</span>

        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">self._sslobj:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Write on closed or unwrapped SSL socket.&quot;</span><span class="s1">)</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._sslobj.write(data)</span>
            <span class="s3">except </span><span class="s1">SSLError </span><span class="s3">as </span><span class="s1">ex:</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_READ:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">self._wait(self._read_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorWriteTimeout)</span>
                <span class="s3">elif </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_WRITE:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">self._wait(self._write_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorWriteTimeout)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">getpeercert(self</span><span class="s3">, </span><span class="s1">binary_form=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Returns a formatted version of the data in the 
        certificate provided by the other end of the SSL channel. 
        Return None if no certificate was provided, {} if a 
        certificate was provided, but not validated.&quot;&quot;&quot;</span>

        <span class="s1">self._checkClosed()</span>
        <span class="s1">self._check_connected()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">c = self._sslobj.peer_certificate</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s0"># 3.6</span>
            <span class="s1">c = self._sslobj.getpeercert</span>

        <span class="s3">return </span><span class="s1">c(binary_form)</span>

    <span class="s3">def </span><span class="s1">selected_npn_protocol(self):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if not </span><span class="s1">self._sslobj </span><span class="s3">or not </span><span class="s1">_ssl.HAS_NPN:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">self._sslobj.selected_npn_protocol()</span>

    <span class="s3">if </span><span class="s1">hasattr(_ssl</span><span class="s3">, </span><span class="s4">'HAS_ALPN'</span><span class="s1">):</span>
        <span class="s0"># 3.5+</span>
        <span class="s3">def </span><span class="s1">selected_alpn_protocol(self):</span>
            <span class="s1">self._checkClosed()</span>
            <span class="s3">if not </span><span class="s1">self._sslobj </span><span class="s3">or not </span><span class="s1">_ssl.HAS_ALPN: </span><span class="s0"># pylint:disable=no-member</span>
                <span class="s3">return None</span>
            <span class="s3">return </span><span class="s1">self._sslobj.selected_alpn_protocol()</span>

        <span class="s3">def </span><span class="s1">shared_ciphers(self):</span>
            <span class="s2">&quot;&quot;&quot;Return a list of ciphers shared by the client during the handshake or 
            None if this is not a valid server connection. 
            &quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">self._sslobj.shared_ciphers()</span>

        <span class="s3">def </span><span class="s1">version(self):</span>
            <span class="s2">&quot;&quot;&quot;Return a string identifying the protocol version used by the 
            current SSL channel. &quot;&quot;&quot;</span>
            <span class="s3">if not </span><span class="s1">self._sslobj:</span>
                <span class="s3">return None</span>
            <span class="s3">return </span><span class="s1">self._sslobj.version()</span>

        <span class="s0"># We inherit sendfile from super(); it always uses `send`</span>

    <span class="s3">def </span><span class="s1">cipher(self):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if not </span><span class="s1">self._sslobj:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">self._sslobj.cipher()</span>

    <span class="s3">def </span><span class="s1">compression(self):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if not </span><span class="s1">self._sslobj:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">self._sslobj.compression()</span>

    <span class="s3">def </span><span class="s1">send(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">timeout=timeout_default):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">timeout </span><span class="s3">is </span><span class="s1">timeout_default:</span>
            <span class="s1">timeout = self.timeout</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">if </span><span class="s1">flags != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;non-zero flags not allowed in calls to send() on %s&quot; </span><span class="s1">%</span>
                    <span class="s1">self.__class__)</span>
            <span class="s3">while True</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">self._sslobj.write(data)</span>
                <span class="s3">except </span><span class="s1">SSLWantReadError:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">return </span><span class="s5">0</span>
                    <span class="s1">self._wait(self._read_event)</span>
                <span class="s3">except </span><span class="s1">SSLWantWriteError:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">return </span><span class="s5">0</span>
                    <span class="s1">self._wait(self._write_event)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">socket.send(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">timeout)</span>

    <span class="s3">def </span><span class="s1">sendto(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags_or_addr</span><span class="s3">, </span><span class="s1">addr=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;sendto not allowed on instances of %s&quot; </span><span class="s1">%</span>
                             <span class="s1">self.__class__)</span>
        <span class="s3">if </span><span class="s1">addr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">socket.sendto(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags_or_addr)</span>
        <span class="s3">return </span><span class="s1">socket.sendto(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags_or_addr</span><span class="s3">, </span><span class="s1">addr)</span>

    <span class="s3">def </span><span class="s1">sendmsg(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># Ensure programs don't send data unencrypted if they try to</span>
        <span class="s0"># use this method.</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;sendmsg not allowed on instances of %s&quot; </span><span class="s1">%</span>
                                  <span class="s1">self.__class__)</span>

    <span class="s3">def </span><span class="s1">sendall(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">if </span><span class="s1">flags != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;non-zero flags not allowed in calls to sendall() on %s&quot; </span><span class="s1">%</span>
                    <span class="s1">self.__class__)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">socket.sendall(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags)</span>
        <span class="s3">except </span><span class="s1">_socket_timeout:</span>
            <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                <span class="s0"># Raised by the stdlib on non-blocking sockets</span>
                <span class="s3">raise </span><span class="s1">SSLWantWriteError(</span><span class="s4">&quot;The operation did not complete (write)&quot;</span><span class="s1">)</span>
            <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">recv(self</span><span class="s3">, </span><span class="s1">buflen=</span><span class="s5">1024</span><span class="s3">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">if </span><span class="s1">flags != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;non-zero flags not allowed in calls to recv() on %s&quot; </span><span class="s1">%</span>
                    <span class="s1">self.__class__)</span>
            <span class="s3">if </span><span class="s1">buflen == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s0"># https://github.com/python/cpython/commit/00915577dd84ba75016400793bf547666e6b29b5</span>
                <span class="s0"># Python #23804</span>
                <span class="s3">return </span><span class="s6">b''</span>
            <span class="s3">return </span><span class="s1">self.read(buflen)</span>
        <span class="s3">return </span><span class="s1">socket.recv(self</span><span class="s3">, </span><span class="s1">buflen</span><span class="s3">, </span><span class="s1">flags)</span>

    <span class="s3">def </span><span class="s1">recv_into(self</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">nbytes=</span><span class="s3">None, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">buffer </span><span class="s3">and </span><span class="s1">(nbytes </span><span class="s3">is None</span><span class="s1">):</span>
            <span class="s1">nbytes = len(buffer)</span>
        <span class="s3">elif </span><span class="s1">nbytes </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">nbytes = </span><span class="s5">1024</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">if </span><span class="s1">flags != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;non-zero flags not allowed in calls to recv_into() on %s&quot; </span><span class="s1">% self.__class__)</span>
            <span class="s3">return </span><span class="s1">self.read(nbytes</span><span class="s3">, </span><span class="s1">buffer)</span>
        <span class="s3">return </span><span class="s1">socket.recv_into(self</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">nbytes</span><span class="s3">, </span><span class="s1">flags)</span>

    <span class="s3">def </span><span class="s1">recvfrom(self</span><span class="s3">, </span><span class="s1">buflen=</span><span class="s5">1024</span><span class="s3">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;recvfrom not allowed on instances of %s&quot; </span><span class="s1">%</span>
                             <span class="s1">self.__class__)</span>
        <span class="s3">return </span><span class="s1">socket.recvfrom(self</span><span class="s3">, </span><span class="s1">buflen</span><span class="s3">, </span><span class="s1">flags)</span>

    <span class="s3">def </span><span class="s1">recvfrom_into(self</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">nbytes=</span><span class="s3">None, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;recvfrom_into not allowed on instances of %s&quot; </span><span class="s1">%</span>
                             <span class="s1">self.__class__)</span>
        <span class="s3">return </span><span class="s1">socket.recvfrom_into(self</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">nbytes</span><span class="s3">, </span><span class="s1">flags)</span>

    <span class="s3">def </span><span class="s1">recvmsg(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;recvmsg not allowed on instances of %s&quot; </span><span class="s1">%</span>
                                  <span class="s1">self.__class__)</span>

    <span class="s3">def </span><span class="s1">recvmsg_into(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;recvmsg_into not allowed on instances of &quot;</span>
                                  <span class="s4">&quot;%s&quot; </span><span class="s1">% self.__class__)</span>

    <span class="s3">def </span><span class="s1">pending(self):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">return </span><span class="s1">self._sslobj.pending()</span>
        <span class="s3">return </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">shutdown(self</span><span class="s3">, </span><span class="s1">how):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s1">self._sslobj = </span><span class="s3">None</span>
        <span class="s1">socket.shutdown(self</span><span class="s3">, </span><span class="s1">how)</span>

    <span class="s3">def </span><span class="s1">unwrap(self):</span>
        <span class="s3">if not </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;No SSL wrapper around &quot; </span><span class="s1">+ str(self))</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s0"># 3.7 and newer, that use the SSLSocket object</span>
            <span class="s0"># call its shutdown.</span>
            <span class="s1">shutdown = self._sslobj.shutdown</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s0"># Earlier versions use SSLObject, which covers</span>
            <span class="s0"># that with a layer.</span>
            <span class="s1">shutdown = self._sslobj.unwrap</span>

        <span class="s1">s = self._sock</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">s = shutdown()</span>
                <span class="s3">break</span>
            <span class="s3">except </span><span class="s1">SSLWantReadError:</span>
                <span class="s0"># Callers of this method expect to get a socket</span>
                <span class="s0"># back, so we can't simply return 0, we have</span>
                <span class="s0"># to let these be raised</span>
                <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">raise</span>
                <span class="s1">self._wait(self._read_event)</span>
            <span class="s3">except </span><span class="s1">SSLWantWriteError:</span>
                <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">raise</span>
                <span class="s1">self._wait(self._write_event)</span>
            <span class="s3">except </span><span class="s1">SSLEOFError:</span>
                <span class="s3">break</span>
            <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">if </span><span class="s1">e.errno == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s0"># The equivalent of SSLEOFError on unpatched versions of Python.</span>
                    <span class="s0"># https://bugs.python.org/issue31122</span>
                    <span class="s3">break</span>
                <span class="s3">raise</span>

        <span class="s1">self._sslobj = </span><span class="s3">None</span>

        <span class="s0"># The return value of shutting down the SSLObject is the</span>
        <span class="s0"># original wrapped socket passed to _wrap_socket, i.e.,</span>
        <span class="s0"># _contextawaresock. But that object doesn't have the</span>
        <span class="s0"># gevent wrapper around it so it can't be used. We have to</span>
        <span class="s0"># wrap it back up with a gevent wrapper.</span>
        <span class="s3">assert </span><span class="s1">s </span><span class="s3">is </span><span class="s1">self._sock</span>
        <span class="s0"># In the stdlib, SSLSocket subclasses socket.socket and passes itself</span>
        <span class="s0"># to _wrap_socket, so it gets itself back. We can't do that, we have to</span>
        <span class="s0"># pass our subclass of _socket.socket, _contextawaresock.</span>
        <span class="s0"># So ultimately we should return ourself.</span>

        <span class="s0"># See test_ftplib.py:TestTLS_FTPClass.test_ccc</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_real_close(self):</span>
        <span class="s1">self._sslobj = </span><span class="s3">None</span>
        <span class="s1">socket._real_close(self)</span>

    <span class="s3">def </span><span class="s1">do_handshake(self):</span>
        <span class="s2">&quot;&quot;&quot;Perform a TLS/SSL handshake.&quot;&quot;&quot;</span>
        <span class="s1">self._check_connected()</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self._sslobj.do_handshake()</span>
                <span class="s3">break</span>
            <span class="s3">except </span><span class="s1">SSLWantReadError:</span>
                <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">raise</span>
                <span class="s1">self._wait(self._read_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorHandshakeTimeout)</span>
            <span class="s3">except </span><span class="s1">SSLWantWriteError:</span>
                <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">raise</span>
                <span class="s1">self._wait(self._write_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorHandshakeTimeout)</span>

        <span class="s3">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &lt; (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s1">) </span><span class="s3">and </span><span class="s1">self._context.check_hostname:</span>
            <span class="s0"># In Python 3.7, the underlying OpenSSL name matching is used.</span>
            <span class="s0"># The version implemented in Python doesn't understand IDNA encoding.</span>
            <span class="s3">if not </span><span class="s1">self.server_hostname:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;check_hostname needs server_hostname &quot;</span>
                                 <span class="s4">&quot;argument&quot;</span><span class="s1">)</span>
            <span class="s1">match_hostname(self.getpeercert()</span><span class="s3">, </span><span class="s1">self.server_hostname) </span><span class="s0"># pylint:disable=deprecated-method</span>

    <span class="s3">if </span><span class="s1">hasattr(SSLObject</span><span class="s3">, </span><span class="s4">'_create'</span><span class="s1">):</span>
        <span class="s0"># 3.7+, making it difficult to create these objects.</span>
        <span class="s0"># There's a new type, _ssl.SSLSocket, that takes the</span>
        <span class="s0"># place of SSLObject for self._sslobj. This one does it all.</span>
        <span class="s3">def </span><span class="s1">__create_sslobj(self</span><span class="s3">, </span><span class="s1">server_side=</span><span class="s3">False, </span><span class="s1">session=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.context._wrap_socket(</span>
                <span class="s1">self._sock</span><span class="s3">, </span><span class="s1">server_side</span><span class="s3">, </span><span class="s1">self.server_hostname</span><span class="s3">,</span>
                <span class="s1">owner=self._sock</span><span class="s3">, </span><span class="s1">session=session</span>
            <span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">PY36: </span><span class="s0"># 3.6</span>
        <span class="s3">def </span><span class="s1">__create_sslobj(self</span><span class="s3">, </span><span class="s1">server_side=</span><span class="s3">False, </span><span class="s1">session=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s1">sslobj = self._context._wrap_socket(self._sock</span><span class="s3">, </span><span class="s1">server_side</span><span class="s3">, </span><span class="s1">self.server_hostname)</span>
            <span class="s3">return </span><span class="s1">SSLObject(sslobj</span><span class="s3">, </span><span class="s1">owner=self._sock</span><span class="s3">, </span><span class="s1">session=session)</span>
    <span class="s3">else</span><span class="s1">: </span><span class="s0"># 3.5</span>
        <span class="s3">def </span><span class="s1">__create_sslobj(self</span><span class="s3">, </span><span class="s1">server_side=</span><span class="s3">False, </span><span class="s1">session=</span><span class="s3">None</span><span class="s1">): </span><span class="s0"># pylint:disable=unused-argument</span>
            <span class="s1">sslobj = self._context._wrap_socket(self._sock</span><span class="s3">, </span><span class="s1">server_side</span><span class="s3">, </span><span class="s1">self.server_hostname)</span>
            <span class="s3">return </span><span class="s1">SSLObject(sslobj</span><span class="s3">, </span><span class="s1">owner=self._sock)</span>


    <span class="s3">def </span><span class="s1">_real_connect(self</span><span class="s3">, </span><span class="s1">addr</span><span class="s3">, </span><span class="s1">connect_ex):</span>
        <span class="s3">if </span><span class="s1">self.server_side:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;can't connect in server-side mode&quot;</span><span class="s1">)</span>
        <span class="s0"># Here we assume that the socket is client-side, and not</span>
        <span class="s0"># connected at the time of the call.  We connect it, then wrap it.</span>
        <span class="s3">if </span><span class="s1">self._connected:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;attempt to connect already-connected SSLSocket!&quot;</span><span class="s1">)</span>
        <span class="s1">self._sslobj = self.__create_sslobj(</span><span class="s3">False, </span><span class="s1">self._session)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">connect_ex:</span>
                <span class="s1">rc = socket.connect_ex(self</span><span class="s3">, </span><span class="s1">addr)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">rc = </span><span class="s3">None</span>
                <span class="s1">socket.connect(self</span><span class="s3">, </span><span class="s1">addr)</span>
            <span class="s3">if not </span><span class="s1">rc:</span>
                <span class="s3">if </span><span class="s1">self.do_handshake_on_connect:</span>
                    <span class="s1">self.do_handshake()</span>
                <span class="s1">self._connected = </span><span class="s3">True</span>
            <span class="s3">return </span><span class="s1">rc</span>
        <span class="s3">except </span><span class="s1">socket_error:</span>
            <span class="s1">self._sslobj = </span><span class="s3">None</span>
            <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">connect(self</span><span class="s3">, </span><span class="s1">addr):</span>
        <span class="s2">&quot;&quot;&quot;Connects to remote ADDR, and then wraps the connection in 
        an SSL channel.&quot;&quot;&quot;</span>
        <span class="s1">self._real_connect(addr</span><span class="s3">, False</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">connect_ex(self</span><span class="s3">, </span><span class="s1">addr):</span>
        <span class="s2">&quot;&quot;&quot;Connects to remote ADDR, and then wraps the connection in 
        an SSL channel.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._real_connect(addr</span><span class="s3">, True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">accept(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Accepts a new connection from a remote client, and returns a 
        tuple containing that new connection wrapped with a 
        server-side SSL channel, and the address of the remote client. 
        &quot;&quot;&quot;</span>
        <span class="s1">newsock</span><span class="s3">, </span><span class="s1">addr = super().accept()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">newsock = self._context.wrap_socket(</span>
                <span class="s1">newsock</span><span class="s3">,</span>
                <span class="s1">do_handshake_on_connect=self.do_handshake_on_connect</span><span class="s3">,</span>
                <span class="s1">suppress_ragged_eofs=self.suppress_ragged_eofs</span><span class="s3">,</span>
                <span class="s1">server_side=</span><span class="s3">True</span>
            <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">newsock</span><span class="s3">, </span><span class="s1">addr</span>
        <span class="s3">except</span><span class="s1">:</span>
            <span class="s1">newsock.close()</span>
            <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">get_channel_binding(self</span><span class="s3">, </span><span class="s1">cb_type=</span><span class="s4">&quot;tls-unique&quot;</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Get channel binding data for current connection.  Raise ValueError 
        if the requested `cb_type` is not supported.  Return bytes of the data 
        or None if the data is not available (e.g. before the handshake). 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">hasattr(self._sslobj</span><span class="s3">, </span><span class="s4">'get_channel_binding'</span><span class="s1">):</span>
            <span class="s0"># 3.7+, and sslobj is not None</span>
            <span class="s3">return </span><span class="s1">self._sslobj.get_channel_binding(cb_type)</span>
        <span class="s3">if </span><span class="s1">cb_type </span><span class="s3">not in </span><span class="s1">CHANNEL_BINDING_TYPES:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unsupported channel binding type&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">cb_type != </span><span class="s4">&quot;tls-unique&quot;</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;{0} channel binding type not implemented&quot;</span><span class="s1">.format(cb_type))</span>
        <span class="s3">if </span><span class="s1">self._sslobj </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">self._sslobj.tls_unique_cb()</span>

    <span class="s3">def </span><span class="s1">verify_client_post_handshake(self):</span>
        <span class="s0"># Only present in 3.7.1+; an attributeerror is alright</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">return </span><span class="s1">self._sslobj.verify_client_post_handshake()</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;No SSL wrapper around &quot; </span><span class="s1">+ str(self))</span>

<span class="s0"># Python does not support forward declaration of types</span>
<span class="s1">SSLContext.sslsocket_class = SSLSocket</span>

<span class="s0"># Python 3.2 onwards raise normal timeout errors, not SSLError.</span>
<span class="s0"># See https://bugs.python.org/issue10272</span>
<span class="s1">_SSLErrorReadTimeout = _socket_timeout(</span><span class="s4">'The read operation timed out'</span><span class="s1">)</span>
<span class="s1">_SSLErrorWriteTimeout = _socket_timeout(</span><span class="s4">'The write operation timed out'</span><span class="s1">)</span>
<span class="s1">_SSLErrorHandshakeTimeout = _socket_timeout(</span><span class="s4">'The handshake operation timed out'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">wrap_socket(sock</span><span class="s3">, </span><span class="s1">keyfile=</span><span class="s3">None, </span><span class="s1">certfile=</span><span class="s3">None,</span>
                <span class="s1">server_side=</span><span class="s3">False, </span><span class="s1">cert_reqs=CERT_NONE</span><span class="s3">,</span>
                <span class="s1">ssl_version=PROTOCOL_SSLv23</span><span class="s3">, </span><span class="s1">ca_certs=</span><span class="s3">None,</span>
                <span class="s1">do_handshake_on_connect=</span><span class="s3">True,</span>
                <span class="s1">suppress_ragged_eofs=</span><span class="s3">True,</span>
                <span class="s1">ciphers=</span><span class="s3">None</span><span class="s1">):</span>

    <span class="s3">return </span><span class="s1">SSLSocket(sock=sock</span><span class="s3">, </span><span class="s1">keyfile=keyfile</span><span class="s3">, </span><span class="s1">certfile=certfile</span><span class="s3">,</span>
                     <span class="s1">server_side=server_side</span><span class="s3">, </span><span class="s1">cert_reqs=cert_reqs</span><span class="s3">,</span>
                     <span class="s1">ssl_version=ssl_version</span><span class="s3">, </span><span class="s1">ca_certs=ca_certs</span><span class="s3">,</span>
                     <span class="s1">do_handshake_on_connect=do_handshake_on_connect</span><span class="s3">,</span>
                     <span class="s1">suppress_ragged_eofs=suppress_ragged_eofs</span><span class="s3">,</span>
                     <span class="s1">ciphers=ciphers)</span>


<span class="s3">def </span><span class="s1">get_server_certificate(addr</span><span class="s3">, </span><span class="s1">ssl_version=PROTOCOL_SSLv23</span><span class="s3">, </span><span class="s1">ca_certs=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Retrieve the certificate from the server at the specified address, 
    and return it as a PEM-encoded string. 
    If 'ca_certs' is specified, validate the server cert against it. 
    If 'ssl_version' is specified, use it in the connection attempt.&quot;&quot;&quot;</span>

    <span class="s1">_</span><span class="s3">, </span><span class="s1">_ = addr</span>
    <span class="s3">if </span><span class="s1">ca_certs </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">cert_reqs = CERT_REQUIRED</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">cert_reqs = CERT_NONE</span>
    <span class="s3">with </span><span class="s1">create_connection(addr) </span><span class="s3">as </span><span class="s1">sock:</span>
        <span class="s3">with </span><span class="s1">wrap_socket(sock</span><span class="s3">, </span><span class="s1">ssl_version=ssl_version</span><span class="s3">,</span>
                         <span class="s1">cert_reqs=cert_reqs</span><span class="s3">, </span><span class="s1">ca_certs=ca_certs) </span><span class="s3">as </span><span class="s1">sslsock:</span>
            <span class="s1">dercert = sslsock.getpeercert(</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">sslsock = sock = </span><span class="s3">None</span>
    <span class="s3">return </span><span class="s1">DER_cert_to_PEM_cert(dercert)</span>
</pre>
</body>
</html>