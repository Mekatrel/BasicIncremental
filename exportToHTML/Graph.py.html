<html>
<head>
<title>Graph.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Graph.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
altgraph.Graph - Base Graph class 
================================= 
 
.. 
  #--Version 2.1 
  #--Bob Ippolito October, 2004 
 
  #--Version 2.0 
  #--Istvan Albert June, 2004 
 
  #--Version 1.0 
  #--Nathan Denny, May 27, 1999 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">deque</span>

<span class="s2">from </span><span class="s1">altgraph </span><span class="s2">import </span><span class="s1">GraphError</span>


<span class="s2">class </span><span class="s1">Graph(object):</span>
    <span class="s0">&quot;&quot;&quot; 
    The Graph class represents a directed graph with *N* nodes and *E* edges. 
 
    Naming conventions: 
 
    - the prefixes such as *out*, *inc* and *all* will refer to methods 
      that operate on the outgoing, incoming or all edges of that node. 
 
      For example: :py:meth:`inc_degree` will refer to the degree of the node 
      computed over the incoming edges (the number of neighbours linking to 
      the node). 
 
    - the prefixes such as *forw* and *back* will refer to the 
      orientation of the edges used in the method with respect to the node. 
 
      For example: :py:meth:`forw_bfs` will start at the node then use the 
      outgoing edges to traverse the graph (goes forward). 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">edges=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialization 
        &quot;&quot;&quot;</span>

        <span class="s1">self.next_edge = </span><span class="s3">0</span>
        <span class="s1">self.nodes</span><span class="s2">, </span><span class="s1">self.edges = {}</span><span class="s2">, </span><span class="s1">{}</span>
        <span class="s1">self.hidden_edges</span><span class="s2">, </span><span class="s1">self.hidden_nodes = {}</span><span class="s2">, </span><span class="s1">{}</span>

        <span class="s2">if </span><span class="s1">edges </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">edges:</span>
                <span class="s2">if </span><span class="s1">len(item) == </span><span class="s3">2</span><span class="s1">:</span>
                    <span class="s1">head</span><span class="s2">, </span><span class="s1">tail = item</span>
                    <span class="s1">self.add_edge(head</span><span class="s2">, </span><span class="s1">tail)</span>
                <span class="s2">elif </span><span class="s1">len(item) == </span><span class="s3">3</span><span class="s1">:</span>
                    <span class="s1">head</span><span class="s2">, </span><span class="s1">tail</span><span class="s2">, </span><span class="s1">data = item</span>
                    <span class="s1">self.add_edge(head</span><span class="s2">, </span><span class="s1">tail</span><span class="s2">, </span><span class="s1">data)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">GraphError(</span><span class="s4">&quot;Cannot create edge from %s&quot; </span><span class="s1">% (item</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;Graph: %d nodes, %d edges&gt;&quot; </span><span class="s1">% (</span>
            <span class="s1">self.number_of_nodes()</span><span class="s2">,</span>
            <span class="s1">self.number_of_edges()</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">add_node(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">node_data=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Adds a new node to the graph.  Arbitrary data can be attached to the 
        node via the node_data parameter.  Adding the same node twice will be 
        silently ignored. 
 
        The node must be a hashable value. 
        &quot;&quot;&quot;</span>
        <span class="s5">#</span>
        <span class="s5"># the nodes will contain tuples that will store incoming edges,</span>
        <span class="s5"># outgoing edges and data</span>
        <span class="s5">#</span>
        <span class="s5"># index 0 -&gt; incoming edges</span>
        <span class="s5"># index 1 -&gt; outgoing edges</span>

        <span class="s2">if </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self.hidden_nodes:</span>
            <span class="s5"># Node is present, but hidden</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">node </span><span class="s2">not in </span><span class="s1">self.nodes:</span>
            <span class="s1">self.nodes[node] = ([]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">node_data)</span>

    <span class="s2">def </span><span class="s1">add_edge(self</span><span class="s2">, </span><span class="s1">head_id</span><span class="s2">, </span><span class="s1">tail_id</span><span class="s2">, </span><span class="s1">edge_data=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">create_nodes=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Adds a directed edge going from head_id to tail_id. 
        Arbitrary data can be attached to the edge via edge_data. 
        It may create the nodes if adding edges between nonexisting ones. 
 
        :param head_id: head node 
        :param tail_id: tail node 
        :param edge_data: (optional) data attached to the edge 
        :param create_nodes: (optional) creates the head_id or tail_id 
            node in case they did not exist 
        &quot;&quot;&quot;</span>
        <span class="s5"># shorcut</span>
        <span class="s1">edge = self.next_edge</span>

        <span class="s5"># add nodes if on automatic node creation</span>
        <span class="s2">if </span><span class="s1">create_nodes:</span>
            <span class="s1">self.add_node(head_id)</span>
            <span class="s1">self.add_node(tail_id)</span>

        <span class="s5"># update the corresponding incoming and outgoing lists in the nodes</span>
        <span class="s5"># index 0 -&gt; incoming edges</span>
        <span class="s5"># index 1 -&gt; outgoing edges</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.nodes[tail_id][</span><span class="s3">0</span><span class="s1">].append(edge)</span>
            <span class="s1">self.nodes[head_id][</span><span class="s3">1</span><span class="s1">].append(edge)</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">GraphError(</span><span class="s4">&quot;Invalid nodes %s -&gt; %s&quot; </span><span class="s1">% (head_id</span><span class="s2">, </span><span class="s1">tail_id))</span>

        <span class="s5"># store edge information</span>
        <span class="s1">self.edges[edge] = (head_id</span><span class="s2">, </span><span class="s1">tail_id</span><span class="s2">, </span><span class="s1">edge_data)</span>

        <span class="s1">self.next_edge += </span><span class="s3">1</span>

    <span class="s2">def </span><span class="s1">hide_edge(self</span><span class="s2">, </span><span class="s1">edge):</span>
        <span class="s0">&quot;&quot;&quot; 
        Hides an edge from the graph. The edge may be unhidden at some later 
        time. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">head_id</span><span class="s2">, </span><span class="s1">tail_id</span><span class="s2">, </span><span class="s1">edge_data = self.hidden_edges[edge] = self.edges[edge]</span>
            <span class="s1">self.nodes[tail_id][</span><span class="s3">0</span><span class="s1">].remove(edge)</span>
            <span class="s1">self.nodes[head_id][</span><span class="s3">1</span><span class="s1">].remove(edge)</span>
            <span class="s2">del </span><span class="s1">self.edges[edge]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">GraphError(</span><span class="s4">&quot;Invalid edge %s&quot; </span><span class="s1">% edge)</span>

    <span class="s2">def </span><span class="s1">hide_node(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Hides a node from the graph.  The incoming and outgoing edges of the 
        node will also be hidden.  The node may be unhidden at some later time. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">all_edges = self.all_edges(node)</span>
            <span class="s1">self.hidden_nodes[node] = (self.nodes[node]</span><span class="s2">, </span><span class="s1">all_edges)</span>
            <span class="s2">for </span><span class="s1">edge </span><span class="s2">in </span><span class="s1">all_edges:</span>
                <span class="s1">self.hide_edge(edge)</span>
            <span class="s2">del </span><span class="s1">self.nodes[node]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">GraphError(</span><span class="s4">&quot;Invalid node %s&quot; </span><span class="s1">% node)</span>

    <span class="s2">def </span><span class="s1">restore_node(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Restores a previously hidden node back into the graph and restores 
        all of its incoming and outgoing edges. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.nodes[node]</span><span class="s2">, </span><span class="s1">all_edges = self.hidden_nodes[node]</span>
            <span class="s2">for </span><span class="s1">edge </span><span class="s2">in </span><span class="s1">all_edges:</span>
                <span class="s1">self.restore_edge(edge)</span>
            <span class="s2">del </span><span class="s1">self.hidden_nodes[node]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">GraphError(</span><span class="s4">&quot;Invalid node %s&quot; </span><span class="s1">% node)</span>

    <span class="s2">def </span><span class="s1">restore_edge(self</span><span class="s2">, </span><span class="s1">edge):</span>
        <span class="s0">&quot;&quot;&quot; 
        Restores a previously hidden edge back into the graph. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">head_id</span><span class="s2">, </span><span class="s1">tail_id</span><span class="s2">, </span><span class="s1">data = self.hidden_edges[edge]</span>
            <span class="s1">self.nodes[tail_id][</span><span class="s3">0</span><span class="s1">].append(edge)</span>
            <span class="s1">self.nodes[head_id][</span><span class="s3">1</span><span class="s1">].append(edge)</span>
            <span class="s1">self.edges[edge] = head_id</span><span class="s2">, </span><span class="s1">tail_id</span><span class="s2">, </span><span class="s1">data</span>
            <span class="s2">del </span><span class="s1">self.hidden_edges[edge]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">GraphError(</span><span class="s4">&quot;Invalid edge %s&quot; </span><span class="s1">% edge)</span>

    <span class="s2">def </span><span class="s1">restore_all_edges(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Restores all hidden edges. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">edge </span><span class="s2">in </span><span class="s1">list(self.hidden_edges.keys()):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.restore_edge(edge)</span>
            <span class="s2">except </span><span class="s1">GraphError:</span>
                <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">restore_all_nodes(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Restores all hidden nodes. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">list(self.hidden_nodes.keys()):</span>
            <span class="s1">self.restore_node(node)</span>

    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test whether a node is in the graph 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self.nodes</span>

    <span class="s2">def </span><span class="s1">edge_by_id(self</span><span class="s2">, </span><span class="s1">edge):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the edge that connects the head_id and tail_id nodes 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">head</span><span class="s2">, </span><span class="s1">tail</span><span class="s2">, </span><span class="s1">data = self.edges[edge]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s1">head</span><span class="s2">, </span><span class="s1">tail = </span><span class="s2">None, None</span>
            <span class="s2">raise </span><span class="s1">GraphError(</span><span class="s4">&quot;Invalid edge %s&quot; </span><span class="s1">% edge)</span>

        <span class="s2">return </span><span class="s1">(head</span><span class="s2">, </span><span class="s1">tail)</span>

    <span class="s2">def </span><span class="s1">edge_by_node(self</span><span class="s2">, </span><span class="s1">head</span><span class="s2">, </span><span class="s1">tail):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the edge that connects the head_id and tail_id nodes 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">edge </span><span class="s2">in </span><span class="s1">self.out_edges(head):</span>
            <span class="s2">if </span><span class="s1">self.tail(edge) == tail:</span>
                <span class="s2">return </span><span class="s1">edge</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">number_of_nodes(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the number of nodes 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self.nodes)</span>

    <span class="s2">def </span><span class="s1">number_of_edges(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the number of edges 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self.edges)</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Iterates over all nodes in the graph 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">iter(self.nodes)</span>

    <span class="s2">def </span><span class="s1">node_list(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of the node ids for all visible nodes in the graph. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list(self.nodes.keys())</span>

    <span class="s2">def </span><span class="s1">edge_list(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns an iterator for all visible nodes in the graph. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list(self.edges.keys())</span>

    <span class="s2">def </span><span class="s1">number_of_hidden_edges(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the number of hidden edges 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self.hidden_edges)</span>

    <span class="s2">def </span><span class="s1">number_of_hidden_nodes(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the number of hidden nodes 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self.hidden_nodes)</span>

    <span class="s2">def </span><span class="s1">hidden_node_list(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the list with the hidden nodes 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list(self.hidden_nodes.keys())</span>

    <span class="s2">def </span><span class="s1">hidden_edge_list(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a list with the hidden edges 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list(self.hidden_edges.keys())</span>

    <span class="s2">def </span><span class="s1">describe_node(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        return node, node data, outgoing edges, incoming edges for node 
        &quot;&quot;&quot;</span>
        <span class="s1">incoming</span><span class="s2">, </span><span class="s1">outgoing</span><span class="s2">, </span><span class="s1">data = self.nodes[node]</span>
        <span class="s2">return </span><span class="s1">node</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">outgoing</span><span class="s2">, </span><span class="s1">incoming</span>

    <span class="s2">def </span><span class="s1">describe_edge(self</span><span class="s2">, </span><span class="s1">edge):</span>
        <span class="s0">&quot;&quot;&quot; 
        return edge, edge data, head, tail for edge 
        &quot;&quot;&quot;</span>
        <span class="s1">head</span><span class="s2">, </span><span class="s1">tail</span><span class="s2">, </span><span class="s1">data = self.edges[edge]</span>
        <span class="s2">return </span><span class="s1">edge</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">head</span><span class="s2">, </span><span class="s1">tail</span>

    <span class="s2">def </span><span class="s1">node_data(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the data associated with a node 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.nodes[node][</span><span class="s3">2</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">edge_data(self</span><span class="s2">, </span><span class="s1">edge):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the data associated with an edge 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.edges[edge][</span><span class="s3">2</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">update_edge_data(self</span><span class="s2">, </span><span class="s1">edge</span><span class="s2">, </span><span class="s1">edge_data):</span>
        <span class="s0">&quot;&quot;&quot; 
        Replace the edge data for a specific edge 
        &quot;&quot;&quot;</span>
        <span class="s1">self.edges[edge] = self.edges[edge][</span><span class="s3">0</span><span class="s1">:</span><span class="s3">2</span><span class="s1">] + (edge_data</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">head(self</span><span class="s2">, </span><span class="s1">edge):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the node of the head of the edge. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.edges[edge][</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">tail(self</span><span class="s2">, </span><span class="s1">edge):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns node of the tail of the edge. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.edges[edge][</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">out_nbrs(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        List of nodes connected by outgoing edges 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[self.tail(n) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.out_edges(node)]</span>

    <span class="s2">def </span><span class="s1">inc_nbrs(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        List of nodes connected by incoming edges 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[self.head(n) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.inc_edges(node)]</span>

    <span class="s2">def </span><span class="s1">all_nbrs(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        List of nodes connected by incoming and outgoing edges 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list(dict.fromkeys(self.inc_nbrs(node) + self.out_nbrs(node)))</span>

    <span class="s2">def </span><span class="s1">out_edges(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a list of the outgoing edges 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">list(self.nodes[node][</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">GraphError(</span><span class="s4">&quot;Invalid node %s&quot; </span><span class="s1">% node)</span>

    <span class="s2">def </span><span class="s1">inc_edges(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a list of the incoming edges 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">list(self.nodes[node][</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">GraphError(</span><span class="s4">&quot;Invalid node %s&quot; </span><span class="s1">% node)</span>

    <span class="s2">def </span><span class="s1">all_edges(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a list of incoming and outging edges. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">set(self.inc_edges(node) + self.out_edges(node))</span>

    <span class="s2">def </span><span class="s1">out_degree(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the number of outgoing edges 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self.out_edges(node))</span>

    <span class="s2">def </span><span class="s1">inc_degree(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the number of incoming edges 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self.inc_edges(node))</span>

    <span class="s2">def </span><span class="s1">all_degree(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        The total degree of a node 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.inc_degree(node) + self.out_degree(node)</span>

    <span class="s2">def </span><span class="s1">_topo_sort(self</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Topological sort. 
 
        Returns a list of nodes where the successors (based on outgoing and 
        incoming edges selected by the forward parameter) of any given node 
        appear in the sequence after that node. 
        &quot;&quot;&quot;</span>
        <span class="s1">topo_list = []</span>
        <span class="s1">queue = deque()</span>
        <span class="s1">indeg = {}</span>

        <span class="s5"># select the operation that will be performed</span>
        <span class="s2">if </span><span class="s1">forward:</span>
            <span class="s1">get_edges = self.out_edges</span>
            <span class="s1">get_degree = self.inc_degree</span>
            <span class="s1">get_next = self.tail</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">get_edges = self.inc_edges</span>
            <span class="s1">get_degree = self.out_degree</span>
            <span class="s1">get_next = self.head</span>

        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self.node_list():</span>
            <span class="s1">degree = get_degree(node)</span>
            <span class="s2">if </span><span class="s1">degree:</span>
                <span class="s1">indeg[node] = degree</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">queue.append(node)</span>

        <span class="s2">while </span><span class="s1">queue:</span>
            <span class="s1">curr_node = queue.popleft()</span>
            <span class="s1">topo_list.append(curr_node)</span>
            <span class="s2">for </span><span class="s1">edge </span><span class="s2">in </span><span class="s1">get_edges(curr_node):</span>
                <span class="s1">tail_id = get_next(edge)</span>
                <span class="s2">if </span><span class="s1">tail_id </span><span class="s2">in </span><span class="s1">indeg:</span>
                    <span class="s1">indeg[tail_id] -= </span><span class="s3">1</span>
                    <span class="s2">if </span><span class="s1">indeg[tail_id] == </span><span class="s3">0</span><span class="s1">:</span>
                        <span class="s1">queue.append(tail_id)</span>

        <span class="s2">if </span><span class="s1">len(topo_list) == len(self.node_list()):</span>
            <span class="s1">valid = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># the graph has cycles, invalid topological sort</span>
            <span class="s1">valid = </span><span class="s2">False</span>

        <span class="s2">return </span><span class="s1">(valid</span><span class="s2">, </span><span class="s1">topo_list)</span>

    <span class="s2">def </span><span class="s1">forw_topo_sort(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Topological sort. 
 
        Returns a list of nodes where the successors (based on outgoing edges) 
        of any given node appear in the sequence after that node. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._topo_sort(forward=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">back_topo_sort(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Reverse topological sort. 
 
        Returns a list of nodes where the successors (based on incoming edges) 
        of any given node appear in the sequence after that node. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._topo_sort(forward=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_bfs_subgraph(self</span><span class="s2">, </span><span class="s1">start_id</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Private method creates a subgraph in a bfs order. 
 
        The forward parameter specifies whether it is a forward or backward 
        traversal. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">forward:</span>
            <span class="s1">get_bfs = self.forw_bfs</span>
            <span class="s1">get_nbrs = self.out_nbrs</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">get_bfs = self.back_bfs</span>
            <span class="s1">get_nbrs = self.inc_nbrs</span>

        <span class="s1">g = Graph()</span>
        <span class="s1">bfs_list = get_bfs(start_id)</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">bfs_list:</span>
            <span class="s1">g.add_node(node)</span>

        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">bfs_list:</span>
            <span class="s2">for </span><span class="s1">nbr_id </span><span class="s2">in </span><span class="s1">get_nbrs(node):</span>
                <span class="s2">if </span><span class="s1">forward:</span>
                    <span class="s1">g.add_edge(node</span><span class="s2">, </span><span class="s1">nbr_id)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">g.add_edge(nbr_id</span><span class="s2">, </span><span class="s1">node)</span>

        <span class="s2">return </span><span class="s1">g</span>

    <span class="s2">def </span><span class="s1">forw_bfs_subgraph(self</span><span class="s2">, </span><span class="s1">start_id):</span>
        <span class="s0">&quot;&quot;&quot; 
        Creates and returns a subgraph consisting of the breadth first 
        reachable nodes based on their outgoing edges. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._bfs_subgraph(start_id</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">back_bfs_subgraph(self</span><span class="s2">, </span><span class="s1">start_id):</span>
        <span class="s0">&quot;&quot;&quot; 
        Creates and returns a subgraph consisting of the breadth first 
        reachable nodes based on the incoming edges. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._bfs_subgraph(start_id</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">iterdfs(self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Collecting nodes in some depth first traversal. 
 
        The forward parameter specifies whether it is a forward or backward 
        traversal. 
        &quot;&quot;&quot;</span>
        <span class="s1">visited</span><span class="s2">, </span><span class="s1">stack = {start}</span><span class="s2">, </span><span class="s1">deque([start])</span>

        <span class="s2">if </span><span class="s1">forward:</span>
            <span class="s1">get_edges = self.out_edges</span>
            <span class="s1">get_next = self.tail</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">get_edges = self.inc_edges</span>
            <span class="s1">get_next = self.head</span>

        <span class="s2">while </span><span class="s1">stack:</span>
            <span class="s1">curr_node = stack.pop()</span>
            <span class="s2">yield </span><span class="s1">curr_node</span>
            <span class="s2">if </span><span class="s1">curr_node == end:</span>
                <span class="s2">break</span>
            <span class="s2">for </span><span class="s1">edge </span><span class="s2">in </span><span class="s1">sorted(get_edges(curr_node)):</span>
                <span class="s1">tail = get_next(edge)</span>
                <span class="s2">if </span><span class="s1">tail </span><span class="s2">not in </span><span class="s1">visited:</span>
                    <span class="s1">visited.add(tail)</span>
                    <span class="s1">stack.append(tail)</span>

    <span class="s2">def </span><span class="s1">iterdata(self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None, </span><span class="s1">forward=</span><span class="s2">True, </span><span class="s1">condition=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Perform a depth-first walk of the graph (as ``iterdfs``) 
        and yield the item data of every node where condition matches. The 
        condition callback is only called when node_data is not None. 
        &quot;&quot;&quot;</span>

        <span class="s1">visited</span><span class="s2">, </span><span class="s1">stack = {start}</span><span class="s2">, </span><span class="s1">deque([start])</span>

        <span class="s2">if </span><span class="s1">forward:</span>
            <span class="s1">get_edges = self.out_edges</span>
            <span class="s1">get_next = self.tail</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">get_edges = self.inc_edges</span>
            <span class="s1">get_next = self.head</span>

        <span class="s1">get_data = self.node_data</span>

        <span class="s2">while </span><span class="s1">stack:</span>
            <span class="s1">curr_node = stack.pop()</span>
            <span class="s1">curr_data = get_data(curr_node)</span>
            <span class="s2">if </span><span class="s1">curr_data </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">condition </span><span class="s2">is not None and not </span><span class="s1">condition(curr_data):</span>
                    <span class="s2">continue</span>
                <span class="s2">yield </span><span class="s1">curr_data</span>
            <span class="s2">if </span><span class="s1">curr_node == end:</span>
                <span class="s2">break</span>
            <span class="s2">for </span><span class="s1">edge </span><span class="s2">in </span><span class="s1">get_edges(curr_node):</span>
                <span class="s1">tail = get_next(edge)</span>
                <span class="s2">if </span><span class="s1">tail </span><span class="s2">not in </span><span class="s1">visited:</span>
                    <span class="s1">visited.add(tail)</span>
                    <span class="s1">stack.append(tail)</span>

    <span class="s2">def </span><span class="s1">_iterbfs(self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        The forward parameter specifies whether it is a forward or backward 
        traversal.  Returns a list of tuples where the first value is the hop 
        value the second value is the node id. 
        &quot;&quot;&quot;</span>
        <span class="s1">queue</span><span class="s2">, </span><span class="s1">visited = deque([(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)])</span><span class="s2">, </span><span class="s1">{start}</span>

        <span class="s5"># the direction of the bfs depends on the edges that are sampled</span>
        <span class="s2">if </span><span class="s1">forward:</span>
            <span class="s1">get_edges = self.out_edges</span>
            <span class="s1">get_next = self.tail</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">get_edges = self.inc_edges</span>
            <span class="s1">get_next = self.head</span>

        <span class="s2">while </span><span class="s1">queue:</span>
            <span class="s1">curr_node</span><span class="s2">, </span><span class="s1">curr_step = queue.popleft()</span>
            <span class="s2">yield </span><span class="s1">(curr_node</span><span class="s2">, </span><span class="s1">curr_step)</span>
            <span class="s2">if </span><span class="s1">curr_node == end:</span>
                <span class="s2">break</span>
            <span class="s2">for </span><span class="s1">edge </span><span class="s2">in </span><span class="s1">get_edges(curr_node):</span>
                <span class="s1">tail = get_next(edge)</span>
                <span class="s2">if </span><span class="s1">tail </span><span class="s2">not in </span><span class="s1">visited:</span>
                    <span class="s1">visited.add(tail)</span>
                    <span class="s1">queue.append((tail</span><span class="s2">, </span><span class="s1">curr_step + </span><span class="s3">1</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">forw_bfs(self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a list of nodes in some forward BFS order. 
 
        Starting from the start node the breadth first search proceeds along 
        outgoing edges. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[node </span><span class="s2">for </span><span class="s1">node</span><span class="s2">, </span><span class="s1">step </span><span class="s2">in </span><span class="s1">self._iterbfs(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">)]</span>

    <span class="s2">def </span><span class="s1">back_bfs(self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a list of nodes in some backward BFS order. 
 
        Starting from the start node the breadth first search proceeds along 
        incoming edges. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[node </span><span class="s2">for </span><span class="s1">node</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">self._iterbfs(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">False</span><span class="s1">)]</span>

    <span class="s2">def </span><span class="s1">forw_dfs(self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a list of nodes in some forward DFS order. 
 
        Starting with the start node the depth first search proceeds along 
        outgoing edges. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list(self.iterdfs(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">back_dfs(self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a list of nodes in some backward DFS order. 
 
        Starting from the start node the depth first search proceeds along 
        incoming edges. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list(self.iterdfs(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">False</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">connected(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns :py:data:`True` if the graph's every node can be reached from 
        every other node. 
        &quot;&quot;&quot;</span>
        <span class="s1">node_list = self.node_list()</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">node_list:</span>
            <span class="s1">bfs_list = self.forw_bfs(node)</span>
            <span class="s2">if </span><span class="s1">len(bfs_list) != len(node_list):</span>
                <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">clust_coef(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Computes and returns the local clustering coefficient of node. 
 
        The local cluster coefficient is proportion of the actual number of 
        edges between neighbours of node and the maximum number of edges 
        between those neighbours. 
 
        See &quot;Local Clustering Coefficient&quot; on 
        &lt;http://en.wikipedia.org/wiki/Clustering_coefficient&gt; 
        for a formal definition. 
        &quot;&quot;&quot;</span>
        <span class="s1">num = </span><span class="s3">0</span>
        <span class="s1">nbr_set = set(self.out_nbrs(node))</span>

        <span class="s2">if </span><span class="s1">node </span><span class="s2">in </span><span class="s1">nbr_set:</span>
            <span class="s1">nbr_set.remove(node)  </span><span class="s5"># loop defense</span>

        <span class="s2">for </span><span class="s1">nbr </span><span class="s2">in </span><span class="s1">nbr_set:</span>
            <span class="s1">sec_set = set(self.out_nbrs(nbr))</span>
            <span class="s2">if </span><span class="s1">nbr </span><span class="s2">in </span><span class="s1">sec_set:</span>
                <span class="s1">sec_set.remove(nbr)  </span><span class="s5"># loop defense</span>
            <span class="s1">num += len(nbr_set &amp; sec_set)</span>

        <span class="s1">nbr_num = len(nbr_set)</span>
        <span class="s2">if </span><span class="s1">nbr_num:</span>
            <span class="s1">clust_coef = float(num) / (nbr_num * (nbr_num - </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">clust_coef = </span><span class="s3">0.0</span>
        <span class="s2">return </span><span class="s1">clust_coef</span>

    <span class="s2">def </span><span class="s1">get_hops(self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end=</span><span class="s2">None, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Computes the hop distance to all nodes centered around a node. 
 
        First order neighbours are at hop 1, their neigbours are at hop 2 etc. 
        Uses :py:meth:`forw_bfs` or :py:meth:`back_bfs` depending on the value 
        of the forward parameter.  If the distance between all neighbouring 
        nodes is 1 the hop number corresponds to the shortest distance between 
        the nodes. 
 
        :param start: the starting node 
        :param end: ending node (optional). When not specified will search the 
            whole graph. 
        :param forward: directionality parameter (optional). 
            If C{True} (default) it uses L{forw_bfs} otherwise L{back_bfs}. 
        :return: returns a list of tuples where each tuple contains the 
            node and the hop. 
 
        Typical usage:: 
 
            &gt;&gt;&gt; print (graph.get_hops(1, 8)) 
            &gt;&gt;&gt; [(1, 0), (2, 1), (3, 1), (4, 2), (5, 3), (7, 4), (8, 5)] 
            # node 1 is at 0 hops 
            # node 2 is at 1 hop 
            # ... 
            # node 8 is at 5 hops 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">forward:</span>
            <span class="s2">return </span><span class="s1">list(self._iterbfs(start=start</span><span class="s2">, </span><span class="s1">end=end</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">list(self._iterbfs(start=start</span><span class="s2">, </span><span class="s1">end=end</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">False</span><span class="s1">))</span>
</pre>
</body>
</html>