<html>
<head>
<title>modulegraph.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
modulegraph.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Find modules used by a script, using bytecode analysis. 
 
Based on the stdlib modulefinder by Thomas Heller and Just van Rossum, 
but uses a graph data structure and 2.3 features 
 
XXX: Verify all calls to _import_hook (and variants) to ensure that 
imports are done in the right way. 
&quot;&quot;&quot;</span>
<span class="s2">#FIXME: To decrease the likelihood of ModuleGraph exceeding the recursion limit</span>
<span class="s2">#and hence unpredictably raising fatal exceptions, increase the recursion</span>
<span class="s2">#limit at PyInstaller startup (i.e., in the</span>
<span class="s2">#PyInstaller.building.build_main.build() function). For details, see:</span>
<span class="s2">#    https://github.com/pyinstaller/pyinstaller/issues/1919#issuecomment-216016176</span>

<span class="s3">import </span><span class="s1">pkg_resources</span>

<span class="s3">import </span><span class="s1">ast</span>
<span class="s3">import </span><span class="s1">codecs</span>
<span class="s3">import </span><span class="s1">imp</span>
<span class="s3">import </span><span class="s1">marshal</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">pkgutil</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">deque</span><span class="s3">, </span><span class="s1">namedtuple</span>
<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">from </span><span class="s1">altgraph.ObjectGraph </span><span class="s3">import </span><span class="s1">ObjectGraph</span>
<span class="s3">from </span><span class="s1">altgraph </span><span class="s3">import </span><span class="s1">GraphError</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">zipio</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">BytesIO</span><span class="s3">, </span><span class="s1">StringIO</span><span class="s3">, </span><span class="s1">pathname2url</span><span class="s3">, </span><span class="s1">_READ_MODE</span>


<span class="s1">BOM = codecs.BOM_UTF8.decode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">BUILTIN_MODULE:</span>
    <span class="s3">def </span><span class="s1">is_package(fqname):</span>
        <span class="s3">return False</span>


<span class="s3">class </span><span class="s1">NAMESPACE_PACKAGE:</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">namespace_dirs):</span>
        <span class="s1">self.namespace_dirs = namespace_dirs</span>

    <span class="s3">def </span><span class="s1">is_package(self</span><span class="s3">, </span><span class="s1">fqname):</span>
        <span class="s3">return True</span>


<span class="s2">#FIXME: Leverage this rather than magic numbers below.</span>
<span class="s1">ABSOLUTE_OR_RELATIVE_IMPORT_LEVEL = -</span><span class="s5">1</span>
<span class="s4">&quot;&quot;&quot; 
Constant instructing the builtin `__import__()` function to attempt both 
absolute and relative imports. 
&quot;&quot;&quot;</span>


<span class="s2">#FIXME: Leverage this rather than magic numbers below.</span>
<span class="s1">ABSOLUTE_IMPORT_LEVEL = </span><span class="s5">0</span>
<span class="s4">&quot;&quot;&quot; 
Constant instructing the builtin `__import__()` function to attempt only 
absolute imports. 
&quot;&quot;&quot;</span>


<span class="s2">#FIXME: Leverage this rather than magic numbers below.</span>
<span class="s1">DEFAULT_IMPORT_LEVEL = (</span>
    <span class="s1">ABSOLUTE_OR_RELATIVE_IMPORT_LEVEL </span><span class="s3">if </span><span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">2 </span><span class="s3">else</span>
    <span class="s1">ABSOLUTE_IMPORT_LEVEL)</span>
<span class="s4">&quot;&quot;&quot; 
Constant instructing the builtin `__import__()` function to attempt the default 
import style specific to the active Python interpreter. 
 
Specifically, under: 
 
* Python 2, this defaults to attempting both absolute and relative imports. 
* Python 3, this defaults to attempting only absolute imports. 
&quot;&quot;&quot;</span>

<span class="s2"># TODO: Refactor all uses of explicit filetypes in this module *AND* of the</span>
<span class="s2"># imp.get_suffixes() function to use this dictionary instead. Unfortunately,</span>
<span class="s2"># tests for explicit filetypes (e.g., &quot;.py&quot;) are non-portable. Under Windows,</span>
<span class="s2"># for example, both the &quot;.py&quot; *AND* &quot;.pyw&quot; filetypes signify valid uncompiled</span>
<span class="s2"># Python modules.</span>
<span class="s2"># TODO: The imp.get_suffixes() function (in fact, the entire &quot;imp&quot; package) has</span>
<span class="s2"># been deprecated as of Python 3.3 by the importlib.machinery.all_suffixes()</span>
<span class="s2"># function, which largely performs the same role. Unfortunately, the latter</span>
<span class="s2"># function was only introduced with Python 3.3. Since PyInstaller requires</span>
<span class="s2"># Python &gt;= 3.3 when running under Python 3, refactor this as follows:</span>
<span class="s2">#</span>
<span class="s2"># * Under Python 2, continue calling imp.get_suffixes().</span>
<span class="s2"># * Under Python 3, call importlib.machinery.all_suffixes() instead.</span>
<span class="s1">_IMPORTABLE_FILETYPE_TO_METADATA = {</span>
    <span class="s1">filetype: (filetype</span><span class="s3">, </span><span class="s1">open_mode</span><span class="s3">, </span><span class="s1">imp_type)</span>
    <span class="s3">for </span><span class="s1">filetype</span><span class="s3">, </span><span class="s1">open_mode</span><span class="s3">, </span><span class="s1">imp_type </span><span class="s3">in </span><span class="s1">imp.get_suffixes()</span>
<span class="s1">}</span>
<span class="s2"># Reverse sort by length so when comparing filenames the longest match first</span>
<span class="s1">_IMPORTABLE_FILETYPE_EXTS = sorted(_IMPORTABLE_FILETYPE_TO_METADATA</span><span class="s3">,</span>
                                   <span class="s1">key=</span><span class="s3">lambda </span><span class="s1">p: len(p)</span><span class="s3">, </span><span class="s1">reverse=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s4">&quot;&quot;&quot; 
Dictionary mapping the filetypes of importable files to the 3-tuple of metadata 
describing such files returned by the `imp.get_suffixes()` function whose first 
element is that filetype. 
 
This dictionary simplifies platform-portable importation of importable files, 
including: 
 
* Uncompiled modules suffixed by `.py` (as well as `.pyw` under Windows). 
* Compiled modules suffixed by either `.pyc` or `.pyo`. 
* C extensions suffixed by the platform-specific shared library filetype (e.g., 
  `.so` under Linux, `.dll` under Windows). 
 
The keys of this dictionary are `.`-prefixed filetypes (e.g., `.py`, `.so`) or 
`-`-prefixed filetypes (e.g., `-cpython-37m.dll`[1]); 
the values of this dictionary are 3-tuples whose: 
 
1. First element is the same `.` or `-` prefixed filetype. 
1. Second element is the mode to be passed to the `open()` built-in to open 
   files of that filetype under the current platform and Python interpreter 
   (e.g., `rU` for the `.py` filetype under Python 2, `r` for the same 
   filetype under Python 3). 
1. Third element is a magic number specific to the `imp` module (e.g., 
   `imp.C_EXTENSION` for filetypes corresponding to C extensions). 
 
[1] For example of `-cpython-m37.dll` search on 
    https://packages.msys2.org/package/mingw-w64-x86_64-python3?repo=mingw64 
&quot;&quot;&quot;</span>



<span class="s2"># Modulegraph does a good job at simulating Python's, but it can not</span>
<span class="s2"># handle packagepath modifications packages make at runtime.  Therefore there</span>
<span class="s2"># is a mechanism whereby you can register extra paths in this map for a</span>
<span class="s2"># package, and it will be honored.</span>
<span class="s2">#</span>
<span class="s2"># Note this is a mapping is lists of paths.</span>
<span class="s1">_packagePathMap = {}</span>

<span class="s2"># Prefix used in magic .pth files used by setuptools to create namespace</span>
<span class="s2"># packages without an __init__.py file.</span>
<span class="s2">#</span>
<span class="s2"># The value is a list of such prefixes as the prefix varies with versions of</span>
<span class="s2"># setuptools.</span>
<span class="s1">_SETUPTOOLS_NAMESPACEPKG_PTHs=(</span>
    <span class="s2"># setuptools 31.0.0</span>
    <span class="s1">(</span><span class="s4">&quot;import sys, types, os;has_mfs = sys.version_info &gt; (3, 5);&quot;</span>
         <span class="s4">&quot;p = os.path.join(sys._getframe(1).f_locals['sitedir'], *('&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s2"># distribute 0.6.10</span>
    <span class="s1">(</span><span class="s4">&quot;import sys,types,os; p = os.path.join(&quot;</span>
         <span class="s4">&quot;sys._getframe(1).f_locals['sitedir'], *('&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s2"># setuptools 0.6c9, distribute 0.6.12</span>
    <span class="s1">(</span><span class="s4">&quot;import sys,new,os; p = os.path.join(sys._getframe(&quot;</span>
         <span class="s4">&quot;1).f_locals['sitedir'], *('&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s2"># setuptools 28.1.0</span>
    <span class="s1">(</span><span class="s4">&quot;import sys, types, os;p = os.path.join(&quot;</span>
         <span class="s4">&quot;sys._getframe(1).f_locals['sitedir'], *('&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s2"># setuptools 28.7.0</span>
    <span class="s1">(</span><span class="s4">&quot;import sys, types, os;pep420 = sys.version_info &gt; (3, 3);&quot;</span>
         <span class="s4">&quot;p = os.path.join(sys._getframe(1).f_locals['sitedir'], *('&quot;</span><span class="s1">)</span><span class="s3">,</span>
<span class="s1">)</span>


<span class="s3">class </span><span class="s1">InvalidRelativeImportError (ImportError):</span>
    <span class="s3">pass</span>


<span class="s3">def </span><span class="s1">_namespace_package_path(fqname</span><span class="s3">, </span><span class="s1">pathnames</span><span class="s3">, </span><span class="s1">path=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the __path__ for the python package in *fqname*. 
 
    This function uses setuptools metadata to extract information 
    about namespace packages from installed eggs. 
    &quot;&quot;&quot;</span>
    <span class="s1">working_set = pkg_resources.WorkingSet(path)</span>

    <span class="s1">path = list(pathnames)</span>

    <span class="s3">for </span><span class="s1">dist </span><span class="s3">in </span><span class="s1">working_set:</span>
        <span class="s3">if </span><span class="s1">dist.has_metadata(</span><span class="s4">'namespace_packages.txt'</span><span class="s1">):</span>
            <span class="s1">namespaces = dist.get_metadata(</span>
                    <span class="s4">'namespace_packages.txt'</span><span class="s1">).splitlines()</span>
            <span class="s3">if </span><span class="s1">fqname </span><span class="s3">in </span><span class="s1">namespaces:</span>
                <span class="s1">nspath = os.path.join(dist.location</span><span class="s3">, </span><span class="s1">*fqname.split(</span><span class="s4">'.'</span><span class="s1">))</span>
                <span class="s3">if </span><span class="s1">nspath </span><span class="s3">not in </span><span class="s1">path:</span>
                    <span class="s1">path.append(nspath)</span>

    <span class="s3">return </span><span class="s1">path</span>

<span class="s1">_strs = re.compile(</span><span class="s4">r'''^\s*[&quot;']([A-Za-z0-9_]+)[&quot;'],?\s*'''</span><span class="s1">)  </span><span class="s2"># &quot;&lt;- emacs happy</span>


<span class="s3">def </span><span class="s1">_eval_str_tuple(value):</span>
    <span class="s0">&quot;&quot;&quot; 
    Input is the repr of a tuple of strings, output 
    is that tuple. 
 
    This only works with a tuple where the members are 
    python identifiers. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">(value.startswith(</span><span class="s4">'('</span><span class="s1">) </span><span class="s3">and </span><span class="s1">value.endswith(</span><span class="s4">')'</span><span class="s1">)):</span>
        <span class="s3">raise </span><span class="s1">ValueError(value)</span>

    <span class="s1">orig_value = value</span>
    <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">result = []</span>
    <span class="s3">while </span><span class="s1">value:</span>
        <span class="s1">m = _strs.match(value)</span>
        <span class="s3">if </span><span class="s1">m </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(orig_value)</span>

        <span class="s1">result.append(m.group(</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">value = value[len(m.group(</span><span class="s5">0</span><span class="s1">)):]</span>

    <span class="s3">return </span><span class="s1">tuple(result)</span>


<span class="s3">def </span><span class="s1">_path_from_importerror(exc</span><span class="s3">, </span><span class="s1">default):</span>
    <span class="s2"># This is a hack, but sadly enough the necessary information</span>
    <span class="s2"># isn't available otherwise.</span>
    <span class="s1">m = re.match(</span><span class="s4">r'^No module named (\S+)$'</span><span class="s3">, </span><span class="s1">str(exc))</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">m.group(</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">default</span>


<span class="s3">def </span><span class="s1">os_listdir(path):</span>
    <span class="s0">&quot;&quot;&quot; 
    Deprecated name 
    &quot;&quot;&quot;</span>
    <span class="s1">warnings.warn(</span>
        <span class="s4">&quot;Use zipio.listdir instead of os_listdir&quot;</span><span class="s3">,</span>
        <span class="s1">DeprecationWarning)</span>
    <span class="s3">return </span><span class="s1">zipio.listdir(path)</span>


<span class="s3">def </span><span class="s1">_code_to_file(co):</span>
    <span class="s0">&quot;&quot;&quot; Convert code object to a .pyc pseudo-file &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s1">):</span>
        <span class="s1">header = imp.get_magic() + (</span><span class="s6">b'</span><span class="s3">\0</span><span class="s6">' </span><span class="s1">* </span><span class="s5">12</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">):</span>
        <span class="s1">header = imp.get_magic() + (</span><span class="s6">b'</span><span class="s3">\0</span><span class="s6">' </span><span class="s1">* </span><span class="s5">8</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">header = imp.get_magic() + (</span><span class="s6">b'</span><span class="s3">\0</span><span class="s6">' </span><span class="s1">* </span><span class="s5">4</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">BytesIO(header + marshal.dumps(co))</span>


<span class="s3">def </span><span class="s1">moduleInfoForPath(path):</span>
    <span class="s3">for </span><span class="s1">(ext</span><span class="s3">, </span><span class="s1">readmode</span><span class="s3">, </span><span class="s1">typ) </span><span class="s3">in </span><span class="s1">imp.get_suffixes():</span>
        <span class="s3">if </span><span class="s1">path.endswith(ext):</span>
            <span class="s3">return </span><span class="s1">os.path.basename(path)[:-len(ext)]</span><span class="s3">, </span><span class="s1">readmode</span><span class="s3">, </span><span class="s1">typ</span>
    <span class="s3">return None</span>


<span class="s3">def </span><span class="s1">AddPackagePath(packagename</span><span class="s3">, </span><span class="s1">path):</span>
    <span class="s1">warnings.warn(</span>
        <span class="s4">&quot;Use addPackagePath instead of AddPackagePath&quot;</span><span class="s3">,</span>
        <span class="s1">DeprecationWarning)</span>
    <span class="s1">addPackagePath(packagename</span><span class="s3">, </span><span class="s1">path)</span>


<span class="s3">def </span><span class="s1">addPackagePath(packagename</span><span class="s3">, </span><span class="s1">path):</span>
    <span class="s1">paths = _packagePathMap.get(packagename</span><span class="s3">, </span><span class="s1">[])</span>
    <span class="s1">paths.append(path)</span>
    <span class="s1">_packagePathMap[packagename] = paths</span>


<span class="s1">_replacePackageMap = {}</span>


<span class="s2"># This ReplacePackage mechanism allows modulefinder to work around the</span>
<span class="s2"># way the _xmlplus package injects itself under the name &quot;xml&quot; into</span>
<span class="s2"># sys.modules at runtime by calling ReplacePackage(&quot;_xmlplus&quot;, &quot;xml&quot;)</span>
<span class="s2"># before running ModuleGraph.</span>
<span class="s3">def </span><span class="s1">ReplacePackage(oldname</span><span class="s3">, </span><span class="s1">newname):</span>
    <span class="s1">warnings.warn(</span><span class="s4">&quot;use replacePackage instead of ReplacePackage&quot;</span><span class="s3">,</span>
            <span class="s1">DeprecationWarning)</span>
    <span class="s1">replacePackage(oldname</span><span class="s3">, </span><span class="s1">newname)</span>


<span class="s3">def </span><span class="s1">replacePackage(oldname</span><span class="s3">, </span><span class="s1">newname):</span>
    <span class="s1">_replacePackageMap[oldname] = newname</span>


<span class="s2">#FIXME: What is this? Do we actually need this? This appears to provide</span>
<span class="s2">#significantly more fine-grained metadata than PyInstaller will ever require.</span>
<span class="s2">#It consumes a great deal of space (slots or no slots), since we store an</span>
<span class="s2">#instance of this class for each edge of the graph.</span>
<span class="s3">class </span><span class="s1">DependencyInfo (namedtuple(</span><span class="s4">&quot;DependencyInfo&quot;</span><span class="s3">,</span>
                      <span class="s1">[</span><span class="s4">&quot;conditional&quot;</span><span class="s3">, </span><span class="s4">&quot;function&quot;</span><span class="s3">, </span><span class="s4">&quot;tryexcept&quot;</span><span class="s3">, </span><span class="s4">&quot;fromlist&quot;</span><span class="s1">])):</span>
    <span class="s1">__slots__ = ()</span>

    <span class="s3">def </span><span class="s1">_merged(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">self.conditional </span><span class="s3">and not </span><span class="s1">self.function </span><span class="s3">and not </span><span class="s1">self.tryexcept) \</span>
           <span class="s3">or </span><span class="s1">(</span><span class="s3">not </span><span class="s1">other.conditional </span><span class="s3">and not </span><span class="s1">other.function </span><span class="s3">and not </span><span class="s1">other.tryexcept):</span>
            <span class="s3">return </span><span class="s1">DependencyInfo(</span>
                <span class="s1">conditional=</span><span class="s3">False,</span>
                <span class="s1">function=</span><span class="s3">False,</span>
                <span class="s1">tryexcept=</span><span class="s3">False,</span>
                <span class="s1">fromlist=self.fromlist </span><span class="s3">and </span><span class="s1">other.fromlist)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">DependencyInfo(</span>
                    <span class="s1">conditional=self.conditional </span><span class="s3">or </span><span class="s1">other.conditional</span><span class="s3">,</span>
                    <span class="s1">function=self.function </span><span class="s3">or </span><span class="s1">other.function</span><span class="s3">,</span>
                    <span class="s1">tryexcept=self.tryexcept </span><span class="s3">or </span><span class="s1">other.tryexcept</span><span class="s3">,</span>
                    <span class="s1">fromlist=self.fromlist </span><span class="s3">and </span><span class="s1">other.fromlist)</span>


<span class="s2">#FIXME: Shift the following Node class hierarchy into a new</span>
<span class="s2">#&quot;PyInstaller.lib.modulegraph.node&quot; module. This module is much too long.</span>
<span class="s2">#FIXME: Refactor &quot;_deferred_imports&quot; from a tuple into a proper lightweight</span>
<span class="s2">#class leveraging &quot;__slots__&quot;. If not for backward compatibility, we'd just</span>
<span class="s2">#leverage a named tuple -- but this should do just as well.</span>
<span class="s2">#FIXME: Move the &quot;packagepath&quot; attribute into the &quot;Package&quot; class. Only</span>
<span class="s2">#packages define the &quot;__path__&quot; special attribute. The codebase currently</span>
<span class="s2">#erroneously tests whether &quot;module.packagepath is not None&quot; to determine</span>
<span class="s2">#whether a node is a package or not. However, &quot;isinstance(module, Package)&quot; is</span>
<span class="s2">#a significantly more reliable test. Refactor the former into the latter.</span>
<span class="s3">class </span><span class="s1">Node(object):</span>
    <span class="s0">&quot;&quot;&quot; 
    Abstract base class (ABC) of all objects added to a `ModuleGraph`. 
 
    Attributes 
    ---------- 
    code : codeobject 
        Code object of the pure-Python module corresponding to this graph node 
        if any _or_ `None` otherwise. 
    graphident : str 
        Synonym of `identifier` required by the `ObjectGraph` superclass of the 
        `ModuleGraph` class. For readability, the `identifier` attribute should 
        typically be used instead. 
    filename : str 
        Absolute path of this graph node's corresponding module, package, or C 
        extension if any _or_ `None` otherwise. 
    identifier : str 
        Fully-qualified name of this graph node's corresponding module, 
        package, or C extension. 
    packagepath : str 
        List of the absolute paths of all directories comprising this graph 
        node's corresponding package. If this is a: 
        * Non-namespace package, this list contains exactly one path. 
        * Namespace package, this list contains one or more paths. 
    _deferred_imports : list 
        List of all target modules imported by the source module corresponding 
        to this graph node whole importations have been deferred for subsequent 
        processing in between calls to the `_ModuleGraph._scan_code()` and 
        `_ModuleGraph._process_imports()` methods for this source module _or_ 
        `None` otherwise. Each element of this list is a 3-tuple 
        `(have_star, _safe_import_hook_args, _safe_import_hook_kwargs)` 
        collecting the importation of a target module from this source module 
        for subsequent processing, where: 
        * `have_star` is a boolean `True` only if this is a `from`-style star 
          import (e.g., resembling `from {target_module_name} import *`). 
        * `_safe_import_hook_args` is a (typically non-empty) sequence of all 
          positional arguments to be passed to the `_safe_import_hook()` method 
          to add this importation to the graph. 
        * `_safe_import_hook_kwargs` is a (typically empty) dictionary of all 
          keyword arguments to be passed to the `_safe_import_hook()` method 
          to add this importation to the graph. 
        Unlike functional languages, Python imposes a maximum depth on the 
        interpreter stack (and hence recursion). On breaching this depth, 
        Python raises a fatal `RuntimeError` exception. Since `ModuleGraph` 
        parses imports recursively rather than iteratively, this depth _was_ 
        commonly breached before the introduction of this list. Python 
        environments installing a large number of modules (e.g., Anaconda) were 
        particularly susceptible. Why? Because `ModuleGraph` concurrently 
        descended through both the abstract syntax trees (ASTs) of all source 
        modules being parsed _and_ the graph of all target modules imported by 
        these source modules being built. The stack thus consisted of 
        alternating layers of AST and graph traversal. To unwind such 
        alternation and effectively halve the stack depth, `ModuleGraph` now 
        descends through the abstract syntax tree (AST) of each source module 
        being parsed and adds all importations originating within this module 
        to this list _before_ descending into the graph of these importations. 
        See pyinstaller/pyinstaller/#1289 for further details. 
    _global_attr_names : set 
        Set of the unqualified names of all global attributes (e.g., classes, 
        variables) defined in the pure-Python module corresponding to this 
        graph node if any _or_ the empty set otherwise. This includes the names 
        of all attributes imported via `from`-style star imports from other 
        existing modules (e.g., `from {target_module_name} import *`). This 
        set is principally used to differentiate the non-ignorable importation 
        of non-existent submodules in a package from the ignorable importation 
        of existing global attributes defined in that package's pure-Python 
        `__init__` submodule in `from`-style imports (e.g., `bar` in 
        `from foo import bar`, which may be either a submodule or attribute of 
        `foo`), as such imports ambiguously allow both. This set is _not_ used 
        to differentiate submodules from attributes in `import`-style imports 
        (e.g., `bar` in `import foo.bar`, which _must_ be a submodule of 
        `foo`), as such imports unambiguously allow only submodules. 
    _starimported_ignored_module_names : set 
        Set of the fully-qualified names of all existing unparsable modules 
        that the existing parsable module corresponding to this graph node 
        attempted to perform one or more &quot;star imports&quot; from. If this module 
        either does _not_ exist or does but is unparsable, this is the empty 
        set. Equivalently, this set contains each fully-qualified name 
        `{trg_module_name}` for which: 
        * This module contains an import statement of the form 
          `from {trg_module_name} import *`. 
        * The module whose name is `{trg_module_name}` exists but is _not_ 
          parsable by `ModuleGraph` (e.g., due to _not_ being pure-Python). 
        **This set is currently defined but otherwise ignored.** 
    _submodule_basename_to_node : dict 
        Dictionary mapping from the unqualified name of each submodule 
        contained by the parent module corresponding to this graph node to that 
        submodule's graph node. If this dictionary is non-empty, this parent 
        module is typically but _not_ always a package (e.g., the non-package 
        `os` module containing the `os.path` submodule). 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = [</span>
        <span class="s4">'code'</span><span class="s3">,</span>
        <span class="s4">'filename'</span><span class="s3">,</span>
        <span class="s4">'graphident'</span><span class="s3">,</span>
        <span class="s4">'identifier'</span><span class="s3">,</span>
        <span class="s4">'packagepath'</span><span class="s3">,</span>
        <span class="s4">'_deferred_imports'</span><span class="s3">,</span>
        <span class="s4">'_global_attr_names'</span><span class="s3">,</span>
        <span class="s4">'_starimported_ignored_module_names'</span><span class="s3">,</span>
        <span class="s4">'_submodule_basename_to_node'</span><span class="s3">,</span>
    <span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">identifier):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize this graph node. 
 
        Parameters 
        ---------- 
        identifier : str 
            Fully-qualified name of this graph node's corresponding module, 
            package, or C extension. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.code = </span><span class="s3">None</span>
        <span class="s1">self.filename = </span><span class="s3">None</span>
        <span class="s1">self.graphident = identifier</span>
        <span class="s1">self.identifier = identifier</span>
        <span class="s1">self.packagepath = </span><span class="s3">None</span>
        <span class="s1">self._deferred_imports = </span><span class="s3">None</span>
        <span class="s1">self._global_attr_names = set()</span>
        <span class="s1">self._starimported_ignored_module_names = set()</span>
        <span class="s1">self._submodule_basename_to_node = dict()</span>


    <span class="s3">def </span><span class="s1">is_global_attr(self</span><span class="s3">, </span><span class="s1">attr_name):</span>
        <span class="s0">&quot;&quot;&quot; 
        `True` only if the pure-Python module corresponding to this graph node 
        defines a global attribute (e.g., class, variable) with the passed 
        name. 
 
        If this module is actually a package, this method instead returns 
        `True` only if this package's pure-Python `__init__` submodule defines 
        such a global attribute. In this case, note that this package may still 
        contain an importable submodule of the same name. Callers should 
        attempt to import this attribute as a submodule of this package 
        _before_ assuming this attribute to be an ignorable global. See 
        &quot;Examples&quot; below for further details. 
 
        Parameters 
        ---------- 
        attr_name : str 
            Unqualified name of the attribute to be tested. 
 
        Returns 
        ---------- 
        bool 
            `True` only if this module defines this global attribute. 
 
        Examples 
        ---------- 
        Consider a hypothetical module `foo` containing submodules `bar` and 
        `__init__` where the latter assigns `bar` to be a global variable 
        (possibly star-exported via the special `__all__` global variable): 
 
        &gt;&gt;&gt; # In &quot;foo.__init__&quot;: 
        &gt;&gt;&gt; bar = 3.1415 
 
        Python 2 and 3 both permissively permit this. This method returns 
        `True` in this case (i.e., when called on the `foo` package's graph 
        node, passed the attribute name `bar`) despite the importability of the 
        `foo.bar` submodule. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">attr_name </span><span class="s3">in </span><span class="s1">self._global_attr_names</span>


    <span class="s3">def </span><span class="s1">is_submodule(self</span><span class="s3">, </span><span class="s1">submodule_basename):</span>
        <span class="s0">&quot;&quot;&quot; 
        `True` only if the parent module corresponding to this graph node 
        contains the submodule with the passed name. 
 
        If `True`, this parent module is typically but _not_ always a package 
        (e.g., the non-package `os` module containing the `os.path` submodule). 
 
        Parameters 
        ---------- 
        submodule_basename : str 
            Unqualified name of the submodule to be tested. 
 
        Returns 
        ---------- 
        bool 
            `True` only if this parent module contains this submodule. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">submodule_basename </span><span class="s3">in </span><span class="s1">self._submodule_basename_to_node</span>


    <span class="s3">def </span><span class="s1">add_global_attr(self</span><span class="s3">, </span><span class="s1">attr_name):</span>
        <span class="s0">&quot;&quot;&quot; 
        Record the global attribute (e.g., class, variable) with the passed 
        name to be defined by the pure-Python module corresponding to this 
        graph node. 
 
        If this module is actually a package, this method instead records this 
        attribute to be defined by this package's pure-Python `__init__` 
        submodule. 
 
        Parameters 
        ---------- 
        attr_name : str 
            Unqualified name of the attribute to be added. 
        &quot;&quot;&quot;</span>

        <span class="s1">self._global_attr_names.add(attr_name)</span>


    <span class="s3">def </span><span class="s1">add_global_attrs_from_module(self</span><span class="s3">, </span><span class="s1">target_module):</span>
        <span class="s0">&quot;&quot;&quot; 
        Record all global attributes (e.g., classes, variables) defined by the 
        target module corresponding to the passed graph node to also be defined 
        by the source module corresponding to this graph node. 
 
        If the source module is actually a package, this method instead records 
        these attributes to be defined by this package's pure-Python `__init__` 
        submodule. 
 
        Parameters 
        ---------- 
        target_module : Node 
            Graph node of the target module to import attributes from. 
        &quot;&quot;&quot;</span>

        <span class="s1">self._global_attr_names.update(target_module._global_attr_names)</span>


    <span class="s3">def </span><span class="s1">add_submodule(self</span><span class="s3">, </span><span class="s1">submodule_basename</span><span class="s3">, </span><span class="s1">submodule_node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add the submodule with the passed name and previously imported graph 
        node to the parent module corresponding to this graph node. 
 
        This parent module is typically but _not_ always a package (e.g., the 
        non-package `os` module containing the `os.path` submodule). 
 
        Parameters 
        ---------- 
        submodule_basename : str 
            Unqualified name of the submodule to add to this parent module. 
        submodule_node : Node 
            Graph node of this submodule. 
        &quot;&quot;&quot;</span>

        <span class="s1">self._submodule_basename_to_node[submodule_basename] = submodule_node</span>


    <span class="s3">def </span><span class="s1">get_submodule(self</span><span class="s3">, </span><span class="s1">submodule_basename):</span>
        <span class="s0">&quot;&quot;&quot; 
        Graph node of the submodule with the passed name in the parent module 
        corresponding to this graph node. 
 
        If this parent module does _not_ contain this submodule, an exception 
        is raised. Else, this parent module is typically but _not_ always a 
        package (e.g., the non-package `os` module containing the `os.path` 
        submodule). 
 
        Parameters 
        ---------- 
        module_basename : str 
            Unqualified name of the submodule to retrieve. 
 
        Returns 
        ---------- 
        Node 
            Graph node of this submodule. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self._submodule_basename_to_node[submodule_basename]</span>


    <span class="s3">def </span><span class="s1">get_submodule_or_none(self</span><span class="s3">, </span><span class="s1">submodule_basename):</span>
        <span class="s0">&quot;&quot;&quot; 
        Graph node of the submodule with the passed unqualified name in the 
        parent module corresponding to this graph node if this module contains 
        this submodule _or_ `None`. 
 
        This parent module is typically but _not_ always a package (e.g., the 
        non-package `os` module containing the `os.path` submodule). 
 
        Parameters 
        ---------- 
        submodule_basename : str 
            Unqualified name of the submodule to retrieve. 
 
        Returns 
        ---------- 
        Node 
            Graph node of this submodule if this parent module contains this 
            submodule _or_ `None`. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self._submodule_basename_to_node.get(submodule_basename)</span>


    <span class="s3">def </span><span class="s1">remove_global_attr_if_found(self</span><span class="s3">, </span><span class="s1">attr_name):</span>
        <span class="s0">&quot;&quot;&quot; 
        Record the global attribute (e.g., class, variable) with the passed 
        name if previously recorded as defined by the pure-Python module 
        corresponding to this graph node to be subsequently undefined by the 
        same module. 
 
        If this module is actually a package, this method instead records this 
        attribute to be undefined by this package's pure-Python `__init__` 
        submodule. 
 
        This method is intended to be called on globals previously defined by 
        this module that are subsequently undefined via the `del` built-in by 
        this module, thus &quot;forgetting&quot; or &quot;undoing&quot; these globals. 
 
        For safety, there exists no corresponding `remove_global_attr()` 
        method. While defining this method is trivial, doing so would invite 
        `KeyError` exceptions on scanning valid Python that lexically deletes a 
        global in a scope under this module's top level (e.g., in a function) 
        _before_ defining this global at this top level. Since `ModuleGraph` 
        cannot and should not (re)implement a full-blown Python interpreter, 
        ignoring out-of-order deletions is the only sane policy. 
 
        Parameters 
        ---------- 
        attr_name : str 
            Unqualified name of the attribute to be removed. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self.is_global_attr(attr_name):</span>
            <span class="s1">self._global_attr_names.remove(attr_name)</span>


    <span class="s3">def </span><span class="s1">__cmp__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">otherIdent = getattr(other</span><span class="s3">, </span><span class="s4">'graphident'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">cmp(self.graphident</span><span class="s3">, </span><span class="s1">otherIdent)  </span><span class="s2"># noqa: F821</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">otherIdent = getattr(other</span><span class="s3">, </span><span class="s4">'graphident'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">return False</span>

        <span class="s3">return </span><span class="s1">self.graphident == otherIdent</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">otherIdent = getattr(other</span><span class="s3">, </span><span class="s4">'graphident'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">return True</span>

        <span class="s3">return </span><span class="s1">self.graphident != otherIdent</span>

    <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">otherIdent = getattr(other</span><span class="s3">, </span><span class="s4">'graphident'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">self.graphident &lt; otherIdent</span>

    <span class="s3">def </span><span class="s1">__le__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">otherIdent = getattr(other</span><span class="s3">, </span><span class="s4">'graphident'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">self.graphident &lt;= otherIdent</span>

    <span class="s3">def </span><span class="s1">__gt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">otherIdent = getattr(other</span><span class="s3">, </span><span class="s4">'graphident'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">self.graphident &gt; otherIdent</span>

    <span class="s3">def </span><span class="s1">__ge__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">otherIdent = getattr(other</span><span class="s3">, </span><span class="s4">'graphident'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">self.graphident &gt;= otherIdent</span>

    <span class="s3">def </span><span class="s1">__hash__(self):</span>
        <span class="s3">return </span><span class="s1">hash(self.graphident)</span>

    <span class="s3">def </span><span class="s1">infoTuple(self):</span>
        <span class="s3">return </span><span class="s1">(self.identifier</span><span class="s3">,</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">'%s%r' </span><span class="s1">% (type(self).__name__</span><span class="s3">, </span><span class="s1">self.infoTuple())</span>


<span class="s2"># TODO: This indirection is, frankly, unnecessary. The</span>
<span class="s2"># ModuleGraph.alias_module() should directly add the desired AliasNode instance</span>
<span class="s2"># to the graph rather than indirectly adding an Alias instance to the</span>
<span class="s2"># &quot;lazynodes&quot; dictionary.</span>
<span class="s3">class </span><span class="s1">Alias(str):</span>
    <span class="s0">&quot;&quot;&quot; 
    Placeholder aliasing an existing source module to a non-existent target 
    module (i.e., the desired alias). 
 
    For obscure reasons, this class subclasses `str`. Each instance of this 
    class is the fully-qualified name of the existing source module being 
    aliased. Unlike the related `AliasNode` class, instances of this class are 
    _not_ actual nodes and hence _not_ added to the graph; they only facilitate 
    communication between the `ModuleGraph.alias_module()` and 
    `ModuleGraph.find_node()` methods. 
    &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">AliasNode(Node):</span>
    <span class="s0">&quot;&quot;&quot; 
    Graph node representing the aliasing of an existing source module under a 
    non-existent target module name (i.e., the desired alias). 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize this alias. 
 
        Parameters 
        ---------- 
        name : str 
            Fully-qualified name of the non-existent target module to be 
            created (as an alias of the existing source module). 
        node : Node 
            Graph node of the existing source module being aliased. 
        &quot;&quot;&quot;</span>
        <span class="s1">super(AliasNode</span><span class="s3">, </span><span class="s1">self).__init__(name)</span>

        <span class="s2">#FIXME: Why only some? Why not *EVERYTHING* except &quot;graphident&quot;, which</span>
        <span class="s2">#must remain equal to &quot;name&quot; for lookup purposes? This is, after all,</span>
        <span class="s2">#an alias. The idea is for the two nodes to effectively be the same.</span>

        <span class="s2"># Copy some attributes from this source module into this target alias.</span>
        <span class="s3">for </span><span class="s1">attr_name </span><span class="s3">in </span><span class="s1">(</span>
            <span class="s4">'identifier'</span><span class="s3">, </span><span class="s4">'packagepath'</span><span class="s3">,</span>
            <span class="s4">'_global_attr_names'</span><span class="s3">, </span><span class="s4">'_starimported_ignored_module_names'</span><span class="s3">,</span>
            <span class="s4">'_submodule_basename_to_node'</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">hasattr(node</span><span class="s3">, </span><span class="s1">attr_name):</span>
                <span class="s1">setattr(self</span><span class="s3">, </span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">getattr(node</span><span class="s3">, </span><span class="s1">attr_name))</span>


    <span class="s3">def </span><span class="s1">infoTuple(self):</span>
        <span class="s3">return </span><span class="s1">(self.graphident</span><span class="s3">, </span><span class="s1">self.identifier)</span>


<span class="s3">class </span><span class="s1">BadModule(Node):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">ExcludedModule(BadModule):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">MissingModule(BadModule):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">InvalidRelativeImport (BadModule):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">relative_path</span><span class="s3">, </span><span class="s1">from_name):</span>
        <span class="s1">identifier = relative_path</span>
        <span class="s3">if </span><span class="s1">relative_path.endswith(</span><span class="s4">'.'</span><span class="s1">):</span>
            <span class="s1">identifier += from_name</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">identifier += </span><span class="s4">'.' </span><span class="s1">+ from_name</span>
        <span class="s1">super(InvalidRelativeImport</span><span class="s3">, </span><span class="s1">self).__init__(identifier)</span>
        <span class="s1">self.relative_path = relative_path</span>
        <span class="s1">self.from_name = from_name</span>

    <span class="s3">def </span><span class="s1">infoTuple(self):</span>
        <span class="s3">return </span><span class="s1">(self.relative_path</span><span class="s3">, </span><span class="s1">self.from_name)</span>


<span class="s3">class </span><span class="s1">Script(Node):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">filename):</span>
        <span class="s1">super(Script</span><span class="s3">, </span><span class="s1">self).__init__(filename)</span>
        <span class="s1">self.filename = filename</span>

    <span class="s3">def </span><span class="s1">infoTuple(self):</span>
        <span class="s3">return </span><span class="s1">(self.filename</span><span class="s3">,</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">BaseModule(Node):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">filename=</span><span class="s3">None, </span><span class="s1">path=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super(BaseModule</span><span class="s3">, </span><span class="s1">self).__init__(name)</span>
        <span class="s1">self.filename = filename</span>
        <span class="s1">self.packagepath = path</span>

    <span class="s3">def </span><span class="s1">infoTuple(self):</span>
        <span class="s3">return </span><span class="s1">tuple(filter(</span><span class="s3">None, </span><span class="s1">(self.identifier</span><span class="s3">, </span><span class="s1">self.filename</span><span class="s3">, </span><span class="s1">self.packagepath)))</span>


<span class="s3">class </span><span class="s1">BuiltinModule(BaseModule):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">SourceModule(BaseModule):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">InvalidSourceModule(SourceModule):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">CompiledModule(BaseModule):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">InvalidCompiledModule(BaseModule):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">Extension(BaseModule):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">Package(BaseModule):</span>
    <span class="s0">&quot;&quot;&quot; 
    Graph node representing a non-namespace package. 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">ExtensionPackage(Extension</span><span class="s3">, </span><span class="s1">Package):</span>
    <span class="s0">&quot;&quot;&quot; 
    Graph node representing a package where the __init__ module is an extension 
    module. 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">NamespacePackage(Package):</span>
    <span class="s0">&quot;&quot;&quot; 
    Graph node representing a namespace package. 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">RuntimeModule(BaseModule):</span>
    <span class="s0">&quot;&quot;&quot; 
    Graph node representing a non-package Python module dynamically defined at 
    runtime. 
 
    Most modules are statically defined on-disk as standard Python files. 
    Some modules, however, are dynamically defined in-memory at runtime 
    (e.g., `gi.repository.Gst`, dynamically defined by the statically 
    defined `gi.repository.__init__` module). 
 
    This node represents such a runtime module. Since this is _not_ a package, 
    all attempts to import submodules from this module in `from`-style import 
    statements (e.g., the `queue` submodule in `from six.moves import queue`) 
    will be silently ignored. 
 
    To ensure that the parent package of this module if any is also imported 
    and added to the graph, this node is typically added to the graph by 
    calling the `ModuleGraph.add_module()` method. 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">RuntimePackage(Package):</span>
    <span class="s0">&quot;&quot;&quot; 
    Graph node representing a non-namespace Python package dynamically defined 
    at runtime. 
 
    Most packages are statically defined on-disk as standard subdirectories 
    containing `__init__.py` files. Some packages, however, are dynamically 
    defined in-memory at runtime (e.g., `six.moves`, dynamically defined by 
    the statically defined `six` module). 
 
    This node represents such a runtime package. All attributes imported from 
    this package in `from`-style import statements that are submodules of this 
    package (e.g., the `queue` submodule in `from six.moves import queue`) will 
    be imported rather than ignored. 
 
    To ensure that the parent package of this package if any is also imported 
    and added to the graph, this node is typically added to the graph by 
    calling the `ModuleGraph.add_module()` method. 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s2">#FIXME: Safely removable. We don't actually use this anywhere. After removing</span>
<span class="s2">#this class, remove the corresponding entry from &quot;compat&quot;.</span>
<span class="s3">class </span><span class="s1">FlatPackage(BaseModule):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwds):</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;This class will be removed in a future version of modulegraph&quot;</span><span class="s3">,</span>
            <span class="s1">DeprecationWarning)</span>
        <span class="s1">super(FlatPackage</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwds)</span>


<span class="s2">#FIXME: Safely removable. We don't actually use this anywhere. After removing</span>
<span class="s2">#this class, remove the corresponding entry from &quot;compat&quot;.</span>
<span class="s3">class </span><span class="s1">ArchiveModule(BaseModule):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwds):</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;This class will be removed in a future version of modulegraph&quot;</span><span class="s3">,</span>
            <span class="s1">DeprecationWarning)</span>
        <span class="s1">super(FlatPackage</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwds)</span>


<span class="s2"># HTML templates for ModuleGraph generator</span>
<span class="s1">header = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
  &lt;head&gt; 
    &lt;meta charset=&quot;UTF-8&quot;&gt; 
    &lt;title&gt;%(TITLE)s&lt;/title&gt; 
    &lt;style&gt; 
      .node { padding: 0.5em 0 0.5em; border-top: thin grey dotted; } 
      .moduletype { font: smaller italic } 
      .node a { text-decoration: none; color: #006699; } 
      .node a:visited { text-decoration: none; color: #2f0099; } 
    &lt;/style&gt; 
  &lt;/head&gt; 
  &lt;body&gt; 
    &lt;h1&gt;%(TITLE)s&lt;/h1&gt;&quot;&quot;&quot;</span>
<span class="s1">entry = </span><span class="s4">&quot;&quot;&quot; 
&lt;div class=&quot;node&quot;&gt; 
  &lt;a name=&quot;%(NAME)s&quot;&gt;&lt;/a&gt; 
  %(CONTENT)s 
&lt;/div&gt;&quot;&quot;&quot;</span>
<span class="s1">contpl = </span><span class="s4">&quot;&quot;&quot;&lt;tt&gt;%(NAME)s&lt;/tt&gt; &lt;span class=&quot;moduletype&quot;&gt;%(TYPE)s&lt;/span&gt;&quot;&quot;&quot;</span>
<span class="s1">contpl_linked = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s4">&lt;a target=&quot;code&quot; href=&quot;%(URL)s&quot; type=&quot;text/plain&quot;&gt;&lt;tt&gt;%(NAME)s&lt;/tt&gt;&lt;/a&gt; 
&lt;span class=&quot;moduletype&quot;&gt;%(TYPE)s&lt;/span&gt;&quot;&quot;&quot;</span>
<span class="s1">imports = </span><span class="s4">&quot;&quot;&quot;</span><span class="s3">\ 
  </span><span class="s4">&lt;div class=&quot;import&quot;&gt; 
%(HEAD)s: 
  %(LINKS)s 
  &lt;/div&gt; 
&quot;&quot;&quot;</span>
<span class="s1">footer = </span><span class="s4">&quot;&quot;&quot; 
  &lt;/body&gt; 
&lt;/html&gt;&quot;&quot;&quot;</span>


<span class="s3">def </span><span class="s1">_ast_names(names):</span>
    <span class="s1">result = []</span>
    <span class="s3">for </span><span class="s1">nm </span><span class="s3">in </span><span class="s1">names:</span>
        <span class="s3">if </span><span class="s1">isinstance(nm</span><span class="s3">, </span><span class="s1">ast.alias):</span>
            <span class="s1">result.append(nm.name)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">result.append(nm)</span>

    <span class="s1">result = [r </span><span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">result </span><span class="s3">if </span><span class="s1">r != </span><span class="s4">'__main__'</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">uniq(seq):</span>
    <span class="s0">&quot;&quot;&quot;Remove duplicates from a list, preserving order&quot;&quot;&quot;</span>
    <span class="s2"># Taken from https://stackoverflow.com/questions/480214</span>
    <span class="s1">seen = set()</span>
    <span class="s1">seen_add = seen.add</span>
    <span class="s3">return </span><span class="s1">[x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">seq </span><span class="s3">if not </span><span class="s1">(x </span><span class="s3">in </span><span class="s1">seen </span><span class="s3">or </span><span class="s1">seen_add(x))]</span>


<span class="s3">if </span><span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">2</span><span class="s1">:</span>
    <span class="s1">DEFAULT_IMPORT_LEVEL = -</span><span class="s5">1</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">DEFAULT_IMPORT_LEVEL = </span><span class="s5">0</span>


<span class="s3">class </span><span class="s1">_Visitor(ast.NodeVisitor):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">graph</span><span class="s3">, </span><span class="s1">module):</span>
        <span class="s1">self._graph = graph</span>
        <span class="s1">self._module = module</span>
        <span class="s1">self._level = DEFAULT_IMPORT_LEVEL</span>
        <span class="s1">self._in_if = [</span><span class="s3">False</span><span class="s1">]</span>
        <span class="s1">self._in_def = [</span><span class="s3">False</span><span class="s1">]</span>
        <span class="s1">self._in_tryexcept = [</span><span class="s3">False</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">in_if(self):</span>
        <span class="s3">return </span><span class="s1">self._in_if[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">in_def(self):</span>
        <span class="s3">return </span><span class="s1">self._in_def[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">in_tryexcept(self):</span>
        <span class="s3">return </span><span class="s1">self._in_tryexcept[-</span><span class="s5">1</span><span class="s1">]</span>


    <span class="s3">def </span><span class="s1">_collect_import(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">fromlist</span><span class="s3">, </span><span class="s1">level):</span>
        <span class="s3">if </span><span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">name == </span><span class="s4">'__future__' </span><span class="s3">and </span><span class="s4">'absolute_import' </span><span class="s3">in </span><span class="s1">(fromlist </span><span class="s3">or </span><span class="s1">()):</span>
                <span class="s1">self._level = </span><span class="s5">0</span>

        <span class="s1">have_star = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">fromlist </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">fromlist = uniq(fromlist)</span>
            <span class="s3">if </span><span class="s4">'*' </span><span class="s3">in </span><span class="s1">fromlist:</span>
                <span class="s1">fromlist.remove(</span><span class="s4">'*'</span><span class="s1">)</span>
                <span class="s1">have_star = </span><span class="s3">True</span>

        <span class="s2"># Record this import as originating from this module for subsequent</span>
        <span class="s2"># handling by the _process_imports() method.</span>
        <span class="s1">self._module._deferred_imports.append(</span>
            <span class="s1">(have_star</span><span class="s3">,</span>
             <span class="s1">(name</span><span class="s3">, </span><span class="s1">self._module</span><span class="s3">, </span><span class="s1">fromlist</span><span class="s3">, </span><span class="s1">level)</span><span class="s3">,</span>
             <span class="s1">{</span><span class="s4">'edge_attr'</span><span class="s1">: DependencyInfo(</span>
                 <span class="s1">conditional=self.in_if</span><span class="s3">,</span>
                 <span class="s1">tryexcept=self.in_tryexcept</span><span class="s3">,</span>
                 <span class="s1">function=self.in_def</span><span class="s3">,</span>
                 <span class="s1">fromlist=</span><span class="s3">False</span><span class="s1">)}))</span>


    <span class="s3">def </span><span class="s1">visit_Import(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s3">for </span><span class="s1">nm </span><span class="s3">in </span><span class="s1">_ast_names(node.names):</span>
            <span class="s1">self._collect_import(nm</span><span class="s3">, None, </span><span class="s1">self._level)</span>

    <span class="s3">def </span><span class="s1">visit_ImportFrom(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">level = node.level </span><span class="s3">if </span><span class="s1">node.level != </span><span class="s5">0 </span><span class="s3">else </span><span class="s1">self._level</span>
        <span class="s1">self._collect_import(node.module </span><span class="s3">or </span><span class="s4">''</span><span class="s3">, </span><span class="s1">_ast_names(node.names)</span><span class="s3">, </span><span class="s1">level)</span>

    <span class="s3">def </span><span class="s1">visit_If(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self._in_if.append(</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">self.generic_visit(node)</span>
        <span class="s1">self._in_if.pop()</span>

    <span class="s3">def </span><span class="s1">visit_FunctionDef(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self._in_def.append(</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">self.generic_visit(node)</span>
        <span class="s1">self._in_def.pop()</span>

    <span class="s1">visit_AsyncFunctionDef = visit_FunctionDef</span>

    <span class="s3">def </span><span class="s1">visit_Try(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self._in_tryexcept.append(</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">self.generic_visit(node)</span>
        <span class="s1">self._in_tryexcept.pop()</span>

    <span class="s3">def </span><span class="s1">visit_TryExcept(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self._in_tryexcept.append(</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">self.generic_visit(node)</span>
        <span class="s1">self._in_tryexcept.pop()</span>

    <span class="s3">def </span><span class="s1">visit_Expression(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s2"># Expression node's cannot contain import statements or</span>
        <span class="s2"># other nodes that are relevant for us.</span>
        <span class="s3">pass</span>

    <span class="s2"># Expression isn't actually used as such in AST trees,</span>
    <span class="s2"># therefore define visitors for all kinds of expression nodes.</span>
    <span class="s1">visit_BoolOp = visit_Expression</span>
    <span class="s1">visit_BinOp = visit_Expression</span>
    <span class="s1">visit_UnaryOp = visit_Expression</span>
    <span class="s1">visit_Lambda = visit_Expression</span>
    <span class="s1">visit_IfExp = visit_Expression</span>
    <span class="s1">visit_Dict = visit_Expression</span>
    <span class="s1">visit_Set = visit_Expression</span>
    <span class="s1">visit_ListComp = visit_Expression</span>
    <span class="s1">visit_SetComp = visit_Expression</span>
    <span class="s1">visit_ListComp = visit_Expression</span>
    <span class="s1">visit_GeneratorExp = visit_Expression</span>
    <span class="s1">visit_Compare = visit_Expression</span>
    <span class="s1">visit_Yield = visit_Expression</span>
    <span class="s1">visit_YieldFrom = visit_Expression</span>
    <span class="s1">visit_Await = visit_Expression</span>
    <span class="s1">visit_Call = visit_Expression</span>
    <span class="s1">visit_Await = visit_Expression</span>


<span class="s3">class </span><span class="s1">ModuleGraph(ObjectGraph):</span>
    <span class="s0">&quot;&quot;&quot; 
    Directed graph whose nodes represent modules and edges represent 
    dependencies between these modules. 
    &quot;&quot;&quot;</span>


    <span class="s3">def </span><span class="s1">createNode(self</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s1">m = self.find_node(name)</span>

        <span class="s3">if </span><span class="s1">m </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s2">#assert m is None, m</span>
            <span class="s1">m = super(ModuleGraph</span><span class="s3">, </span><span class="s1">self).createNode(cls</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw)</span>

        <span class="s3">return </span><span class="s1">m</span>


    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">path=</span><span class="s3">None, </span><span class="s1">excludes=()</span><span class="s3">, </span><span class="s1">replace_paths=()</span><span class="s3">, </span><span class="s1">implies=()</span><span class="s3">, </span><span class="s1">graph=</span><span class="s3">None, </span><span class="s1">debug=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">super(ModuleGraph</span><span class="s3">, </span><span class="s1">self).__init__(graph=graph</span><span class="s3">, </span><span class="s1">debug=debug)</span>
        <span class="s3">if </span><span class="s1">path </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">path = sys.path</span>
        <span class="s1">self.path = path</span>
        <span class="s1">self.lazynodes = {}</span>
        <span class="s2"># excludes is stronger than implies</span>
        <span class="s1">self.lazynodes.update(dict(implies))</span>
        <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">excludes:</span>
            <span class="s1">self.lazynodes[m] = </span><span class="s3">None</span>
        <span class="s1">self.replace_paths = replace_paths</span>

        <span class="s1">self.set_setuptools_nspackages()</span>
        <span class="s2"># Maintain own list of package path mappings in the scope of Modulegraph</span>
        <span class="s2"># object.</span>
        <span class="s1">self._package_path_map = _packagePathMap</span>

    <span class="s3">def </span><span class="s1">set_setuptools_nspackages(self):</span>
        <span class="s2"># This is used when running in the test-suite</span>
        <span class="s1">self.nspackages = self._calc_setuptools_nspackages()</span>

    <span class="s3">def </span><span class="s1">_calc_setuptools_nspackages(self):</span>
        <span class="s2"># Setuptools has some magic handling for namespace</span>
        <span class="s2"># packages when using 'install --single-version-externally-managed'</span>
        <span class="s2"># (used by system packagers and also by pip)</span>
        <span class="s2">#</span>
        <span class="s2"># When this option is used namespace packages are writting to</span>
        <span class="s2"># disk *without* an __init__.py file, which means the regular</span>
        <span class="s2"># import machinery will not find them.</span>
        <span class="s2">#</span>
        <span class="s2"># We therefore explicitly look for the hack used by</span>
        <span class="s2"># setuptools to get this kind of namespace packages to work.</span>

        <span class="s1">pkgmap = {}</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">from </span><span class="s1">pkgutil </span><span class="s3">import </span><span class="s1">ImpImporter</span>
        <span class="s3">except </span><span class="s1">ImportError:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">from </span><span class="s1">_pkgutil </span><span class="s3">import </span><span class="s1">ImpImporter</span>
            <span class="s3">except </span><span class="s1">ImportError:</span>
                <span class="s1">ImpImporter = pkg_resources.ImpWrapper</span>

        <span class="s3">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">):</span>
            <span class="s3">import </span><span class="s1">importlib.machinery</span>
            <span class="s1">ImpImporter = importlib.machinery.FileFinder</span>

        <span class="s3">for </span><span class="s1">entry </span><span class="s3">in </span><span class="s1">self.path:</span>
            <span class="s1">importer = pkg_resources.get_importer(entry)</span>

            <span class="s3">if </span><span class="s1">isinstance(importer</span><span class="s3">, </span><span class="s1">ImpImporter):</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">ldir = os.listdir(entry)</span>
                <span class="s3">except </span><span class="s1">os.error:</span>
                    <span class="s3">continue</span>

                <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">ldir:</span>
                    <span class="s3">if </span><span class="s1">fn.endswith(</span><span class="s4">'-nspkg.pth'</span><span class="s1">):</span>
                        <span class="s3">with </span><span class="s1">open(os.path.join(entry</span><span class="s3">, </span><span class="s1">fn)</span><span class="s3">, </span><span class="s1">_READ_MODE) </span><span class="s3">as </span><span class="s1">fp:</span>
                            <span class="s3">for </span><span class="s1">ln </span><span class="s3">in </span><span class="s1">fp:</span>
                                <span class="s3">for </span><span class="s1">pfx </span><span class="s3">in </span><span class="s1">_SETUPTOOLS_NAMESPACEPKG_PTHs:</span>
                                    <span class="s3">if </span><span class="s1">ln.startswith(pfx):</span>
                                        <span class="s3">try</span><span class="s1">:</span>
                                            <span class="s1">start = len(pfx)-</span><span class="s5">2</span>
                                            <span class="s1">stop = ln.index(</span><span class="s4">')'</span><span class="s3">, </span><span class="s1">start)+</span><span class="s5">1</span>
                                        <span class="s3">except </span><span class="s1">ValueError:</span>
                                            <span class="s3">continue</span>

                                        <span class="s1">pkg = _eval_str_tuple(ln[start:stop])</span>
                                        <span class="s1">identifier = </span><span class="s4">&quot;.&quot;</span><span class="s1">.join(pkg)</span>
                                        <span class="s1">subdir = os.path.join(entry</span><span class="s3">, </span><span class="s1">*pkg)</span>
                                        <span class="s3">if </span><span class="s1">os.path.exists(os.path.join(subdir</span><span class="s3">, </span><span class="s4">'__init__.py'</span><span class="s1">)):</span>
                                            <span class="s2"># There is a real __init__.py,</span>
                                            <span class="s2"># ignore the setuptools hack</span>
                                            <span class="s3">continue</span>

                                        <span class="s3">if </span><span class="s1">identifier </span><span class="s3">in </span><span class="s1">pkgmap:</span>
                                            <span class="s1">pkgmap[identifier].append(subdir)</span>
                                        <span class="s3">else</span><span class="s1">:</span>
                                            <span class="s1">pkgmap[identifier] = [subdir]</span>
                                        <span class="s3">break</span>

        <span class="s3">return </span><span class="s1">pkgmap</span>

    <span class="s3">def </span><span class="s1">implyNodeReference(self</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">edge_data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a reference from the passed source node to the passed other node, 
        implying the former to depend upon the latter. 
 
        While the source node _must_ be an existing graph node, the target node 
        may be either an existing graph node _or_ a fully-qualified module name. 
        In the latter case, the module with that name and all parent packages of 
        that module will be imported _without_ raising exceptions and for each 
        newly imported module or package: 
 
        * A new graph node will be created for that module or package. 
        * A reference from the passed source node to that module or package will 
          be created. 
 
        This method allows dependencies between Python objects _not_ importable 
        with standard techniques (e.g., module aliases, C extensions). 
 
        Parameters 
        ---------- 
        node : str 
            Graph node for this reference's source module or package. 
        other : {Node, str} 
            Either a graph node _or_ fully-qualified name for this reference's 
            target module or package. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Node):</span>
            <span class="s1">self._updateReference(node</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">edge_data)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">tuple):</span>
                <span class="s3">raise </span><span class="s1">ValueError(other)</span>
            <span class="s1">others = self._safe_import_hook(other</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s3">for </span><span class="s1">other </span><span class="s3">in </span><span class="s1">others:</span>
                <span class="s1">self._updateReference(node</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">edge_data)</span>

    <span class="s3">def </span><span class="s1">outgoing(self</span><span class="s3">, </span><span class="s1">fromnode):</span>
        <span class="s0">&quot;&quot;&quot; 
        Yield all nodes that `fromnode` dependes on (that is, 
        all modules that `fromnode` imports. 
        &quot;&quot;&quot;</span>

        <span class="s1">node = self.find_node(fromnode)</span>
        <span class="s1">out_edges</span><span class="s3">, </span><span class="s1">_ = self.get_edges(node)</span>
        <span class="s3">return </span><span class="s1">out_edges</span>

    <span class="s1">getReferences = outgoing</span>

    <span class="s3">def </span><span class="s1">incoming(self</span><span class="s3">, </span><span class="s1">tonode</span><span class="s3">, </span><span class="s1">collapse_missing_modules=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">node = self.find_node(tonode)</span>
        <span class="s1">_</span><span class="s3">, </span><span class="s1">in_edges = self.get_edges(node)</span>

        <span class="s3">if </span><span class="s1">collapse_missing_modules:</span>
            <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">in_edges:</span>
                <span class="s3">if </span><span class="s1">isinstance(n</span><span class="s3">, </span><span class="s1">MissingModule):</span>
                    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">self.incoming(n</span><span class="s3">, False</span><span class="s1">):</span>
                        <span class="s3">yield </span><span class="s1">n</span>

                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">yield </span><span class="s1">n</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">in_edges:</span>
                <span class="s3">yield </span><span class="s1">n</span>

    <span class="s1">getReferers = incoming</span>

    <span class="s3">def </span><span class="s1">hasEdge(self</span><span class="s3">, </span><span class="s1">fromnode</span><span class="s3">, </span><span class="s1">tonode):</span>
        <span class="s0">&quot;&quot;&quot; Return True iff there is an edge from 'fromnode' to 'tonode' &quot;&quot;&quot;</span>
        <span class="s1">fromnode = self.find_node(fromnode)</span>
        <span class="s1">tonode = self.find_node(tonode)</span>

        <span class="s3">return </span><span class="s1">self.graph.edge_by_node(fromnode</span><span class="s3">, </span><span class="s1">tonode) </span><span class="s3">is not None</span>

    <span class="s3">def </span><span class="s1">foldReferences(self</span><span class="s3">, </span><span class="s1">packagenode):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create edges to/from `packagenode` based on the edges to/from all 
        submodules of that package _and_ then hide the graph nodes 
        corresponding to those submodules. 
        &quot;&quot;&quot;</span>

        <span class="s1">pkg = self.find_node(packagenode)</span>

        <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">self.nodes():</span>
            <span class="s3">if not </span><span class="s1">n.identifier.startswith(pkg.identifier + </span><span class="s4">'.'</span><span class="s1">):</span>
                <span class="s3">continue</span>

            <span class="s1">iter_out</span><span class="s3">, </span><span class="s1">iter_inc = self.get_edges(n)</span>
            <span class="s3">for </span><span class="s1">other </span><span class="s3">in </span><span class="s1">iter_out:</span>
                <span class="s3">if </span><span class="s1">other.identifier.startswith(pkg.identifier + </span><span class="s4">'.'</span><span class="s1">):</span>
                    <span class="s3">continue</span>

                <span class="s3">if not </span><span class="s1">self.hasEdge(pkg</span><span class="s3">, </span><span class="s1">other):</span>
                    <span class="s2"># Ignore circular dependencies</span>
                    <span class="s1">self._updateReference(pkg</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s4">'pkg-internal-import'</span><span class="s1">)</span>

            <span class="s3">for </span><span class="s1">other </span><span class="s3">in </span><span class="s1">iter_inc:</span>
                <span class="s3">if </span><span class="s1">other.identifier.startswith(pkg.identifier + </span><span class="s4">'.'</span><span class="s1">):</span>
                    <span class="s2"># Ignore circular dependencies</span>
                    <span class="s3">continue</span>

                <span class="s3">if not </span><span class="s1">self.hasEdge(other</span><span class="s3">, </span><span class="s1">pkg):</span>
                    <span class="s1">self._updateReference(other</span><span class="s3">, </span><span class="s1">pkg</span><span class="s3">, </span><span class="s4">'pkg-import'</span><span class="s1">)</span>

            <span class="s1">self.graph.hide_node(n)</span>

    <span class="s2"># TODO: unfoldReferences(pkg) that restore the submodule nodes and</span>
    <span class="s2">#       removes 'pkg-import' and 'pkg-internal-import' edges. Care should</span>
    <span class="s2">#       be taken to ensure that references are correct if multiple packages</span>
    <span class="s2">#       are folded and then one of them in unfolded</span>

    <span class="s3">def </span><span class="s1">_updateReference(self</span><span class="s3">, </span><span class="s1">fromnode</span><span class="s3">, </span><span class="s1">tonode</span><span class="s3">, </span><span class="s1">edge_data):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">ed = self.edgeData(fromnode</span><span class="s3">, </span><span class="s1">tonode)</span>
        <span class="s3">except </span><span class="s1">(KeyError</span><span class="s3">, </span><span class="s1">GraphError):  </span><span class="s2"># XXX: Why 'GraphError'</span>
            <span class="s3">return </span><span class="s1">self.add_edge(fromnode</span><span class="s3">, </span><span class="s1">tonode</span><span class="s3">, </span><span class="s1">edge_data)</span>

        <span class="s3">if not </span><span class="s1">(isinstance(ed</span><span class="s3">, </span><span class="s1">DependencyInfo) </span><span class="s3">and </span><span class="s1">isinstance(edge_data</span><span class="s3">, </span><span class="s1">DependencyInfo)):</span>
            <span class="s1">self.updateEdgeData(fromnode</span><span class="s3">, </span><span class="s1">tonode</span><span class="s3">, </span><span class="s1">edge_data)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.updateEdgeData(fromnode</span><span class="s3">, </span><span class="s1">tonode</span><span class="s3">, </span><span class="s1">ed._merged(edge_data))</span>

    <span class="s3">def </span><span class="s1">add_edge(self</span><span class="s3">, </span><span class="s1">fromnode</span><span class="s3">, </span><span class="s1">tonode</span><span class="s3">, </span><span class="s1">edge_data=</span><span class="s4">'direct'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a reference from fromnode to tonode 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">super(ModuleGraph</span><span class="s3">, </span><span class="s1">self).createReference(fromnode</span><span class="s3">, </span><span class="s1">tonode</span><span class="s3">, </span><span class="s1">edge_data=edge_data)</span>

    <span class="s1">createReference = add_edge</span>

    <span class="s3">def </span><span class="s1">find_node(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">create_nspkg=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Graph node uniquely identified by the passed fully-qualified module 
        name if this module has been added to the graph _or_ `None` otherwise. 
 
        If (in order): 
 
        . A namespace package with this identifier exists _and_ the passed 
          `create_nspkg` parameter is `True`, this package will be 
          instantiated and returned. 
        . A lazy node with this identifier and: 
          * No dependencies exists, this node will be instantiated and 
            returned. 
          * Dependencies exists, this node and all transitive dependencies of 
            this node be instantiated and this node returned. 
        . A non-lazy node with this identifier exists, this node will be 
          returned as is. 
 
        Parameters 
        ---------- 
        name : str 
            Fully-qualified name of the module whose graph node is to be found. 
        create_nspkg : bool 
            Whether or not to implicitly instantiate namespace packages. If 
            `True` _and_ this name is that of a previously registered namespace 
            package (i.e., in `self.nspackages`) not already added to the 
            graph, this package will be added to the graph. Defaults to `True`. 
 
        Returns 
        ---------- 
        Node 
            Graph node of this module if added to the graph _or_ `None` 
            otherwise. 
        &quot;&quot;&quot;</span>

        <span class="s1">data = super(ModuleGraph</span><span class="s3">, </span><span class="s1">self).findNode(name)</span>

        <span class="s3">if </span><span class="s1">data </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">data</span>

        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self.lazynodes:</span>
            <span class="s1">deps = self.lazynodes.pop(name)</span>

            <span class="s3">if </span><span class="s1">deps </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s2"># excluded module</span>
                <span class="s1">m = self.createNode(ExcludedModule</span><span class="s3">, </span><span class="s1">name)</span>
            <span class="s3">elif </span><span class="s1">isinstance(deps</span><span class="s3">, </span><span class="s1">Alias):</span>
                <span class="s1">other = self._safe_import_hook(deps</span><span class="s3">, None, None</span><span class="s1">).pop()</span>
                <span class="s1">m = self.createNode(AliasNode</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">other)</span>
                <span class="s1">self.implyNodeReference(m</span><span class="s3">, </span><span class="s1">other)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">m = self._safe_import_hook(name</span><span class="s3">, None, None</span><span class="s1">).pop()</span>
                <span class="s3">for </span><span class="s1">dep </span><span class="s3">in </span><span class="s1">deps:</span>
                    <span class="s1">self.implyNodeReference(m</span><span class="s3">, </span><span class="s1">dep)</span>

            <span class="s3">return </span><span class="s1">m</span>

        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self.nspackages </span><span class="s3">and </span><span class="s1">create_nspkg:</span>
            <span class="s2"># name is a --single-version-externally-managed</span>
            <span class="s2"># namespace package (setuptools/distribute)</span>
            <span class="s1">pathnames = self.nspackages.pop(name)</span>
            <span class="s1">m = self.createNode(NamespacePackage</span><span class="s3">, </span><span class="s1">name)</span>

            <span class="s2"># FIXME: The filename must be set to a string to ensure that py2app</span>
            <span class="s2"># works, it is not clear yet why that is. Setting to None would be</span>
            <span class="s2"># cleaner.</span>
            <span class="s1">m.filename = </span><span class="s4">'-'</span>
            <span class="s1">m.packagepath = _namespace_package_path(name</span><span class="s3">, </span><span class="s1">pathnames</span><span class="s3">, </span><span class="s1">self.path)</span>

            <span class="s2"># As per comment at top of file, simulate runtime packagepath additions.</span>
            <span class="s1">m.packagepath = m.packagepath + self._package_path_map.get(name</span><span class="s3">, </span><span class="s1">[])</span>
            <span class="s3">return </span><span class="s1">m</span>

        <span class="s3">return None</span>

    <span class="s1">findNode = find_node</span>
    <span class="s1">iter_graph = ObjectGraph.flatten</span>

    <span class="s3">def </span><span class="s1">add_script(self</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s1">caller=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a node by path (not module name).  It is expected to be a Python 
        source file, and will be scanned for dependencies. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;run_script&quot;</span><span class="s3">, </span><span class="s1">pathname)</span>

        <span class="s1">pathname = os.path.realpath(pathname)</span>
        <span class="s1">m = self.find_node(pathname)</span>
        <span class="s3">if </span><span class="s1">m </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">m</span>

        <span class="s3">if </span><span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">with </span><span class="s1">open(pathname</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">fp:</span>
                <span class="s1">encoding = util.guess_encoding(fp)</span>

            <span class="s3">with </span><span class="s1">open(pathname</span><span class="s3">, </span><span class="s1">_READ_MODE</span><span class="s3">, </span><span class="s1">encoding=encoding) </span><span class="s3">as </span><span class="s1">fp:</span>
                <span class="s1">contents = fp.read() + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span>
            <span class="s3">if </span><span class="s1">contents.startswith(BOM):</span>
                <span class="s2"># Ignore BOM at start of input</span>
                <span class="s1">contents = contents[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">with </span><span class="s1">open(pathname</span><span class="s3">, </span><span class="s1">_READ_MODE) </span><span class="s3">as </span><span class="s1">fp:</span>
                <span class="s1">contents = fp.read() + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span>

        <span class="s1">co_ast = compile(contents</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s4">'exec'</span><span class="s3">, </span><span class="s1">ast.PyCF_ONLY_AST</span><span class="s3">, True</span><span class="s1">)</span>
        <span class="s1">co = compile(co_ast</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s4">'exec'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, True</span><span class="s1">)</span>
        <span class="s1">m = self.createNode(Script</span><span class="s3">, </span><span class="s1">pathname)</span>
        <span class="s1">self._updateReference(caller</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">n = self._scan_code(m</span><span class="s3">, </span><span class="s1">co</span><span class="s3">, </span><span class="s1">co_ast)</span>
        <span class="s1">self._process_imports(n)</span>
        <span class="s1">m.code = co</span>
        <span class="s3">if </span><span class="s1">self.replace_paths:</span>
            <span class="s1">m.code = self._replace_paths_in_code(m.code)</span>
        <span class="s3">return </span><span class="s1">m</span>


    <span class="s2">#FIXME: For safety, the &quot;source_module&quot; parameter should default to the</span>
    <span class="s2">#root node of the current graph if unpassed. This parameter currently</span>
    <span class="s2">#defaults to None, thus disconnected modules imported in this manner (e.g.,</span>
    <span class="s2">#hidden imports imported by depend.analysis.initialize_modgraph()).</span>
    <span class="s3">def </span><span class="s1">import_hook(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">target_module_partname</span><span class="s3">,</span>
        <span class="s1">source_module=</span><span class="s3">None,</span>
        <span class="s1">target_attr_names=</span><span class="s3">None,</span>
        <span class="s1">level=DEFAULT_IMPORT_LEVEL</span><span class="s3">,</span>
        <span class="s1">edge_attr=</span><span class="s3">None,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Import the module with the passed name, all parent packages of this 
        module, _and_ all submodules and attributes in this module with the 
        passed names from the previously imported caller module signified by 
        the passed graph node. 
 
        Unlike most import methods (e.g., `_safe_import_hook()`), this method 
        is designed to be publicly called by both external and internal 
        callers and hence is public. 
 
        Parameters 
        ---------- 
        target_module_partname : str 
            Partially-qualified name of the target module to be imported. See 
            `_safe_import_hook()` for further details. 
        source_module : Node 
            Graph node for the previously imported **source module** (i.e., 
            module containing the `import` statement triggering the call to 
            this method) _or_ `None` if this module is to be imported in a 
            &quot;disconnected&quot; manner. **Passing `None` is _not_ recommended.** 
            Doing so produces a disconnected graph in which the graph node 
            created for the module to be imported will be disconnected and 
            hence unreachable from all other nodes -- which frequently causes 
            subtle issues in external callers (namely PyInstaller, which 
            silently ignores unreachable nodes). 
        target_attr_names : list 
            List of the unqualified names of all submodules and attributes to 
            be imported from the module to be imported if this is a &quot;from&quot;- 
            style import (e.g., `[encode_base64, encode_noop]` for the import 
            `from email.encoders import encode_base64, encode_noop`) _or_ 
            `None` otherwise. 
        level : int 
            Whether to perform an absolute or relative import. See 
            `_safe_import_hook()` for further details. 
 
        Returns 
        ---------- 
        list 
            List of the graph nodes created for all modules explicitly imported 
            by this call, including the passed module and all submodules listed 
            in `target_attr_names` _but_ excluding all parent packages 
            implicitly imported by this call. If `target_attr_names` is `None` 
            or the empty list, this is guaranteed to be a list of one element: 
            the graph node created for the passed module. 
 
        Raises 
        ---------- 
        ImportError 
            If the target module to be imported is unimportable. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg(</span><span class="s5">3</span><span class="s3">, </span><span class="s4">&quot;_import_hook&quot;</span><span class="s3">, </span><span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">source_module</span><span class="s3">, </span><span class="s1">source_module</span><span class="s3">, </span><span class="s1">level)</span>

        <span class="s1">source_package = self._determine_parent(source_module)</span>
        <span class="s1">target_package</span><span class="s3">, </span><span class="s1">target_module_partname = self._find_head_package(</span>
            <span class="s1">source_package</span><span class="s3">, </span><span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">level)</span>

        <span class="s1">self.msgin(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;load_tail&quot;</span><span class="s3">, </span><span class="s1">target_package</span><span class="s3">, </span><span class="s1">target_module_partname)</span>

        <span class="s1">submodule = target_package</span>
        <span class="s3">while </span><span class="s1">target_module_partname:</span>
            <span class="s1">i = target_module_partname.find(</span><span class="s4">'.'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">i &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">i = len(target_module_partname)</span>
            <span class="s1">head</span><span class="s3">, </span><span class="s1">target_module_partname = target_module_partname[</span>
                <span class="s1">:i]</span><span class="s3">, </span><span class="s1">target_module_partname[i+</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s1">mname = </span><span class="s4">&quot;%s.%s&quot; </span><span class="s1">% (submodule.identifier</span><span class="s3">, </span><span class="s1">head)</span>
            <span class="s1">submodule = self._safe_import_module(head</span><span class="s3">, </span><span class="s1">mname</span><span class="s3">, </span><span class="s1">submodule)</span>

            <span class="s3">if </span><span class="s1">submodule </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s2"># FIXME: Why do we no longer return a MissingModule instance?</span>
                <span class="s2"># result = self.createNode(MissingModule, mname)</span>
                <span class="s1">self.msgout(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;raise ImportError: No module named&quot;</span><span class="s3">, </span><span class="s1">mname)</span>
                <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s4">&quot;No module named &quot; </span><span class="s1">+ repr(mname))</span>

        <span class="s1">self.msgout(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;load_tail -&gt;&quot;</span><span class="s3">, </span><span class="s1">submodule)</span>

        <span class="s1">target_module = submodule</span>
        <span class="s1">target_modules = [target_module]</span>

        <span class="s2"># If this is a &quot;from&quot;-style import *AND* this target module is</span>
        <span class="s2"># actually a package, import all submodules of this package specified</span>
        <span class="s2"># by the &quot;import&quot; half of this import (e.g., the submodules &quot;bar&quot; and</span>
        <span class="s2"># &quot;car&quot; of the target package &quot;foo&quot; in &quot;from foo import bar, car&quot;).</span>
        <span class="s2">#</span>
        <span class="s2"># If this target module is a non-package, it could still contain</span>
        <span class="s2"># importable submodules (e.g., the non-package `os` module containing</span>
        <span class="s2"># the `os.path` submodule). In this case, these submodules are already</span>
        <span class="s2"># imported by this target module's pure-Python code. Since our import</span>
        <span class="s2"># scanner already detects such imports, these submodules need *NOT* be</span>
        <span class="s2"># reimported here.</span>
        <span class="s3">if </span><span class="s1">target_attr_names </span><span class="s3">and </span><span class="s1">isinstance(target_module</span><span class="s3">,</span>
                                            <span class="s1">(Package</span><span class="s3">, </span><span class="s1">AliasNode)):</span>
            <span class="s3">for </span><span class="s1">target_submodule </span><span class="s3">in </span><span class="s1">self._import_importable_package_submodules(</span>
                <span class="s1">target_module</span><span class="s3">, </span><span class="s1">target_attr_names):</span>
                <span class="s3">if </span><span class="s1">target_submodule </span><span class="s3">not in </span><span class="s1">target_modules:</span>
                    <span class="s1">target_modules.append(target_submodule)</span>

        <span class="s2"># Add an edge from this source module to each target module.</span>
        <span class="s3">for </span><span class="s1">target_module </span><span class="s3">in </span><span class="s1">target_modules:</span>
            <span class="s1">self._updateReference(</span>
                <span class="s1">source_module</span><span class="s3">, </span><span class="s1">target_module</span><span class="s3">, </span><span class="s1">edge_data=edge_attr)</span>

        <span class="s3">return </span><span class="s1">target_modules</span>


    <span class="s3">def </span><span class="s1">_determine_parent(self</span><span class="s3">, </span><span class="s1">caller):</span>
        <span class="s0">&quot;&quot;&quot; 
        Determine the package containing a node. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msgin(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;determine_parent&quot;</span><span class="s3">, </span><span class="s1">caller)</span>

        <span class="s1">parent = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">caller:</span>
            <span class="s1">pname = caller.identifier</span>

            <span class="s3">if </span><span class="s1">isinstance(caller</span><span class="s3">, </span><span class="s1">Package):</span>
                <span class="s1">parent = caller</span>

            <span class="s3">elif </span><span class="s4">'.' </span><span class="s3">in </span><span class="s1">pname:</span>
                <span class="s1">pname = pname[:pname.rfind(</span><span class="s4">'.'</span><span class="s1">)]</span>
                <span class="s1">parent = self.find_node(pname)</span>

            <span class="s3">elif </span><span class="s1">caller.packagepath:</span>
                <span class="s2"># XXX: I have no idea why this line</span>
                <span class="s2"># is necessary.</span>
                <span class="s1">parent = self.find_node(pname)</span>

        <span class="s1">self.msgout(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;determine_parent -&gt;&quot;</span><span class="s3">, </span><span class="s1">parent)</span>
        <span class="s3">return </span><span class="s1">parent</span>


    <span class="s3">def </span><span class="s1">_find_head_package(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">source_package</span><span class="s3">,</span>
        <span class="s1">target_module_partname</span><span class="s3">,</span>
        <span class="s1">level=DEFAULT_IMPORT_LEVEL):</span>
        <span class="s0">&quot;&quot;&quot; 
        Import the target package providing the target module with the passed 
        name to be subsequently imported from the previously imported source 
        package corresponding to the passed graph node. 
 
        Parameters 
        ---------- 
        source_package : Package 
            Graph node for the previously imported **source package** (i.e., 
            package containing the module containing the `import` statement 
            triggering the call to this method) _or_ `None` if this module is 
            to be imported in a &quot;disconnected&quot; manner. **Passing `None` is 
            _not_ recommended.** See the `_import_hook()` method for further 
            details. 
        target_module_partname : str 
            Partially-qualified name of the target module to be imported. See 
            `_safe_import_hook()` for further details. 
        level : int 
            Whether to perform absolute or relative imports. See the 
            `_safe_import_hook()` method for further details. 
 
        Returns 
        ---------- 
        (target_package, target_module_tailname) 
            2-tuple describing the imported target package, where: 
            * `target_package` is the graph node created for this package. 
            * `target_module_tailname` is the unqualified name of the target 
              module to be subsequently imported (e.g., `text` when passed a 
              `target_module_partname` of `email.mime.text`). 
 
        Raises 
        ---------- 
        ImportError 
            If the package to be imported is unimportable. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msgin(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;find_head_package&quot;</span><span class="s3">, </span><span class="s1">source_package</span><span class="s3">, </span><span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">level)</span>

        <span class="s2">#FIXME: Rename all local variable names to something sensible. No,</span>
        <span class="s2">#&quot;p_fqdn&quot; is not a sensible name.</span>

        <span class="s2"># If this target module is a submodule...</span>
        <span class="s3">if </span><span class="s4">'.' </span><span class="s3">in </span><span class="s1">target_module_partname:</span>
            <span class="s1">target_module_headname</span><span class="s3">, </span><span class="s1">target_module_tailname = (</span>
                <span class="s1">target_module_partname.split(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s2"># Else, this target module is a top-level module.</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">target_module_headname = target_module_partname</span>
            <span class="s1">target_module_tailname = </span><span class="s4">''</span>

        <span class="s2"># If attempting both absolute and relative imports...</span>
        <span class="s3">if </span><span class="s1">level == ABSOLUTE_OR_RELATIVE_IMPORT_LEVEL:</span>
            <span class="s3">if </span><span class="s1">source_package:</span>
                <span class="s1">target_package_name = source_package.identifier + </span><span class="s4">'.' </span><span class="s1">+ target_module_headname</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">target_package_name = target_module_headname</span>
        <span class="s2"># Else if attempting only absolute imports...</span>
        <span class="s3">elif </span><span class="s1">level == ABSOLUTE_IMPORT_LEVEL:</span>
            <span class="s1">target_package_name = target_module_headname</span>

            <span class="s2"># Absolute import, ignore the parent</span>
            <span class="s1">source_package = </span><span class="s3">None</span>
        <span class="s2"># Else if attempting only relative imports...</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">source_package </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">self.msg(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;Relative import outside of package&quot;</span><span class="s1">)</span>
                <span class="s3">raise </span><span class="s1">InvalidRelativeImportError(</span>
                    <span class="s4">&quot;Relative import outside of package (name=%r, parent=%r, level=%r)&quot; </span><span class="s1">% (</span>
                        <span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">source_package</span><span class="s3">, </span><span class="s1">level))</span>

            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(level - </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s3">if </span><span class="s4">'.' </span><span class="s3">not in </span><span class="s1">source_package.identifier:</span>
                    <span class="s1">self.msg(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;Relative import outside of package&quot;</span><span class="s1">)</span>
                    <span class="s3">raise </span><span class="s1">InvalidRelativeImportError(</span>
                        <span class="s4">&quot;Relative import outside of package (name=%r, parent=%r, level=%r)&quot; </span><span class="s1">% (</span>
                            <span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">source_package</span><span class="s3">, </span><span class="s1">level))</span>

                <span class="s1">p_fqdn = source_package.identifier.rsplit(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">new_parent = self.find_node(p_fqdn)</span>
                <span class="s3">if </span><span class="s1">new_parent </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s2">#FIXME: Repetition detected. Exterminate. Exterminate.</span>
                    <span class="s1">self.msg(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;Relative import outside of package&quot;</span><span class="s1">)</span>
                    <span class="s3">raise </span><span class="s1">InvalidRelativeImportError(</span>
                        <span class="s4">&quot;Relative import outside of package (name=%r, parent=%r, level=%r)&quot; </span><span class="s1">% (</span>
                            <span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">source_package</span><span class="s3">, </span><span class="s1">level))</span>

                <span class="s3">assert </span><span class="s1">new_parent </span><span class="s3">is not </span><span class="s1">source_package</span><span class="s3">, </span><span class="s1">(</span>
                    <span class="s1">new_parent</span><span class="s3">, </span><span class="s1">source_package)</span>
                <span class="s1">source_package = new_parent</span>

            <span class="s3">if </span><span class="s1">target_module_headname:</span>
                <span class="s1">target_package_name = (</span>
                    <span class="s1">source_package.identifier + </span><span class="s4">'.' </span><span class="s1">+ target_module_headname)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">target_package_name = source_package.identifier</span>

        <span class="s2"># Graph node of this target package.</span>
        <span class="s1">target_package = self._safe_import_module(</span>
            <span class="s1">target_module_headname</span><span class="s3">, </span><span class="s1">target_package_name</span><span class="s3">, </span><span class="s1">source_package)</span>

        <span class="s2">#FIXME: Why exactly is this necessary again? This doesn't quite seem</span>
        <span class="s2">#right but maybe it is. Shouldn't absolute imports only be performed if</span>
        <span class="s2">#the passed &quot;level&quot; is either &quot;ABSOLUTE_IMPORT_LEVEL&quot; or</span>
        <span class="s2">#&quot;ABSOLUTE_OR_RELATIVE_IMPORT_LEVEL&quot; -- or, more succinctly:</span>
        <span class="s2">#</span>
        <span class="s2">#    if level &lt; 1:</span>

        <span class="s2"># If this target package is *NOT* importable and a source package was</span>
        <span class="s2"># passed, attempt to import this target package as an absolute import.</span>
        <span class="s3">if </span><span class="s1">target_package </span><span class="s3">is None and </span><span class="s1">source_package </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">target_package_name = target_module_headname</span>
            <span class="s1">source_package = </span><span class="s3">None</span>

            <span class="s2"># Graph node for the target package, again.</span>
            <span class="s1">target_package = self._safe_import_module(</span>
                <span class="s1">target_module_headname</span><span class="s3">, </span><span class="s1">target_package_name</span><span class="s3">, </span><span class="s1">source_package)</span>

        <span class="s2"># If this target package is importable, return this package.</span>
        <span class="s3">if </span><span class="s1">target_package </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.msgout(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;find_head_package -&gt;&quot;</span><span class="s3">, </span><span class="s1">(target_package</span><span class="s3">, </span><span class="s1">target_module_tailname))</span>
            <span class="s3">return </span><span class="s1">target_package</span><span class="s3">, </span><span class="s1">target_module_tailname</span>

        <span class="s2"># Else, raise an exception.</span>
        <span class="s1">self.msgout(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;raise ImportError: No module named&quot;</span><span class="s3">, </span><span class="s1">target_package_name)</span>
        <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s4">&quot;No module named &quot; </span><span class="s1">+ target_package_name)</span>




    <span class="s2">#FIXME: Refactor from a generator yielding graph nodes into a non-generator</span>
    <span class="s2">#returning a list or tuple of all yielded graph nodes. This method is only</span>
    <span class="s2">#called once above and the return value of that call is only iterated over</span>
    <span class="s2">#as a list or tuple. There's no demonstrable reason for this to be a</span>
    <span class="s2">#generator. Generators are great for their intended purposes (e.g., as</span>
    <span class="s2">#continuations). This isn't one of those purposes.</span>
    <span class="s3">def </span><span class="s1">_import_importable_package_submodules(self</span><span class="s3">, </span><span class="s1">package</span><span class="s3">, </span><span class="s1">attr_names):</span>
        <span class="s0">&quot;&quot;&quot; 
        Generator importing and yielding each importable submodule (of the 
        previously imported package corresponding to the passed graph node) 
        whose unqualified name is in the passed list. 
 
        Elements of this list that are _not_ importable submodules of this 
        package are either: 
 
        * Ignorable attributes (e.g., classes, globals) defined at the top 
          level of this package's `__init__` submodule, which will be ignored. 
        * Else, unignorable unimportable submodules, in which case an 
          exception is raised. 
 
        Parameters 
        ---------- 
        package : Package 
            Graph node of the previously imported package containing the 
            modules to be imported and yielded. 
 
        attr_names : list 
            List of the unqualified names of all attributes of this package to 
            attempt to import as submodules. This list will be internally 
            converted into a set, safely ignoring any duplicates in this list 
            (e.g., reducing the &quot;from&quot;-style import 
            `from foo import bar, car, far, bar, car, far` to merely 
            `from foo import bar, car, far`). 
 
        Yields 
        ---------- 
        Node 
            Graph node created for the currently imported submodule. 
 
        Raises 
        ---------- 
        ImportError 
            If any attribute whose name is in `attr_names` is neither: 
            * An importable submodule of this package. 
            * An ignorable global attribute (e.g., class, variable) defined at 
              the top level of this package's `__init__` submodule. 
            In this case, this attribute _must_ be an unimportable submodule of 
            this package. 
        &quot;&quot;&quot;</span>

        <span class="s2"># Ignore duplicate submodule names in the passed list.</span>
        <span class="s1">attr_names = set(attr_names)</span>
        <span class="s1">self.msgin(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;_import_importable_package_submodules&quot;</span><span class="s3">, </span><span class="s1">package</span><span class="s3">, </span><span class="s1">attr_names)</span>

        <span class="s2">#FIXME: This test *SHOULD* be superfluous and hence safely removable.</span>
        <span class="s2">#The higher-level _scan_bytecode() and _collect_import() methods</span>
        <span class="s2">#already guarantee &quot;*&quot; characters to be removed from fromlists.</span>
        <span class="s3">if </span><span class="s4">'*' </span><span class="s3">in </span><span class="s1">attr_names:</span>
            <span class="s1">attr_names.update(self._find_all_submodules(package))</span>
            <span class="s1">attr_names.remove(</span><span class="s4">'*'</span><span class="s1">)</span>

        <span class="s2"># self.msg(4, '_import_importable_package_submodules (global attrs)', package.identifier, package._global_attr_names)</span>

        <span class="s2"># For the name of each attribute to be imported from this package...</span>
        <span class="s3">for </span><span class="s1">attr_name </span><span class="s3">in </span><span class="s1">attr_names:</span>
            <span class="s2"># self.msg(4, '_import_importable_package_submodules (fromlist attr)', package.identifier, attr_name)</span>

            <span class="s2"># Graph node of this attribute if this attribute is a previously</span>
            <span class="s2"># imported module or None otherwise.</span>
            <span class="s1">submodule = package.get_submodule_or_none(attr_name)</span>

            <span class="s2"># If this attribute is *NOT* a previously imported module, attempt</span>
            <span class="s2"># to import this attribute as a submodule of this package.</span>
            <span class="s3">if </span><span class="s1">submodule </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s2"># Fully-qualified name of this submodule.</span>
                <span class="s1">submodule_name = package.identifier + </span><span class="s4">'.' </span><span class="s1">+ attr_name</span>

                <span class="s2"># Graph node of this submodule if importable or None otherwise.</span>
                <span class="s1">submodule = self._safe_import_module(</span>
                    <span class="s1">attr_name</span><span class="s3">, </span><span class="s1">submodule_name</span><span class="s3">, </span><span class="s1">package)</span>

                <span class="s2"># If this submodule is unimportable...</span>
                <span class="s3">if </span><span class="s1">submodule </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s2"># If this attribute is a global (e.g., class, variable)</span>
                    <span class="s2"># defined at the top level of this package's &quot;__init__&quot;</span>
                    <span class="s2"># submodule, this importation is safely ignorable. Do so</span>
                    <span class="s2"># and skip to the next attribute.</span>
                    <span class="s2">#</span>
                    <span class="s2"># This behaviour is non-conformant with Python behaviour,</span>
                    <span class="s2"># which is bad, but is required to sanely handle all</span>
                    <span class="s2"># possible edge cases, which is good. In Python, a global</span>
                    <span class="s2"># attribute defined at the top level of a package's</span>
                    <span class="s2"># &quot;__init__&quot; submodule shadows a submodule of the same name</span>
                    <span class="s2"># in that package. Attempting to import that submodule</span>
                    <span class="s2"># instead imports that attribute; thus, that submodule is</span>
                    <span class="s2"># effectively unimportable. In this method and elsewhere,</span>
                    <span class="s2"># that submodule is tested for first and hence shadows that</span>
                    <span class="s2"># attribute -- the opposite logic. Attempts to import that</span>
                    <span class="s2"># attribute are mistakenly seen as attempts to import that</span>
                    <span class="s2"># submodule! Why?</span>
                    <span class="s2">#</span>
                    <span class="s2"># Edge cases. PyInstaller (and by extension ModuleGraph)</span>
                    <span class="s2"># only cares about module imports. Global attribute imports</span>
                    <span class="s2"># are parsed only as the means to this ends and are</span>
                    <span class="s2"># otherwise ignorable. The cost of erroneously shadowing:</span>
                    <span class="s2">#</span>
                    <span class="s2"># * Submodules by attributes is significant. Doing so</span>
                    <span class="s2">#   prevents such submodules from being frozen and hence</span>
                    <span class="s2">#   imported at application runtime.</span>
                    <span class="s2"># * Attributes by submodules is insignificant. Doing so</span>
                    <span class="s2">#   could erroneously freeze such submodules despite their</span>
                    <span class="s2">#   never being imported at application runtime. However,</span>
                    <span class="s2">#   ModuleGraph is incapable of determining with certainty</span>
                    <span class="s2">#   that Python logic in another module other than the</span>
                    <span class="s2">#   &quot;__init__&quot; submodule containing these attributes does</span>
                    <span class="s2">#   *NOT* delete these attributes and hence unshadow these</span>
                    <span class="s2">#   submodules, which would then become importable at</span>
                    <span class="s2">#   runtime and require freezing. Hence, ModuleGraph *MUST*</span>
                    <span class="s2">#   permissively assume submodules of the same name as</span>
                    <span class="s2">#   attributes to be unshadowed elsewhere and require</span>
                    <span class="s2">#   freezing -- even if they do not.</span>
                    <span class="s2">#</span>
                    <span class="s2"># It is practically difficult (albeit technically feasible)</span>
                    <span class="s2"># for ModuleGraph to determine whether or not the target</span>
                    <span class="s2"># attribute names of &quot;from&quot;-style import statements (e.g.,</span>
                    <span class="s2"># &quot;bar&quot; and &quot;car&quot; in &quot;from foo import bar, car&quot;) refer to</span>
                    <span class="s2"># non-ignorable submodules or ignorable non-module globals</span>
                    <span class="s2"># during opcode scanning. Distinguishing these two cases</span>
                    <span class="s2"># during opcode scanning would require a costly call to the</span>
                    <span class="s2"># _find_module() method, which would subsequently be</span>
                    <span class="s2"># repeated during import-graph construction. This could be</span>
                    <span class="s2"># ameliorated with caching, which itself would require</span>
                    <span class="s2"># costly space consumption and developer time.</span>
                    <span class="s2">#</span>
                    <span class="s2"># Since opcode scanning fails to distinguish these two</span>
                    <span class="s2"># cases, this and other methods subsequently called at</span>
                    <span class="s2"># import-graph construction time (e.g.,</span>
                    <span class="s2"># _safe_import_hook()) must do so. Since submodules of the</span>
                    <span class="s2"># same name as attributes must assume to be unshadowed</span>
                    <span class="s2"># elsewhere and require freezing, the only solution is to</span>
                    <span class="s2"># attempt to import an attribute as a non-ignorable module</span>
                    <span class="s2"># *BEFORE* assuming an attribute to be an ignorable</span>
                    <span class="s2"># non-module. Which is what this and other methods do.</span>
                    <span class="s2">#</span>
                    <span class="s2"># See Package.is_global_attr() for similar discussion.</span>
                    <span class="s3">if </span><span class="s1">package.is_global_attr(attr_name):</span>
                        <span class="s1">self.msg(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">'_import_importable_package_submodules: ignoring from-imported global'</span><span class="s3">, </span><span class="s1">package.identifier</span><span class="s3">, </span><span class="s1">attr_name)</span>
                        <span class="s3">continue</span>
                    <span class="s2"># Else, this attribute is an unimportable submodule. Since</span>
                    <span class="s2"># this is *NOT* safely ignorable, raise an exception.</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s4">&quot;No module named &quot; </span><span class="s1">+ submodule_name)</span>

            <span class="s2"># Yield this submodule's graph node to the caller.</span>
            <span class="s3">yield </span><span class="s1">submodule</span>

        <span class="s1">self.msgin(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;_import_importable_package_submodules -&gt;&quot;</span><span class="s1">)</span>


    <span class="s3">def </span><span class="s1">_find_all_submodules(self</span><span class="s3">, </span><span class="s1">m):</span>
        <span class="s3">if not </span><span class="s1">m.packagepath:</span>
            <span class="s3">return</span>
        <span class="s2"># 'suffixes' used to be a list hardcoded to [&quot;.py&quot;, &quot;.pyc&quot;, &quot;.pyo&quot;].</span>
        <span class="s2"># But we must also collect Python extension modules - although</span>
        <span class="s2"># we cannot separate normal dlls from Python extensions.</span>
        <span class="s3">for </span><span class="s1">path </span><span class="s3">in </span><span class="s1">m.packagepath:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">names = zipio.listdir(path)</span>
            <span class="s3">except </span><span class="s1">(os.error</span><span class="s3">, </span><span class="s1">IOError):</span>
                <span class="s1">self.msg(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;can't list directory&quot;</span><span class="s3">, </span><span class="s1">path)</span>
                <span class="s3">continue</span>
            <span class="s3">for </span><span class="s1">info </span><span class="s3">in </span><span class="s1">(moduleInfoForPath(p) </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">names):</span>
                <span class="s3">if </span><span class="s1">info </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s3">continue</span>
                <span class="s3">if </span><span class="s1">info[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'__init__'</span><span class="s1">:</span>
                    <span class="s3">yield </span><span class="s1">info[</span><span class="s5">0</span><span class="s1">]</span>


    <span class="s3">def </span><span class="s1">alias_module(self</span><span class="s3">, </span><span class="s1">src_module_name</span><span class="s3">, </span><span class="s1">trg_module_name):</span>
        <span class="s0">&quot;&quot;&quot; 
        Alias the source module to the target module with the passed names. 
 
        This method ensures that the next call to findNode() given the target 
        module name will resolve this alias. This includes importing and adding 
        a graph node for the source module if needed as well as adding a 
        reference from the target to source module. 
 
        Parameters 
        ---------- 
        src_module_name : str 
            Fully-qualified name of the existing **source module** (i.e., the 
            module being aliased). 
        trg_module_name : str 
            Fully-qualified name of the non-existent **target module** (i.e., 
            the alias to be created). 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg(</span><span class="s5">3</span><span class="s3">, </span><span class="s4">'alias_module &quot;%s&quot; -&gt; &quot;%s&quot;' </span><span class="s1">% (src_module_name</span><span class="s3">, </span><span class="s1">trg_module_name))</span>
        <span class="s2"># print('alias_module &quot;%s&quot; -&gt; &quot;%s&quot;' % (src_module_name, trg_module_name))</span>
        <span class="s3">assert </span><span class="s1">isinstance(src_module_name</span><span class="s3">, </span><span class="s1">str)</span><span class="s3">, </span><span class="s4">'&quot;%s&quot; not a module name.' </span><span class="s1">% str(src_module_name)</span>
        <span class="s3">assert </span><span class="s1">isinstance(trg_module_name</span><span class="s3">, </span><span class="s1">str)</span><span class="s3">, </span><span class="s4">'&quot;%s&quot; not a module name.' </span><span class="s1">% str(trg_module_name)</span>

        <span class="s2"># If the target module has already been added to the graph as either a</span>
        <span class="s2"># non-alias or as a different alias, raise an exception.</span>
        <span class="s1">trg_module = self.find_node(trg_module_name)</span>
        <span class="s3">if </span><span class="s1">trg_module </span><span class="s3">is not None and not </span><span class="s1">(</span>
           <span class="s1">isinstance(trg_module</span><span class="s3">, </span><span class="s1">AliasNode) </span><span class="s3">and</span>
           <span class="s1">trg_module.identifier == src_module_name):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">'Target module &quot;%s&quot; already imported as &quot;%s&quot;.' </span><span class="s1">% (</span>
                    <span class="s1">trg_module_name</span><span class="s3">, </span><span class="s1">trg_module))</span>

        <span class="s2"># See findNode() for details.</span>
        <span class="s1">self.lazynodes[trg_module_name] = Alias(src_module_name)</span>


    <span class="s3">def </span><span class="s1">add_module(self</span><span class="s3">, </span><span class="s1">module):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add the passed module node to the graph if not already added. 
 
        If that module has a parent module or package with a previously added 
        node, this method also adds a reference from this module node to its 
        parent node and adds this module node to its parent node's namespace. 
 
        This high-level method wraps the low-level `addNode()` method, but is 
        typically _only_ called by graph hooks adding runtime module nodes. For 
        all other node types, the `import_module()` method should be called. 
 
        Parameters 
        ---------- 
        module : BaseModule 
            Graph node of the module to be added. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg(</span><span class="s5">3</span><span class="s3">, </span><span class="s4">'add_module'</span><span class="s3">, </span><span class="s1">module)</span>

        <span class="s2"># If no node exists for this module, add such a node.</span>
        <span class="s1">module_added = self.find_node(module.identifier)</span>
        <span class="s3">if </span><span class="s1">module_added </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.addNode(module)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">assert </span><span class="s1">module == module_added</span><span class="s3">, </span><span class="s4">'New module %r != previous %r.' </span><span class="s1">% (module</span><span class="s3">, </span><span class="s1">module_added)</span>

        <span class="s2"># If this module has a previously added parent, reference this module to</span>
        <span class="s2"># its parent and add this module to its parent's namespace.</span>
        <span class="s1">parent_name</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">module_basename = module.identifier.rpartition(</span><span class="s4">'.'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">parent_name:</span>
            <span class="s1">parent = self.find_node(parent_name)</span>
            <span class="s3">if </span><span class="s1">parent </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">self.msg(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">'add_module parent not found:'</span><span class="s3">, </span><span class="s1">parent_name)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.add_edge(module</span><span class="s3">, </span><span class="s1">parent)</span>
                <span class="s1">parent.add_submodule(module_basename</span><span class="s3">, </span><span class="s1">module)</span>


    <span class="s3">def </span><span class="s1">append_package_path(self</span><span class="s3">, </span><span class="s1">package_name</span><span class="s3">, </span><span class="s1">directory):</span>
        <span class="s0">&quot;&quot;&quot; 
        Modulegraph does a good job at simulating Python's, but it can not 
        handle packagepath '__path__' modifications packages make at runtime. 
 
        Therefore there is a mechanism whereby you can register extra paths 
        in this map for a package, and it will be honored. 
 
        NOTE: This method has to be called before a package is resolved by 
              modulegraph. 
 
        Parameters 
        ---------- 
        module : str 
            Fully-qualified module name. 
        directory : str 
            Absolute or relative path of the directory to append to the 
            '__path__' attribute. 
        &quot;&quot;&quot;</span>

        <span class="s1">paths = self._package_path_map.setdefault(package_name</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s1">paths.append(directory)</span>


    <span class="s3">def </span><span class="s1">_safe_import_module(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">module_partname</span><span class="s3">, </span><span class="s1">module_name</span><span class="s3">, </span><span class="s1">parent_module):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new graph node for the module with the passed name under the 
        parent package signified by the passed graph node _without_ raising 
        `ImportError` exceptions. 
 
        If this module has already been imported, this module's existing graph 
        node will be returned; else if this module is importable, a new graph 
        node will be added for this module and returned; else this module is 
        unimportable, in which case `None` will be returned. Like the 
        `_safe_import_hook()` method, this method does _not_ raise 
        `ImportError` exceptions when this module is unimportable. 
 
        Parameters 
        ---------- 
        module_partname : str 
            Unqualified name of the module to be imported (e.g., `text`). 
        module_name : str 
            Fully-qualified name of this module (e.g., `email.mime.text`). 
        parent_module : Package 
            Graph node of the previously imported parent module containing this 
            submodule _or_ `None` if this is a top-level module (i.e., 
            `module_name` contains no `.` delimiters). This parent module is 
            typically but _not_ always a package (e.g., the `os.path` submodule 
            contained by the `os` module). 
 
        Returns 
        ---------- 
        Node 
            Graph node created for this module _or_ `None` if this module is 
            unimportable. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msgin(</span><span class="s5">3</span><span class="s3">, </span><span class="s4">&quot;safe_import_module&quot;</span><span class="s3">, </span><span class="s1">module_partname</span><span class="s3">, </span><span class="s1">module_name</span><span class="s3">, </span><span class="s1">parent_module)</span>

        <span class="s2"># If this module has *NOT* already been imported, do so.</span>
        <span class="s1">module = self.find_node(module_name)</span>
        <span class="s3">if </span><span class="s1">module </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s2"># List of the absolute paths of all directories to be searched for</span>
            <span class="s2"># this module. This effectively defaults to &quot;sys.path&quot;.</span>
            <span class="s1">search_dirs = </span><span class="s3">None</span>

            <span class="s2"># If this module has a parent package...</span>
            <span class="s3">if </span><span class="s1">parent_module </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s2"># ...with a list of the absolute paths of all directories</span>
                <span class="s2"># comprising this package, prefer that to &quot;sys.path&quot;.</span>
                <span class="s3">if </span><span class="s1">parent_module.packagepath </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">search_dirs = parent_module.packagepath</span>
                <span class="s2"># Else, something is horribly wrong. Return emptiness.</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self.msgout(</span><span class="s5">3</span><span class="s3">, </span><span class="s4">&quot;safe_import_module -&gt; None (parent_parent.packagepath is None)&quot;</span><span class="s1">)</span>
                    <span class="s3">return None</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">pathname</span><span class="s3">, </span><span class="s1">loader = self._find_module(</span>
                    <span class="s1">module_partname</span><span class="s3">, </span><span class="s1">search_dirs</span><span class="s3">, </span><span class="s1">parent_module)</span>
            <span class="s3">except </span><span class="s1">ImportError </span><span class="s3">as </span><span class="s1">exc:</span>
                <span class="s1">self.msgout(</span><span class="s5">3</span><span class="s3">, </span><span class="s4">&quot;safe_import_module -&gt; None (%r)&quot; </span><span class="s1">% exc)</span>
                <span class="s3">return None</span>

            <span class="s1">(module</span><span class="s3">, </span><span class="s1">co) = self._load_module(module_name</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s1">loader)</span>
            <span class="s3">if </span><span class="s1">co </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">isinstance(co</span><span class="s3">, </span><span class="s1">ast.AST):</span>
                        <span class="s1">co_ast = co</span>
                        <span class="s1">co = compile(co_ast</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s4">'exec'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, True</span><span class="s1">)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">co_ast = </span><span class="s3">None</span>
                    <span class="s1">n = self._scan_code(module</span><span class="s3">, </span><span class="s1">co</span><span class="s3">, </span><span class="s1">co_ast)</span>
                    <span class="s1">self._process_imports(n)</span>

                    <span class="s3">if </span><span class="s1">self.replace_paths:</span>
                        <span class="s1">co = self._replace_paths_in_code(co)</span>
                    <span class="s1">module.code = co</span>
                <span class="s3">except </span><span class="s1">SyntaxError:</span>
                    <span class="s1">self.msg(</span>
                        <span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;safe_import_module: SyntaxError in &quot;</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">,</span>
                    <span class="s1">)</span>
                    <span class="s1">cls = InvalidSourceModule</span>
                    <span class="s1">module = self.createNode(cls</span><span class="s3">, </span><span class="s1">module_name)</span>

        <span class="s2"># If this is a submodule rather than top-level module...</span>
        <span class="s3">if </span><span class="s1">parent_module </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.msg(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;safe_import_module create reference&quot;</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s4">&quot;-&gt;&quot;</span><span class="s3">, </span><span class="s1">parent_module)</span>

            <span class="s2"># Add an edge from this submodule to its parent module.</span>
            <span class="s1">self._updateReference(</span>
                <span class="s1">module</span><span class="s3">, </span><span class="s1">parent_module</span><span class="s3">, </span><span class="s1">edge_data=DependencyInfo(</span>
                    <span class="s1">conditional=</span><span class="s3">False,</span>
                    <span class="s1">fromlist=</span><span class="s3">False,</span>
                    <span class="s1">function=</span><span class="s3">False,</span>
                    <span class="s1">tryexcept=</span><span class="s3">False,</span>
            <span class="s1">))</span>

            <span class="s2"># Add this submodule to its parent module.</span>
            <span class="s1">parent_module.add_submodule(module_partname</span><span class="s3">, </span><span class="s1">module)</span>

        <span class="s2"># Return this module.</span>
        <span class="s1">self.msgout(</span><span class="s5">3</span><span class="s3">, </span><span class="s4">&quot;safe_import_module -&gt;&quot;</span><span class="s3">, </span><span class="s1">module)</span>
        <span class="s3">return </span><span class="s1">module</span>

    <span class="s3">def </span><span class="s1">_load_module(self</span><span class="s3">, </span><span class="s1">fqname</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s1">loader):</span>
        <span class="s3">from </span><span class="s1">importlib._bootstrap_external </span><span class="s3">import </span><span class="s1">ExtensionFileLoader</span>
        <span class="s1">self.msgin(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;load_module&quot;</span><span class="s3">, </span><span class="s1">fqname</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">,</span>
                   <span class="s1">loader.__class__.__name__)</span>
        <span class="s1">partname = fqname.rpartition(</span><span class="s4">&quot;.&quot;</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s3">if </span><span class="s1">loader.is_package(partname):</span>
            <span class="s1">is_nspkg = isinstance(loader</span><span class="s3">, </span><span class="s1">NAMESPACE_PACKAGE)</span>
            <span class="s3">if </span><span class="s1">is_nspkg:</span>
                <span class="s1">pkgpath = loader.namespace_dirs[:]  </span><span class="s2"># copy for safety</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">pkgpath = []</span>

            <span class="s1">newname = _replacePackageMap.get(fqname)</span>
            <span class="s3">if </span><span class="s1">newname:</span>
                <span class="s1">fqname = newname</span>
            <span class="s1">ns_pkgpath = _namespace_package_path(</span>
                <span class="s1">fqname</span><span class="s3">, </span><span class="s1">pkgpath </span><span class="s3">or </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">self.path)</span>

            <span class="s3">if </span><span class="s1">(ns_pkgpath </span><span class="s3">or </span><span class="s1">pkgpath) </span><span class="s3">and </span><span class="s1">is_nspkg:</span>
                <span class="s2"># this is a PEP-420 namespace package</span>
                <span class="s1">m = self.createNode(NamespacePackage</span><span class="s3">, </span><span class="s1">fqname)</span>
                <span class="s1">m.filename = </span><span class="s4">'-'</span>
                <span class="s1">m.packagepath = ns_pkgpath</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">isinstance(loader</span><span class="s3">, </span><span class="s1">ExtensionFileLoader):</span>
                    <span class="s1">m = self.createNode(ExtensionPackage</span><span class="s3">, </span><span class="s1">fqname)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">m = self.createNode(Package</span><span class="s3">, </span><span class="s1">fqname)</span>
                <span class="s1">m.filename = pathname</span>
                <span class="s2"># PEP-302-compliant loaders return the pathname of the</span>
                <span class="s2"># `__init__`-file, not the packge directory.</span>
                <span class="s3">assert </span><span class="s1">os.path.basename(pathname).startswith(</span><span class="s4">'__init__.'</span><span class="s1">)</span>
                <span class="s1">m.packagepath = [os.path.dirname(pathname)] + ns_pkgpath</span>

            <span class="s2"># As per comment at top of file, simulate runtime packagepath</span>
            <span class="s2"># additions</span>
            <span class="s1">m.packagepath = m.packagepath + self._package_path_map.get(</span>
                <span class="s1">fqname</span><span class="s3">, </span><span class="s1">[])</span>

            <span class="s3">if </span><span class="s1">isinstance(m</span><span class="s3">, </span><span class="s1">NamespacePackage):</span>
                <span class="s3">return </span><span class="s1">(m</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">co = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">loader </span><span class="s3">is </span><span class="s1">BUILTIN_MODULE:</span>
            <span class="s1">cls = BuiltinModule</span>
        <span class="s3">elif </span><span class="s1">isinstance(loader</span><span class="s3">, </span><span class="s1">ExtensionFileLoader):</span>
            <span class="s1">cls = Extension</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">src = loader.get_source(partname)</span>
            <span class="s3">if </span><span class="s1">src </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">co = compile(src</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s4">'exec'</span><span class="s3">, </span><span class="s1">ast.PyCF_ONLY_AST</span><span class="s3">,</span>
                                 <span class="s3">True</span><span class="s1">)</span>
                    <span class="s1">cls = SourceModule</span>
                    <span class="s3">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] == (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s1">):</span>
                        <span class="s2"># In Python 3.5 some syntax problems with async</span>
                        <span class="s2"># functions are only reported when compiling to</span>
                        <span class="s2"># bytecode</span>
                        <span class="s1">compile(co</span><span class="s3">, </span><span class="s4">'-'</span><span class="s3">, </span><span class="s4">'exec'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, True</span><span class="s1">)</span>
                <span class="s3">except </span><span class="s1">SyntaxError:</span>
                    <span class="s1">co = </span><span class="s3">None</span>
                    <span class="s1">cls = InvalidSourceModule</span>
                <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">exc:  </span><span class="s2"># FIXME: more specific?</span>
                    <span class="s1">cls = InvalidSourceModule</span>
                    <span class="s1">self.msg(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;load_module: InvalidSourceModule&quot;</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">,</span>
                             <span class="s1">exc)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s2"># no src available</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">co = loader.get_code(partname)</span>
                    <span class="s1">cls = (CompiledModule </span><span class="s3">if </span><span class="s1">co </span><span class="s3">is not None</span>
                           <span class="s3">else </span><span class="s1">InvalidCompiledModule)</span>
                <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">exc:  </span><span class="s2"># FIXME: more specific?</span>
                    <span class="s1">self.msg(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;load_module: InvalidCompiledModule, &quot;</span>
                             <span class="s4">&quot;Cannot load code&quot;</span><span class="s3">, </span><span class="s1">pathname</span><span class="s3">, </span><span class="s1">exc)</span>
                    <span class="s1">cls = InvalidCompiledModule</span>

        <span class="s1">m = self.createNode(cls</span><span class="s3">, </span><span class="s1">fqname)</span>
        <span class="s1">m.filename = pathname</span>

        <span class="s1">self.msgout(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;load_module -&gt;&quot;</span><span class="s3">, </span><span class="s1">m)</span>
        <span class="s3">return </span><span class="s1">(m</span><span class="s3">, </span><span class="s1">co)</span>

    <span class="s3">def </span><span class="s1">_safe_import_hook(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">source_module</span><span class="s3">, </span><span class="s1">target_attr_names</span><span class="s3">,</span>
        <span class="s1">level=DEFAULT_IMPORT_LEVEL</span><span class="s3">, </span><span class="s1">edge_attr=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Import the module with the passed name and all parent packages of this 
        module from the previously imported caller module signified by the 
        passed graph node _without_ raising `ImportError` exceptions. 
 
        This method wraps the lowel-level `_import_hook()` method. On catching 
        an `ImportError` exception raised by that method, this method creates 
        and adds a `MissingNode` instance describing the unimportable module to 
        the graph instead. 
 
        Parameters 
        ---------- 
        target_module_partname : str 
            Partially-qualified name of the module to be imported. If `level` 
            is: 
            * `ABSOLUTE_OR_RELATIVE_IMPORT_LEVEL` (e.g., the Python 2 default) 
              or a positive integer (e.g., an explicit relative import), the 
              fully-qualified name of this module is the concatenation of the 
              fully-qualified name of the caller module's package and this 
              parameter. 
            * `ABSOLUTE_IMPORT_LEVEL` (e.g., the Python 3 default), this name 
              is already fully-qualified. 
            * A non-negative integer (e.g., `1`), this name is typically the 
              empty string. In this case, this is a &quot;from&quot;-style relative 
              import (e.g., &quot;from . import bar&quot;) and the fully-qualified name 
              of this module is dynamically resolved by import machinery. 
        source_module : Node 
            Graph node for the previously imported **caller module** (i.e., 
            module containing the `import` statement triggering the call to 
            this method) _or_ `None` if this module is to be imported in a 
            &quot;disconnected&quot; manner. **Passing `None` is _not_ recommended.** 
            Doing so produces a disconnected graph in which the graph node 
            created for the module to be imported will be disconnected and 
            hence unreachable from all other nodes -- which frequently causes 
            subtle issues in external callers (e.g., PyInstaller, which 
            silently ignores unreachable nodes). 
        target_attr_names : list 
            List of the unqualified names of all submodules and attributes to 
            be imported via a `from`-style import statement from this target 
            module if any (e.g., the list `[encode_base64, encode_noop]` for 
            the import `from email.encoders import encode_base64, encode_noop`) 
            _or_ `None` otherwise. Ignored unless `source_module` is the graph 
            node of a package (i.e., is an instance of the `Package` class). 
            Why? Because: 
            * Consistency. The `_import_importable_package_submodules()` 
              method accepts a similar list applicable only to packages. 
            * Efficiency. Unlike packages, modules cannot physically contain 
              submodules. Hence, any target module imported via a `from`-style 
              import statement as an attribute from another target parent 
              module must itself have been imported in that target parent 
              module. The import statement responsible for that import must 
              already have been previously parsed by `ModuleGraph`, in which 
              case that target module will already be frozen by PyInstaller. 
              These imports are safely ignorable here. 
        level : int 
            Whether to perform an absolute or relative import. This parameter 
            corresponds exactly to the parameter of the same name accepted by 
            the `__import__()` built-in: &quot;The default is -1 which indicates 
            both absolute and relative imports will be attempted. 0 means only 
            perform absolute imports. Positive values for level indicate the 
            number of parent directories to search relative to the directory of 
            the module calling `__import__()`.&quot; Defaults to -1 under Python 2 
            and 0 under Python 3. Since this default depends on the major 
            version of the current Python interpreter, depending on this 
            default can result in unpredictable and non-portable behaviour. 
            Callers are strongly recommended to explicitly pass this parameter 
            rather than implicitly accept this default. 
 
        Returns 
        ---------- 
        list 
            List of the graph nodes created for all modules explicitly imported 
            by this call, including the passed module and all submodules listed 
            in `target_attr_names` _but_ excluding all parent packages 
            implicitly imported by this call. If `target_attr_names` is either 
            `None` or the empty list, this is guaranteed to be a list of one 
            element: the graph node created for the passed module. As above, 
            `MissingNode` instances are created for all unimportable modules. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msg(</span><span class="s5">3</span><span class="s3">, </span><span class="s4">&quot;_safe_import_hook&quot;</span><span class="s3">, </span><span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">source_module</span><span class="s3">, </span><span class="s1">target_attr_names</span><span class="s3">, </span><span class="s1">level)</span>

        <span class="s3">def </span><span class="s1">is_swig_candidate():</span>
            <span class="s3">return </span><span class="s1">(source_module </span><span class="s3">is not None and</span>
                    <span class="s1">target_attr_names </span><span class="s3">is None and</span>
                    <span class="s1">level == ABSOLUTE_IMPORT_LEVEL </span><span class="s3">and</span>
                    <span class="s1">type(source_module) </span><span class="s3">is </span><span class="s1">SourceModule </span><span class="s3">and</span>
                    <span class="s1">target_module_partname ==</span>
                      <span class="s4">'_' </span><span class="s1">+ source_module.identifier.rpartition(</span><span class="s4">'.'</span><span class="s1">)[</span><span class="s5">2</span><span class="s1">] </span><span class="s3">and</span>
                    <span class="s1">sys.version_info[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">3</span><span class="s1">)</span>

        <span class="s3">def </span><span class="s1">is_swig_wrapper(source_module):</span>
            <span class="s2"># TODO Define a new function util.open_text_file() performing</span>
            <span class="s2"># this logic, which is repeated numerous times in this module.</span>
            <span class="s2"># FIXME: Actually, can't we just use the new compat.open()</span>
            <span class="s2"># function to reliably open text files in a portable manner?</span>
            <span class="s3">with </span><span class="s1">open(source_module.filename</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">source_module_file:</span>
                <span class="s1">encoding = util.guess_encoding(source_module_file)</span>
            <span class="s3">with </span><span class="s1">open(source_module.filename</span><span class="s3">, </span><span class="s1">_READ_MODE</span><span class="s3">, </span><span class="s1">encoding=encoding) \</span>
                    <span class="s3">as </span><span class="s1">source_module_file:</span>
                <span class="s1">first_line = source_module_file.readline()</span>
            <span class="s1">self.msg(</span><span class="s5">5</span><span class="s3">, </span><span class="s4">'SWIG wrapper candidate first line: %r' </span><span class="s1">% (first_line))</span>
            <span class="s3">return </span><span class="s4">&quot;automatically generated by SWIG&quot; </span><span class="s3">in </span><span class="s1">first_line</span>


        <span class="s2"># List of the graph nodes created for all target modules both</span>
        <span class="s2"># imported by and returned from this call, whose:</span>
        <span class="s2">#</span>
        <span class="s2"># * First element is the graph node for the core target module</span>
        <span class="s2">#   specified by the &quot;target_module_partname&quot; parameter.</span>
        <span class="s2"># * Remaining elements are the graph nodes for all target submodules</span>
        <span class="s2">#   specified by the &quot;target_attr_names&quot; parameter.</span>
        <span class="s1">target_modules = </span><span class="s3">None</span>

        <span class="s2"># True if this is a Python 2-style implicit relative import of a</span>
        <span class="s2"># SWIG-generated C extension. False if we checked and it is not SWIG.</span>
        <span class="s2"># None if we haven't checked yet.</span>
        <span class="s1">is_swig_import = </span><span class="s3">None</span>

        <span class="s2"># Attempt to import this target module in the customary way.</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">target_modules = self.import_hook(</span>
                <span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">source_module</span><span class="s3">,</span>
                <span class="s1">target_attr_names=</span><span class="s3">None, </span><span class="s1">level=level</span><span class="s3">, </span><span class="s1">edge_attr=edge_attr)</span>
        <span class="s2"># Failing that, defer to custom module importers handling non-standard</span>
        <span class="s2"># import schemes (namely, SWIG).</span>
        <span class="s3">except </span><span class="s1">InvalidRelativeImportError:</span>
            <span class="s1">self.msgout(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;Invalid relative import&quot;</span><span class="s3">, </span><span class="s1">level</span><span class="s3">,</span>
                        <span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">target_attr_names)</span>
            <span class="s1">result = []</span>
            <span class="s3">for </span><span class="s1">sub </span><span class="s3">in </span><span class="s1">target_attr_names </span><span class="s3">or </span><span class="s4">'*'</span><span class="s1">:</span>
                <span class="s1">m = self.createNode(InvalidRelativeImport</span><span class="s3">,</span>
                                    <span class="s4">'.' </span><span class="s1">* level + target_module_partname</span><span class="s3">, </span><span class="s1">sub)</span>
                <span class="s1">self._updateReference(source_module</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">edge_data=edge_attr)</span>
                <span class="s1">result.append(m)</span>
            <span class="s3">return </span><span class="s1">result</span>
        <span class="s3">except </span><span class="s1">ImportError </span><span class="s3">as </span><span class="s1">msg:</span>
            <span class="s2"># If this is an absolute top-level import under Python 3 and if the</span>
            <span class="s2"># name to be imported is the caller's name prefixed by &quot;_&quot;, this</span>
            <span class="s2"># could be a SWIG-generated Python 2-style implicit relative import.</span>
            <span class="s2"># SWIG-generated files contain functions named swig_import_helper()</span>
            <span class="s2"># importing dynamic libraries residing in the same directory. For</span>
            <span class="s2"># example, a SWIG-generated caller module &quot;csr.py&quot; might resemble:</span>
            <span class="s2">#</span>
            <span class="s2">#     # This file was automatically generated by SWIG (http://www.swig.org).</span>
            <span class="s2">#     ...</span>
            <span class="s2">#     def swig_import_helper():</span>
            <span class="s2">#         ...</span>
            <span class="s2">#         try:</span>
            <span class="s2">#             fp, pathname, description = imp.find_module('_csr',</span>
            <span class="s2">#                   [dirname(__file__)])</span>
            <span class="s2">#         except ImportError:</span>
            <span class="s2">#             import _csr</span>
            <span class="s2">#             return _csr</span>
            <span class="s2">#</span>
            <span class="s2"># While there exists no reasonable means for modulegraph to parse</span>
            <span class="s2"># the call to imp.find_module(), the subsequent implicit relative</span>
            <span class="s2"># import is trivially parsable. This import is prohibited under</span>
            <span class="s2"># Python 3, however, and thus parsed only if the caller's file is</span>
            <span class="s2"># parsable plaintext (as indicated by a filetype of &quot;.py&quot;) and the</span>
            <span class="s2"># first line of this file is the above SWIG header comment.</span>
            <span class="s2">#</span>
            <span class="s2"># The constraint that this library's name be the caller's name</span>
            <span class="s2"># prefixed by '_' is explicitly mandated by SWIG and thus a</span>
            <span class="s2"># reliable indicator of &quot;SWIG-ness&quot;. The SWIG documentation states:</span>
            <span class="s2"># &quot;When linking the module, the name of the output file has to match</span>
            <span class="s2">#  the name of the module prefixed by an underscore.&quot;</span>
            <span class="s2">#</span>
            <span class="s2"># Only source modules (e.g., &quot;.py&quot;-suffixed files) are SWIG import</span>
            <span class="s2"># candidates. All other node types are safely ignorable.</span>
            <span class="s3">if </span><span class="s1">is_swig_candidate():</span>
                <span class="s1">self.msg(</span>
                    <span class="s5">4</span><span class="s3">,</span>
                    <span class="s4">'SWIG import candidate (name=%r, caller=%r, level=%r)' </span><span class="s1">% (</span>
                        <span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">source_module</span><span class="s3">, </span><span class="s1">level))</span>
                <span class="s1">is_swig_import = is_swig_wrapper(source_module)</span>
                <span class="s3">if </span><span class="s1">is_swig_import:</span>
                    <span class="s2"># Convert this Python 2-compliant implicit relative</span>
                    <span class="s2"># import prohibited by Python 3 into a Python</span>
                    <span class="s2"># 3-compliant explicit relative &quot;from&quot;-style import for</span>
                    <span class="s2"># the duration of this function call by overwriting the</span>
                    <span class="s2"># original parameters passed to this call.</span>
                    <span class="s1">target_attr_names = [target_module_partname]</span>
                    <span class="s1">target_module_partname = </span><span class="s4">''</span>
                    <span class="s1">level = </span><span class="s5">1</span>
                    <span class="s1">self.msg(</span><span class="s5">2</span><span class="s3">,</span>
                             <span class="s4">'SWIG import (caller=%r, fromlist=%r, level=%r)'</span>
                             <span class="s1">% (source_module</span><span class="s3">, </span><span class="s1">target_attr_names</span><span class="s3">, </span><span class="s1">level))</span>
                    <span class="s2"># Import this target SWIG C extension's package.</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">target_modules = self.import_hook(</span>
                            <span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">source_module</span><span class="s3">,</span>
                            <span class="s1">target_attr_names=</span><span class="s3">None,</span>
                            <span class="s1">level=level</span><span class="s3">,</span>
                            <span class="s1">edge_attr=edge_attr)</span>
                    <span class="s3">except </span><span class="s1">ImportError </span><span class="s3">as </span><span class="s1">msg:</span>
                        <span class="s1">self.msg(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;SWIG ImportError:&quot;</span><span class="s3">, </span><span class="s1">str(msg))</span>

            <span class="s2"># If this module remains unimportable...</span>
            <span class="s3">if </span><span class="s1">target_modules </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">self.msg(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;ImportError:&quot;</span><span class="s3">, </span><span class="s1">str(msg))</span>

                <span class="s2"># Add this module as a MissingModule node.</span>
                <span class="s1">target_module = self.createNode(</span>
                    <span class="s1">MissingModule</span><span class="s3">,</span>
                    <span class="s1">_path_from_importerror(msg</span><span class="s3">, </span><span class="s1">target_module_partname))</span>
                <span class="s1">self._updateReference(</span>
                    <span class="s1">source_module</span><span class="s3">, </span><span class="s1">target_module</span><span class="s3">, </span><span class="s1">edge_data=edge_attr)</span>

                <span class="s2"># Initialize this list to this node.</span>
                <span class="s1">target_modules = [target_module]</span>

        <span class="s2"># Ensure that the above logic imported exactly one target module.</span>
        <span class="s3">assert </span><span class="s1">len(target_modules) == </span><span class="s5">1</span><span class="s3">, </span><span class="s1">(</span>
            <span class="s4">'Expected import_hook() to'</span>
            <span class="s4">'return only one module but received: {}'</span><span class="s1">.format(target_modules))</span>

        <span class="s2"># Target module imported above.</span>
        <span class="s1">target_module = target_modules[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s3">if </span><span class="s1">isinstance(target_module</span><span class="s3">, </span><span class="s1">MissingModule) \</span>
           <span class="s3">and </span><span class="s1">is_swig_import </span><span class="s3">is None and </span><span class="s1">is_swig_candidate() \</span>
           <span class="s3">and </span><span class="s1">is_swig_wrapper(source_module):</span>
            <span class="s2"># if this possible swig C module was previously imported from</span>
            <span class="s2"># a python module other than its corresponding swig python</span>
            <span class="s2"># module, then it may have been considered a MissingModule.</span>
            <span class="s2"># Try to reimport it now. For details see pull-request #2578</span>
            <span class="s2"># and issue #1522.</span>
            <span class="s2">#</span>
            <span class="s2"># If this module was takes as a SWIG candidate above, but failed</span>
            <span class="s2"># to import, this would be a MissingModule, too. Thus check if</span>
            <span class="s2"># this was the case (is_swig_import would be not None) to avoid</span>
            <span class="s2"># recursion error. If `is_swig_import` is None and we are still a</span>
            <span class="s2"># swig candidate then that means we haven't properly imported this</span>
            <span class="s2"># swig module yet so do that below.</span>
            <span class="s2">#</span>
            <span class="s2"># Remove the MissingModule node from the graph so that we can</span>
            <span class="s2"># attempt a reimport and avoid collisions. This node should be</span>
            <span class="s2"># fine to remove because the proper module will be imported and</span>
            <span class="s2"># added to the graph in the next line (call to _safe_import_hook).</span>
            <span class="s1">self.removeNode(target_module)</span>
            <span class="s2"># Reimport the SWIG C module relative to the wrapper</span>
            <span class="s1">target_modules = self._safe_import_hook(</span>
                <span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">source_module</span><span class="s3">,</span>
                <span class="s1">target_attr_names=</span><span class="s3">None, </span><span class="s1">level=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">edge_attr=edge_attr)</span>
            <span class="s2"># return the output regardless because it would just be</span>
            <span class="s2"># duplicating the processing below</span>
            <span class="s3">return </span><span class="s1">target_modules</span>

        <span class="s3">if </span><span class="s1">isinstance(edge_attr</span><span class="s3">, </span><span class="s1">DependencyInfo):</span>
            <span class="s1">edge_attr = edge_attr._replace(fromlist=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s2"># If this is a &quot;from&quot;-style import *AND* this target module is a</span>
        <span class="s2"># package, import all attributes listed by the &quot;import&quot; clause of this</span>
        <span class="s2"># import that are submodules of this package. If this target module is</span>
        <span class="s2"># *NOT* a package, these attributes are always ignorable globals (e.g.,</span>
        <span class="s2"># classes, variables) defined at the top level of this module.</span>
        <span class="s2">#</span>
        <span class="s2"># If this target module is a non-package, it could still contain</span>
        <span class="s2"># importable submodules (e.g., the non-package `os` module containing</span>
        <span class="s2"># the `os.path` submodule). In this case, these submodules are already</span>
        <span class="s2"># imported by this target module's pure-Python code. Since our import</span>
        <span class="s2"># scanner already detects these imports, these submodules need *NOT* be</span>
        <span class="s2"># reimported here. (Doing so would be harmless but inefficient.)</span>
        <span class="s3">if </span><span class="s1">target_attr_names </span><span class="s3">and </span><span class="s1">isinstance(target_module</span><span class="s3">,</span>
                                            <span class="s1">(Package</span><span class="s3">, </span><span class="s1">AliasNode)):</span>
            <span class="s2"># For the name of each attribute imported from this target package</span>
            <span class="s2"># into this source module...</span>
            <span class="s3">for </span><span class="s1">target_submodule_partname </span><span class="s3">in </span><span class="s1">target_attr_names:</span>
                <span class="s2">#FIXME: Is this optimization *REALLY* an optimization or at all</span>
                <span class="s2">#necessary? The findNode() method called below should already</span>
                <span class="s2">#be heavily optimized, in which case this optimization here is</span>
                <span class="s2">#premature, senseless, and should be eliminated.</span>

                <span class="s2"># If this attribute is a previously imported submodule of this</span>
                <span class="s2"># target module, optimize this edge case.</span>
                <span class="s3">if </span><span class="s1">target_module.is_submodule(target_submodule_partname):</span>
                    <span class="s2"># Graph node for this submodule.</span>
                    <span class="s1">target_submodule = target_module.get_submodule(</span>
                        <span class="s1">target_submodule_partname)</span>

                    <span class="s2">#FIXME: What? Shouldn't &quot;target_submodule&quot; *ALWAYS* be</span>
                    <span class="s2">#non-None here? Assert this to be non-None instead.</span>
                    <span class="s3">if </span><span class="s1">target_submodule </span><span class="s3">is not None</span><span class="s1">:</span>
                        <span class="s2">#FIXME: Why does duplication matter? List searches are</span>
                        <span class="s2">#mildly expensive.</span>

                        <span class="s2"># If this submodule has not already been added to the</span>
                        <span class="s2"># list of submodules to be returned, do so.</span>
                        <span class="s3">if </span><span class="s1">target_submodule </span><span class="s3">not in </span><span class="s1">target_modules:</span>
                            <span class="s1">self._updateReference(</span>
                                <span class="s1">source_module</span><span class="s3">,</span>
                                <span class="s1">target_submodule</span><span class="s3">,</span>
                                <span class="s1">edge_data=edge_attr)</span>
                            <span class="s1">target_modules.append(target_submodule)</span>
                        <span class="s3">continue</span>

                <span class="s2"># Fully-qualified name of this submodule.</span>
                <span class="s1">target_submodule_name = (</span>
                    <span class="s1">target_module.identifier + </span><span class="s4">'.' </span><span class="s1">+ target_submodule_partname)</span>

                <span class="s2"># Graph node of this submodule if previously imported or None.</span>
                <span class="s1">target_submodule = self.find_node(target_submodule_name)</span>

                <span class="s2"># If this submodule has not been imported, do so as if this</span>
                <span class="s2"># submodule were the only attribute listed by the &quot;import&quot;</span>
                <span class="s2"># clause of this import (e.g., as &quot;from foo import bar&quot; rather</span>
                <span class="s2"># than &quot;from foo import car, far, bar&quot;).</span>
                <span class="s3">if </span><span class="s1">target_submodule </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s2"># Attempt to import this submodule.</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s2"># Ignore the list of graph nodes returned by this</span>
                        <span class="s2"># method. If both this submodule's package and this</span>
                        <span class="s2"># submodule are importable, this method returns a</span>
                        <span class="s2"># 2-element list whose second element is this</span>
                        <span class="s2"># submodule's graph node. However, if this submodule's</span>
                        <span class="s2"># package is importable but this submodule is not,</span>
                        <span class="s2"># this submodule is either:</span>
                        <span class="s2">#</span>
                        <span class="s2"># * An ignorable global attribute defined at the top</span>
                        <span class="s2">#   level of this package's &quot;__init__&quot; submodule. In</span>
                        <span class="s2">#   this case, this method returns a 1-element list</span>
                        <span class="s2">#   without raising an exception.</span>
                        <span class="s2"># * A non-ignorable unimportable submodule. In this</span>
                        <span class="s2">#   case, this method raises an &quot;ImportError&quot;.</span>
                        <span class="s2">#</span>
                        <span class="s2"># While the first two cases are disambiguatable by the</span>
                        <span class="s2"># length of this list, doing so would render this code</span>
                        <span class="s2"># dependent on import_hook() details subject to change.</span>
                        <span class="s2"># Instead, call findNode() to decide the truthiness.</span>
                        <span class="s1">self.import_hook(</span>
                            <span class="s1">target_module_partname</span><span class="s3">, </span><span class="s1">source_module</span><span class="s3">,</span>
                            <span class="s1">target_attr_names=[target_submodule_partname]</span><span class="s3">,</span>
                            <span class="s1">level=level</span><span class="s3">,</span>
                            <span class="s1">edge_attr=edge_attr)</span>

                        <span class="s2"># Graph node of this submodule imported by the prior</span>
                        <span class="s2"># call if importable or None otherwise.</span>
                        <span class="s1">target_submodule = self.find_node(target_submodule_name)</span>

                        <span class="s2"># If this submodule does not exist, this *MUST* be an</span>
                        <span class="s2"># ignorable global attribute defined at the top level</span>
                        <span class="s2"># of this package's &quot;__init__&quot; submodule.</span>
                        <span class="s3">if </span><span class="s1">target_submodule </span><span class="s3">is None</span><span class="s1">:</span>
                            <span class="s2"># Assert this to actually be the case.</span>
                            <span class="s3">assert </span><span class="s1">target_module.is_global_attr(</span>
                                <span class="s1">target_submodule_partname)</span><span class="s3">, </span><span class="s1">(</span>
                                <span class="s4">'No global named {} in {}.__init__'</span><span class="s1">.format(</span>
                                    <span class="s1">target_submodule_partname</span><span class="s3">,</span>
                                    <span class="s1">target_module.identifier))</span>

                            <span class="s2"># Skip this safely ignorable importation to the</span>
                            <span class="s2"># next attribute. See similar logic in the body of</span>
                            <span class="s2"># _import_importable_package_submodules().</span>
                            <span class="s1">self.msg(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">'_safe_import_hook'</span><span class="s3">, </span><span class="s4">'ignoring imported non-module global'</span><span class="s3">, </span><span class="s1">target_module.identifier</span><span class="s3">, </span><span class="s1">target_submodule_partname)</span>
                            <span class="s3">continue</span>

                        <span class="s2"># If this is a SWIG C extension, instruct PyInstaller</span>
                        <span class="s2"># to freeze this extension under its unqualified rather</span>
                        <span class="s2"># than qualified name (e.g., as &quot;_csr&quot; rather than</span>
                        <span class="s2"># &quot;scipy.sparse.sparsetools._csr&quot;), permitting the</span>
                        <span class="s2"># implicit relative import in its parent SWIG module to</span>
                        <span class="s2"># successfully find this extension.</span>
                        <span class="s3">if </span><span class="s1">is_swig_import:</span>
                            <span class="s2"># If a graph node with this name already exists,</span>
                            <span class="s2"># avoid collisions by emitting an error instead.</span>
                            <span class="s3">if </span><span class="s1">self.find_node(target_submodule_partname):</span>
                                <span class="s1">self.msg(</span>
                                    <span class="s5">2</span><span class="s3">,</span>
                                    <span class="s4">'SWIG import error: %r basename %r '</span>
                                    <span class="s4">'already exists' </span><span class="s1">% (</span>
                                        <span class="s1">target_submodule_name</span><span class="s3">,</span>
                                        <span class="s1">target_submodule_partname))</span>
                            <span class="s3">else</span><span class="s1">:</span>
                                <span class="s1">self.msg(</span>
                                    <span class="s5">4</span><span class="s3">,</span>
                                    <span class="s4">'SWIG import renamed from %r to %r' </span><span class="s1">% (</span>
                                        <span class="s1">target_submodule_name</span><span class="s3">,</span>
                                        <span class="s1">target_submodule_partname))</span>
                                <span class="s1">target_submodule.identifier = (</span>
                                    <span class="s1">target_submodule_partname)</span>
                    <span class="s2"># If this submodule is unimportable, add a MissingModule.</span>
                    <span class="s3">except </span><span class="s1">ImportError </span><span class="s3">as </span><span class="s1">msg:</span>
                        <span class="s1">self.msg(</span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;ImportError:&quot;</span><span class="s3">, </span><span class="s1">str(msg))</span>
                        <span class="s1">target_submodule = self.createNode(</span>
                            <span class="s1">MissingModule</span><span class="s3">, </span><span class="s1">target_submodule_name)</span>

                <span class="s2"># Add this submodule to its package.</span>
                <span class="s1">target_module.add_submodule(</span>
                    <span class="s1">target_submodule_partname</span><span class="s3">, </span><span class="s1">target_submodule)</span>
                <span class="s3">if </span><span class="s1">target_submodule </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">self._updateReference(</span>
                        <span class="s1">target_module</span><span class="s3">, </span><span class="s1">target_submodule</span><span class="s3">, </span><span class="s1">edge_data=edge_attr)</span>
                    <span class="s1">self._updateReference(</span>
                        <span class="s1">source_module</span><span class="s3">, </span><span class="s1">target_submodule</span><span class="s3">, </span><span class="s1">edge_data=edge_attr)</span>

                    <span class="s3">if </span><span class="s1">target_submodule </span><span class="s3">not in </span><span class="s1">target_modules:</span>
                        <span class="s1">target_modules.append(target_submodule)</span>

        <span class="s2"># Return the list of all target modules imported by this call.</span>
        <span class="s3">return </span><span class="s1">target_modules</span>


    <span class="s3">def </span><span class="s1">_scan_code(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">module</span><span class="s3">,</span>
        <span class="s1">module_code_object</span><span class="s3">,</span>
        <span class="s1">module_code_object_ast=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parse and add all import statements from the passed code object of the 
        passed source module to this graph, recursively. 
 
        **This method is at the root of all `ModuleGraph` recursion.** 
        Recursion begins here and ends when all import statements in all code 
        objects of all modules transitively imported by the source module 
        passed to the first call to this method have been added to the graph. 
        Specifically, this method: 
 
        1. If the passed `module_code_object_ast` parameter is non-`None`, 
           parses all import statements from this object. 
        2. Else, parses all import statements from the passed 
           `module_code_object` parameter. 
        1. For each such import statement: 
           1. Adds to this `ModuleGraph` instance: 
              1. Nodes for all target modules of these imports. 
              1. Directed edges from this source module to these target 
                 modules. 
           2. Recursively calls this method with these target modules. 
 
        Parameters 
        ---------- 
        module : Node 
            Graph node of the module to be parsed. 
        module_code_object : PyCodeObject 
            Code object providing this module's disassembled Python bytecode. 
            Ignored unless `module_code_object_ast` is `None`. 
        module_code_object_ast : optional[ast.AST] 
            Optional abstract syntax tree (AST) of this module if any or `None` 
            otherwise. Defaults to `None`, in which case the passed 
            `module_code_object` is parsed instead. 
        Returns 
        ---------- 
        module : Node 
            Graph node of the module to be parsed. 
        &quot;&quot;&quot;</span>

        <span class="s2"># For safety, guard against multiple scans of the same module by</span>
        <span class="s2"># resetting this module's list of deferred target imports. While</span>
        <span class="s2"># uncommon, this edge case can occur due to:</span>
        <span class="s2">#</span>
        <span class="s2"># * Dynamic package replacement via the replacePackage() function. For</span>
        <span class="s2">#   example, the real &quot;_xmlplus&quot; package dynamically replaces itself</span>
        <span class="s2">#   with the fake &quot;xml&quot; package into the &quot;sys.modules&quot; cache of all</span>
        <span class="s2">#   currently loaded modules at runtime.</span>
        <span class="s1">module._deferred_imports = []</span>

        <span class="s2"># Parse all imports from this module *BEFORE* adding these imports to</span>
        <span class="s2"># the graph. If an AST is provided, parse that rather than this</span>
        <span class="s2"># module's code object.</span>
        <span class="s3">if </span><span class="s1">module_code_object_ast </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s2"># Parse this module's AST for imports.</span>
            <span class="s1">self._scan_ast(module</span><span class="s3">, </span><span class="s1">module_code_object_ast)</span>

            <span class="s2"># Parse this module's code object for all relevant non-imports</span>
            <span class="s2"># (e.g., global variable declarations and undeclarations).</span>
            <span class="s1">self._scan_bytecode(</span>
                <span class="s1">module</span><span class="s3">, </span><span class="s1">module_code_object</span><span class="s3">, </span><span class="s1">is_scanning_imports=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s2"># Else, parse this module's code object for imports.</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._scan_bytecode(</span>
                <span class="s1">module</span><span class="s3">, </span><span class="s1">module_code_object</span><span class="s3">, </span><span class="s1">is_scanning_imports=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">module</span>

    <span class="s3">def </span><span class="s1">_scan_ast(self</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">module_code_object_ast):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parse and add all import statements from the passed abstract syntax 
        tree (AST) of the passed source module to this graph, non-recursively. 
 
        Parameters 
        ---------- 
        module : Node 
            Graph node of the module to be parsed. 
        module_code_object_ast : ast.AST 
            Abstract syntax tree (AST) of this module to be parsed. 
        &quot;&quot;&quot;</span>

        <span class="s1">visitor = _Visitor(self</span><span class="s3">, </span><span class="s1">module)</span>
        <span class="s1">visitor.visit(module_code_object_ast)</span>

    <span class="s2">#FIXME: Optimize. Global attributes added by this method are tested by</span>
    <span class="s2">#other methods *ONLY* for packages, implying this method should scan and</span>
    <span class="s2">#handle opcodes pertaining to global attributes (e.g.,</span>
    <span class="s2">#&quot;STORE_NAME&quot;, &quot;DELETE_GLOBAL&quot;) only if the passed &quot;module&quot;</span>
    <span class="s2">#object is an instance of the &quot;Package&quot; class. For all other module types,</span>
    <span class="s2">#these opcodes should simply be ignored.</span>
    <span class="s2">#</span>
    <span class="s2">#After doing so, the &quot;Node._global_attr_names&quot; attribute and all methods</span>
    <span class="s2">#using this attribute (e.g., Node.is_global()) should be moved from the</span>
    <span class="s2">#&quot;Node&quot; superclass to the &quot;Package&quot; subclass.</span>
    <span class="s3">def </span><span class="s1">_scan_bytecode(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">module_code_object</span><span class="s3">, </span><span class="s1">is_scanning_imports):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parse and add all import statements from the passed code object of the 
        passed source module to this graph, non-recursively. 
 
        This method parses all reasonably parsable operations (i.e., operations 
        that are both syntactically and semantically parsable _without_ 
        requiring Turing-complete interpretation) directly or indirectly 
        involving module importation from this code object. This includes: 
 
        * `IMPORT_NAME`, denoting an import statement. Ignored unless 
          the passed `is_scanning_imports` parameter is `True`. 
        * `STORE_NAME` and `STORE_GLOBAL`, denoting the 
          declaration of a global attribute (e.g., class, variable) in this 
          module. This method stores each such declaration for subsequent 
          lookup. While global attributes are usually irrelevant to import 
          parsing, they remain the only means of distinguishing erroneous 
          non-ignorable attempts to import non-existent submodules of a package 
          from successful ignorable attempts to import existing global 
          attributes of a package's `__init__` submodule (e.g., the `bar` in 
          `from foo import bar`, which is either a non-ignorable submodule of 
          `foo` or an ignorable global attribute of `foo.__init__`). 
        * `DELETE_NAME` and `DELETE_GLOBAL`, denoting the 
          undeclaration of a previously declared global attribute in this 
          module. 
 
        Since `ModuleGraph` is _not_ intended to replicate the behaviour of a 
        full-featured Turing-complete Python interpreter, this method ignores 
        operations that are _not_ reasonably parsable from this code object -- 
        even those directly or indirectly involving module importation. This 
        includes: 
 
        * `STORE_ATTR(namei)`, implementing `TOS.name = TOS1`. If `TOS` is the 
          name of a target module currently imported into the namespace of the 
          passed source module, this opcode would ideally be parsed to add that 
          global attribute to that target module. Since this addition only 
          conditionally occurs on the importation of this source module and 
          execution of the code branch in this module performing this addition, 
          however, that global _cannot_ be unconditionally added to that target 
          module. In short, only Turing-complete behaviour suffices. 
        * `DELETE_ATTR(namei)`, implementing `del TOS.name`. If `TOS` is the 
          name of a target module currently imported into the namespace of the 
          passed source module, this opcode would ideally be parsed to remove 
          that global attribute from that target module. Again, however, only 
          Turing-complete behaviour suffices. 
 
        Parameters 
        ---------- 
        module : Node 
            Graph node of the module to be parsed. 
        module_code_object : PyCodeObject 
            Code object of the module to be parsed. 
        is_scanning_imports : bool 
            `True` only if this method is parsing import statements from 
            `IMPORT_NAME` opcodes. If `False`, no import statements will be 
            parsed. This parameter is typically: 
            * `True` when parsing this module's code object for such imports. 
            * `False` when parsing this module's abstract syntax tree (AST) 
              (rather than code object) for such imports. In this case, that 
              parsing will have already parsed import statements, which this 
              parsing must avoid repeating. 
        &quot;&quot;&quot;</span>
        <span class="s1">level = </span><span class="s3">None</span>
        <span class="s1">fromlist = </span><span class="s3">None</span>

        <span class="s2"># 'deque' is a list-like container with fast appends, pops on</span>
        <span class="s2"># either end, and automatically discarding elements too much.</span>
        <span class="s1">prev_insts = deque(maxlen=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">inst </span><span class="s3">in </span><span class="s1">util.iterate_instructions(module_code_object):</span>
            <span class="s3">if not </span><span class="s1">inst:</span>
                <span class="s3">continue</span>
            <span class="s2"># If this is an import statement originating from this module,</span>
            <span class="s2"># parse this import.</span>
            <span class="s2">#</span>
            <span class="s2"># Note that the related &quot;IMPORT_FROM&quot; opcode need *NOT* be parsed.</span>
            <span class="s2"># &quot;IMPORT_NAME&quot; suffices. For further details, see</span>
            <span class="s2">#     http://probablyprogramming.com/2008/04/14/python-import_name</span>
            <span class="s3">if </span><span class="s1">inst.opname == </span><span class="s4">'IMPORT_NAME'</span><span class="s1">:</span>
                <span class="s2"># If this method is ignoring import statements, skip to the</span>
                <span class="s2"># next opcode.</span>
                <span class="s3">if not </span><span class="s1">is_scanning_imports:</span>
                    <span class="s3">continue</span>

                <span class="s3">assert </span><span class="s1">prev_insts[-</span><span class="s5">2</span><span class="s1">].opname == </span><span class="s4">'LOAD_CONST'</span>
                <span class="s3">assert </span><span class="s1">prev_insts[-</span><span class="s5">1</span><span class="s1">].opname == </span><span class="s4">'LOAD_CONST'</span>

                <span class="s2"># Python &gt;=2.5: LOAD_CONST flags, LOAD_CONST names, IMPORT_NAME name</span>
                <span class="s1">level = prev_insts[-</span><span class="s5">2</span><span class="s1">].argval</span>
                <span class="s1">fromlist = prev_insts[-</span><span class="s5">1</span><span class="s1">].argval</span>

                <span class="s3">assert </span><span class="s1">fromlist </span><span class="s3">is None or </span><span class="s1">type(fromlist) </span><span class="s3">is </span><span class="s1">tuple</span>
                <span class="s1">target_module_partname = inst.argval</span>

                <span class="s2">#FIXME: The exact same logic appears in _collect_import(),</span>
                <span class="s2">#which isn't particularly helpful. Instead, defer this logic</span>
                <span class="s2">#until later by:</span>
                <span class="s2">#</span>
                <span class="s2">#* Refactor the &quot;_deferred_imports&quot; list to contain 2-tuples</span>
                <span class="s2">#  &quot;(_safe_import_hook_args, _safe_import_hook_kwargs)&quot; rather</span>
                <span class="s2">#  than 3-tuples &quot;(have_star, _safe_import_hook_args,</span>
                <span class="s2">#  _safe_import_hook_kwargs)&quot;.</span>
                <span class="s2">#* Stop prepending these tuples by a &quot;have_star&quot; boolean both</span>
                <span class="s2">#  here, in _collect_import(), and in _process_imports().</span>
                <span class="s2">#* Shift the logic below to _process_imports().</span>
                <span class="s2">#* Remove the same logic from _collect_import().</span>
                <span class="s1">have_star = </span><span class="s3">False</span>
                <span class="s3">if </span><span class="s1">fromlist </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">fromlist = uniq(fromlist)</span>
                    <span class="s3">if </span><span class="s4">'*' </span><span class="s3">in </span><span class="s1">fromlist:</span>
                        <span class="s1">fromlist.remove(</span><span class="s4">'*'</span><span class="s1">)</span>
                        <span class="s1">have_star = </span><span class="s3">True</span>

                <span class="s2"># Record this import as originating from this module for</span>
                <span class="s2"># subsequent handling by the _process_imports() method.</span>
                <span class="s1">module._deferred_imports.append((</span>
                    <span class="s1">have_star</span><span class="s3">,</span>
                    <span class="s1">(target_module_partname</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">fromlist</span><span class="s3">, </span><span class="s1">level)</span><span class="s3">,</span>
                    <span class="s1">{}</span>
                <span class="s1">))</span>

            <span class="s3">elif </span><span class="s1">inst.opname </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'STORE_NAME'</span><span class="s3">, </span><span class="s4">'STORE_GLOBAL'</span><span class="s1">):</span>
                <span class="s2"># If this is the declaration of a global attribute (e.g.,</span>
                <span class="s2"># class, variable) in this module, store this declaration for</span>
                <span class="s2"># subsequent lookup. See method docstring for further details.</span>
                <span class="s2">#</span>
                <span class="s2"># Global attributes are usually irrelevant to import parsing, but</span>
                <span class="s2"># remain the only means of distinguishing erroneous non-ignorable</span>
                <span class="s2"># attempts to import non-existent submodules of a package from</span>
                <span class="s2"># successful ignorable attempts to import existing global</span>
                <span class="s2"># attributes of a package's &quot;__init__&quot; submodule (e.g., the &quot;bar&quot;</span>
                <span class="s2"># in &quot;from foo import bar&quot;, which is either a non-ignorable</span>
                <span class="s2"># submodule of &quot;foo&quot; or an ignorable global attribute of</span>
                <span class="s2"># &quot;foo.__init__&quot;).</span>
                <span class="s1">name = inst.argval</span>
                <span class="s1">module.add_global_attr(name)</span>

            <span class="s3">elif </span><span class="s1">inst.opname </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'DELETE_NAME'</span><span class="s3">, </span><span class="s4">'DELETE_GLOBAL'</span><span class="s1">):</span>
                <span class="s2"># If this is the undeclaration of a previously declared global</span>
                <span class="s2"># attribute (e.g., class, variable) in this module, remove that</span>
                <span class="s2"># declaration to prevent subsequent lookup. See method docstring</span>
                <span class="s2"># for further details.</span>
                <span class="s1">name = inst.argval</span>
                <span class="s1">module.remove_global_attr_if_found(name)</span>

            <span class="s1">prev_insts.append(inst)</span>


    <span class="s3">def </span><span class="s1">_process_imports(self</span><span class="s3">, </span><span class="s1">source_module):</span>
        <span class="s0">&quot;&quot;&quot; 
        Graph all target modules whose importations were previously parsed from 
        the passed source module by a prior call to the `_scan_code()` method 
        and methods call by that method (e.g., `_scan_ast()`, 
        `_scan_bytecode()`, `_scan_bytecode_stores()`). 
 
        Parameters 
        ---------- 
        source_module : Node 
            Graph node of the source module to graph target imports for. 
        &quot;&quot;&quot;</span>

        <span class="s2"># If this source module imported no target modules, noop.</span>
        <span class="s3">if not </span><span class="s1">source_module._deferred_imports:</span>
            <span class="s3">return</span>

        <span class="s2"># For each target module imported by this source module...</span>
        <span class="s3">for </span><span class="s1">have_star</span><span class="s3">, </span><span class="s1">import_info</span><span class="s3">, </span><span class="s1">kwargs </span><span class="s3">in </span><span class="s1">source_module._deferred_imports:</span>
            <span class="s2"># Graph node of the target module specified by the &quot;from&quot; portion</span>
            <span class="s2"># of this &quot;from&quot;-style star import (e.g., an import resembling</span>
            <span class="s2"># &quot;from {target_module_name} import *&quot;) or ignored otherwise.</span>
            <span class="s1">target_module = self._safe_import_hook(*import_info</span><span class="s3">, </span><span class="s1">**kwargs)[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s2"># If this is a &quot;from&quot;-style star import, process this import.</span>
            <span class="s3">if </span><span class="s1">have_star:</span>
                <span class="s2">#FIXME: Sadly, the current approach to importing attributes</span>
                <span class="s2">#from &quot;from&quot;-style star imports is... simplistic. This should</span>
                <span class="s2">#be revised as follows. If this target module is:</span>
                <span class="s2">#</span>
                <span class="s2">#* A package:</span>
                <span class="s2">#  * Whose &quot;__init__&quot; submodule defines the &quot;__all__&quot; global</span>
                <span class="s2">#    attribute, only attributes listed by this attribute should</span>
                <span class="s2">#    be imported.</span>
                <span class="s2">#  * Else, *NO* attributes should be imported.</span>
                <span class="s2">#* A non-package:</span>
                <span class="s2">#  * Defining the &quot;__all__&quot; global attribute, only attributes</span>
                <span class="s2">#    listed by this attribute should be imported.</span>
                <span class="s2">#  * Else, only public attributes whose names are *NOT*</span>
                <span class="s2">#    prefixed by &quot;_&quot; should be imported.</span>
                <span class="s1">source_module.add_global_attrs_from_module(target_module)</span>

                <span class="s1">source_module._starimported_ignored_module_names.update(</span>
                    <span class="s1">target_module._starimported_ignored_module_names)</span>

                <span class="s2"># If this target module has no code object and hence is</span>
                <span class="s2"># unparsable, record its name for posterity.</span>
                <span class="s3">if </span><span class="s1">target_module.code </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">target_module_name = import_info[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">source_module._starimported_ignored_module_names.add(</span>
                        <span class="s1">target_module_name)</span>

        <span class="s2"># For safety, prevent these imports from being reprocessed.</span>
        <span class="s1">source_module._deferred_imports = </span><span class="s3">None</span>


    <span class="s3">def </span><span class="s1">_find_module(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">parent=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        3-tuple describing the physical location of the module with the passed 
        name if this module is physically findable _or_ raise `ImportError`. 
 
        This high-level method wraps the low-level `modulegraph.find_module()` 
        function with additional support for graph-based module caching. 
 
        Parameters 
        ---------- 
        name : str 
            Fully-qualified name of the Python module to be found. 
        path : list 
            List of the absolute paths of all directories to search for this 
            module _or_ `None` if the default path list `self.path` is to be 
            searched. 
        parent : Node 
            Package containing this module if this module is a submodule of a 
            package _or_ `None` if this is a top-level module. 
 
        Returns 
        ---------- 
        (filename, loader) 
            See `modulegraph._find_module()` for details. 
 
        Raises 
        ---------- 
        ImportError 
            If this module is _not_ found. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">parent </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s2"># assert path is not None</span>
            <span class="s1">fullname = parent.identifier + </span><span class="s4">'.' </span><span class="s1">+ name</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">fullname = name</span>

        <span class="s1">node = self.find_node(fullname)</span>
        <span class="s3">if </span><span class="s1">node </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.msg(</span><span class="s5">3</span><span class="s3">, </span><span class="s4">&quot;find_module: already included?&quot;</span><span class="s3">, </span><span class="s1">node)</span>
            <span class="s3">raise </span><span class="s1">ImportError(name)</span>

        <span class="s3">if </span><span class="s1">path </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">sys.builtin_module_names:</span>
                <span class="s3">return </span><span class="s1">(</span><span class="s3">None, </span><span class="s1">BUILTIN_MODULE)</span>

            <span class="s1">path = self.path</span>

        <span class="s3">return </span><span class="s1">self._find_module_path(fullname</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">path)</span>


    <span class="s3">def </span><span class="s1">_find_module_path(self</span><span class="s3">, </span><span class="s1">fullname</span><span class="s3">, </span><span class="s1">module_name</span><span class="s3">, </span><span class="s1">search_dirs):</span>
        <span class="s0">&quot;&quot;&quot; 
        3-tuple describing the physical location of the module with the passed 
        name if this module is physically findable _or_ raise `ImportError`. 
 
        This low-level function is a variant on the standard `imp.find_module()` 
        function with additional support for: 
 
        * Multiple search paths. The passed list of absolute paths will be 
          iteratively searched for the first directory containing a file 
          corresponding to this module. 
        * Compressed (e.g., zipped) packages. 
 
        For efficiency, the higher level `ModuleGraph._find_module()` method 
        wraps this function with support for module caching. 
 
        Parameters 
        ---------- 
        module_name : str 
            Fully-qualified name of the module to be found. 
        search_dirs : list 
            List of the absolute paths of all directories to search for this 
            module (in order). Searching will halt at the first directory 
            containing this module. 
 
        Returns 
        ---------- 
        (filename, loader) 
            2-tuple describing the physical location of this module, where: 
            * `filename` is the absolute path of this file. 
            * `loader` is the import loader. 
              In case of a namespace package, this is a NAMESPACE_PACKAGE 
              instance 
 
        Raises 
        ---------- 
        ImportError 
            If this module is _not_ found. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.msgin(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;_find_module_path &lt;-&quot;</span><span class="s3">, </span><span class="s1">fullname</span><span class="s3">, </span><span class="s1">search_dirs)</span>

        <span class="s2"># Top-level 2-tuple to be returned.</span>
        <span class="s1">path_data = </span><span class="s3">None</span>

        <span class="s2"># List of the absolute paths of all directories comprising the</span>
        <span class="s2"># namespace package to which this module belongs if any.</span>
        <span class="s1">namespace_dirs = []</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">search_dir </span><span class="s3">in </span><span class="s1">search_dirs:</span>
                <span class="s2"># PEP 302-compliant importer making loaders for this directory.</span>
                <span class="s1">importer = pkgutil.get_importer(search_dir)</span>

                <span class="s2"># If this directory is not importable, continue.</span>
                <span class="s3">if </span><span class="s1">importer </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s2"># self.msg(4, &quot;_find_module_path importer not found&quot;, search_dir)</span>
                    <span class="s3">continue</span>

                <span class="s2"># Get the PEP 302-compliant loader object loading this module.</span>
                <span class="s2">#</span>
                <span class="s2"># If this importer defines the PEP 302-compliant find_loader()</span>
                <span class="s2"># method, prefer that.</span>
                <span class="s3">if </span><span class="s1">hasattr(importer</span><span class="s3">, </span><span class="s4">'find_loader'</span><span class="s1">):</span>
                    <span class="s1">loader</span><span class="s3">, </span><span class="s1">loader_namespace_dirs = importer.find_loader(</span>
                        <span class="s1">module_name)</span>
                    <span class="s1">namespace_dirs.extend(loader_namespace_dirs)</span>
                <span class="s2"># Else if this importer defines the Python 2-specific</span>
                <span class="s2"># find_module() method, fall back to that. Despite the method</span>
                <span class="s2"># name, this method returns a loader rather than a module.</span>
                <span class="s3">elif </span><span class="s1">hasattr(importer</span><span class="s3">, </span><span class="s4">'find_module'</span><span class="s1">):</span>
                    <span class="s1">loader = importer.find_module(module_name)</span>
                <span class="s2"># Else, raise an exception.</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ImportError(</span>
                        <span class="s4">&quot;Module %r importer %r loader unobtainable&quot; </span><span class="s1">% (module_name</span><span class="s3">, </span><span class="s1">importer))</span>

                <span class="s2"># If this module is not loadable from this directory, continue.</span>
                <span class="s3">if </span><span class="s1">loader </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s2"># self.msg(4, &quot;_find_module_path loader not found&quot;, search_dir)</span>
                    <span class="s3">continue</span>

                <span class="s2"># Absolute path of this module. If this module resides in a</span>
                <span class="s2"># compressed archive, this is the absolute path of this module</span>
                <span class="s2"># after extracting this module from that archive and hence</span>
                <span class="s2"># should not exist; else, this path should typically exist.</span>
                <span class="s1">pathname = </span><span class="s3">None</span>

                <span class="s2"># If this loader defines the PEP 302-compliant get_filename()</span>
                <span class="s2"># method, preferably call that method first. Most if not all</span>
                <span class="s2"># loaders (including zipimporter objects) define this method.</span>
                <span class="s3">if </span><span class="s1">hasattr(loader</span><span class="s3">, </span><span class="s4">'get_filename'</span><span class="s1">):</span>
                    <span class="s1">pathname = loader.get_filename(module_name)</span>
                <span class="s2"># Else if this loader provides a &quot;path&quot; attribute, defer to that.</span>
                <span class="s3">elif </span><span class="s1">hasattr(loader</span><span class="s3">, </span><span class="s4">'path'</span><span class="s1">):</span>
                    <span class="s1">pathname = loader.path</span>
                <span class="s2"># Else, raise an exception.</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ImportError(</span>
                        <span class="s4">&quot;Module %r loader %r path unobtainable&quot; </span><span class="s1">% (module_name</span><span class="s3">, </span><span class="s1">loader))</span>

                <span class="s2"># If no path was found, this is probably a namespace package. In</span>
                <span class="s2"># such case, continue collecting namespace directories.</span>
                <span class="s3">if </span><span class="s1">pathname </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">self.msg(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;_find_module_path path not found&quot;</span><span class="s3">, </span><span class="s1">pathname)</span>
                    <span class="s3">continue</span>

                <span class="s2"># Return such metadata.</span>
                <span class="s1">path_data = (pathname</span><span class="s3">, </span><span class="s1">loader)</span>
                <span class="s3">break</span>
            <span class="s2"># Else if this is a namespace package, return such metadata.</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">namespace_dirs:</span>
                    <span class="s1">path_data = (namespace_dirs[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span>
                                 <span class="s1">NAMESPACE_PACKAGE(namespace_dirs))</span>
        <span class="s3">except </span><span class="s1">UnicodeDecodeError </span><span class="s3">as </span><span class="s1">exc:</span>
            <span class="s1">self.msgout(</span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;_find_module_path -&gt; unicode error&quot;</span><span class="s3">, </span><span class="s1">exc)</span>
        <span class="s2"># Ensure that exceptions are logged, as this function is typically</span>
        <span class="s2"># called by the import_module() method which squelches ImportErrors.</span>
        <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">exc:</span>
            <span class="s1">self.msgout(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;_find_module_path -&gt; exception&quot;</span><span class="s3">, </span><span class="s1">exc)</span>
            <span class="s3">raise</span>

        <span class="s2"># If this module was not found, raise an exception.</span>
        <span class="s1">self.msgout(</span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;_find_module_path -&gt;&quot;</span><span class="s3">, </span><span class="s1">path_data)</span>
        <span class="s3">if </span><span class="s1">path_data </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s4">&quot;No module named &quot; </span><span class="s1">+ repr(module_name))</span>

        <span class="s3">return </span><span class="s1">path_data</span>


    <span class="s3">def </span><span class="s1">create_xref(self</span><span class="s3">, </span><span class="s1">out=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">global </span><span class="s1">header</span><span class="s3">, </span><span class="s1">footer</span><span class="s3">, </span><span class="s1">entry</span><span class="s3">, </span><span class="s1">contpl</span><span class="s3">, </span><span class="s1">contpl_linked</span><span class="s3">, </span><span class="s1">imports</span>
        <span class="s3">if </span><span class="s1">out </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">out = sys.stdout</span>
        <span class="s1">scripts = []</span>
        <span class="s1">mods = []</span>
        <span class="s3">for </span><span class="s1">mod </span><span class="s3">in </span><span class="s1">self.iter_graph():</span>
            <span class="s1">name = os.path.basename(mod.identifier)</span>
            <span class="s3">if </span><span class="s1">isinstance(mod</span><span class="s3">, </span><span class="s1">Script):</span>
                <span class="s1">scripts.append((name</span><span class="s3">, </span><span class="s1">mod))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">mods.append((name</span><span class="s3">, </span><span class="s1">mod))</span>
        <span class="s1">scripts.sort()</span>
        <span class="s1">mods.sort()</span>
        <span class="s1">scriptnames = [sn </span><span class="s3">for </span><span class="s1">sn</span><span class="s3">, </span><span class="s1">m </span><span class="s3">in </span><span class="s1">scripts]</span>
        <span class="s1">scripts.extend(mods)</span>
        <span class="s1">mods = scripts</span>

        <span class="s1">title = </span><span class="s4">&quot;modulegraph cross reference for &quot; </span><span class="s1">+ </span><span class="s4">', '</span><span class="s1">.join(scriptnames)</span>
        <span class="s1">print(header % {</span><span class="s4">&quot;TITLE&quot;</span><span class="s1">: title}</span><span class="s3">, </span><span class="s1">file=out)</span>

        <span class="s3">def </span><span class="s1">sorted_namelist(mods):</span>
            <span class="s1">lst = [os.path.basename(mod.identifier) </span><span class="s3">for </span><span class="s1">mod </span><span class="s3">in </span><span class="s1">mods </span><span class="s3">if </span><span class="s1">mod]</span>
            <span class="s1">lst.sort()</span>
            <span class="s3">return </span><span class="s1">lst</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">m </span><span class="s3">in </span><span class="s1">mods:</span>
            <span class="s1">content = </span><span class="s4">&quot;&quot;</span>
            <span class="s3">if </span><span class="s1">isinstance(m</span><span class="s3">, </span><span class="s1">BuiltinModule):</span>
                <span class="s1">content = contpl % {</span><span class="s4">&quot;NAME&quot;</span><span class="s1">: name</span><span class="s3">,</span>
                                    <span class="s4">&quot;TYPE&quot;</span><span class="s1">: </span><span class="s4">&quot;&lt;i&gt;(builtin module)&lt;/i&gt;&quot;</span><span class="s1">}</span>
            <span class="s3">elif </span><span class="s1">isinstance(m</span><span class="s3">, </span><span class="s1">Extension):</span>
                <span class="s1">content = contpl % {</span><span class="s4">&quot;NAME&quot;</span><span class="s1">: name</span><span class="s3">,</span>
                                    <span class="s4">&quot;TYPE&quot;</span><span class="s1">: </span><span class="s4">&quot;&lt;tt&gt;%s&lt;/tt&gt;&quot; </span><span class="s1">% m.filename}</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">url = pathname2url(m.filename </span><span class="s3">or </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">content = contpl_linked % {</span><span class="s4">&quot;NAME&quot;</span><span class="s1">: name</span><span class="s3">, </span><span class="s4">&quot;URL&quot;</span><span class="s1">: url</span><span class="s3">,</span>
                                           <span class="s4">'TYPE'</span><span class="s1">: m.__class__.__name__}</span>
            <span class="s1">oute</span><span class="s3">, </span><span class="s1">ince = map(sorted_namelist</span><span class="s3">, </span><span class="s1">self.get_edges(m))</span>
            <span class="s3">if </span><span class="s1">oute:</span>
                <span class="s1">links = []</span>
                <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">oute:</span>
                    <span class="s1">links.append(</span><span class="s4">&quot;&quot;&quot;  &lt;a href=&quot;#%s&quot;&gt;%s&lt;/a&gt;</span><span class="s3">\n</span><span class="s4">&quot;&quot;&quot; </span><span class="s1">% (n</span><span class="s3">, </span><span class="s1">n))</span>
                <span class="s2"># #8226 = bullet-point; can't use html-entities since the</span>
                <span class="s2"># test-suite uses xml.etree.ElementTree.XMLParser, which</span>
                <span class="s2"># does't supprot them.</span>
                <span class="s1">links = </span><span class="s4">&quot; &amp;#8226; &quot;</span><span class="s1">.join(links)</span>
                <span class="s1">content += imports % {</span><span class="s4">&quot;HEAD&quot;</span><span class="s1">: </span><span class="s4">&quot;imports&quot;</span><span class="s3">, </span><span class="s4">&quot;LINKS&quot;</span><span class="s1">: links}</span>
            <span class="s3">if </span><span class="s1">ince:</span>
                <span class="s1">links = []</span>
                <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">ince:</span>
                    <span class="s1">links.append(</span><span class="s4">&quot;&quot;&quot;  &lt;a href=&quot;#%s&quot;&gt;%s&lt;/a&gt;</span><span class="s3">\n</span><span class="s4">&quot;&quot;&quot; </span><span class="s1">% (n</span><span class="s3">, </span><span class="s1">n))</span>
                <span class="s2"># #8226 = bullet-point; can't use html-entities since the</span>
                <span class="s2"># test-suite uses xml.etree.ElementTree.XMLParser, which</span>
                <span class="s2"># does't supprot them.</span>
                <span class="s1">links = </span><span class="s4">&quot; &amp;#8226; &quot;</span><span class="s1">.join(links)</span>
                <span class="s1">content += imports % {</span><span class="s4">&quot;HEAD&quot;</span><span class="s1">: </span><span class="s4">&quot;imported by&quot;</span><span class="s3">, </span><span class="s4">&quot;LINKS&quot;</span><span class="s1">: links}</span>
            <span class="s1">print(entry % {</span><span class="s4">&quot;NAME&quot;</span><span class="s1">: name</span><span class="s3">, </span><span class="s4">&quot;CONTENT&quot;</span><span class="s1">: content}</span><span class="s3">, </span><span class="s1">file=out)</span>
        <span class="s1">print(footer</span><span class="s3">, </span><span class="s1">file=out)</span>

    <span class="s3">def </span><span class="s1">itergraphreport(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s4">'G'</span><span class="s3">, </span><span class="s1">flatpackages=()):</span>
        <span class="s2"># XXX: Can this be implemented using Dot()?</span>
        <span class="s1">nodes = list(map(self.graph.describe_node</span><span class="s3">, </span><span class="s1">self.graph.iterdfs(self)))</span>
        <span class="s1">describe_edge = self.graph.describe_edge</span>
        <span class="s1">edges = deque()</span>
        <span class="s1">packagenodes = set()</span>
        <span class="s1">packageidents = {}</span>
        <span class="s1">nodetoident = {}</span>
        <span class="s1">inpackages = {}</span>
        <span class="s1">mainedges = set()</span>

        <span class="s2"># XXX - implement</span>
        <span class="s1">flatpackages = dict(flatpackages)</span>

        <span class="s3">def </span><span class="s1">nodevisitor(node</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">outgoing</span><span class="s3">, </span><span class="s1">incoming):</span>
            <span class="s3">if not </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">Node):</span>
                <span class="s3">return </span><span class="s1">{</span><span class="s4">'label'</span><span class="s1">: str(node)}</span>
            <span class="s2">#if isinstance(d, (ExcludedModule, MissingModule, BadModule)):</span>
            <span class="s2">#    return None</span>
            <span class="s1">s = </span><span class="s4">'&lt;f0&gt; ' </span><span class="s1">+ type(data).__name__</span>
            <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">enumerate(data.infoTuple()[:</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">s += </span><span class="s4">'| &lt;f%d&gt; %s' </span><span class="s1">% (i</span><span class="s3">, </span><span class="s1">v)</span>
            <span class="s3">return </span><span class="s1">{</span><span class="s4">'label'</span><span class="s1">: s</span><span class="s3">, </span><span class="s4">'shape'</span><span class="s1">: </span><span class="s4">'record'</span><span class="s1">}</span>


        <span class="s3">def </span><span class="s1">edgevisitor(edge</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">head</span><span class="s3">, </span><span class="s1">tail):</span>
            <span class="s2"># XXX: This method nonsense, the edge</span>
            <span class="s2"># data is never initialized.</span>
            <span class="s3">if </span><span class="s1">data == </span><span class="s4">'orphan'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">{</span><span class="s4">'style'</span><span class="s1">: </span><span class="s4">'dashed'</span><span class="s1">}</span>
            <span class="s3">elif </span><span class="s1">data == </span><span class="s4">'pkgref'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">{</span><span class="s4">'style'</span><span class="s1">: </span><span class="s4">'dotted'</span><span class="s1">}</span>
            <span class="s3">return </span><span class="s1">{}</span>

        <span class="s3">yield </span><span class="s4">'digraph %s {</span><span class="s3">\n</span><span class="s4">charset=&quot;UTF-8&quot;;</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (name</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">attr = dict(rankdir=</span><span class="s4">'LR'</span><span class="s3">, </span><span class="s1">concentrate=</span><span class="s4">'true'</span><span class="s1">)</span>
        <span class="s1">cpatt = </span><span class="s4">'%s=&quot;%s&quot;'</span>
        <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">attr.items():</span>
            <span class="s3">yield </span><span class="s4">'</span><span class="s3">\t</span><span class="s4">%s;</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (cpatt % item</span><span class="s3">,</span><span class="s1">)</span>

        <span class="s2"># find all packages (subgraphs)</span>
        <span class="s3">for </span><span class="s1">(node</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">outgoing</span><span class="s3">, </span><span class="s1">incoming) </span><span class="s3">in </span><span class="s1">nodes:</span>
            <span class="s1">nodetoident[node] = getattr(data</span><span class="s3">, </span><span class="s4">'identifier'</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">Package):</span>
                <span class="s1">packageidents[data.identifier] = node</span>
                <span class="s1">inpackages[node] = set([node])</span>
                <span class="s1">packagenodes.add(node)</span>

        <span class="s2"># create sets for subgraph, write out descriptions</span>
        <span class="s3">for </span><span class="s1">(node</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">outgoing</span><span class="s3">, </span><span class="s1">incoming) </span><span class="s3">in </span><span class="s1">nodes:</span>
            <span class="s2"># update edges</span>
            <span class="s3">for </span><span class="s1">edge </span><span class="s3">in </span><span class="s1">(describe_edge(e) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">outgoing):</span>
                <span class="s1">edges.append(edge)</span>

            <span class="s2"># describe node</span>
            <span class="s3">yield </span><span class="s4">'</span><span class="s3">\t</span><span class="s4">&quot;%s&quot; [%s];</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (</span>
                <span class="s1">node</span><span class="s3">,</span>
                <span class="s4">','</span><span class="s1">.join([</span>
                    <span class="s1">(cpatt % item) </span><span class="s3">for </span><span class="s1">item </span><span class="s3">in</span>
                    <span class="s1">nodevisitor(node</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">outgoing</span><span class="s3">, </span><span class="s1">incoming).items()</span>
                <span class="s1">])</span><span class="s3">,</span>
            <span class="s1">)</span>

            <span class="s1">inside = inpackages.get(node)</span>
            <span class="s3">if </span><span class="s1">inside </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">inside = inpackages[node] = set()</span>
            <span class="s1">ident = nodetoident[node]</span>
            <span class="s3">if </span><span class="s1">ident </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">continue</span>
            <span class="s1">pkgnode = packageidents.get(ident[:ident.rfind(</span><span class="s4">'.'</span><span class="s1">)])</span>
            <span class="s3">if </span><span class="s1">pkgnode </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">inside.add(pkgnode)</span>

        <span class="s1">graph = []</span>
        <span class="s1">subgraphs = {}</span>
        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">packagenodes:</span>
            <span class="s1">subgraphs[key] = []</span>

        <span class="s3">while </span><span class="s1">edges:</span>
            <span class="s1">edge</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">head</span><span class="s3">, </span><span class="s1">tail = edges.popleft()</span>
            <span class="s3">if </span><span class="s1">((head</span><span class="s3">, </span><span class="s1">tail)) </span><span class="s3">in </span><span class="s1">mainedges:</span>
                <span class="s3">continue</span>
            <span class="s1">mainedges.add((head</span><span class="s3">, </span><span class="s1">tail))</span>
            <span class="s1">tailpkgs = inpackages[tail]</span>
            <span class="s1">common = inpackages[head] &amp; tailpkgs</span>
            <span class="s3">if not </span><span class="s1">common </span><span class="s3">and </span><span class="s1">tailpkgs:</span>
                <span class="s1">usepkgs = sorted(tailpkgs)</span>
                <span class="s3">if </span><span class="s1">len(usepkgs) != </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">usepkgs[</span><span class="s5">0</span><span class="s1">] != tail:</span>
                    <span class="s1">edges.append((edge</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">head</span><span class="s3">, </span><span class="s1">usepkgs[</span><span class="s5">0</span><span class="s1">]))</span>
                    <span class="s1">edges.append((edge</span><span class="s3">, </span><span class="s4">'pkgref'</span><span class="s3">, </span><span class="s1">usepkgs[-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">tail))</span>
                    <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">common:</span>
                <span class="s1">common = common.pop()</span>
                <span class="s3">if </span><span class="s1">tail == common:</span>
                    <span class="s1">edges.append((edge</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">tail</span><span class="s3">, </span><span class="s1">head))</span>
                <span class="s3">elif </span><span class="s1">head == common:</span>
                    <span class="s1">subgraphs[common].append((edge</span><span class="s3">, </span><span class="s4">'pkgref'</span><span class="s3">, </span><span class="s1">head</span><span class="s3">, </span><span class="s1">tail))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">edges.append((edge</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">common</span><span class="s3">, </span><span class="s1">head))</span>
                    <span class="s1">edges.append((edge</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">common</span><span class="s3">, </span><span class="s1">tail))</span>

            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">graph.append((edge</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">head</span><span class="s3">, </span><span class="s1">tail))</span>

        <span class="s3">def </span><span class="s1">do_graph(edges</span><span class="s3">, </span><span class="s1">tabs):</span>
            <span class="s1">edgestr = tabs + </span><span class="s4">'&quot;%s&quot; -&gt; &quot;%s&quot; [%s];</span><span class="s3">\n</span><span class="s4">'</span>
            <span class="s2"># describe edge</span>
            <span class="s3">for </span><span class="s1">(edge</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">head</span><span class="s3">, </span><span class="s1">tail) </span><span class="s3">in </span><span class="s1">edges:</span>
                <span class="s1">attribs = edgevisitor(edge</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">head</span><span class="s3">, </span><span class="s1">tail)</span>
                <span class="s3">yield </span><span class="s1">edgestr % (</span>
                    <span class="s1">head</span><span class="s3">,</span>
                    <span class="s1">tail</span><span class="s3">,</span>
                    <span class="s4">','</span><span class="s1">.join([(cpatt % item) </span><span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">attribs.items()])</span><span class="s3">,</span>
                <span class="s1">)</span>

        <span class="s3">for </span><span class="s1">g</span><span class="s3">, </span><span class="s1">edges </span><span class="s3">in </span><span class="s1">subgraphs.items():</span>
            <span class="s3">yield </span><span class="s4">'</span><span class="s3">\t</span><span class="s4">subgraph &quot;cluster_%s&quot; {</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (g</span><span class="s3">,</span><span class="s1">)</span>
            <span class="s3">yield </span><span class="s4">'</span><span class="s3">\t\t</span><span class="s4">label=&quot;%s&quot;;</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (nodetoident[g]</span><span class="s3">,</span><span class="s1">)</span>
            <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">do_graph(edges</span><span class="s3">, </span><span class="s4">'</span><span class="s3">\t\t</span><span class="s4">'</span><span class="s1">):</span>
                <span class="s3">yield </span><span class="s1">s</span>
            <span class="s3">yield </span><span class="s4">'</span><span class="s3">\t</span><span class="s4">}</span><span class="s3">\n</span><span class="s4">'</span>

        <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">do_graph(graph</span><span class="s3">, </span><span class="s4">'</span><span class="s3">\t</span><span class="s4">'</span><span class="s1">):</span>
            <span class="s3">yield </span><span class="s1">s</span>

        <span class="s3">yield </span><span class="s4">'}</span><span class="s3">\n</span><span class="s4">'</span>

    <span class="s3">def </span><span class="s1">graphreport(self</span><span class="s3">, </span><span class="s1">fileobj=</span><span class="s3">None, </span><span class="s1">flatpackages=()):</span>
        <span class="s3">if </span><span class="s1">fileobj </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">fileobj = sys.stdout</span>
        <span class="s1">fileobj.writelines(self.itergraphreport(flatpackages=flatpackages))</span>

    <span class="s3">def </span><span class="s1">report(self):</span>
        <span class="s0">&quot;&quot;&quot;Print a report to stdout, listing the found modules with their 
        paths, as well as modules that are missing, or seem to be missing. 
        &quot;&quot;&quot;</span>
        <span class="s1">print()</span>
        <span class="s1">print(</span><span class="s4">&quot;%-15s %-25s %s&quot; </span><span class="s1">% (</span><span class="s4">&quot;Class&quot;</span><span class="s3">, </span><span class="s4">&quot;Name&quot;</span><span class="s3">, </span><span class="s4">&quot;File&quot;</span><span class="s1">))</span>
        <span class="s1">print(</span><span class="s4">&quot;%-15s %-25s %s&quot; </span><span class="s1">% (</span><span class="s4">&quot;-----&quot;</span><span class="s3">, </span><span class="s4">&quot;----&quot;</span><span class="s3">, </span><span class="s4">&quot;----&quot;</span><span class="s1">))</span>
        <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">sorted(self.iter_graph()</span><span class="s3">, </span><span class="s1">key=</span><span class="s3">lambda </span><span class="s1">n: n.identifier):</span>
            <span class="s1">print(</span><span class="s4">&quot;%-15s %-25s %s&quot; </span><span class="s1">% (type(m).__name__</span><span class="s3">, </span><span class="s1">m.identifier</span><span class="s3">, </span><span class="s1">m.filename </span><span class="s3">or </span><span class="s4">&quot;&quot;</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">_replace_paths_in_code(self</span><span class="s3">, </span><span class="s1">co):</span>
        <span class="s1">new_filename = original_filename = os.path.normpath(co.co_filename)</span>
        <span class="s3">for </span><span class="s1">f</span><span class="s3">, </span><span class="s1">r </span><span class="s3">in </span><span class="s1">self.replace_paths:</span>
            <span class="s1">f = os.path.join(f</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
            <span class="s1">r = os.path.join(r</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">original_filename.startswith(f):</span>
                <span class="s1">new_filename = r + original_filename[len(f):]</span>
                <span class="s3">break</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">co</span>

        <span class="s1">consts = list(co.co_consts)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(consts)):</span>
            <span class="s3">if </span><span class="s1">isinstance(consts[i]</span><span class="s3">, </span><span class="s1">type(co)):</span>
                <span class="s1">consts[i] = self._replace_paths_in_code(consts[i])</span>

        <span class="s1">code_func = type(co)</span>

        <span class="s3">if </span><span class="s1">hasattr(co</span><span class="s3">, </span><span class="s4">'replace'</span><span class="s1">): </span><span class="s2"># is_py38</span>
            <span class="s3">return </span><span class="s1">co.replace(co_consts=tuple(consts)</span><span class="s3">,</span>
                              <span class="s1">co_filename=new_filename)</span>
        <span class="s3">elif </span><span class="s1">hasattr(co</span><span class="s3">, </span><span class="s4">'co_kwonlyargcount'</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">code_func(</span>
                        <span class="s1">co.co_argcount</span><span class="s3">, </span><span class="s1">co.co_kwonlyargcount</span><span class="s3">, </span><span class="s1">co.co_nlocals</span><span class="s3">,</span>
                        <span class="s1">co.co_stacksize</span><span class="s3">, </span><span class="s1">co.co_flags</span><span class="s3">, </span><span class="s1">co.co_code</span><span class="s3">,</span>
                        <span class="s1">tuple(consts)</span><span class="s3">, </span><span class="s1">co.co_names</span><span class="s3">, </span><span class="s1">co.co_varnames</span><span class="s3">,</span>
                        <span class="s1">new_filename</span><span class="s3">, </span><span class="s1">co.co_name</span><span class="s3">, </span><span class="s1">co.co_firstlineno</span><span class="s3">,</span>
                        <span class="s1">co.co_lnotab</span><span class="s3">, </span><span class="s1">co.co_freevars</span><span class="s3">, </span><span class="s1">co.co_cellvars)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">code_func(</span>
                        <span class="s1">co.co_argcount</span><span class="s3">, </span><span class="s1">co.co_nlocals</span><span class="s3">, </span><span class="s1">co.co_stacksize</span><span class="s3">,</span>
                        <span class="s1">co.co_flags</span><span class="s3">, </span><span class="s1">co.co_code</span><span class="s3">, </span><span class="s1">tuple(consts)</span><span class="s3">, </span><span class="s1">co.co_names</span><span class="s3">,</span>
                        <span class="s1">co.co_varnames</span><span class="s3">, </span><span class="s1">new_filename</span><span class="s3">, </span><span class="s1">co.co_name</span><span class="s3">,</span>
                        <span class="s1">co.co_firstlineno</span><span class="s3">, </span><span class="s1">co.co_lnotab</span><span class="s3">,</span>
                        <span class="s1">co.co_freevars</span><span class="s3">, </span><span class="s1">co.co_cellvars)</span>
</pre>
</body>
</html>