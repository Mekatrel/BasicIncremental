<html>
<head>
<title>test_greenlet.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_greenlet.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">absolute_import</span>
<span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">division</span>
<span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">print_function</span>

<span class="s0">import </span><span class="s1">gc</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">time</span>
<span class="s0">import </span><span class="s1">threading</span>

<span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">ABCMeta</span><span class="s0">, </span><span class="s1">abstractmethod</span>

<span class="s0">from </span><span class="s1">greenlet </span><span class="s0">import </span><span class="s1">greenlet</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">TestCase</span>
<span class="s0">from </span><span class="s1">.leakcheck </span><span class="s0">import </span><span class="s1">fails_leakcheck</span>


<span class="s2"># We manually manage locks in many tests</span>
<span class="s2"># pylint:disable=consider-using-with</span>
<span class="s2"># pylint:disable=too-many-public-methods</span>

<span class="s0">class </span><span class="s1">SomeError(Exception):</span>
    <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">fmain(seen):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">greenlet.getcurrent().parent.switch()</span>
    <span class="s0">except</span><span class="s1">:</span>
        <span class="s1">seen.append(sys.exc_info()[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s0">raise</span>
    <span class="s0">raise </span><span class="s1">SomeError</span>


<span class="s0">def </span><span class="s1">send_exception(g</span><span class="s0">, </span><span class="s1">exc):</span>
    <span class="s2"># note: send_exception(g, exc)  can be now done with  g.throw(exc).</span>
    <span class="s2"># the purpose of this test is to explicitly check the propagation rules.</span>
    <span class="s0">def </span><span class="s1">crasher(exc):</span>
        <span class="s0">raise </span><span class="s1">exc</span>
    <span class="s1">g1 = greenlet(crasher</span><span class="s0">, </span><span class="s1">parent=g)</span>
    <span class="s1">g1.switch(exc)</span>


<span class="s0">class </span><span class="s1">TestGreenlet(TestCase):</span>

    <span class="s0">def </span><span class="s1">_do_simple_test(self):</span>
        <span class="s1">lst = []</span>

        <span class="s0">def </span><span class="s1">f():</span>
            <span class="s1">lst.append(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">greenlet.getcurrent().parent.switch()</span>
            <span class="s1">lst.append(</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">g = greenlet(f)</span>
        <span class="s1">lst.append(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">g.switch()</span>
        <span class="s1">lst.append(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">g.switch()</span>
        <span class="s1">lst.append(</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(lst</span><span class="s0">, </span><span class="s1">list(range(</span><span class="s3">5</span><span class="s1">)))</span>

    <span class="s0">def </span><span class="s1">test_simple(self):</span>
        <span class="s1">self._do_simple_test()</span>

    <span class="s0">def </span><span class="s1">test_switch_no_run_raises_AttributeError(self):</span>
        <span class="s1">g = greenlet()</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(AttributeError) </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s1">g.switch()</span>

        <span class="s1">self.assertIn(</span><span class="s4">&quot;run&quot;</span><span class="s0">, </span><span class="s1">str(exc.exception))</span>

    <span class="s0">def </span><span class="s1">test_throw_no_run_raises_AttributeError(self):</span>
        <span class="s1">g = greenlet()</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(AttributeError) </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s1">g.throw(SomeError)</span>

        <span class="s1">self.assertIn(</span><span class="s4">&quot;run&quot;</span><span class="s0">, </span><span class="s1">str(exc.exception))</span>

    <span class="s0">def </span><span class="s1">test_parent_equals_None(self):</span>
        <span class="s1">g = greenlet(parent=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">self.assertIsNotNone(g)</span>
        <span class="s1">self.assertIs(g.parent</span><span class="s0">, </span><span class="s1">greenlet.getcurrent())</span>

    <span class="s0">def </span><span class="s1">test_run_equals_None(self):</span>
        <span class="s1">g = greenlet(run=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">self.assertIsNotNone(g)</span>
        <span class="s1">self.assertIsNone(g.run)</span>

    <span class="s0">def </span><span class="s1">test_two_children(self):</span>
        <span class="s1">lst = []</span>

        <span class="s0">def </span><span class="s1">f():</span>
            <span class="s1">lst.append(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">greenlet.getcurrent().parent.switch()</span>
            <span class="s1">lst.extend([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">g = greenlet(f)</span>
        <span class="s1">h = greenlet(f)</span>
        <span class="s1">g.switch()</span>
        <span class="s1">self.assertEqual(len(lst)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">h.switch()</span>
        <span class="s1">self.assertEqual(len(lst)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">h.switch()</span>
        <span class="s1">self.assertEqual(len(lst)</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(h.dead</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">g.switch()</span>
        <span class="s1">self.assertEqual(len(lst)</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(g.dead</span><span class="s0">, True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_two_recursive_children(self):</span>
        <span class="s1">lst = []</span>

        <span class="s0">def </span><span class="s1">f():</span>
            <span class="s1">lst.append(</span><span class="s4">'b'</span><span class="s1">)</span>
            <span class="s1">greenlet.getcurrent().parent.switch()</span>

        <span class="s0">def </span><span class="s1">g():</span>
            <span class="s1">lst.append(</span><span class="s4">'a'</span><span class="s1">)</span>
            <span class="s1">g = greenlet(f)</span>
            <span class="s1">g.switch()</span>
            <span class="s1">lst.append(</span><span class="s4">'c'</span><span class="s1">)</span>

        <span class="s1">g = greenlet(g)</span>
        <span class="s1">self.assertEqual(sys.getrefcount(g)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">g.switch()</span>
        <span class="s1">self.assertEqual(lst</span><span class="s0">, </span><span class="s1">[</span><span class="s4">'a'</span><span class="s0">, </span><span class="s4">'b'</span><span class="s0">, </span><span class="s4">'c'</span><span class="s1">])</span>
        <span class="s2"># Just the one in this frame, plus the one on the stack we pass to the function</span>
        <span class="s1">self.assertEqual(sys.getrefcount(g)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_threads(self):</span>
        <span class="s1">success = []</span>

        <span class="s0">def </span><span class="s1">f():</span>
            <span class="s1">self._do_simple_test()</span>
            <span class="s1">success.append(</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">ths = [threading.Thread(target=f) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">10</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">th </span><span class="s0">in </span><span class="s1">ths:</span>
            <span class="s1">th.start()</span>
        <span class="s0">for </span><span class="s1">th </span><span class="s0">in </span><span class="s1">ths:</span>
            <span class="s1">th.join(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(success)</span><span class="s0">, </span><span class="s1">len(ths))</span>

    <span class="s0">def </span><span class="s1">test_exception(self):</span>
        <span class="s1">seen = []</span>
        <span class="s1">g1 = greenlet(fmain)</span>
        <span class="s1">g2 = greenlet(fmain)</span>
        <span class="s1">g1.switch(seen)</span>
        <span class="s1">g2.switch(seen)</span>
        <span class="s1">g2.parent = g1</span>

        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s2">#with self.assertRaises(SomeError):</span>
        <span class="s2">#    p(&quot;***Switching back&quot;)</span>
        <span class="s2">#    g2.switch()</span>
        <span class="s2"># Creating this as a bound method can reveal bugs that</span>
        <span class="s2"># are hidden on newer versions of Python that avoid creating</span>
        <span class="s2"># bound methods for direct expressions; IOW, don't use the `with`</span>
        <span class="s2"># form!</span>
        <span class="s1">self.assertRaises(SomeError</span><span class="s0">, </span><span class="s1">g2.switch)</span>
        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[SomeError])</span>

        <span class="s1">value = g2.switch()</span>
        <span class="s1">self.assertEqual(value</span><span class="s0">, </span><span class="s1">())</span>
        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[SomeError])</span>

        <span class="s1">value = g2.switch(</span><span class="s3">25</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(value</span><span class="s0">, </span><span class="s3">25</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[SomeError])</span>


    <span class="s0">def </span><span class="s1">test_send_exception(self):</span>
        <span class="s1">seen = []</span>
        <span class="s1">g1 = greenlet(fmain)</span>
        <span class="s1">g1.switch(seen)</span>
        <span class="s1">self.assertRaises(KeyError</span><span class="s0">, </span><span class="s1">send_exception</span><span class="s0">, </span><span class="s1">g1</span><span class="s0">, </span><span class="s1">KeyError)</span>
        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[KeyError])</span>

    <span class="s0">def </span><span class="s1">test_dealloc(self):</span>
        <span class="s1">seen = []</span>
        <span class="s1">g1 = greenlet(fmain)</span>
        <span class="s1">g2 = greenlet(fmain)</span>
        <span class="s1">g1.switch(seen)</span>
        <span class="s1">g2.switch(seen)</span>
        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s0">del </span><span class="s1">g1</span>
        <span class="s1">gc.collect()</span>
        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[greenlet.GreenletExit])</span>
        <span class="s0">del </span><span class="s1">g2</span>
        <span class="s1">gc.collect()</span>
        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[greenlet.GreenletExit</span><span class="s0">, </span><span class="s1">greenlet.GreenletExit])</span>

    <span class="s0">def </span><span class="s1">test_dealloc_catches_GreenletExit_throws_other(self):</span>
        <span class="s0">def </span><span class="s1">run():</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">greenlet.getcurrent().parent.switch()</span>
            <span class="s0">except </span><span class="s1">greenlet.GreenletExit:</span>
                <span class="s0">raise </span><span class="s1">SomeError</span>

        <span class="s1">g = greenlet(run)</span>
        <span class="s1">g.switch()</span>
        <span class="s2"># Destroying the only reference to the greenlet causes it</span>
        <span class="s2"># to get GreenletExit; when it in turn raises, even though we're the parent</span>
        <span class="s2"># we don't get the exception, it just gets printed.</span>
        <span class="s2"># When we run on 3.8 only, we can use sys.unraisablehook</span>
        <span class="s1">oldstderr = sys.stderr</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">cStringIO </span><span class="s0">import </span><span class="s1">StringIO</span>
        <span class="s0">except </span><span class="s1">ImportError:</span>
            <span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">StringIO</span>
        <span class="s1">stderr = sys.stderr = StringIO()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">del </span><span class="s1">g</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">sys.stderr = oldstderr</span>

        <span class="s1">v = stderr.getvalue()</span>
        <span class="s1">self.assertIn(</span><span class="s4">&quot;Exception&quot;</span><span class="s0">, </span><span class="s1">v)</span>
        <span class="s1">self.assertIn(</span><span class="s4">'ignored'</span><span class="s0">, </span><span class="s1">v)</span>
        <span class="s1">self.assertIn(</span><span class="s4">&quot;SomeError&quot;</span><span class="s0">, </span><span class="s1">v)</span>


    <span class="s0">def </span><span class="s1">test_dealloc_other_thread(self):</span>
        <span class="s1">seen = []</span>
        <span class="s1">someref = []</span>

        <span class="s1">bg_glet_created_running_and_no_longer_ref_in_bg = threading.Event()</span>
        <span class="s1">fg_ref_released = threading.Event()</span>
        <span class="s1">bg_should_be_clear = threading.Event()</span>
        <span class="s1">ok_to_exit_bg_thread = threading.Event()</span>

        <span class="s0">def </span><span class="s1">f():</span>
            <span class="s1">g1 = greenlet(fmain)</span>
            <span class="s1">g1.switch(seen)</span>
            <span class="s1">someref.append(g1)</span>
            <span class="s0">del </span><span class="s1">g1</span>
            <span class="s1">gc.collect()</span>

            <span class="s1">bg_glet_created_running_and_no_longer_ref_in_bg.set()</span>
            <span class="s1">fg_ref_released.wait(</span><span class="s3">3</span><span class="s1">)</span>

            <span class="s1">greenlet()   </span><span class="s2"># trigger release</span>
            <span class="s1">bg_should_be_clear.set()</span>
            <span class="s1">ok_to_exit_bg_thread.wait(</span><span class="s3">3</span><span class="s1">)</span>
            <span class="s1">greenlet() </span><span class="s2"># One more time</span>

        <span class="s1">t = threading.Thread(target=f)</span>
        <span class="s1">t.start()</span>
        <span class="s1">bg_glet_created_running_and_no_longer_ref_in_bg.wait(</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">self.assertEqual(len(someref)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">del </span><span class="s1">someref[:]</span>
        <span class="s1">gc.collect()</span>
        <span class="s2"># g1 is not released immediately because it's from another thread</span>
        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">fg_ref_released.set()</span>
        <span class="s1">bg_should_be_clear.wait(</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[greenlet.GreenletExit])</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">ok_to_exit_bg_thread.set()</span>
            <span class="s1">t.join(</span><span class="s3">10</span><span class="s1">)</span>
            <span class="s0">del </span><span class="s1">seen[:]</span>
            <span class="s0">del </span><span class="s1">someref[:]</span>

    <span class="s0">def </span><span class="s1">test_frame(self):</span>
        <span class="s0">def </span><span class="s1">f1():</span>
            <span class="s1">f = sys._getframe(</span><span class="s3">0</span><span class="s1">) </span><span class="s2"># pylint:disable=protected-access</span>
            <span class="s1">self.assertEqual(f.f_back</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">greenlet.getcurrent().parent.switch(f)</span>
            <span class="s0">return </span><span class="s4">&quot;meaning of life&quot;</span>
        <span class="s1">g = greenlet(f1)</span>
        <span class="s1">frame = g.switch()</span>
        <span class="s1">self.assertTrue(frame </span><span class="s0">is </span><span class="s1">g.gr_frame)</span>
        <span class="s1">self.assertTrue(g)</span>

        <span class="s1">from_g = g.switch()</span>
        <span class="s1">self.assertFalse(g)</span>
        <span class="s1">self.assertEqual(from_g</span><span class="s0">, </span><span class="s4">'meaning of life'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(g.gr_frame</span><span class="s0">, None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_thread_bug(self):</span>
        <span class="s0">def </span><span class="s1">runner(x):</span>
            <span class="s1">g = greenlet(</span><span class="s0">lambda</span><span class="s1">: time.sleep(x))</span>
            <span class="s1">g.switch()</span>
        <span class="s1">t1 = threading.Thread(target=runner</span><span class="s0">, </span><span class="s1">args=(</span><span class="s3">0.2</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">t2 = threading.Thread(target=runner</span><span class="s0">, </span><span class="s1">args=(</span><span class="s3">0.3</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">t1.start()</span>
        <span class="s1">t2.start()</span>
        <span class="s1">t1.join(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">t2.join(</span><span class="s3">10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_switch_kwargs(self):</span>
        <span class="s0">def </span><span class="s1">run(a</span><span class="s0">, </span><span class="s1">b):</span>
            <span class="s1">self.assertEqual(a</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(b</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s3">42</span>
        <span class="s1">x = greenlet(run).switch(a=</span><span class="s3">4</span><span class="s0">, </span><span class="s1">b=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(x</span><span class="s0">, </span><span class="s3">42</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_switch_kwargs_to_parent(self):</span>
        <span class="s0">def </span><span class="s1">run(x):</span>
            <span class="s1">greenlet.getcurrent().parent.switch(x=x)</span>
            <span class="s1">greenlet.getcurrent().parent.switch(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">x=</span><span class="s3">3</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">x</span><span class="s0">, </span><span class="s1">x ** </span><span class="s3">2</span>
        <span class="s1">g = greenlet(run)</span>
        <span class="s1">self.assertEqual({</span><span class="s4">'x'</span><span class="s1">: </span><span class="s3">3</span><span class="s1">}</span><span class="s0">, </span><span class="s1">g.switch(</span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(((</span><span class="s3">2</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{</span><span class="s4">'x'</span><span class="s1">: </span><span class="s3">3</span><span class="s1">})</span><span class="s0">, </span><span class="s1">g.switch())</span>
        <span class="s1">self.assertEqual((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span><span class="s0">, </span><span class="s1">g.switch())</span>

    <span class="s0">def </span><span class="s1">test_switch_to_another_thread(self):</span>
        <span class="s1">data = {}</span>
        <span class="s1">created_event = threading.Event()</span>
        <span class="s1">done_event = threading.Event()</span>

        <span class="s0">def </span><span class="s1">run():</span>
            <span class="s1">data[</span><span class="s4">'g'</span><span class="s1">] = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">created_event.set()</span>
            <span class="s1">done_event.wait(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">thread = threading.Thread(target=run)</span>
        <span class="s1">thread.start()</span>
        <span class="s1">created_event.wait(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(greenlet.error):</span>
            <span class="s1">data[</span><span class="s4">'g'</span><span class="s1">].switch()</span>
        <span class="s1">done_event.set()</span>
        <span class="s1">thread.join(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s2"># XXX: Should handle this automatically</span>
        <span class="s1">data.clear()</span>

    <span class="s0">def </span><span class="s1">test_exc_state(self):</span>
        <span class="s0">def </span><span class="s1">f():</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'fun'</span><span class="s1">)</span>
            <span class="s0">except</span><span class="s1">: </span><span class="s2"># pylint:disable=bare-except</span>
                <span class="s1">exc_info = sys.exc_info()</span>
                <span class="s1">greenlet(h).switch()</span>
                <span class="s1">self.assertEqual(exc_info</span><span class="s0">, </span><span class="s1">sys.exc_info())</span>

        <span class="s0">def </span><span class="s1">h():</span>
            <span class="s1">self.assertEqual(sys.exc_info()</span><span class="s0">, </span><span class="s1">(</span><span class="s0">None, None, None</span><span class="s1">))</span>

        <span class="s1">greenlet(f).switch()</span>

    <span class="s0">def </span><span class="s1">test_instance_dict(self):</span>
        <span class="s0">def </span><span class="s1">f():</span>
            <span class="s1">greenlet.getcurrent().test = </span><span class="s3">42</span>
        <span class="s0">def </span><span class="s1">deldict(g):</span>
            <span class="s0">del </span><span class="s1">g.__dict__</span>
        <span class="s0">def </span><span class="s1">setdict(g</span><span class="s0">, </span><span class="s1">value):</span>
            <span class="s1">g.__dict__ = value</span>
        <span class="s1">g = greenlet(f)</span>
        <span class="s1">self.assertEqual(g.__dict__</span><span class="s0">, </span><span class="s1">{})</span>
        <span class="s1">g.switch()</span>
        <span class="s1">self.assertEqual(g.test</span><span class="s0">, </span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(g.__dict__</span><span class="s0">, </span><span class="s1">{</span><span class="s4">'test'</span><span class="s1">: </span><span class="s3">42</span><span class="s1">})</span>
        <span class="s1">g.__dict__ = g.__dict__</span>
        <span class="s1">self.assertEqual(g.__dict__</span><span class="s0">, </span><span class="s1">{</span><span class="s4">'test'</span><span class="s1">: </span><span class="s3">42</span><span class="s1">})</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s0">, </span><span class="s1">deldict</span><span class="s0">, </span><span class="s1">g)</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s0">, </span><span class="s1">setdict</span><span class="s0">, </span><span class="s1">g</span><span class="s0">, </span><span class="s3">42</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_running_greenlet_has_no_run(self):</span>
        <span class="s1">has_run = []</span>
        <span class="s0">def </span><span class="s1">func():</span>
            <span class="s1">has_run.append(</span>
                <span class="s1">hasattr(greenlet.getcurrent()</span><span class="s0">, </span><span class="s4">'run'</span><span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">g = greenlet(func)</span>
        <span class="s1">g.switch()</span>
        <span class="s1">self.assertEqual(has_run</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_deepcopy(self):</span>
        <span class="s0">import </span><span class="s1">copy</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s0">, </span><span class="s1">copy.copy</span><span class="s0">, </span><span class="s1">greenlet())</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s0">, </span><span class="s1">copy.deepcopy</span><span class="s0">, </span><span class="s1">greenlet())</span>

    <span class="s0">def </span><span class="s1">test_parent_restored_on_kill(self):</span>
        <span class="s1">hub = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">main = greenlet.getcurrent()</span>
        <span class="s1">result = []</span>
        <span class="s0">def </span><span class="s1">worker():</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s2"># Wait to be killed by going back to the test.</span>
                <span class="s1">main.switch()</span>
            <span class="s0">except </span><span class="s1">greenlet.GreenletExit:</span>
                <span class="s2"># Resurrect and switch to parent</span>
                <span class="s1">result.append(greenlet.getcurrent().parent)</span>
                <span class="s1">result.append(greenlet.getcurrent())</span>
                <span class="s1">hub.switch()</span>
        <span class="s1">g = greenlet(worker</span><span class="s0">, </span><span class="s1">parent=hub)</span>
        <span class="s1">g.switch()</span>
        <span class="s2"># delete the only reference, thereby raising GreenletExit</span>
        <span class="s0">del </span><span class="s1">g</span>
        <span class="s1">self.assertTrue(result)</span>
        <span class="s1">self.assertIs(result[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">main)</span>
        <span class="s1">self.assertIs(result[</span><span class="s3">1</span><span class="s1">].parent</span><span class="s0">, </span><span class="s1">hub)</span>
        <span class="s2"># Delete them, thereby breaking the cycle between the greenlet</span>
        <span class="s2"># and the frame, which otherwise would never be collectable</span>
        <span class="s2"># XXX: We should be able to automatically fix this.</span>
        <span class="s0">del </span><span class="s1">result[:]</span>
        <span class="s1">hub = </span><span class="s0">None</span>
        <span class="s1">main = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">test_parent_return_failure(self):</span>
        <span class="s2"># No run causes AttributeError on switch</span>
        <span class="s1">g1 = greenlet()</span>
        <span class="s2"># Greenlet that implicitly switches to parent</span>
        <span class="s1">g2 = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None, </span><span class="s1">parent=g1)</span>
        <span class="s2"># AttributeError should propagate to us, no fatal errors</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(AttributeError):</span>
            <span class="s1">g2.switch()</span>

    <span class="s0">def </span><span class="s1">test_throw_exception_not_lost(self):</span>
        <span class="s0">class </span><span class="s1">mygreenlet(greenlet):</span>
            <span class="s0">def </span><span class="s1">__getattribute__(self</span><span class="s0">, </span><span class="s1">name):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">Exception()</span>
                <span class="s0">except</span><span class="s1">: </span><span class="s2"># pylint:disable=bare-except</span>
                    <span class="s0">pass</span>
                <span class="s0">return </span><span class="s1">greenlet.__getattribute__(self</span><span class="s0">, </span><span class="s1">name)</span>
        <span class="s1">g = mygreenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(SomeError</span><span class="s0">, </span><span class="s1">g.throw</span><span class="s0">, </span><span class="s1">SomeError())</span>

    <span class="s1">@fails_leakcheck</span>
    <span class="s0">def </span><span class="s1">_do_test_throw_to_dead_thread_doesnt_crash(self</span><span class="s0">, </span><span class="s1">wait_for_cleanup=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s1">result = []</span>
        <span class="s0">def </span><span class="s1">worker():</span>
            <span class="s1">greenlet.getcurrent().parent.switch()</span>

        <span class="s0">def </span><span class="s1">creator():</span>
            <span class="s1">g = greenlet(worker)</span>
            <span class="s1">g.switch()</span>
            <span class="s1">result.append(g)</span>
            <span class="s0">if </span><span class="s1">wait_for_cleanup:</span>
                <span class="s2"># Let this greenlet eventually be cleaned up.</span>
                <span class="s1">g.switch()</span>
                <span class="s1">greenlet.getcurrent()</span>
        <span class="s1">t = threading.Thread(target=creator)</span>
        <span class="s1">t.start()</span>
        <span class="s1">t.join(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s0">del </span><span class="s1">t</span>
        <span class="s2"># But, depending on the operating system, the thread</span>
        <span class="s2"># deallocator may not actually have run yet! So we can't be</span>
        <span class="s2"># sure about the error message unless we wait.</span>
        <span class="s0">if </span><span class="s1">wait_for_cleanup:</span>
            <span class="s1">self.wait_for_pending_cleanups()</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(greenlet.error) </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s1">result[</span><span class="s3">0</span><span class="s1">].throw(SomeError)</span>

        <span class="s0">if not </span><span class="s1">wait_for_cleanup:</span>
            <span class="s1">self.assertIn(</span>
                <span class="s1">str(exc.exception)</span><span class="s0">, </span><span class="s1">[</span>
                    <span class="s4">&quot;cannot switch to a different thread (which happens to have exited)&quot;</span><span class="s0">,</span>
                    <span class="s4">&quot;cannot switch to a different thread&quot;</span>
                <span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.assertEqual(</span>
                <span class="s1">str(exc.exception)</span><span class="s0">,</span>
                <span class="s4">&quot;cannot switch to a different thread (which happens to have exited)&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">hasattr(result[</span><span class="s3">0</span><span class="s1">].gr_frame</span><span class="s0">, </span><span class="s4">'clear'</span><span class="s1">):</span>
            <span class="s2"># The frame is actually executing (it thinks), we can't clear it.</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(RuntimeError):</span>
                <span class="s1">result[</span><span class="s3">0</span><span class="s1">].gr_frame.clear()</span>
        <span class="s2"># Unfortunately, this doesn't actually clear the references, they're in the</span>
        <span class="s2"># fast local array.</span>
        <span class="s0">if not </span><span class="s1">wait_for_cleanup:</span>
            <span class="s1">result[</span><span class="s3">0</span><span class="s1">].gr_frame.f_locals.clear()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.assertIsNone(result[</span><span class="s3">0</span><span class="s1">].gr_frame)</span>

        <span class="s0">del </span><span class="s1">creator</span>
        <span class="s1">worker = </span><span class="s0">None</span>
        <span class="s0">del </span><span class="s1">result[:]</span>
        <span class="s2"># XXX: we ought to be able to automatically fix this.</span>
        <span class="s2"># See issue 252</span>
        <span class="s1">self.expect_greenlet_leak = </span><span class="s0">True </span><span class="s2"># direct us not to wait for it to go away</span>

    <span class="s1">@fails_leakcheck</span>
    <span class="s0">def </span><span class="s1">test_throw_to_dead_thread_doesnt_crash(self):</span>
        <span class="s1">self._do_test_throw_to_dead_thread_doesnt_crash()</span>

    <span class="s0">def </span><span class="s1">test_throw_to_dead_thread_doesnt_crash_wait(self):</span>
        <span class="s1">self._do_test_throw_to_dead_thread_doesnt_crash(</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">@fails_leakcheck</span>
    <span class="s0">def </span><span class="s1">test_recursive_startup(self):</span>
        <span class="s0">class </span><span class="s1">convoluted(greenlet):</span>
            <span class="s0">def </span><span class="s1">__init__(self):</span>
                <span class="s1">greenlet.__init__(self)</span>
                <span class="s1">self.count = </span><span class="s3">0</span>
            <span class="s0">def </span><span class="s1">__getattribute__(self</span><span class="s0">, </span><span class="s1">name):</span>
                <span class="s0">if </span><span class="s1">name == </span><span class="s4">'run' </span><span class="s0">and </span><span class="s1">self.count == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">self.count = </span><span class="s3">1</span>
                    <span class="s1">self.switch(</span><span class="s3">43</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">greenlet.__getattribute__(self</span><span class="s0">, </span><span class="s1">name)</span>
            <span class="s0">def </span><span class="s1">run(self</span><span class="s0">, </span><span class="s1">value):</span>
                <span class="s0">while True</span><span class="s1">:</span>
                    <span class="s1">self.parent.switch(value)</span>
        <span class="s1">g = convoluted()</span>
        <span class="s1">self.assertEqual(g.switch(</span><span class="s3">42</span><span class="s1">)</span><span class="s0">, </span><span class="s3">43</span><span class="s1">)</span>
        <span class="s2"># Exits the running greenlet, otherwise it leaks</span>
        <span class="s2"># XXX: We should be able to automatically fix this</span>
        <span class="s2">#g.throw(greenlet.GreenletExit)</span>
        <span class="s2">#del g</span>
        <span class="s1">self.expect_greenlet_leak = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">test_threaded_updatecurrent(self):</span>
        <span class="s2"># released when main thread should execute</span>
        <span class="s1">lock1 = threading.Lock()</span>
        <span class="s1">lock1.acquire()</span>
        <span class="s2"># released when another thread should execute</span>
        <span class="s1">lock2 = threading.Lock()</span>
        <span class="s1">lock2.acquire()</span>
        <span class="s0">class </span><span class="s1">finalized(object):</span>
            <span class="s0">def </span><span class="s1">__del__(self):</span>
                <span class="s2"># happens while in green_updatecurrent() in main greenlet</span>
                <span class="s2"># should be very careful not to accidentally call it again</span>
                <span class="s2"># at the same time we must make sure another thread executes</span>
                <span class="s1">lock2.release()</span>
                <span class="s1">lock1.acquire()</span>
                <span class="s2"># now ts_current belongs to another thread</span>
        <span class="s0">def </span><span class="s1">deallocator():</span>
            <span class="s1">greenlet.getcurrent().parent.switch()</span>
        <span class="s0">def </span><span class="s1">fthread():</span>
            <span class="s1">lock2.acquire()</span>
            <span class="s1">greenlet.getcurrent()</span>
            <span class="s0">del </span><span class="s1">g[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">lock1.release()</span>
            <span class="s1">lock2.acquire()</span>
            <span class="s1">greenlet.getcurrent()</span>
            <span class="s1">lock1.release()</span>
        <span class="s1">main = greenlet.getcurrent()</span>
        <span class="s1">g = [greenlet(deallocator)]</span>
        <span class="s1">g[</span><span class="s3">0</span><span class="s1">].bomb = finalized()</span>
        <span class="s1">g[</span><span class="s3">0</span><span class="s1">].switch()</span>
        <span class="s1">t = threading.Thread(target=fthread)</span>
        <span class="s1">t.start()</span>
        <span class="s2"># let another thread grab ts_current and deallocate g[0]</span>
        <span class="s1">lock2.release()</span>
        <span class="s1">lock1.acquire()</span>
        <span class="s2"># this is the corner stone</span>
        <span class="s2"># getcurrent() will notice that ts_current belongs to another thread</span>
        <span class="s2"># and start the update process, which would notice that g[0] should</span>
        <span class="s2"># be deallocated, and that will execute an object's finalizer. Now,</span>
        <span class="s2"># that object will let another thread run so it can grab ts_current</span>
        <span class="s2"># again, which would likely crash the interpreter if there's no</span>
        <span class="s2"># check for this case at the end of green_updatecurrent(). This test</span>
        <span class="s2"># passes if getcurrent() returns correct result, but it's likely</span>
        <span class="s2"># to randomly crash if it's not anyway.</span>
        <span class="s1">self.assertEqual(greenlet.getcurrent()</span><span class="s0">, </span><span class="s1">main)</span>
        <span class="s2"># wait for another thread to complete, just in case</span>
        <span class="s1">t.join(</span><span class="s3">10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_dealloc_switch_args_not_lost(self):</span>
        <span class="s1">seen = []</span>
        <span class="s0">def </span><span class="s1">worker():</span>
            <span class="s2"># wait for the value</span>
            <span class="s1">value = greenlet.getcurrent().parent.switch()</span>
            <span class="s2"># delete all references to ourself</span>
            <span class="s0">del </span><span class="s1">worker[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">initiator.parent = greenlet.getcurrent().parent</span>
            <span class="s2"># switch to main with the value, but because</span>
            <span class="s2"># ts_current is the last reference to us we</span>
            <span class="s2"># return here immediately, where we resurrect ourself.</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">greenlet.getcurrent().parent.switch(value)</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s1">seen.append(greenlet.getcurrent())</span>
        <span class="s0">def </span><span class="s1">initiator():</span>
            <span class="s0">return </span><span class="s3">42 </span><span class="s2"># implicitly falls thru to parent</span>

        <span class="s1">worker = [greenlet(worker)]</span>

        <span class="s1">worker[</span><span class="s3">0</span><span class="s1">].switch() </span><span class="s2"># prime worker</span>
        <span class="s1">initiator = greenlet(initiator</span><span class="s0">, </span><span class="s1">worker[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">value = initiator.switch()</span>
        <span class="s1">self.assertTrue(seen)</span>
        <span class="s1">self.assertEqual(value</span><span class="s0">, </span><span class="s3">42</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_tuple_subclass(self):</span>
        <span class="s2"># XXX: This is failing on Python 2 with a SystemError: error return without exception set</span>

        <span class="s2"># The point of this test is to see what happens when a custom</span>
        <span class="s2"># tuple subclass is used as an object passed directly to the C</span>
        <span class="s2"># function ``green_switch``; part of ``green_switch`` checks</span>
        <span class="s2"># the ``len()`` of the ``args`` tuple, and that can call back</span>
        <span class="s2"># into Python. Here, when it calls back into Python, we</span>
        <span class="s2"># recursively enter ``green_switch`` again.</span>

        <span class="s2"># This test is really only relevant on Python 2. The builtin</span>
        <span class="s2"># `apply` function directly passes the given args tuple object</span>
        <span class="s2"># to the underlying function, whereas the Python 3 version</span>
        <span class="s2"># unpacks and repacks into an actual tuple. This could still</span>
        <span class="s2"># happen using the C API on Python 3 though.</span>
        <span class="s0">if </span><span class="s1">sys.version_info[</span><span class="s3">0</span><span class="s1">] &gt; </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s2"># There's no apply in Python 3.x</span>
            <span class="s0">def </span><span class="s1">_apply(func</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">k):</span>
                <span class="s1">func(*a</span><span class="s0">, </span><span class="s1">**k)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">_apply = apply </span><span class="s2"># pylint:disable=undefined-variable</span>

        <span class="s0">class </span><span class="s1">mytuple(tuple):</span>
            <span class="s0">def </span><span class="s1">__len__(self):</span>
                <span class="s1">greenlet.getcurrent().switch()</span>
                <span class="s0">return </span><span class="s1">tuple.__len__(self)</span>
        <span class="s1">args = mytuple()</span>
        <span class="s1">kwargs = dict(a=</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s0">def </span><span class="s1">switchapply():</span>
            <span class="s1">_apply(greenlet.getcurrent().parent.switch</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s1">g = greenlet(switchapply)</span>
        <span class="s1">self.assertEqual(g.switch()</span><span class="s0">, </span><span class="s1">kwargs)</span>

    <span class="s0">def </span><span class="s1">test_abstract_subclasses(self):</span>
        <span class="s1">AbstractSubclass = ABCMeta(</span>
            <span class="s4">'AbstractSubclass'</span><span class="s0">,</span>
            <span class="s1">(greenlet</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s4">'run'</span><span class="s1">: abstractmethod(</span><span class="s0">lambda </span><span class="s1">self: </span><span class="s0">None</span><span class="s1">)})</span>

        <span class="s0">class </span><span class="s1">BadSubclass(AbstractSubclass):</span>
            <span class="s0">pass</span>

        <span class="s0">class </span><span class="s1">GoodSubclass(AbstractSubclass):</span>
            <span class="s0">def </span><span class="s1">run(self):</span>
                <span class="s0">pass</span>

        <span class="s1">GoodSubclass() </span><span class="s2"># should not raise</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s0">, </span><span class="s1">BadSubclass)</span>

    <span class="s0">def </span><span class="s1">test_implicit_parent_with_threads(self):</span>
        <span class="s0">if not </span><span class="s1">gc.isenabled():</span>
            <span class="s0">return </span><span class="s2"># cannot test with disabled gc</span>
        <span class="s1">N = gc.get_threshold()[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">N &lt; </span><span class="s3">50</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2"># cannot test with such a small N</span>
        <span class="s0">def </span><span class="s1">attempt():</span>
            <span class="s1">lock1 = threading.Lock()</span>
            <span class="s1">lock1.acquire()</span>
            <span class="s1">lock2 = threading.Lock()</span>
            <span class="s1">lock2.acquire()</span>
            <span class="s1">recycled = [</span><span class="s0">False</span><span class="s1">]</span>
            <span class="s0">def </span><span class="s1">another_thread():</span>
                <span class="s1">lock1.acquire() </span><span class="s2"># wait for gc</span>
                <span class="s1">greenlet.getcurrent() </span><span class="s2"># update ts_current</span>
                <span class="s1">lock2.release() </span><span class="s2"># release gc</span>
            <span class="s1">t = threading.Thread(target=another_thread)</span>
            <span class="s1">t.start()</span>
            <span class="s0">class </span><span class="s1">gc_callback(object):</span>
                <span class="s0">def </span><span class="s1">__del__(self):</span>
                    <span class="s1">lock1.release()</span>
                    <span class="s1">lock2.acquire()</span>
                    <span class="s1">recycled[</span><span class="s3">0</span><span class="s1">] = </span><span class="s0">True</span>
            <span class="s0">class </span><span class="s1">garbage(object):</span>
                <span class="s0">def </span><span class="s1">__init__(self):</span>
                    <span class="s1">self.cycle = self</span>
                    <span class="s1">self.callback = gc_callback()</span>
            <span class="s1">l = []</span>
            <span class="s1">x = range(N*</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">current = greenlet.getcurrent()</span>
            <span class="s1">g = garbage()</span>
            <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">x:</span>
                <span class="s1">g = </span><span class="s0">None </span><span class="s2"># lose reference to garbage</span>
                <span class="s0">if </span><span class="s1">recycled[</span><span class="s3">0</span><span class="s1">]:</span>
                    <span class="s2"># gc callback called prematurely</span>
                    <span class="s1">t.join(</span><span class="s3">10</span><span class="s1">)</span>
                    <span class="s0">return False</span>
                <span class="s1">last = greenlet()</span>
                <span class="s0">if </span><span class="s1">recycled[</span><span class="s3">0</span><span class="s1">]:</span>
                    <span class="s0">break </span><span class="s2"># yes! gc called in green_new</span>
                <span class="s1">l.append(last) </span><span class="s2"># increase allocation counter</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># gc callback not called when expected</span>
                <span class="s1">gc.collect()</span>
                <span class="s0">if </span><span class="s1">recycled[</span><span class="s3">0</span><span class="s1">]:</span>
                    <span class="s1">t.join(</span><span class="s3">10</span><span class="s1">)</span>
                <span class="s0">return False</span>
            <span class="s1">self.assertEqual(last.parent</span><span class="s0">, </span><span class="s1">current)</span>
            <span class="s0">for </span><span class="s1">g </span><span class="s0">in </span><span class="s1">l:</span>
                <span class="s1">self.assertEqual(g.parent</span><span class="s0">, </span><span class="s1">current)</span>
            <span class="s0">return True</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">5</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">attempt():</span>
                <span class="s0">break</span>

    <span class="s0">def </span><span class="s1">test_issue_245_reference_counting_subclass_no_threads(self):</span>
        <span class="s2"># https://github.com/python-greenlet/greenlet/issues/245</span>
        <span class="s2"># Before the fix, this crashed pretty reliably on</span>
        <span class="s2"># Python 3.10, at least on macOS; but much less reliably on other</span>
        <span class="s2"># interpreters (memory layout must have changed).</span>
        <span class="s2"># The threaded test crashed more reliably on more interpreters.</span>
        <span class="s0">from </span><span class="s1">greenlet </span><span class="s0">import </span><span class="s1">getcurrent</span>
        <span class="s0">from </span><span class="s1">greenlet </span><span class="s0">import </span><span class="s1">GreenletExit</span>

        <span class="s0">class </span><span class="s1">Greenlet(greenlet):</span>
            <span class="s0">pass</span>

        <span class="s1">initial_refs = sys.getrefcount(Greenlet)</span>
        <span class="s2"># This has to be an instance variable because</span>
        <span class="s2"># Python 2 raises a SyntaxError if we delete a local</span>
        <span class="s2"># variable referenced in an inner scope.</span>
        <span class="s1">self.glets = [] </span><span class="s2"># pylint:disable=attribute-defined-outside-init</span>

        <span class="s0">def </span><span class="s1">greenlet_main():</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">getcurrent().parent.switch()</span>
            <span class="s0">except </span><span class="s1">GreenletExit:</span>
                <span class="s1">self.glets.append(getcurrent())</span>

        <span class="s2"># Before the</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">10</span><span class="s1">):</span>
            <span class="s1">Greenlet(greenlet_main).switch()</span>

        <span class="s0">del </span><span class="s1">self.glets</span>
        <span class="s1">self.assertEqual(sys.getrefcount(Greenlet)</span><span class="s0">, </span><span class="s1">initial_refs)</span>

    <span class="s0">def </span><span class="s1">test_issue_245_reference_counting_subclass_threads(self):</span>
        <span class="s2"># https://github.com/python-greenlet/greenlet/issues/245</span>
        <span class="s0">from </span><span class="s1">threading </span><span class="s0">import </span><span class="s1">Thread</span>
        <span class="s0">from </span><span class="s1">threading </span><span class="s0">import </span><span class="s1">Event</span>

        <span class="s0">from </span><span class="s1">greenlet </span><span class="s0">import </span><span class="s1">getcurrent</span>

        <span class="s0">class </span><span class="s1">MyGreenlet(greenlet):</span>
            <span class="s0">pass</span>

        <span class="s1">glets = []</span>
        <span class="s1">ref_cleared = Event()</span>

        <span class="s0">def </span><span class="s1">greenlet_main():</span>
            <span class="s1">getcurrent().parent.switch()</span>

        <span class="s0">def </span><span class="s1">thread_main(greenlet_running_event):</span>
            <span class="s1">mine = MyGreenlet(greenlet_main)</span>
            <span class="s1">glets.append(mine)</span>
            <span class="s2"># The greenlets being deleted must be active</span>
            <span class="s1">mine.switch()</span>
            <span class="s2"># Don't keep any reference to it in this thread</span>
            <span class="s0">del </span><span class="s1">mine</span>
            <span class="s2"># Let main know we published our greenlet.</span>
            <span class="s1">greenlet_running_event.set()</span>
            <span class="s2"># Wait for main to let us know the references are</span>
            <span class="s2"># gone and the greenlet objects no longer reachable</span>
            <span class="s1">ref_cleared.wait(</span><span class="s3">10</span><span class="s1">)</span>
            <span class="s2"># The creating thread must call getcurrent() (or a few other</span>
            <span class="s2"># greenlet APIs) because that's when the thread-local list of dead</span>
            <span class="s2"># greenlets gets cleared.</span>
            <span class="s1">getcurrent()</span>

        <span class="s2"># We start with 3 references to the subclass:</span>
        <span class="s2"># - This module</span>
        <span class="s2"># - Its __mro__</span>
        <span class="s2"># - The __subclassess__ attribute of greenlet</span>
        <span class="s2"># - (If we call gc.get_referents(), we find four entries, including</span>
        <span class="s2">#   some other tuple ``(greenlet)`` that I'm not sure about but must be part</span>
        <span class="s2">#   of the machinery.)</span>
        <span class="s2">#</span>
        <span class="s2"># On Python 3.10 it's often enough to just run 3 threads; on Python 2.7,</span>
        <span class="s2"># more threads are needed, and the results are still</span>
        <span class="s2"># non-deterministic. Presumably the memory layouts are different</span>
        <span class="s1">initial_refs = sys.getrefcount(MyGreenlet)</span>
        <span class="s1">thread_ready_events = []</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span>
                <span class="s1">initial_refs + </span><span class="s3">45</span>
        <span class="s1">):</span>
            <span class="s1">event = Event()</span>
            <span class="s1">thread = Thread(target=thread_main</span><span class="s0">, </span><span class="s1">args=(event</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s1">thread_ready_events.append(event)</span>
            <span class="s1">thread.start()</span>


        <span class="s0">for </span><span class="s1">done_event </span><span class="s0">in </span><span class="s1">thread_ready_events:</span>
            <span class="s1">done_event.wait(</span><span class="s3">10</span><span class="s1">)</span>


        <span class="s0">del </span><span class="s1">glets[:]</span>
        <span class="s1">ref_cleared.set()</span>
        <span class="s2"># Let any other thread run; it will crash the interpreter</span>
        <span class="s2"># if not fixed (or silently corrupt memory and we possibly crash</span>
        <span class="s2"># later).</span>
        <span class="s1">self.wait_for_pending_cleanups()</span>
        <span class="s1">self.assertEqual(sys.getrefcount(MyGreenlet)</span><span class="s0">, </span><span class="s1">initial_refs)</span>

    <span class="s0">def </span><span class="s1">test_falling_off_end_switches_to_unstarted_parent_raises_error(self):</span>
        <span class="s0">def </span><span class="s1">no_args():</span>
            <span class="s0">return </span><span class="s3">13</span>

        <span class="s1">parent_never_started = greenlet(no_args)</span>

        <span class="s0">def </span><span class="s1">leaf():</span>
            <span class="s0">return </span><span class="s3">42</span>

        <span class="s1">child = greenlet(leaf</span><span class="s0">, </span><span class="s1">parent_never_started)</span>

        <span class="s2"># Because the run function takes to arguments</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">child.switch()</span>

    <span class="s0">def </span><span class="s1">test_falling_off_end_switches_to_unstarted_parent_works(self):</span>
        <span class="s0">def </span><span class="s1">one_arg(x):</span>
            <span class="s0">return </span><span class="s1">(x</span><span class="s0">, </span><span class="s3">24</span><span class="s1">)</span>

        <span class="s1">parent_never_started = greenlet(one_arg)</span>

        <span class="s0">def </span><span class="s1">leaf():</span>
            <span class="s0">return </span><span class="s3">42</span>

        <span class="s1">child = greenlet(leaf</span><span class="s0">, </span><span class="s1">parent_never_started)</span>

        <span class="s1">result = child.switch()</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s1">(</span><span class="s3">42</span><span class="s0">, </span><span class="s3">24</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_switch_to_dead_greenlet_with_unstarted_perverse_parent(self):</span>
        <span class="s0">class </span><span class="s1">Parent(greenlet):</span>
            <span class="s0">def </span><span class="s1">__getattribute__(self</span><span class="s0">, </span><span class="s1">name):</span>
                <span class="s0">if </span><span class="s1">name == </span><span class="s4">'run'</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">SomeError</span>


        <span class="s1">parent_never_started = Parent()</span>
        <span class="s1">seen = []</span>
        <span class="s1">child = greenlet(</span><span class="s0">lambda</span><span class="s1">: seen.append(</span><span class="s3">42</span><span class="s1">)</span><span class="s0">, </span><span class="s1">parent_never_started)</span>
        <span class="s2"># Because we automatically start the parent when the child is</span>
        <span class="s2"># finished</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(SomeError):</span>
            <span class="s1">child.switch()</span>

        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[</span><span class="s3">42</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(SomeError):</span>
            <span class="s1">child.switch()</span>
        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[</span><span class="s3">42</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_switch_to_dead_greenlet_reparent(self):</span>
        <span class="s1">seen = []</span>
        <span class="s1">parent_never_started = greenlet(</span><span class="s0">lambda</span><span class="s1">: seen.append(</span><span class="s3">24</span><span class="s1">))</span>
        <span class="s1">child = greenlet(</span><span class="s0">lambda</span><span class="s1">: seen.append(</span><span class="s3">42</span><span class="s1">))</span>

        <span class="s1">child.switch()</span>
        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[</span><span class="s3">42</span><span class="s1">])</span>

        <span class="s1">child.parent = parent_never_started</span>
        <span class="s2"># This actually is the same as switching to the parent.</span>
        <span class="s1">result = child.switch()</span>
        <span class="s1">self.assertIsNone(result)</span>
        <span class="s1">self.assertEqual(seen</span><span class="s0">, </span><span class="s1">[</span><span class="s3">42</span><span class="s0">, </span><span class="s3">24</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">TestGreenletSetParentErrors(TestCase):</span>
    <span class="s0">def </span><span class="s1">test_threaded_reparent(self):</span>
        <span class="s1">data = {}</span>
        <span class="s1">created_event = threading.Event()</span>
        <span class="s1">done_event = threading.Event()</span>

        <span class="s0">def </span><span class="s1">run():</span>
            <span class="s1">data[</span><span class="s4">'g'</span><span class="s1">] = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">created_event.set()</span>
            <span class="s1">done_event.wait(</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">blank():</span>
            <span class="s1">greenlet.getcurrent().parent.switch()</span>

        <span class="s1">thread = threading.Thread(target=run)</span>
        <span class="s1">thread.start()</span>
        <span class="s1">created_event.wait(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">g = greenlet(blank)</span>
        <span class="s1">g.switch()</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(ValueError) </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s1">g.parent = data[</span><span class="s4">'g'</span><span class="s1">]</span>
        <span class="s1">done_event.set()</span>
        <span class="s1">thread.join(</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(str(exc.exception)</span><span class="s0">, </span><span class="s4">&quot;parent cannot be on a different thread&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_unexpected_reparenting(self):</span>
        <span class="s1">another = []</span>
        <span class="s0">def </span><span class="s1">worker():</span>
            <span class="s1">g = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">another.append(g)</span>
            <span class="s1">g.switch()</span>
        <span class="s1">t = threading.Thread(target=worker)</span>
        <span class="s1">t.start()</span>
        <span class="s1">t.join(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s2"># The first time we switch (running g_initialstub(), which is</span>
        <span class="s2"># when we look up the run attribute) we attempt to change the</span>
        <span class="s2"># parent to one from another thread (which also happens to be</span>
        <span class="s2"># dead). ``g_initialstub()`` should detect this and raise a</span>
        <span class="s2"># greenlet error.</span>
        <span class="s2">#</span>
        <span class="s2"># EXCEPT: With the fix for #252, this is actually detected</span>
        <span class="s2"># sooner, when setting the parent itself. Prior to that fix,</span>
        <span class="s2"># the main greenlet from the background thread kept a valid</span>
        <span class="s2"># value for ``run_info``, and appeared to be a valid parent</span>
        <span class="s2"># until we actually started the greenlet. But now that it's</span>
        <span class="s2"># cleared, this test is catching whether ``green_setparent``</span>
        <span class="s2"># can detect the dead thread.</span>
        <span class="s2">#</span>
        <span class="s2"># Further refactoring once again changes this back to a greenlet.error</span>
        <span class="s2">#</span>
        <span class="s2"># We need to wait for the cleanup to happen, but we're</span>
        <span class="s2"># deliberately leaking a main greenlet here.</span>
        <span class="s1">self.wait_for_pending_cleanups(initial_main_greenlets=self.main_greenlets_before_test + </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s0">class </span><span class="s1">convoluted(greenlet):</span>
            <span class="s0">def </span><span class="s1">__getattribute__(self</span><span class="s0">, </span><span class="s1">name):</span>
                <span class="s0">if </span><span class="s1">name == </span><span class="s4">'run'</span><span class="s1">:</span>
                    <span class="s1">self.parent = another[</span><span class="s3">0</span><span class="s1">] </span><span class="s2"># pylint:disable=attribute-defined-outside-init</span>
                <span class="s0">return </span><span class="s1">greenlet.__getattribute__(self</span><span class="s0">, </span><span class="s1">name)</span>
        <span class="s1">g = convoluted(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(greenlet.error) </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s1">g.switch()</span>
        <span class="s1">self.assertEqual(str(exc.exception)</span><span class="s0">,</span>
                         <span class="s4">&quot;cannot switch to a different thread (which happens to have exited)&quot;</span><span class="s1">)</span>
        <span class="s0">del </span><span class="s1">another[:]</span>

    <span class="s0">def </span><span class="s1">test_unexpected_reparenting_thread_running(self):</span>
        <span class="s2"># Like ``test_unexpected_reparenting``, except the background thread is</span>
        <span class="s2"># actually still alive.</span>
        <span class="s1">another = []</span>
        <span class="s1">switched_to_greenlet = threading.Event()</span>
        <span class="s1">keep_main_alive = threading.Event()</span>
        <span class="s0">def </span><span class="s1">worker():</span>
            <span class="s1">g = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">another.append(g)</span>
            <span class="s1">g.switch()</span>
            <span class="s1">switched_to_greenlet.set()</span>
            <span class="s1">keep_main_alive.wait(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s0">class </span><span class="s1">convoluted(greenlet):</span>
            <span class="s0">def </span><span class="s1">__getattribute__(self</span><span class="s0">, </span><span class="s1">name):</span>
                <span class="s0">if </span><span class="s1">name == </span><span class="s4">'run'</span><span class="s1">:</span>
                    <span class="s1">self.parent = another[</span><span class="s3">0</span><span class="s1">] </span><span class="s2"># pylint:disable=attribute-defined-outside-init</span>
                <span class="s0">return </span><span class="s1">greenlet.__getattribute__(self</span><span class="s0">, </span><span class="s1">name)</span>

        <span class="s1">t = threading.Thread(target=worker)</span>
        <span class="s1">t.start()</span>

        <span class="s1">switched_to_greenlet.wait(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">g = convoluted(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(greenlet.error) </span><span class="s0">as </span><span class="s1">exc:</span>
                <span class="s1">g.switch()</span>
            <span class="s1">self.assertEqual(str(exc.exception)</span><span class="s0">, </span><span class="s4">&quot;cannot switch to a different thread&quot;</span><span class="s1">)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">keep_main_alive.set()</span>
            <span class="s1">t.join(</span><span class="s3">10</span><span class="s1">)</span>
            <span class="s2"># XXX: Should handle this automatically.</span>
            <span class="s0">del </span><span class="s1">another[:]</span>

    <span class="s0">def </span><span class="s1">test_cannot_delete_parent(self):</span>
        <span class="s1">worker = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">self.assertIs(worker.parent</span><span class="s0">, </span><span class="s1">greenlet.getcurrent())</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(AttributeError) </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s0">del </span><span class="s1">worker.parent</span>
        <span class="s1">self.assertEqual(str(exc.exception)</span><span class="s0">, </span><span class="s4">&quot;can't delete attribute&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_cannot_delete_parent_of_main(self):</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(AttributeError) </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s0">del </span><span class="s1">greenlet.getcurrent().parent</span>
        <span class="s1">self.assertEqual(str(exc.exception)</span><span class="s0">, </span><span class="s4">&quot;can't delete attribute&quot;</span><span class="s1">)</span>


    <span class="s0">def </span><span class="s1">test_main_greenlet_parent_is_none(self):</span>
        <span class="s2"># assuming we're in a main greenlet here.</span>
        <span class="s1">self.assertIsNone(greenlet.getcurrent().parent)</span>

    <span class="s0">def </span><span class="s1">test_set_parent_wrong_types(self):</span>
        <span class="s0">def </span><span class="s1">bg():</span>
            <span class="s2"># Go back to main.</span>
            <span class="s1">greenlet.getcurrent().parent.switch()</span>

        <span class="s0">def </span><span class="s1">check(glet):</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in None, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">self</span><span class="s0">, </span><span class="s4">&quot;42&quot;</span><span class="s1">:</span>
                <span class="s0">with </span><span class="s1">self.assertRaises(TypeError) </span><span class="s0">as </span><span class="s1">exc:</span>
                    <span class="s1">glet.parent = p</span>

                <span class="s1">self.assertEqual(</span>
                    <span class="s1">str(exc.exception)</span><span class="s0">,</span>
                    <span class="s4">&quot;GreenletChecker: Expected any type of greenlet, not &quot; </span><span class="s1">+ type(p).__name__)</span>

        <span class="s2"># First, not running</span>
        <span class="s1">g = greenlet(bg)</span>
        <span class="s1">self.assertFalse(g)</span>
        <span class="s1">check(g)</span>

        <span class="s2"># Then when running.</span>
        <span class="s1">g.switch()</span>
        <span class="s1">self.assertTrue(g)</span>
        <span class="s1">check(g)</span>

        <span class="s2"># Let it finish</span>
        <span class="s1">g.switch()</span>


    <span class="s0">def </span><span class="s1">test_trivial_cycle(self):</span>
        <span class="s1">glet = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(ValueError) </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s1">glet.parent = glet</span>
        <span class="s1">self.assertEqual(str(exc.exception)</span><span class="s0">, </span><span class="s4">&quot;cyclic parent chain&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_trivial_cycle_main(self):</span>
        <span class="s2"># This used to produce a ValueError, but we catch it earlier than that now.</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(AttributeError) </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s1">greenlet.getcurrent().parent = greenlet.getcurrent()</span>
        <span class="s1">self.assertEqual(str(exc.exception)</span><span class="s0">, </span><span class="s4">&quot;cannot set the parent of a main greenlet&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_deeper_cycle(self):</span>
        <span class="s1">g1 = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">g2 = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">g3 = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>

        <span class="s1">g1.parent = g2</span>
        <span class="s1">g2.parent = g3</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(ValueError) </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s1">g3.parent = g1</span>
        <span class="s1">self.assertEqual(str(exc.exception)</span><span class="s0">, </span><span class="s4">&quot;cyclic parent chain&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestRepr(TestCase):</span>

    <span class="s0">def </span><span class="s1">assertEndsWith(self</span><span class="s0">, </span><span class="s1">got</span><span class="s0">, </span><span class="s1">suffix):</span>
        <span class="s1">self.assertTrue(got.endswith(suffix)</span><span class="s0">, </span><span class="s1">(got</span><span class="s0">, </span><span class="s1">suffix))</span>

    <span class="s0">def </span><span class="s1">test_main_while_running(self):</span>
        <span class="s1">r = repr(greenlet.getcurrent())</span>
        <span class="s1">self.assertEndsWith(r</span><span class="s0">, </span><span class="s4">&quot; current active started main&gt;&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_main_in_background(self):</span>
        <span class="s1">main = greenlet.getcurrent()</span>
        <span class="s0">def </span><span class="s1">run():</span>
            <span class="s0">return </span><span class="s1">repr(main)</span>

        <span class="s1">g = greenlet(run)</span>
        <span class="s1">r = g.switch()</span>
        <span class="s1">self.assertEndsWith(r</span><span class="s0">, </span><span class="s4">' suspended active started main&gt;'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_initial(self):</span>
        <span class="s1">r = repr(greenlet())</span>
        <span class="s1">self.assertEndsWith(r</span><span class="s0">, </span><span class="s4">' pending&gt;'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_main_from_other_thread(self):</span>
        <span class="s1">main = greenlet.getcurrent()</span>

        <span class="s0">class </span><span class="s1">T(threading.Thread):</span>
            <span class="s1">original_main = thread_main = </span><span class="s0">None</span>
            <span class="s1">main_glet = </span><span class="s0">None</span>
            <span class="s0">def </span><span class="s1">run(self):</span>
                <span class="s1">self.original_main = repr(main)</span>
                <span class="s1">self.main_glet = greenlet.getcurrent()</span>
                <span class="s1">self.thread_main = repr(self.main_glet)</span>

        <span class="s1">t = T()</span>
        <span class="s1">t.start()</span>
        <span class="s1">t.join(</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s1">self.assertEndsWith(t.original_main</span><span class="s0">, </span><span class="s4">' suspended active started main&gt;'</span><span class="s1">)</span>
        <span class="s1">self.assertEndsWith(t.thread_main</span><span class="s0">, </span><span class="s4">' current active started main&gt;'</span><span class="s1">)</span>
        <span class="s2"># give the machinery time to notice the death of the thread,</span>
        <span class="s2"># and clean it up. Note that we don't use</span>
        <span class="s2"># ``expect_greenlet_leak`` or wait_for_pending_cleanups,</span>
        <span class="s2"># because at this point we know we have an extra greenlet</span>
        <span class="s2"># still reachable.</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">):</span>
            <span class="s1">time.sleep(</span><span class="s3">0.001</span><span class="s1">)</span>

        <span class="s2"># In the past, main greenlets, even from dead threads, never</span>
        <span class="s2"># really appear dead. We have fixed that, and we also report</span>
        <span class="s2"># that the thread is dead in the repr. (Do this multiple times</span>
        <span class="s2"># to make sure that we don't self-modify and forget our state</span>
        <span class="s2"># in the C++ code).</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">):</span>
            <span class="s1">self.assertTrue(t.main_glet.dead)</span>
            <span class="s1">r = repr(t.main_glet)</span>
            <span class="s1">self.assertEndsWith(r</span><span class="s0">, </span><span class="s4">' (thread exited) dead&gt;'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_dead(self):</span>
        <span class="s1">g = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">g.switch()</span>
        <span class="s1">self.assertEndsWith(repr(g)</span><span class="s0">, </span><span class="s4">' dead&gt;'</span><span class="s1">)</span>
        <span class="s1">self.assertNotIn(</span><span class="s4">'suspended'</span><span class="s0">, </span><span class="s1">repr(g))</span>
        <span class="s1">self.assertNotIn(</span><span class="s4">'started'</span><span class="s0">, </span><span class="s1">repr(g))</span>
        <span class="s1">self.assertNotIn(</span><span class="s4">'active'</span><span class="s0">, </span><span class="s1">repr(g))</span>

    <span class="s0">def </span><span class="s1">test_formatting_produces_native_str(self):</span>
        <span class="s2"># https://github.com/python-greenlet/greenlet/issues/218</span>
        <span class="s2"># %s formatting on Python 2 was producing unicode, not str.</span>

        <span class="s1">g_dead = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">g_not_started = greenlet(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">g_cur = greenlet.getcurrent()</span>

        <span class="s0">for </span><span class="s1">g </span><span class="s0">in </span><span class="s1">g_dead</span><span class="s0">, </span><span class="s1">g_not_started</span><span class="s0">, </span><span class="s1">g_cur:</span>

            <span class="s1">self.assertIsInstance(</span>
                <span class="s4">'%s' </span><span class="s1">% (g</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">str</span>
            <span class="s1">)</span>
            <span class="s1">self.assertIsInstance(</span>
                <span class="s4">'%r' </span><span class="s1">% (g</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">str</span><span class="s0">,</span>
            <span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestMainGreenlet(TestCase):</span>
    <span class="s2"># Tests some implementation details, and relies on some</span>
    <span class="s2"># implementation details.</span>

    <span class="s0">def </span><span class="s1">_check_current_is_main(self):</span>
        <span class="s2"># implementation detail</span>
        <span class="s0">assert </span><span class="s4">'main' </span><span class="s0">in </span><span class="s1">repr(greenlet.getcurrent())</span>

        <span class="s1">t = type(greenlet.getcurrent())</span>
        <span class="s0">assert </span><span class="s4">'main' </span><span class="s0">not in </span><span class="s1">repr(t)</span>
        <span class="s0">return </span><span class="s1">t</span>

    <span class="s0">def </span><span class="s1">test_main_greenlet_type_can_be_subclassed(self):</span>
        <span class="s1">main_type = self._check_current_is_main()</span>
        <span class="s1">subclass = type(</span><span class="s4">'subclass'</span><span class="s0">, </span><span class="s1">(main_type</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{})</span>
        <span class="s1">self.assertIsNotNone(subclass)</span>

    <span class="s0">def </span><span class="s1">test_main_greenlet_is_greenlet(self):</span>
        <span class="s1">self._check_current_is_main()</span>
        <span class="s1">self.assertIsInstance(greenlet.getcurrent()</span><span class="s0">, </span><span class="s1">greenlet)</span>

<span class="s0">if </span><span class="s1">__name__ == </span><span class="s4">'__main__'</span><span class="s1">:</span>
    <span class="s0">import </span><span class="s1">unittest</span>
    <span class="s1">unittest.main()</span>
</pre>
</body>
</html>