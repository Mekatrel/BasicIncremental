<html>
<head>
<title>_sslgte279.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_sslgte279.py</font>
</center></td></tr></table>
<pre><span class="s0"># Wrapper module for _ssl. Written by Bill Janssen.</span>
<span class="s0"># Ported to gevent by Denis Bilenko.</span>
<span class="s2">&quot;&quot;&quot;SSL wrapper for socket objects on Python 2.7.9 and above. 
 
For the documentation, refer to :mod:`ssl` module manual. 
 
This module implements cooperative SSL socket wrappers. 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">absolute_import</span>
<span class="s0"># Our import magic sadly makes this warning useless</span>
<span class="s0"># pylint: disable=undefined-variable</span>
<span class="s0"># pylint: disable=too-many-instance-attributes,too-many-locals,too-many-statements,too-many-branches</span>
<span class="s0"># pylint: disable=arguments-differ,too-many-public-methods</span>

<span class="s3">import </span><span class="s1">ssl </span><span class="s3">as </span><span class="s1">__ssl__</span>

<span class="s1">_ssl = __ssl__._ssl </span><span class="s0"># pylint:disable=no-member</span>

<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">from </span><span class="s1">gevent._socket2 </span><span class="s3">import </span><span class="s1">socket</span>
<span class="s3">from </span><span class="s1">gevent._socket2 </span><span class="s3">import </span><span class="s1">AF_INET </span><span class="s0"># pylint:disable=no-name-in-module</span>
<span class="s3">from </span><span class="s1">gevent.socket </span><span class="s3">import </span><span class="s1">timeout_default</span>
<span class="s3">from </span><span class="s1">gevent.socket </span><span class="s3">import </span><span class="s1">create_connection</span>
<span class="s3">from </span><span class="s1">gevent.socket </span><span class="s3">import </span><span class="s1">error </span><span class="s3">as </span><span class="s1">socket_error</span>
<span class="s3">from </span><span class="s1">gevent.socket </span><span class="s3">import </span><span class="s1">timeout </span><span class="s3">as </span><span class="s1">_socket_timeout</span>
<span class="s3">from </span><span class="s1">gevent._compat </span><span class="s3">import </span><span class="s1">PYPY</span>
<span class="s3">from </span><span class="s1">gevent._util </span><span class="s3">import </span><span class="s1">copy_globals</span>

<span class="s1">__implements__ = [</span>
    <span class="s4">'SSLContext'</span><span class="s3">,</span>
    <span class="s4">'SSLSocket'</span><span class="s3">,</span>
    <span class="s4">'wrap_socket'</span><span class="s3">,</span>
    <span class="s4">'get_server_certificate'</span><span class="s3">,</span>
    <span class="s4">'create_default_context'</span><span class="s3">,</span>
    <span class="s4">'_create_unverified_context'</span><span class="s3">,</span>
    <span class="s4">'_create_default_https_context'</span><span class="s3">,</span>
    <span class="s4">'_create_stdlib_context'</span><span class="s3">,</span>
    <span class="s4">'_fileobject'</span><span class="s3">,</span>
<span class="s1">]</span>

<span class="s0"># Import all symbols from Python's ssl.py, except those that we are implementing</span>
<span class="s0"># and &quot;private&quot; symbols.</span>
<span class="s1">__imports__ = copy_globals(__ssl__</span><span class="s3">, </span><span class="s1">globals()</span><span class="s3">,</span>
                           <span class="s0"># SSLSocket *must* subclass gevent.socket.socket; see issue 597 and 801</span>
                           <span class="s1">names_to_ignore=__implements__ + [</span><span class="s4">'socket'</span><span class="s3">, </span><span class="s4">'create_connection'</span><span class="s1">]</span><span class="s3">,</span>
                           <span class="s1">dunder_names_to_keep=())</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s1">_delegate_methods </span><span class="s0"># pylint:disable=used-before-assignment</span>
<span class="s3">except </span><span class="s1">NameError: </span><span class="s0"># PyPy doesn't expose this detail</span>
    <span class="s1">_delegate_methods = (</span><span class="s4">'recv'</span><span class="s3">, </span><span class="s4">'recvfrom'</span><span class="s3">, </span><span class="s4">'recv_into'</span><span class="s3">, </span><span class="s4">'recvfrom_into'</span><span class="s3">, </span><span class="s4">'send'</span><span class="s3">, </span><span class="s4">'sendto'</span><span class="s1">)</span>

<span class="s1">__all__ = __implements__ + __imports__</span>
<span class="s3">if </span><span class="s4">'namedtuple' </span><span class="s3">in </span><span class="s1">__all__:</span>
    <span class="s1">__all__.remove(</span><span class="s4">'namedtuple'</span><span class="s1">)</span>

<span class="s0"># See notes in _socket2.py. Python 3 returns much nicer</span>
<span class="s0"># `io` object wrapped around a SocketIO class.</span>
<span class="s3">if </span><span class="s1">hasattr(__ssl__</span><span class="s3">, </span><span class="s4">'_fileobject'</span><span class="s1">):</span>
    <span class="s3">assert not </span><span class="s1">hasattr(__ssl__._fileobject</span><span class="s3">, </span><span class="s4">'__enter__'</span><span class="s1">) </span><span class="s0"># pylint:disable=no-member</span>

<span class="s3">class </span><span class="s1">_fileobject(getattr(__ssl__</span><span class="s3">, </span><span class="s4">'_fileobject'</span><span class="s3">, </span><span class="s1">object)): </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s3">def </span><span class="s1">__enter__(self):</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__exit__(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s0"># pylint:disable=no-member</span>
        <span class="s3">if not </span><span class="s1">self.closed:</span>
            <span class="s1">self.close()</span>


<span class="s1">orig_SSLContext = __ssl__.SSLContext </span><span class="s0"># pylint: disable=no-member</span>

<span class="s3">class </span><span class="s1">SSLContext(orig_SSLContext):</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s3">def </span><span class="s1">wrap_socket(self</span><span class="s3">, </span><span class="s1">sock</span><span class="s3">, </span><span class="s1">server_side=</span><span class="s3">False,</span>
                    <span class="s1">do_handshake_on_connect=</span><span class="s3">True,</span>
                    <span class="s1">suppress_ragged_eofs=</span><span class="s3">True,</span>
                    <span class="s1">server_hostname=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">SSLSocket(sock=sock</span><span class="s3">, </span><span class="s1">server_side=server_side</span><span class="s3">,</span>
                         <span class="s1">do_handshake_on_connect=do_handshake_on_connect</span><span class="s3">,</span>
                         <span class="s1">suppress_ragged_eofs=suppress_ragged_eofs</span><span class="s3">,</span>
                         <span class="s1">server_hostname=server_hostname</span><span class="s3">,</span>
                         <span class="s1">_context=self)</span>


<span class="s3">def </span><span class="s1">create_default_context(purpose=Purpose.SERVER_AUTH</span><span class="s3">, </span><span class="s1">cafile=</span><span class="s3">None,</span>
                           <span class="s1">capath=</span><span class="s3">None, </span><span class="s1">cadata=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Create a SSLContext object with default settings. 
 
    NOTE: The protocol and settings may change anytime without prior 
          deprecation. The values represent a fair balance between maximum 
          compatibility and security. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">isinstance(purpose</span><span class="s3">, </span><span class="s1">_ASN1Object):</span>
        <span class="s3">raise </span><span class="s1">TypeError(purpose)</span>

    <span class="s1">context = SSLContext(PROTOCOL_SSLv23)</span>

    <span class="s0"># SSLv2 considered harmful.</span>
    <span class="s1">context.options |= OP_NO_SSLv2 </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s0"># SSLv3 has problematic security and is only required for really old</span>
    <span class="s0"># clients such as IE6 on Windows XP</span>
    <span class="s1">context.options |= OP_NO_SSLv3 </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s0"># disable compression to prevent CRIME attacks (OpenSSL 1.0+)</span>
    <span class="s1">context.options |= getattr(_ssl</span><span class="s3">, </span><span class="s4">&quot;OP_NO_COMPRESSION&quot;</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s3">if </span><span class="s1">purpose == Purpose.SERVER_AUTH:</span>
        <span class="s0"># verify certs and host name in client mode</span>
        <span class="s1">context.verify_mode = CERT_REQUIRED</span>
        <span class="s1">context.check_hostname = </span><span class="s3">True </span><span class="s0"># pylint: disable=attribute-defined-outside-init</span>
    <span class="s3">elif </span><span class="s1">purpose == Purpose.CLIENT_AUTH:</span>
        <span class="s0"># Prefer the server's ciphers by default so that we get stronger</span>
        <span class="s0"># encryption</span>
        <span class="s1">context.options |= getattr(_ssl</span><span class="s3">, </span><span class="s4">&quot;OP_CIPHER_SERVER_PREFERENCE&quot;</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) </span><span class="s0"># pylint:disable=no-member</span>

        <span class="s0"># Use single use keys in order to improve forward secrecy</span>
        <span class="s1">context.options |= getattr(_ssl</span><span class="s3">, </span><span class="s4">&quot;OP_SINGLE_DH_USE&quot;</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) </span><span class="s0"># pylint:disable=no-member</span>
        <span class="s1">context.options |= getattr(_ssl</span><span class="s3">, </span><span class="s4">&quot;OP_SINGLE_ECDH_USE&quot;</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) </span><span class="s0"># pylint:disable=no-member</span>

        <span class="s0"># disallow ciphers with known vulnerabilities</span>
        <span class="s1">context.set_ciphers(_RESTRICTED_SERVER_CIPHERS)</span>

    <span class="s3">if </span><span class="s1">cafile </span><span class="s3">or </span><span class="s1">capath </span><span class="s3">or </span><span class="s1">cadata:</span>
        <span class="s1">context.load_verify_locations(cafile</span><span class="s3">, </span><span class="s1">capath</span><span class="s3">, </span><span class="s1">cadata)</span>
    <span class="s3">elif </span><span class="s1">context.verify_mode != CERT_NONE:</span>
        <span class="s0"># no explicit cafile, capath or cadata but the verify mode is</span>
        <span class="s0"># CERT_OPTIONAL or CERT_REQUIRED. Let's try to load default system</span>
        <span class="s0"># root CA certificates for the given purpose. This may fail silently.</span>
        <span class="s1">context.load_default_certs(purpose)</span>
    <span class="s3">return </span><span class="s1">context</span>

<span class="s3">def </span><span class="s1">_create_unverified_context(protocol=PROTOCOL_SSLv23</span><span class="s3">, </span><span class="s1">cert_reqs=</span><span class="s3">None,</span>
                               <span class="s1">check_hostname=</span><span class="s3">False, </span><span class="s1">purpose=Purpose.SERVER_AUTH</span><span class="s3">,</span>
                               <span class="s1">certfile=</span><span class="s3">None, </span><span class="s1">keyfile=</span><span class="s3">None,</span>
                               <span class="s1">cafile=</span><span class="s3">None, </span><span class="s1">capath=</span><span class="s3">None, </span><span class="s1">cadata=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Create a SSLContext object for Python stdlib modules 
 
    All Python stdlib modules shall use this function to create SSLContext 
    objects in order to keep common settings in one place. The configuration 
    is less restrict than create_default_context()'s to increase backward 
    compatibility. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">isinstance(purpose</span><span class="s3">, </span><span class="s1">_ASN1Object):</span>
        <span class="s3">raise </span><span class="s1">TypeError(purpose)</span>

    <span class="s1">context = SSLContext(protocol)</span>
    <span class="s0"># SSLv2 considered harmful.</span>
    <span class="s1">context.options |= OP_NO_SSLv2 </span><span class="s0"># pylint:disable=no-member</span>
    <span class="s0"># SSLv3 has problematic security and is only required for really old</span>
    <span class="s0"># clients such as IE6 on Windows XP</span>
    <span class="s1">context.options |= OP_NO_SSLv3 </span><span class="s0"># pylint:disable=no-member</span>

    <span class="s3">if </span><span class="s1">cert_reqs </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">context.verify_mode = cert_reqs</span>
    <span class="s1">context.check_hostname = check_hostname </span><span class="s0"># pylint: disable=attribute-defined-outside-init</span>

    <span class="s3">if </span><span class="s1">keyfile </span><span class="s3">and not </span><span class="s1">certfile:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;certfile must be specified&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">certfile </span><span class="s3">or </span><span class="s1">keyfile:</span>
        <span class="s1">context.load_cert_chain(certfile</span><span class="s3">, </span><span class="s1">keyfile)</span>

    <span class="s0"># load CA root certs</span>
    <span class="s3">if </span><span class="s1">cafile </span><span class="s3">or </span><span class="s1">capath </span><span class="s3">or </span><span class="s1">cadata:</span>
        <span class="s1">context.load_verify_locations(cafile</span><span class="s3">, </span><span class="s1">capath</span><span class="s3">, </span><span class="s1">cadata)</span>
    <span class="s3">elif </span><span class="s1">context.verify_mode != CERT_NONE:</span>
        <span class="s0"># no explicit cafile, capath or cadata but the verify mode is</span>
        <span class="s0"># CERT_OPTIONAL or CERT_REQUIRED. Let's try to load default system</span>
        <span class="s0"># root CA certificates for the given purpose. This may fail silently.</span>
        <span class="s1">context.load_default_certs(purpose)</span>

    <span class="s3">return </span><span class="s1">context</span>

<span class="s0"># Used by http.client if no context is explicitly passed.</span>
<span class="s1">_create_default_https_context = create_default_context</span>


<span class="s0"># Backwards compatibility alias, even though it's not a public name.</span>
<span class="s1">_create_stdlib_context = _create_unverified_context</span>

<span class="s3">class </span><span class="s1">SSLSocket(socket):</span>
    <span class="s2">&quot;&quot;&quot; 
    gevent `ssl.SSLSocket &lt;https://docs.python.org/2/library/ssl.html#ssl-sockets&gt;`_ 
    for Pythons &gt;= 2.7.9 but less than 3. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">sock=</span><span class="s3">None, </span><span class="s1">keyfile=</span><span class="s3">None, </span><span class="s1">certfile=</span><span class="s3">None,</span>
                 <span class="s1">server_side=</span><span class="s3">False, </span><span class="s1">cert_reqs=CERT_NONE</span><span class="s3">,</span>
                 <span class="s1">ssl_version=PROTOCOL_SSLv23</span><span class="s3">, </span><span class="s1">ca_certs=</span><span class="s3">None,</span>
                 <span class="s1">do_handshake_on_connect=</span><span class="s3">True,</span>
                 <span class="s1">family=AF_INET</span><span class="s3">, </span><span class="s1">type=SOCK_STREAM</span><span class="s3">, </span><span class="s1">proto=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">fileno=</span><span class="s3">None,</span>
                 <span class="s1">suppress_ragged_eofs=</span><span class="s3">True, </span><span class="s1">npn_protocols=</span><span class="s3">None, </span><span class="s1">ciphers=</span><span class="s3">None,</span>
                 <span class="s1">server_hostname=</span><span class="s3">None,</span>
                 <span class="s1">_context=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># fileno is ignored</span>
        <span class="s0"># pylint: disable=unused-argument</span>
        <span class="s3">if </span><span class="s1">_context:</span>
            <span class="s1">self._context = _context</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">server_side </span><span class="s3">and not </span><span class="s1">certfile:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;certfile must be specified for server-side &quot;</span>
                                 <span class="s4">&quot;operations&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">keyfile </span><span class="s3">and not </span><span class="s1">certfile:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;certfile must be specified&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">certfile </span><span class="s3">and not </span><span class="s1">keyfile:</span>
                <span class="s1">keyfile = certfile</span>
            <span class="s1">self._context = SSLContext(ssl_version)</span>
            <span class="s1">self._context.verify_mode = cert_reqs</span>
            <span class="s3">if </span><span class="s1">ca_certs:</span>
                <span class="s1">self._context.load_verify_locations(ca_certs)</span>
            <span class="s3">if </span><span class="s1">certfile:</span>
                <span class="s1">self._context.load_cert_chain(certfile</span><span class="s3">, </span><span class="s1">keyfile)</span>
            <span class="s3">if </span><span class="s1">npn_protocols:</span>
                <span class="s1">self._context.set_npn_protocols(npn_protocols)</span>
            <span class="s3">if </span><span class="s1">ciphers:</span>
                <span class="s1">self._context.set_ciphers(ciphers)</span>
            <span class="s1">self.keyfile = keyfile</span>
            <span class="s1">self.certfile = certfile</span>
            <span class="s1">self.cert_reqs = cert_reqs</span>
            <span class="s1">self.ssl_version = ssl_version</span>
            <span class="s1">self.ca_certs = ca_certs</span>
            <span class="s1">self.ciphers = ciphers</span>
        <span class="s0"># Can't use sock.type as other flags (such as SOCK_NONBLOCK) get</span>
        <span class="s0"># mixed in.</span>
        <span class="s3">if </span><span class="s1">sock.getsockopt(SOL_SOCKET</span><span class="s3">, </span><span class="s1">SO_TYPE) != SOCK_STREAM:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;only stream sockets are supported&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">PYPY:</span>
            <span class="s1">socket.__init__(self</span><span class="s3">, </span><span class="s1">_sock=sock)</span>
            <span class="s1">sock._drop()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># CPython: XXX: Must pass the underlying socket, not our</span>
            <span class="s0"># potential wrapper; test___example_servers fails the SSL test</span>
            <span class="s0"># with a client-side EOF error. (Why?)</span>
            <span class="s1">socket.__init__(self</span><span class="s3">, </span><span class="s1">_sock=sock._sock)</span>

        <span class="s0"># The initializer for socket overrides the methods send(), recv(), etc.</span>
        <span class="s0"># in the instance, which we don't need -- but we want to provide the</span>
        <span class="s0"># methods defined in SSLSocket.</span>
        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">_delegate_methods:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">delattr(self</span><span class="s3">, </span><span class="s1">attr)</span>
            <span class="s3">except </span><span class="s1">AttributeError:</span>
                <span class="s3">pass</span>
        <span class="s3">if </span><span class="s1">server_side </span><span class="s3">and </span><span class="s1">server_hostname:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;server_hostname can only be specified &quot;</span>
                             <span class="s4">&quot;in client mode&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self._context.check_hostname </span><span class="s3">and not </span><span class="s1">server_hostname:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;check_hostname requires server_hostname&quot;</span><span class="s1">)</span>
        <span class="s1">self.server_side = server_side</span>
        <span class="s1">self.server_hostname = server_hostname</span>
        <span class="s1">self.do_handshake_on_connect = do_handshake_on_connect</span>
        <span class="s1">self.suppress_ragged_eofs = suppress_ragged_eofs</span>
        <span class="s1">self.settimeout(sock.gettimeout())</span>

        <span class="s0"># See if we are connected</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.getpeername()</span>
        <span class="s3">except </span><span class="s1">socket_error </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">if </span><span class="s1">e.errno != errno.ENOTCONN:</span>
                <span class="s3">raise</span>
            <span class="s1">connected = </span><span class="s3">False</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">connected = </span><span class="s3">True</span>

        <span class="s1">self._makefile_refs = </span><span class="s5">0</span>
        <span class="s1">self._closed = </span><span class="s3">False</span>
        <span class="s1">self._sslobj = </span><span class="s3">None</span>
        <span class="s1">self._connected = connected</span>
        <span class="s3">if </span><span class="s1">connected:</span>
            <span class="s0"># create the SSL object</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self._sslobj = self._context._wrap_socket(self._sock</span><span class="s3">, </span><span class="s1">server_side</span><span class="s3">,</span>
                                                          <span class="s1">server_hostname</span><span class="s3">, </span><span class="s1">ssl_sock=self)</span>
                <span class="s3">if </span><span class="s1">do_handshake_on_connect:</span>
                    <span class="s1">timeout = self.gettimeout()</span>
                    <span class="s3">if </span><span class="s1">timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s0"># non-blocking</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;do_handshake_on_connect should not be specified for non-blocking sockets&quot;</span><span class="s1">)</span>
                    <span class="s1">self.do_handshake()</span>

            <span class="s3">except </span><span class="s1">socket_error </span><span class="s3">as </span><span class="s1">x:</span>
                <span class="s1">self.close()</span>
                <span class="s3">raise </span><span class="s1">x</span>


    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">context(self):</span>
        <span class="s3">return </span><span class="s1">self._context</span>

    <span class="s1">@context.setter</span>
    <span class="s3">def </span><span class="s1">context(self</span><span class="s3">, </span><span class="s1">ctx):</span>
        <span class="s1">self._context = ctx</span>
        <span class="s1">self._sslobj.context = ctx</span>

    <span class="s3">def </span><span class="s1">dup(self):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Can't dup() %s instances&quot; </span><span class="s1">%</span>
                                  <span class="s1">self.__class__.__name__)</span>

    <span class="s3">def </span><span class="s1">_checkClosed(self</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># raise an exception here if you wish to check for spurious closes</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">_check_connected(self):</span>
        <span class="s3">if not </span><span class="s1">self._connected:</span>
            <span class="s0"># getpeername() will raise ENOTCONN if the socket is really</span>
            <span class="s0"># not connected; note that we can be connected even without</span>
            <span class="s0"># _connected being set, e.g. if connect() first returned</span>
            <span class="s0"># EAGAIN.</span>
            <span class="s1">self.getpeername()</span>

    <span class="s3">def </span><span class="s1">read(self</span><span class="s3">, </span><span class="s1">len=</span><span class="s5">1024</span><span class="s3">, </span><span class="s1">buffer=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Read up to LEN bytes and return them. 
        Return zero-length string on EOF.&quot;&quot;&quot;</span>
        <span class="s1">self._checkClosed()</span>

        <span class="s3">while </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">self._sslobj:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Read on closed or unwrapped SSL socket.&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">len == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s6">b'' </span><span class="s3">if </span><span class="s1">buffer </span><span class="s3">is None else </span><span class="s5">0</span>
            <span class="s3">if </span><span class="s1">len &lt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">buffer </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s0"># This is handled natively in python 2.7.12+</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Negative read length&quot;</span><span class="s1">)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">buffer </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">self._sslobj.read(len</span><span class="s3">, </span><span class="s1">buffer)</span>
                <span class="s3">return </span><span class="s1">self._sslobj.read(len </span><span class="s3">or </span><span class="s5">1024</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">SSLWantReadError:</span>
                <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">raise</span>
                <span class="s1">self._wait(self._read_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorReadTimeout)</span>
            <span class="s3">except </span><span class="s1">SSLWantWriteError:</span>
                <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">raise</span>
                <span class="s0"># note: using _SSLErrorReadTimeout rather than _SSLErrorWriteTimeout below is intentional</span>
                <span class="s1">self._wait(self._write_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorReadTimeout)</span>
            <span class="s3">except </span><span class="s1">SSLError </span><span class="s3">as </span><span class="s1">ex:</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_EOF </span><span class="s3">and </span><span class="s1">self.suppress_ragged_eofs:</span>
                    <span class="s3">if </span><span class="s1">buffer </span><span class="s3">is not None</span><span class="s1">:</span>
                        <span class="s3">return </span><span class="s5">0</span>
                    <span class="s3">return </span><span class="s6">b''</span>
                <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">write(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s2">&quot;&quot;&quot;Write DATA to the underlying SSL channel.  Returns 
        number of bytes of DATA actually transmitted.&quot;&quot;&quot;</span>
        <span class="s1">self._checkClosed()</span>

        <span class="s3">while </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">self._sslobj:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Write on closed or unwrapped SSL socket.&quot;</span><span class="s1">)</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._sslobj.write(data)</span>
            <span class="s3">except </span><span class="s1">SSLError </span><span class="s3">as </span><span class="s1">ex:</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_READ:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">self._wait(self._read_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorWriteTimeout)</span>
                <span class="s3">elif </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_WRITE:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">self._wait(self._write_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorWriteTimeout)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">getpeercert(self</span><span class="s3">, </span><span class="s1">binary_form=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Returns a formatted version of the data in the 
        certificate provided by the other end of the SSL channel. 
        Return None if no certificate was provided, {} if a 
        certificate was provided, but not validated.&quot;&quot;&quot;</span>

        <span class="s1">self._checkClosed()</span>
        <span class="s1">self._check_connected()</span>
        <span class="s3">return </span><span class="s1">self._sslobj.peer_certificate(binary_form)</span>

    <span class="s3">def </span><span class="s1">selected_npn_protocol(self):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if not </span><span class="s1">self._sslobj </span><span class="s3">or not </span><span class="s1">_ssl.HAS_NPN:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">self._sslobj.selected_npn_protocol()</span>

    <span class="s3">if </span><span class="s1">hasattr(_ssl</span><span class="s3">, </span><span class="s4">'HAS_ALPN'</span><span class="s1">):</span>
        <span class="s0"># 2.7.10+</span>
        <span class="s3">def </span><span class="s1">selected_alpn_protocol(self):</span>
            <span class="s1">self._checkClosed()</span>
            <span class="s3">if not </span><span class="s1">self._sslobj </span><span class="s3">or not </span><span class="s1">_ssl.HAS_ALPN: </span><span class="s0"># pylint:disable=no-member</span>
                <span class="s3">return None</span>
            <span class="s3">return </span><span class="s1">self._sslobj.selected_alpn_protocol()</span>

    <span class="s3">def </span><span class="s1">cipher(self):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if not </span><span class="s1">self._sslobj:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">self._sslobj.cipher()</span>

    <span class="s3">def </span><span class="s1">compression(self):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if not </span><span class="s1">self._sslobj:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">self._sslobj.compression()</span>

    <span class="s3">def </span><span class="s1">__check_flags(self</span><span class="s3">, </span><span class="s1">meth</span><span class="s3">, </span><span class="s1">flags):</span>
        <span class="s3">if </span><span class="s1">flags != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;non-zero flags not allowed in calls to %s on %s&quot; </span><span class="s1">%</span>
                <span class="s1">(meth</span><span class="s3">, </span><span class="s1">self.__class__))</span>

    <span class="s3">def </span><span class="s1">send(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">timeout=timeout_default):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s1">self.__check_flags(</span><span class="s4">'send'</span><span class="s3">, </span><span class="s1">flags)</span>

        <span class="s3">if </span><span class="s1">timeout </span><span class="s3">is </span><span class="s1">timeout_default:</span>
            <span class="s1">timeout = self.timeout</span>

        <span class="s3">if not </span><span class="s1">self._sslobj:</span>
            <span class="s3">return </span><span class="s1">socket.send(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">timeout)</span>

        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._sslobj.write(data)</span>
            <span class="s3">except </span><span class="s1">SSLWantReadError:</span>
                <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s5">0</span>
                <span class="s1">self._wait(self._read_event)</span>
            <span class="s3">except </span><span class="s1">SSLWantWriteError:</span>
                <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s5">0</span>
                <span class="s1">self._wait(self._write_event)</span>

    <span class="s3">def </span><span class="s1">sendto(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags_or_addr</span><span class="s3">, </span><span class="s1">addr=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;sendto not allowed on instances of %s&quot; </span><span class="s1">%</span>
                             <span class="s1">self.__class__)</span>
        <span class="s3">if </span><span class="s1">addr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">socket.sendto(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags_or_addr)</span>
        <span class="s3">return </span><span class="s1">socket.sendto(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags_or_addr</span><span class="s3">, </span><span class="s1">addr)</span>

    <span class="s3">def </span><span class="s1">sendmsg(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># Ensure programs don't send data unencrypted if they try to</span>
        <span class="s0"># use this method.</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;sendmsg not allowed on instances of %s&quot; </span><span class="s1">%</span>
                                  <span class="s1">self.__class__)</span>

    <span class="s3">def </span><span class="s1">sendall(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s1">self.__check_flags(</span><span class="s4">'sendall'</span><span class="s3">, </span><span class="s1">flags)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">socket.sendall(self</span><span class="s3">, </span><span class="s1">data)</span>
        <span class="s3">except </span><span class="s1">_socket_timeout </span><span class="s3">as </span><span class="s1">ex:</span>
            <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                <span class="s0"># Python 2 simply *hangs* in this case, which is bad, but</span>
                <span class="s0"># Python 3 raises SSLWantWriteError. We do the same.</span>
                <span class="s3">raise </span><span class="s1">SSLWantWriteError(</span><span class="s4">&quot;The operation did not complete (write)&quot;</span><span class="s1">)</span>
            <span class="s0"># Convert the socket.timeout back to the sslerror</span>
            <span class="s3">raise </span><span class="s1">SSLError(*ex.args)</span>

    <span class="s3">def </span><span class="s1">recv(self</span><span class="s3">, </span><span class="s1">buflen=</span><span class="s5">1024</span><span class="s3">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">if </span><span class="s1">flags != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;non-zero flags not allowed in calls to recv() on %s&quot; </span><span class="s1">%</span>
                    <span class="s1">self.__class__)</span>
            <span class="s3">if </span><span class="s1">buflen == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s6">b''</span>
            <span class="s3">return </span><span class="s1">self.read(buflen)</span>
        <span class="s3">return </span><span class="s1">socket.recv(self</span><span class="s3">, </span><span class="s1">buflen</span><span class="s3">, </span><span class="s1">flags)</span>

    <span class="s3">def </span><span class="s1">recv_into(self</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">nbytes=</span><span class="s3">None, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">buffer </span><span class="s3">is not None and </span><span class="s1">(nbytes </span><span class="s3">is None</span><span class="s1">):</span>
            <span class="s0"># Fix for python bug #23804: bool(bytearray()) is False,</span>
            <span class="s0"># but we should read 0 bytes.</span>
            <span class="s1">nbytes = len(buffer)</span>
        <span class="s3">elif </span><span class="s1">nbytes </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">nbytes = </span><span class="s5">1024</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">if </span><span class="s1">flags != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;non-zero flags not allowed in calls to recv_into() on %s&quot; </span><span class="s1">%</span>
                    <span class="s1">self.__class__)</span>
            <span class="s3">return </span><span class="s1">self.read(nbytes</span><span class="s3">, </span><span class="s1">buffer)</span>
        <span class="s3">return </span><span class="s1">socket.recv_into(self</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">nbytes</span><span class="s3">, </span><span class="s1">flags)</span>

    <span class="s3">def </span><span class="s1">recvfrom(self</span><span class="s3">, </span><span class="s1">buflen=</span><span class="s5">1024</span><span class="s3">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;recvfrom not allowed on instances of %s&quot; </span><span class="s1">%</span>
                             <span class="s1">self.__class__)</span>
        <span class="s3">return </span><span class="s1">socket.recvfrom(self</span><span class="s3">, </span><span class="s1">buflen</span><span class="s3">, </span><span class="s1">flags)</span>

    <span class="s3">def </span><span class="s1">recvfrom_into(self</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">nbytes=</span><span class="s3">None, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;recvfrom_into not allowed on instances of %s&quot; </span><span class="s1">%</span>
                             <span class="s1">self.__class__)</span>
        <span class="s3">return </span><span class="s1">socket.recvfrom_into(self</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">nbytes</span><span class="s3">, </span><span class="s1">flags)</span>

    <span class="s3">def </span><span class="s1">recvmsg(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;recvmsg not allowed on instances of %s&quot; </span><span class="s1">%</span>
                                  <span class="s1">self.__class__)</span>

    <span class="s3">def </span><span class="s1">recvmsg_into(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;recvmsg_into not allowed on instances of &quot;</span>
                                  <span class="s4">&quot;%s&quot; </span><span class="s1">% self.__class__)</span>

    <span class="s3">def </span><span class="s1">pending(self):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">return </span><span class="s1">self._sslobj.pending()</span>
        <span class="s3">return </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">shutdown(self</span><span class="s3">, </span><span class="s1">how):</span>
        <span class="s1">self._checkClosed()</span>
        <span class="s1">self._sslobj = </span><span class="s3">None</span>
        <span class="s1">socket.shutdown(self</span><span class="s3">, </span><span class="s1">how)</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s3">if </span><span class="s1">self._makefile_refs &lt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self._sslobj = </span><span class="s3">None</span>
            <span class="s1">socket.close(self)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._makefile_refs -= </span><span class="s5">1</span>

    <span class="s3">if </span><span class="s1">PYPY:</span>

        <span class="s3">def </span><span class="s1">_reuse(self):</span>
            <span class="s1">self._makefile_refs += </span><span class="s5">1</span>

        <span class="s3">def </span><span class="s1">_drop(self):</span>
            <span class="s3">if </span><span class="s1">self._makefile_refs &lt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">self.close()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._makefile_refs -= </span><span class="s5">1</span>

    <span class="s3">def </span><span class="s1">_sslobj_shutdown(self):</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._sslobj.shutdown()</span>
            <span class="s3">except </span><span class="s1">SSLError </span><span class="s3">as </span><span class="s1">ex:</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_EOF </span><span class="s3">and </span><span class="s1">self.suppress_ragged_eofs:</span>
                    <span class="s3">return </span><span class="s4">''</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_READ:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">sys.exc_clear()</span>
                    <span class="s1">self._wait(self._read_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorReadTimeout)</span>
                <span class="s3">elif </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_WRITE:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">sys.exc_clear()</span>
                    <span class="s1">self._wait(self._write_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorWriteTimeout)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">unwrap(self):</span>
        <span class="s3">if not </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;No SSL wrapper around &quot; </span><span class="s1">+ str(self))</span>

        <span class="s1">s = self._sock</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">s = self._sslobj_shutdown()</span>
        <span class="s3">except </span><span class="s1">socket_error </span><span class="s3">as </span><span class="s1">ex:</span>
            <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise</span>

        <span class="s1">self._sslobj = </span><span class="s3">None</span>
        <span class="s0"># match _ssl2; critical to drop/reuse here on PyPy</span>
        <span class="s0"># XXX: _ssl3 returns an SSLSocket. Is that what the standard lib does on</span>
        <span class="s0"># Python 2? Should we do that?</span>
        <span class="s3">return </span><span class="s1">socket(_sock=s)</span>

    <span class="s3">def </span><span class="s1">_real_close(self):</span>
        <span class="s1">self._sslobj = </span><span class="s3">None</span>
        <span class="s1">socket._real_close(self) </span><span class="s0"># pylint: disable=no-member</span>

    <span class="s3">def </span><span class="s1">do_handshake(self):</span>
        <span class="s2">&quot;&quot;&quot;Perform a TLS/SSL handshake.&quot;&quot;&quot;</span>
        <span class="s1">self._check_connected()</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self._sslobj.do_handshake()</span>
                <span class="s3">break</span>
            <span class="s3">except </span><span class="s1">SSLWantReadError:</span>
                <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">raise</span>
                <span class="s1">self._wait(self._read_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorHandshakeTimeout)</span>
            <span class="s3">except </span><span class="s1">SSLWantWriteError:</span>
                <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">raise</span>
                <span class="s1">self._wait(self._write_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorHandshakeTimeout)</span>

        <span class="s3">if </span><span class="s1">self._context.check_hostname:</span>
            <span class="s3">if not </span><span class="s1">self.server_hostname:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;check_hostname needs server_hostname &quot;</span>
                                 <span class="s4">&quot;argument&quot;</span><span class="s1">)</span>
            <span class="s1">match_hostname(self.getpeercert()</span><span class="s3">, </span><span class="s1">self.server_hostname)</span>

    <span class="s3">def </span><span class="s1">_real_connect(self</span><span class="s3">, </span><span class="s1">addr</span><span class="s3">, </span><span class="s1">connect_ex):</span>
        <span class="s3">if </span><span class="s1">self.server_side:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;can't connect in server-side mode&quot;</span><span class="s1">)</span>
        <span class="s0"># Here we assume that the socket is client-side, and not</span>
        <span class="s0"># connected at the time of the call.  We connect it, then wrap it.</span>
        <span class="s3">if </span><span class="s1">self._connected:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;attempt to connect already-connected SSLSocket!&quot;</span><span class="s1">)</span>
        <span class="s1">self._sslobj = self._context._wrap_socket(self._sock</span><span class="s3">, False, </span><span class="s1">self.server_hostname</span><span class="s3">, </span><span class="s1">ssl_sock=self)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">connect_ex:</span>
                <span class="s1">rc = socket.connect_ex(self</span><span class="s3">, </span><span class="s1">addr)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">rc = </span><span class="s3">None</span>
                <span class="s1">socket.connect(self</span><span class="s3">, </span><span class="s1">addr)</span>
            <span class="s3">if not </span><span class="s1">rc:</span>
                <span class="s1">self._connected = </span><span class="s3">True</span>
                <span class="s3">if </span><span class="s1">self.do_handshake_on_connect:</span>
                    <span class="s1">self.do_handshake()</span>
            <span class="s3">return </span><span class="s1">rc</span>
        <span class="s3">except </span><span class="s1">socket_error:</span>
            <span class="s1">self._sslobj = </span><span class="s3">None</span>
            <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">connect(self</span><span class="s3">, </span><span class="s1">addr): </span><span class="s0"># pylint:disable=arguments-renamed</span>
        <span class="s2">&quot;&quot;&quot;Connects to remote ADDR, and then wraps the connection in 
        an SSL channel.&quot;&quot;&quot;</span>
        <span class="s1">self._real_connect(addr</span><span class="s3">, False</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">connect_ex(self</span><span class="s3">, </span><span class="s1">addr): </span><span class="s0"># pylint:disable=arguments-renamed</span>
        <span class="s2">&quot;&quot;&quot;Connects to remote ADDR, and then wraps the connection in 
        an SSL channel.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._real_connect(addr</span><span class="s3">, True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">accept(self):</span>
        <span class="s2">&quot;&quot;&quot;Accepts a new connection from a remote client, and returns 
        a tuple containing that new connection wrapped with a server-side 
        SSL channel, and the address of the remote client.&quot;&quot;&quot;</span>

        <span class="s1">newsock</span><span class="s3">, </span><span class="s1">addr = socket.accept(self)</span>
        <span class="s1">newsock._drop_events_and_close(closefd=</span><span class="s3">False</span><span class="s1">) </span><span class="s0"># Why, again?</span>
        <span class="s1">newsock = self._context.wrap_socket(newsock</span><span class="s3">,</span>
                                            <span class="s1">do_handshake_on_connect=self.do_handshake_on_connect</span><span class="s3">,</span>
                                            <span class="s1">suppress_ragged_eofs=self.suppress_ragged_eofs</span><span class="s3">,</span>
                                            <span class="s1">server_side=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">newsock</span><span class="s3">, </span><span class="s1">addr</span>

    <span class="s3">def </span><span class="s1">makefile(self</span><span class="s3">, </span><span class="s1">mode=</span><span class="s4">'r'</span><span class="s3">, </span><span class="s1">bufsize=-</span><span class="s5">1</span><span class="s1">):</span>

        <span class="s2">&quot;&quot;&quot;Make and return a file-like object that 
        works with the SSL connection.  Just use the code 
        from the socket module.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">PYPY:</span>
            <span class="s1">self._makefile_refs += </span><span class="s5">1</span>
        <span class="s0"># close=True so as to decrement the reference count when done with</span>
        <span class="s0"># the file-like object.</span>
        <span class="s3">return </span><span class="s1">_fileobject(self</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">bufsize</span><span class="s3">, </span><span class="s1">close=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_channel_binding(self</span><span class="s3">, </span><span class="s1">cb_type=</span><span class="s4">&quot;tls-unique&quot;</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Get channel binding data for current connection.  Raise ValueError 
        if the requested `cb_type` is not supported.  Return bytes of the data 
        or None if the data is not available (e.g. before the handshake). 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">cb_type </span><span class="s3">not in </span><span class="s1">CHANNEL_BINDING_TYPES:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unsupported channel binding type&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">cb_type != </span><span class="s4">&quot;tls-unique&quot;</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s4">&quot;{0} channel binding type not implemented&quot;</span>
                <span class="s1">.format(cb_type))</span>
        <span class="s3">if </span><span class="s1">self._sslobj </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">self._sslobj.tls_unique_cb()</span>

    <span class="s3">def </span><span class="s1">version(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return a string identifying the protocol version used by the 
        current SSL channel, or None if there is no established channel. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._sslobj </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">self._sslobj.version()</span>

<span class="s3">if </span><span class="s1">PYPY </span><span class="s3">or not </span><span class="s1">hasattr(SSLSocket</span><span class="s3">, </span><span class="s4">'timeout'</span><span class="s1">):</span>
    <span class="s0"># PyPy (and certain versions of CPython) doesn't have a direct</span>
    <span class="s0"># 'timeout' property on raw sockets, because that's not part of</span>
    <span class="s0"># the documented specification. We may wind up wrapping a raw</span>
    <span class="s0"># socket (when ssl is used with PyWSGI) or a gevent socket, which</span>
    <span class="s0"># does have a read/write timeout property as an alias for</span>
    <span class="s0"># get/settimeout, so make sure that's always the case because</span>
    <span class="s0"># pywsgi can depend on that.</span>
    <span class="s1">SSLSocket.timeout = property(</span><span class="s3">lambda </span><span class="s1">self: self.gettimeout()</span><span class="s3">,</span>
                                 <span class="s3">lambda </span><span class="s1">self</span><span class="s3">, </span><span class="s1">value: self.settimeout(value))</span>



<span class="s1">_SSLErrorReadTimeout = SSLError(</span><span class="s4">'The read operation timed out'</span><span class="s1">)</span>
<span class="s1">_SSLErrorWriteTimeout = SSLError(</span><span class="s4">'The write operation timed out'</span><span class="s1">)</span>
<span class="s1">_SSLErrorHandshakeTimeout = SSLError(</span><span class="s4">'The handshake operation timed out'</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">wrap_socket(sock</span><span class="s3">, </span><span class="s1">keyfile=</span><span class="s3">None, </span><span class="s1">certfile=</span><span class="s3">None,</span>
                <span class="s1">server_side=</span><span class="s3">False, </span><span class="s1">cert_reqs=CERT_NONE</span><span class="s3">,</span>
                <span class="s1">ssl_version=PROTOCOL_SSLv23</span><span class="s3">, </span><span class="s1">ca_certs=</span><span class="s3">None,</span>
                <span class="s1">do_handshake_on_connect=</span><span class="s3">True,</span>
                <span class="s1">suppress_ragged_eofs=</span><span class="s3">True,</span>
                <span class="s1">ciphers=</span><span class="s3">None</span><span class="s1">):</span>

    <span class="s3">return </span><span class="s1">SSLSocket(sock=sock</span><span class="s3">, </span><span class="s1">keyfile=keyfile</span><span class="s3">, </span><span class="s1">certfile=certfile</span><span class="s3">,</span>
                     <span class="s1">server_side=server_side</span><span class="s3">, </span><span class="s1">cert_reqs=cert_reqs</span><span class="s3">,</span>
                     <span class="s1">ssl_version=ssl_version</span><span class="s3">, </span><span class="s1">ca_certs=ca_certs</span><span class="s3">,</span>
                     <span class="s1">do_handshake_on_connect=do_handshake_on_connect</span><span class="s3">,</span>
                     <span class="s1">suppress_ragged_eofs=suppress_ragged_eofs</span><span class="s3">,</span>
                     <span class="s1">ciphers=ciphers)</span>

<span class="s3">def </span><span class="s1">get_server_certificate(addr</span><span class="s3">, </span><span class="s1">ssl_version=PROTOCOL_SSLv23</span><span class="s3">, </span><span class="s1">ca_certs=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Retrieve the certificate from the server at the specified address, 
    and return it as a PEM-encoded string. 
    If 'ca_certs' is specified, validate the server cert against it. 
    If 'ssl_version' is specified, use it in the connection attempt.&quot;&quot;&quot;</span>

    <span class="s1">_</span><span class="s3">, </span><span class="s1">_ = addr</span>
    <span class="s3">if </span><span class="s1">ca_certs </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">cert_reqs = CERT_REQUIRED</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">cert_reqs = CERT_NONE</span>
    <span class="s1">context = _create_stdlib_context(ssl_version</span><span class="s3">,</span>
                                     <span class="s1">cert_reqs=cert_reqs</span><span class="s3">,</span>
                                     <span class="s1">cafile=ca_certs)</span>
    <span class="s3">with </span><span class="s1">closing(create_connection(addr)) </span><span class="s3">as </span><span class="s1">sock:</span>
        <span class="s3">with </span><span class="s1">closing(context.wrap_socket(sock)) </span><span class="s3">as </span><span class="s1">sslsock:</span>
            <span class="s1">dercert = sslsock.getpeercert(</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">DER_cert_to_PEM_cert(dercert)</span>
</pre>
</body>
</html>