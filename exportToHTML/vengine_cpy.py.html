<html>
<head>
<title>vengine_cpy.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
vengine_cpy.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># DEPRECATED: implementation for ffi.verify()</span>
<span class="s0">#</span>
<span class="s2">import </span><span class="s1">sys</span><span class="s2">, </span><span class="s1">imp</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">model</span>
<span class="s2">from </span><span class="s1">.error </span><span class="s2">import </span><span class="s1">VerificationError</span>


<span class="s2">class </span><span class="s1">VCPythonEngine(object):</span>
    <span class="s1">_class_key = </span><span class="s3">'x'</span>
    <span class="s1">_gen_python_module = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">verifier):</span>
        <span class="s1">self.verifier = verifier</span>
        <span class="s1">self.ffi = verifier.ffi</span>
        <span class="s1">self._struct_pending_verification = {}</span>
        <span class="s1">self._types_of_builtin_functions = {}</span>

    <span class="s2">def </span><span class="s1">patch_extension_kwds(self</span><span class="s2">, </span><span class="s1">kwds):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">find_module(self</span><span class="s2">, </span><span class="s1">module_name</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">so_suffixes):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">f</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">descr = imp.find_module(module_name</span><span class="s2">, </span><span class="s1">path)</span>
        <span class="s2">except </span><span class="s1">ImportError:</span>
            <span class="s2">return None</span>
        <span class="s2">if </span><span class="s1">f </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">f.close()</span>
        <span class="s0"># Note that after a setuptools installation, there are both .py</span>
        <span class="s0"># and .so files with the same basename.  The code here relies on</span>
        <span class="s0"># imp.find_module() locating the .so in priority.</span>
        <span class="s2">if </span><span class="s1">descr[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">so_suffixes:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">filename</span>

    <span class="s2">def </span><span class="s1">collect_types(self):</span>
        <span class="s1">self._typesdict = {}</span>
        <span class="s1">self._generate(</span><span class="s3">&quot;collecttype&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_prnt(self</span><span class="s2">, </span><span class="s1">what=</span><span class="s3">''</span><span class="s1">):</span>
        <span class="s1">self._f.write(what + </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_gettypenum(self</span><span class="s2">, </span><span class="s1">type):</span>
        <span class="s0"># a KeyError here is a bug.  please report it! :-)</span>
        <span class="s2">return </span><span class="s1">self._typesdict[type]</span>

    <span class="s2">def </span><span class="s1">_do_collect_type(self</span><span class="s2">, </span><span class="s1">tp):</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s2">not </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.PrimitiveType)</span>
             <span class="s2">or </span><span class="s1">tp.name == </span><span class="s3">'long double'</span><span class="s1">)</span>
                <span class="s2">and </span><span class="s1">tp </span><span class="s2">not in </span><span class="s1">self._typesdict):</span>
            <span class="s1">num = len(self._typesdict)</span>
            <span class="s1">self._typesdict[tp] = num</span>

    <span class="s2">def </span><span class="s1">write_source_to_f(self):</span>
        <span class="s1">self.collect_types()</span>
        <span class="s0">#</span>
        <span class="s0"># The new module will have a _cffi_setup() function that receives</span>
        <span class="s0"># objects from the ffi world, and that calls some setup code in</span>
        <span class="s0"># the module.  This setup code is split in several independent</span>
        <span class="s0"># functions, e.g. one per constant.  The functions are &quot;chained&quot;</span>
        <span class="s0"># by ending in a tail call to each other.</span>
        <span class="s0">#</span>
        <span class="s0"># This is further split in two chained lists, depending on if we</span>
        <span class="s0"># can do it at import-time or if we must wait for _cffi_setup() to</span>
        <span class="s0"># provide us with the &lt;ctype&gt; objects.  This is needed because we</span>
        <span class="s0"># need the values of the enum constants in order to build the</span>
        <span class="s0"># &lt;ctype 'enum'&gt; that we may have to pass to _cffi_setup().</span>
        <span class="s0">#</span>
        <span class="s0"># The following two 'chained_list_constants' items contains</span>
        <span class="s0"># the head of these two chained lists, as a string that gives the</span>
        <span class="s0"># call to do, if any.</span>
        <span class="s1">self._chained_list_constants = [</span><span class="s3">'((void)lib,0)'</span><span class="s2">, </span><span class="s3">'((void)lib,0)'</span><span class="s1">]</span>
        <span class="s0">#</span>
        <span class="s1">prnt = self._prnt</span>
        <span class="s0"># first paste some standard set of lines that are mostly '#define'</span>
        <span class="s1">prnt(cffimod_header)</span>
        <span class="s1">prnt()</span>
        <span class="s0"># then paste the C source given by the user, verbatim.</span>
        <span class="s1">prnt(self.verifier.preamble)</span>
        <span class="s1">prnt()</span>
        <span class="s0">#</span>
        <span class="s0"># call generate_cpy_xxx_decl(), for every xxx found from</span>
        <span class="s0"># ffi._parser._declarations.  This generates all the functions.</span>
        <span class="s1">self._generate(</span><span class="s3">&quot;decl&quot;</span><span class="s1">)</span>
        <span class="s0">#</span>
        <span class="s0"># implement the function _cffi_setup_custom() as calling the</span>
        <span class="s0"># head of the chained list.</span>
        <span class="s1">self._generate_setup_custom()</span>
        <span class="s1">prnt()</span>
        <span class="s0">#</span>
        <span class="s0"># produce the method table, including the entries for the</span>
        <span class="s0"># generated Python-&gt;C function wrappers, which are done</span>
        <span class="s0"># by generate_cpy_function_method().</span>
        <span class="s1">prnt(</span><span class="s3">'static PyMethodDef _cffi_methods[] = {'</span><span class="s1">)</span>
        <span class="s1">self._generate(</span><span class="s3">&quot;method&quot;</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  {&quot;_cffi_setup&quot;, _cffi_setup, METH_VARARGS, NULL},'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  {NULL, NULL, 0, NULL}    /* Sentinel */'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'};'</span><span class="s1">)</span>
        <span class="s1">prnt()</span>
        <span class="s0">#</span>
        <span class="s0"># standard init.</span>
        <span class="s1">modname = self.verifier.get_module_name()</span>
        <span class="s1">constants = self._chained_list_constants[</span><span class="s2">False</span><span class="s1">]</span>
        <span class="s1">prnt(</span><span class="s3">'#if PY_MAJOR_VERSION &gt;= 3'</span><span class="s1">)</span>
        <span class="s1">prnt()</span>
        <span class="s1">prnt(</span><span class="s3">'static struct PyModuleDef _cffi_module_def = {'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  PyModuleDef_HEAD_INIT,'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  &quot;%s&quot;,' </span><span class="s1">% modname)</span>
        <span class="s1">prnt(</span><span class="s3">'  NULL,'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  -1,'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  _cffi_methods,'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  NULL, NULL, NULL, NULL'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'};'</span><span class="s1">)</span>
        <span class="s1">prnt()</span>
        <span class="s1">prnt(</span><span class="s3">'PyMODINIT_FUNC'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'PyInit_%s(void)' </span><span class="s1">% modname)</span>
        <span class="s1">prnt(</span><span class="s3">'{'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  PyObject *lib;'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  lib = PyModule_Create(&amp;_cffi_module_def);'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  if (lib == NULL)'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'    return NULL;'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  if (%s &lt; 0 || _cffi_init() &lt; 0) {' </span><span class="s1">% (constants</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">prnt(</span><span class="s3">'    Py_DECREF(lib);'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'    return NULL;'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  }'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  return lib;'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'}'</span><span class="s1">)</span>
        <span class="s1">prnt()</span>
        <span class="s1">prnt(</span><span class="s3">'#else'</span><span class="s1">)</span>
        <span class="s1">prnt()</span>
        <span class="s1">prnt(</span><span class="s3">'PyMODINIT_FUNC'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'init%s(void)' </span><span class="s1">% modname)</span>
        <span class="s1">prnt(</span><span class="s3">'{'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  PyObject *lib;'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  lib = Py_InitModule(&quot;%s&quot;, _cffi_methods);' </span><span class="s1">% modname)</span>
        <span class="s1">prnt(</span><span class="s3">'  if (lib == NULL)'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'    return;'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  if (%s &lt; 0 || _cffi_init() &lt; 0)' </span><span class="s1">% (constants</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">prnt(</span><span class="s3">'    return;'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  return;'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'}'</span><span class="s1">)</span>
        <span class="s1">prnt()</span>
        <span class="s1">prnt(</span><span class="s3">'#endif'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">load_library(self</span><span class="s2">, </span><span class="s1">flags=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># XXX review all usages of 'self' here!</span>
        <span class="s0"># import it as a new extension module</span>
        <span class="s1">imp.acquire_lock()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">hasattr(sys</span><span class="s2">, </span><span class="s3">&quot;getdlopenflags&quot;</span><span class="s1">):</span>
                <span class="s1">previous_flags = sys.getdlopenflags()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">hasattr(sys</span><span class="s2">, </span><span class="s3">&quot;setdlopenflags&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">flags </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">sys.setdlopenflags(flags)</span>
                <span class="s1">module = imp.load_dynamic(self.verifier.get_module_name()</span><span class="s2">,</span>
                                          <span class="s1">self.verifier.modulefilename)</span>
            <span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">error = </span><span class="s3">&quot;importing %r: %s&quot; </span><span class="s1">% (self.verifier.modulefilename</span><span class="s2">, </span><span class="s1">e)</span>
                <span class="s2">raise </span><span class="s1">VerificationError(error)</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">hasattr(sys</span><span class="s2">, </span><span class="s3">&quot;setdlopenflags&quot;</span><span class="s1">):</span>
                    <span class="s1">sys.setdlopenflags(previous_flags)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">imp.release_lock()</span>
        <span class="s0">#</span>
        <span class="s0"># call loading_cpy_struct() to get the struct layout inferred by</span>
        <span class="s0"># the C compiler</span>
        <span class="s1">self._load(module</span><span class="s2">, </span><span class="s3">'loading'</span><span class="s1">)</span>
        <span class="s0">#</span>
        <span class="s0"># the C code will need the &lt;ctype&gt; objects.  Collect them in</span>
        <span class="s0"># order in a list.</span>
        <span class="s1">revmapping = dict([(value</span><span class="s2">, </span><span class="s1">key)</span>
                           <span class="s2">for </span><span class="s1">(key</span><span class="s2">, </span><span class="s1">value) </span><span class="s2">in </span><span class="s1">self._typesdict.items()])</span>
        <span class="s1">lst = [revmapping[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(revmapping))]</span>
        <span class="s1">lst = list(map(self.ffi._get_cached_btype</span><span class="s2">, </span><span class="s1">lst))</span>
        <span class="s0">#</span>
        <span class="s0"># build the FFILibrary class and instance and call _cffi_setup().</span>
        <span class="s0"># this will set up some fields like '_cffi_types', and only then</span>
        <span class="s0"># it will invoke the chained list of functions that will really</span>
        <span class="s0"># build (notably) the constant objects, as &lt;cdata&gt; if they are</span>
        <span class="s0"># pointers, and store them as attributes on the 'library' object.</span>
        <span class="s2">class </span><span class="s1">FFILibrary(object):</span>
            <span class="s1">_cffi_python_module = module</span>
            <span class="s1">_cffi_ffi = self.ffi</span>
            <span class="s1">_cffi_dir = []</span>
            <span class="s2">def </span><span class="s1">__dir__(self):</span>
                <span class="s2">return </span><span class="s1">FFILibrary._cffi_dir + list(self.__dict__)</span>
        <span class="s1">library = FFILibrary()</span>
        <span class="s2">if </span><span class="s1">module._cffi_setup(lst</span><span class="s2">, </span><span class="s1">VerificationError</span><span class="s2">, </span><span class="s1">library):</span>
            <span class="s2">import </span><span class="s1">warnings</span>
            <span class="s1">warnings.warn(</span><span class="s3">&quot;reimporting %r might overwrite older definitions&quot;</span>
                          <span class="s1">% (self.verifier.get_module_name()))</span>
        <span class="s0">#</span>
        <span class="s0"># finally, call the loaded_cpy_xxx() functions.  This will perform</span>
        <span class="s0"># the final adjustments, like copying the Python-&gt;C wrapper</span>
        <span class="s0"># functions from the module to the 'library' object, and setting</span>
        <span class="s0"># up the FFILibrary class with properties for the global C variables.</span>
        <span class="s1">self._load(module</span><span class="s2">, </span><span class="s3">'loaded'</span><span class="s2">, </span><span class="s1">library=library)</span>
        <span class="s1">module._cffi_original_ffi = self.ffi</span>
        <span class="s1">module._cffi_types_of_builtin_funcs = self._types_of_builtin_functions</span>
        <span class="s2">return </span><span class="s1">library</span>

    <span class="s2">def </span><span class="s1">_get_declarations(self):</span>
        <span class="s1">lst = [(key</span><span class="s2">, </span><span class="s1">tp) </span><span class="s2">for </span><span class="s1">(key</span><span class="s2">, </span><span class="s1">(tp</span><span class="s2">, </span><span class="s1">qual)) </span><span class="s2">in</span>
                                <span class="s1">self.ffi._parser._declarations.items()]</span>
        <span class="s1">lst.sort()</span>
        <span class="s2">return </span><span class="s1">lst</span>

    <span class="s2">def </span><span class="s1">_generate(self</span><span class="s2">, </span><span class="s1">step_name):</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self._get_declarations():</span>
            <span class="s1">kind</span><span class="s2">, </span><span class="s1">realname = name.split(</span><span class="s3">' '</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">method = getattr(self</span><span class="s2">, </span><span class="s3">'_generate_cpy_%s_%s' </span><span class="s1">% (kind</span><span class="s2">,</span>
                                                                <span class="s1">step_name))</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s2">raise </span><span class="s1">VerificationError(</span>
                    <span class="s3">&quot;not implemented in verify(): %r&quot; </span><span class="s1">% name)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">method(tp</span><span class="s2">, </span><span class="s1">realname)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">model.attach_exception_info(e</span><span class="s2">, </span><span class="s1">name)</span>
                <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">_load(self</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">step_name</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self._get_declarations():</span>
            <span class="s1">kind</span><span class="s2">, </span><span class="s1">realname = name.split(</span><span class="s3">' '</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">method = getattr(self</span><span class="s2">, </span><span class="s3">'_%s_cpy_%s' </span><span class="s1">% (step_name</span><span class="s2">, </span><span class="s1">kind))</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">method(tp</span><span class="s2">, </span><span class="s1">realname</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">**kwds)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">model.attach_exception_info(e</span><span class="s2">, </span><span class="s1">name)</span>
                <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">_generate_nothing(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_loaded_noop(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s2">pass</span>

    <span class="s0"># ----------</span>

    <span class="s2">def </span><span class="s1">_convert_funcarg_to_c(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">fromvar</span><span class="s2">, </span><span class="s1">tovar</span><span class="s2">, </span><span class="s1">errcode):</span>
        <span class="s1">extraarg = </span><span class="s3">''</span>
        <span class="s2">if </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.PrimitiveType):</span>
            <span class="s2">if </span><span class="s1">tp.is_integer_type() </span><span class="s2">and </span><span class="s1">tp.name != </span><span class="s3">'_Bool'</span><span class="s1">:</span>
                <span class="s1">converter = </span><span class="s3">'_cffi_to_c_int'</span>
                <span class="s1">extraarg = </span><span class="s3">', %s' </span><span class="s1">% tp.name</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">converter = </span><span class="s3">'(%s)_cffi_to_c_%s' </span><span class="s1">% (tp.get_c_name(</span><span class="s3">''</span><span class="s1">)</span><span class="s2">,</span>
                                                   <span class="s1">tp.name.replace(</span><span class="s3">' '</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">))</span>
            <span class="s1">errvalue = </span><span class="s3">'-1'</span>
        <span class="s0">#</span>
        <span class="s2">elif </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.PointerType):</span>
            <span class="s1">self._convert_funcarg_to_c_ptr_or_array(tp</span><span class="s2">, </span><span class="s1">fromvar</span><span class="s2">,</span>
                                                    <span class="s1">tovar</span><span class="s2">, </span><span class="s1">errcode)</span>
            <span class="s2">return</span>
        <span class="s0">#</span>
        <span class="s2">elif </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">(model.StructOrUnion</span><span class="s2">, </span><span class="s1">model.EnumType)):</span>
            <span class="s0"># a struct (not a struct pointer) as a function argument</span>
            <span class="s1">self._prnt(</span><span class="s3">'  if (_cffi_to_c((char *)&amp;%s, _cffi_type(%d), %s) &lt; 0)'</span>
                      <span class="s1">% (tovar</span><span class="s2">, </span><span class="s1">self._gettypenum(tp)</span><span class="s2">, </span><span class="s1">fromvar))</span>
            <span class="s1">self._prnt(</span><span class="s3">'    %s;' </span><span class="s1">% errcode)</span>
            <span class="s2">return</span>
        <span class="s0">#</span>
        <span class="s2">elif </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.FunctionPtrType):</span>
            <span class="s1">converter = </span><span class="s3">'(%s)_cffi_to_c_pointer' </span><span class="s1">% tp.get_c_name(</span><span class="s3">''</span><span class="s1">)</span>
            <span class="s1">extraarg = </span><span class="s3">', _cffi_type(%d)' </span><span class="s1">% self._gettypenum(tp)</span>
            <span class="s1">errvalue = </span><span class="s3">'NULL'</span>
        <span class="s0">#</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(tp)</span>
        <span class="s0">#</span>
        <span class="s1">self._prnt(</span><span class="s3">'  %s = %s(%s%s);' </span><span class="s1">% (tovar</span><span class="s2">, </span><span class="s1">converter</span><span class="s2">, </span><span class="s1">fromvar</span><span class="s2">, </span><span class="s1">extraarg))</span>
        <span class="s1">self._prnt(</span><span class="s3">'  if (%s == (%s)%s &amp;&amp; PyErr_Occurred())' </span><span class="s1">% (</span>
            <span class="s1">tovar</span><span class="s2">, </span><span class="s1">tp.get_c_name(</span><span class="s3">''</span><span class="s1">)</span><span class="s2">, </span><span class="s1">errvalue))</span>
        <span class="s1">self._prnt(</span><span class="s3">'    %s;' </span><span class="s1">% errcode)</span>

    <span class="s2">def </span><span class="s1">_extra_local_variables(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">localvars</span><span class="s2">, </span><span class="s1">freelines):</span>
        <span class="s2">if </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.PointerType):</span>
            <span class="s1">localvars.add(</span><span class="s3">'Py_ssize_t datasize'</span><span class="s1">)</span>
            <span class="s1">localvars.add(</span><span class="s3">'struct _cffi_freeme_s *large_args_free = NULL'</span><span class="s1">)</span>
            <span class="s1">freelines.add(</span><span class="s3">'if (large_args_free != NULL)'</span>
                          <span class="s3">' _cffi_free_array_arguments(large_args_free);'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_convert_funcarg_to_c_ptr_or_array(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">fromvar</span><span class="s2">, </span><span class="s1">tovar</span><span class="s2">, </span><span class="s1">errcode):</span>
        <span class="s1">self._prnt(</span><span class="s3">'  datasize = _cffi_prepare_pointer_call_argument('</span><span class="s1">)</span>
        <span class="s1">self._prnt(</span><span class="s3">'      _cffi_type(%d), %s, (char **)&amp;%s);' </span><span class="s1">% (</span>
            <span class="s1">self._gettypenum(tp)</span><span class="s2">, </span><span class="s1">fromvar</span><span class="s2">, </span><span class="s1">tovar))</span>
        <span class="s1">self._prnt(</span><span class="s3">'  if (datasize != 0) {'</span><span class="s1">)</span>
        <span class="s1">self._prnt(</span><span class="s3">'    %s = ((size_t)datasize) &lt;= 640 ? '</span>
                   <span class="s3">'alloca((size_t)datasize) : NULL;' </span><span class="s1">% (tovar</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">self._prnt(</span><span class="s3">'    if (_cffi_convert_array_argument(_cffi_type(%d), %s, '</span>
                   <span class="s3">'(char **)&amp;%s,' </span><span class="s1">% (self._gettypenum(tp)</span><span class="s2">, </span><span class="s1">fromvar</span><span class="s2">, </span><span class="s1">tovar))</span>
        <span class="s1">self._prnt(</span><span class="s3">'            datasize, &amp;large_args_free) &lt; 0)'</span><span class="s1">)</span>
        <span class="s1">self._prnt(</span><span class="s3">'      %s;' </span><span class="s1">% errcode)</span>
        <span class="s1">self._prnt(</span><span class="s3">'  }'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_convert_expr_from_c(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">var</span><span class="s2">, </span><span class="s1">context):</span>
        <span class="s2">if </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.PrimitiveType):</span>
            <span class="s2">if </span><span class="s1">tp.is_integer_type() </span><span class="s2">and </span><span class="s1">tp.name != </span><span class="s3">'_Bool'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s3">'_cffi_from_c_int(%s, %s)' </span><span class="s1">% (var</span><span class="s2">, </span><span class="s1">tp.name)</span>
            <span class="s2">elif </span><span class="s1">tp.name != </span><span class="s3">'long double'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s3">'_cffi_from_c_%s(%s)' </span><span class="s1">% (tp.name.replace(</span><span class="s3">' '</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">var)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s3">'_cffi_from_c_deref((char *)&amp;%s, _cffi_type(%d))' </span><span class="s1">% (</span>
                    <span class="s1">var</span><span class="s2">, </span><span class="s1">self._gettypenum(tp))</span>
        <span class="s2">elif </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">(model.PointerType</span><span class="s2">, </span><span class="s1">model.FunctionPtrType)):</span>
            <span class="s2">return </span><span class="s3">'_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' </span><span class="s1">% (</span>
                <span class="s1">var</span><span class="s2">, </span><span class="s1">self._gettypenum(tp))</span>
        <span class="s2">elif </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.ArrayType):</span>
            <span class="s2">return </span><span class="s3">'_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' </span><span class="s1">% (</span>
                <span class="s1">var</span><span class="s2">, </span><span class="s1">self._gettypenum(model.PointerType(tp.item)))</span>
        <span class="s2">elif </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.StructOrUnion):</span>
            <span class="s2">if </span><span class="s1">tp.fldnames </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;'%s' is used as %s, but is opaque&quot; </span><span class="s1">% (</span>
                    <span class="s1">tp._get_c_name()</span><span class="s2">, </span><span class="s1">context))</span>
            <span class="s2">return </span><span class="s3">'_cffi_from_c_struct((char *)&amp;%s, _cffi_type(%d))' </span><span class="s1">% (</span>
                <span class="s1">var</span><span class="s2">, </span><span class="s1">self._gettypenum(tp))</span>
        <span class="s2">elif </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.EnumType):</span>
            <span class="s2">return </span><span class="s3">'_cffi_from_c_deref((char *)&amp;%s, _cffi_type(%d))' </span><span class="s1">% (</span>
                <span class="s1">var</span><span class="s2">, </span><span class="s1">self._gettypenum(tp))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(tp)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># typedefs: generates no code so far</span>

    <span class="s1">_generate_cpy_typedef_collecttype = _generate_nothing</span>
    <span class="s1">_generate_cpy_typedef_decl   = _generate_nothing</span>
    <span class="s1">_generate_cpy_typedef_method = _generate_nothing</span>
    <span class="s1">_loading_cpy_typedef         = _loaded_noop</span>
    <span class="s1">_loaded_cpy_typedef          = _loaded_noop</span>

    <span class="s0"># ----------</span>
    <span class="s0"># function declarations</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_function_collecttype(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">assert </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.FunctionPtrType)</span>
        <span class="s2">if </span><span class="s1">tp.ellipsis:</span>
            <span class="s1">self._do_collect_type(tp)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># don't call _do_collect_type(tp) in this common case,</span>
            <span class="s0"># otherwise test_autofilled_struct_as_argument fails</span>
            <span class="s2">for </span><span class="s1">type </span><span class="s2">in </span><span class="s1">tp.args:</span>
                <span class="s1">self._do_collect_type(type)</span>
            <span class="s1">self._do_collect_type(tp.result)</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_function_decl(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">assert </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.FunctionPtrType)</span>
        <span class="s2">if </span><span class="s1">tp.ellipsis:</span>
            <span class="s0"># cannot support vararg functions better than this: check for its</span>
            <span class="s0"># exact type (including the fixed arguments), and build it as a</span>
            <span class="s0"># constant function pointer (no CPython wrapper)</span>
            <span class="s1">self._generate_cpy_const(</span><span class="s2">False, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">tp)</span>
            <span class="s2">return</span>
        <span class="s1">prnt = self._prnt</span>
        <span class="s1">numargs = len(tp.args)</span>
        <span class="s2">if </span><span class="s1">numargs == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">argname = </span><span class="s3">'noarg'</span>
        <span class="s2">elif </span><span class="s1">numargs == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">argname = </span><span class="s3">'arg0'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">argname = </span><span class="s3">'args'</span>
        <span class="s1">prnt(</span><span class="s3">'static PyObject *'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'_cffi_f_%s(PyObject *self, PyObject *%s)' </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">argname))</span>
        <span class="s1">prnt(</span><span class="s3">'{'</span><span class="s1">)</span>
        <span class="s0">#</span>
        <span class="s1">context = </span><span class="s3">'argument of %s' </span><span class="s1">% name</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">type </span><span class="s2">in </span><span class="s1">enumerate(tp.args):</span>
            <span class="s1">prnt(</span><span class="s3">'  %s;' </span><span class="s1">% type.get_c_name(</span><span class="s3">' x%d' </span><span class="s1">% i</span><span class="s2">, </span><span class="s1">context))</span>
        <span class="s0">#</span>
        <span class="s1">localvars = set()</span>
        <span class="s1">freelines = set()</span>
        <span class="s2">for </span><span class="s1">type </span><span class="s2">in </span><span class="s1">tp.args:</span>
            <span class="s1">self._extra_local_variables(type</span><span class="s2">, </span><span class="s1">localvars</span><span class="s2">, </span><span class="s1">freelines)</span>
        <span class="s2">for </span><span class="s1">decl </span><span class="s2">in </span><span class="s1">sorted(localvars):</span>
            <span class="s1">prnt(</span><span class="s3">'  %s;' </span><span class="s1">% (decl</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s0">#</span>
        <span class="s2">if not </span><span class="s1">isinstance(tp.result</span><span class="s2">, </span><span class="s1">model.VoidType):</span>
            <span class="s1">result_code = </span><span class="s3">'result = '</span>
            <span class="s1">context = </span><span class="s3">'result of %s' </span><span class="s1">% name</span>
            <span class="s1">prnt(</span><span class="s3">'  %s;' </span><span class="s1">% tp.result.get_c_name(</span><span class="s3">' result'</span><span class="s2">, </span><span class="s1">context))</span>
            <span class="s1">prnt(</span><span class="s3">'  PyObject *pyresult;'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result_code = </span><span class="s3">''</span>
        <span class="s0">#</span>
        <span class="s2">if </span><span class="s1">len(tp.args) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">rng = range(len(tp.args))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">rng:</span>
                <span class="s1">prnt(</span><span class="s3">'  PyObject *arg%d;' </span><span class="s1">% i)</span>
            <span class="s1">prnt()</span>
            <span class="s1">prnt(</span><span class="s3">'  if (!PyArg_ParseTuple(args, &quot;%s:%s&quot;, %s))' </span><span class="s1">% (</span>
                <span class="s3">'O' </span><span class="s1">* numargs</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s3">', '</span><span class="s1">.join([</span><span class="s3">'&amp;arg%d' </span><span class="s1">% i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">rng])))</span>
            <span class="s1">prnt(</span><span class="s3">'    return NULL;'</span><span class="s1">)</span>
        <span class="s1">prnt()</span>
        <span class="s0">#</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">type </span><span class="s2">in </span><span class="s1">enumerate(tp.args):</span>
            <span class="s1">self._convert_funcarg_to_c(type</span><span class="s2">, </span><span class="s3">'arg%d' </span><span class="s1">% i</span><span class="s2">, </span><span class="s3">'x%d' </span><span class="s1">% i</span><span class="s2">,</span>
                                       <span class="s3">'return NULL'</span><span class="s1">)</span>
            <span class="s1">prnt()</span>
        <span class="s0">#</span>
        <span class="s1">prnt(</span><span class="s3">'  Py_BEGIN_ALLOW_THREADS'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  _cffi_restore_errno();'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  { %s%s(%s); }' </span><span class="s1">% (</span>
            <span class="s1">result_code</span><span class="s2">, </span><span class="s1">name</span><span class="s2">,</span>
            <span class="s3">', '</span><span class="s1">.join([</span><span class="s3">'x%d' </span><span class="s1">% i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(tp.args))])))</span>
        <span class="s1">prnt(</span><span class="s3">'  _cffi_save_errno();'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  Py_END_ALLOW_THREADS'</span><span class="s1">)</span>
        <span class="s1">prnt()</span>
        <span class="s0">#</span>
        <span class="s1">prnt(</span><span class="s3">'  (void)self; /* unused */'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">numargs == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">prnt(</span><span class="s3">'  (void)noarg; /* unused */'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">result_code:</span>
            <span class="s1">prnt(</span><span class="s3">'  pyresult = %s;' </span><span class="s1">%</span>
                 <span class="s1">self._convert_expr_from_c(tp.result</span><span class="s2">, </span><span class="s3">'result'</span><span class="s2">, </span><span class="s3">'result type'</span><span class="s1">))</span>
            <span class="s2">for </span><span class="s1">freeline </span><span class="s2">in </span><span class="s1">freelines:</span>
                <span class="s1">prnt(</span><span class="s3">'  ' </span><span class="s1">+ freeline)</span>
            <span class="s1">prnt(</span><span class="s3">'  return pyresult;'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">freeline </span><span class="s2">in </span><span class="s1">freelines:</span>
                <span class="s1">prnt(</span><span class="s3">'  ' </span><span class="s1">+ freeline)</span>
            <span class="s1">prnt(</span><span class="s3">'  Py_INCREF(Py_None);'</span><span class="s1">)</span>
            <span class="s1">prnt(</span><span class="s3">'  return Py_None;'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'}'</span><span class="s1">)</span>
        <span class="s1">prnt()</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_function_method(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">tp.ellipsis:</span>
            <span class="s2">return</span>
        <span class="s1">numargs = len(tp.args)</span>
        <span class="s2">if </span><span class="s1">numargs == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">meth = </span><span class="s3">'METH_NOARGS'</span>
        <span class="s2">elif </span><span class="s1">numargs == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">meth = </span><span class="s3">'METH_O'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">meth = </span><span class="s3">'METH_VARARGS'</span>
        <span class="s1">self._prnt(</span><span class="s3">'  {&quot;%s&quot;, _cffi_f_%s, %s, NULL},' </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">meth))</span>

    <span class="s1">_loading_cpy_function = _loaded_noop</span>

    <span class="s2">def </span><span class="s1">_loaded_cpy_function(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">library):</span>
        <span class="s2">if </span><span class="s1">tp.ellipsis:</span>
            <span class="s2">return</span>
        <span class="s1">func = getattr(module</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s1">setattr(library</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">func)</span>
        <span class="s1">self._types_of_builtin_functions[func] = tp</span>

    <span class="s0"># ----------</span>
    <span class="s0"># named structs</span>

    <span class="s1">_generate_cpy_struct_collecttype = _generate_nothing</span>
    <span class="s2">def </span><span class="s1">_generate_cpy_struct_decl(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">assert </span><span class="s1">name == tp.name</span>
        <span class="s1">self._generate_struct_or_union_decl(tp</span><span class="s2">, </span><span class="s3">'struct'</span><span class="s2">, </span><span class="s1">name)</span>
    <span class="s2">def </span><span class="s1">_generate_cpy_struct_method(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">self._generate_struct_or_union_method(tp</span><span class="s2">, </span><span class="s3">'struct'</span><span class="s2">, </span><span class="s1">name)</span>
    <span class="s2">def </span><span class="s1">_loading_cpy_struct(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module):</span>
        <span class="s1">self._loading_struct_or_union(tp</span><span class="s2">, </span><span class="s3">'struct'</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module)</span>
    <span class="s2">def </span><span class="s1">_loaded_cpy_struct(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s1">self._loaded_struct_or_union(tp)</span>

    <span class="s1">_generate_cpy_union_collecttype = _generate_nothing</span>
    <span class="s2">def </span><span class="s1">_generate_cpy_union_decl(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">assert </span><span class="s1">name == tp.name</span>
        <span class="s1">self._generate_struct_or_union_decl(tp</span><span class="s2">, </span><span class="s3">'union'</span><span class="s2">, </span><span class="s1">name)</span>
    <span class="s2">def </span><span class="s1">_generate_cpy_union_method(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">self._generate_struct_or_union_method(tp</span><span class="s2">, </span><span class="s3">'union'</span><span class="s2">, </span><span class="s1">name)</span>
    <span class="s2">def </span><span class="s1">_loading_cpy_union(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module):</span>
        <span class="s1">self._loading_struct_or_union(tp</span><span class="s2">, </span><span class="s3">'union'</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module)</span>
    <span class="s2">def </span><span class="s1">_loaded_cpy_union(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s1">self._loaded_struct_or_union(tp)</span>

    <span class="s2">def </span><span class="s1">_generate_struct_or_union_decl(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">tp.fldnames </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return     </span><span class="s0"># nothing to do with opaque structs</span>
        <span class="s1">checkfuncname = </span><span class="s3">'_cffi_check_%s_%s' </span><span class="s1">% (prefix</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s1">layoutfuncname = </span><span class="s3">'_cffi_layout_%s_%s' </span><span class="s1">% (prefix</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s1">cname = (</span><span class="s3">'%s %s' </span><span class="s1">% (prefix</span><span class="s2">, </span><span class="s1">name)).strip()</span>
        <span class="s0">#</span>
        <span class="s1">prnt = self._prnt</span>
        <span class="s1">prnt(</span><span class="s3">'static void %s(%s *p)' </span><span class="s1">% (checkfuncname</span><span class="s2">, </span><span class="s1">cname))</span>
        <span class="s1">prnt(</span><span class="s3">'{'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  /* only to generate compile-time warnings or errors */'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  (void)p;'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">ftype</span><span class="s2">, </span><span class="s1">fbitsize</span><span class="s2">, </span><span class="s1">fqual </span><span class="s2">in </span><span class="s1">tp.enumfields():</span>
            <span class="s2">if </span><span class="s1">(isinstance(ftype</span><span class="s2">, </span><span class="s1">model.PrimitiveType)</span>
                <span class="s2">and </span><span class="s1">ftype.is_integer_type()) </span><span class="s2">or </span><span class="s1">fbitsize &gt;= </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0"># accept all integers, but complain on float or double</span>
                <span class="s1">prnt(</span><span class="s3">'  (void)((p-&gt;%s) &lt;&lt; 1);' </span><span class="s1">% fname)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># only accept exactly the type declared.</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">prnt(</span><span class="s3">'  { %s = &amp;p-&gt;%s; (void)tmp; }' </span><span class="s1">% (</span>
                        <span class="s1">ftype.get_c_name(</span><span class="s3">'*tmp'</span><span class="s2">, </span><span class="s3">'field %r'</span><span class="s1">%fname</span><span class="s2">, </span><span class="s1">quals=fqual)</span><span class="s2">,</span>
                        <span class="s1">fname))</span>
                <span class="s2">except </span><span class="s1">VerificationError </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s1">prnt(</span><span class="s3">'  /* %s */' </span><span class="s1">% str(e))   </span><span class="s0"># cannot verify it, ignore</span>
        <span class="s1">prnt(</span><span class="s3">'}'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'static PyObject *'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'%s(PyObject *self, PyObject *noarg)' </span><span class="s1">% (layoutfuncname</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">prnt(</span><span class="s3">'{'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  struct _cffi_aligncheck { char x; %s y; };' </span><span class="s1">% cname)</span>
        <span class="s1">prnt(</span><span class="s3">'  static Py_ssize_t nums[] = {'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'    sizeof(%s),' </span><span class="s1">% cname)</span>
        <span class="s1">prnt(</span><span class="s3">'    offsetof(struct _cffi_aligncheck, y),'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">ftype</span><span class="s2">, </span><span class="s1">fbitsize</span><span class="s2">, </span><span class="s1">fqual </span><span class="s2">in </span><span class="s1">tp.enumfields():</span>
            <span class="s2">if </span><span class="s1">fbitsize &gt;= </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">continue      </span><span class="s0"># xxx ignore fbitsize for now</span>
            <span class="s1">prnt(</span><span class="s3">'    offsetof(%s, %s),' </span><span class="s1">% (cname</span><span class="s2">, </span><span class="s1">fname))</span>
            <span class="s2">if </span><span class="s1">isinstance(ftype</span><span class="s2">, </span><span class="s1">model.ArrayType) </span><span class="s2">and </span><span class="s1">ftype.length </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">prnt(</span><span class="s3">'    0,  /* %s */' </span><span class="s1">% ftype._get_c_name())</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">prnt(</span><span class="s3">'    sizeof(((%s *)0)-&gt;%s),' </span><span class="s1">% (cname</span><span class="s2">, </span><span class="s1">fname))</span>
        <span class="s1">prnt(</span><span class="s3">'    -1'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  };'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  (void)self; /* unused */'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  (void)noarg; /* unused */'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  return _cffi_get_struct_layout(nums);'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  /* the next line is not executed, but compiled */'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  %s(0);' </span><span class="s1">% (checkfuncname</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">prnt(</span><span class="s3">'}'</span><span class="s1">)</span>
        <span class="s1">prnt()</span>

    <span class="s2">def </span><span class="s1">_generate_struct_or_union_method(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">tp.fldnames </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return     </span><span class="s0"># nothing to do with opaque structs</span>
        <span class="s1">layoutfuncname = </span><span class="s3">'_cffi_layout_%s_%s' </span><span class="s1">% (prefix</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s1">self._prnt(</span><span class="s3">'  {&quot;%s&quot;, %s, METH_NOARGS, NULL},' </span><span class="s1">% (layoutfuncname</span><span class="s2">,</span>
                                                         <span class="s1">layoutfuncname))</span>

    <span class="s2">def </span><span class="s1">_loading_struct_or_union(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module):</span>
        <span class="s2">if </span><span class="s1">tp.fldnames </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return     </span><span class="s0"># nothing to do with opaque structs</span>
        <span class="s1">layoutfuncname = </span><span class="s3">'_cffi_layout_%s_%s' </span><span class="s1">% (prefix</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s0">#</span>
        <span class="s1">function = getattr(module</span><span class="s2">, </span><span class="s1">layoutfuncname)</span>
        <span class="s1">layout = function()</span>
        <span class="s2">if </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.StructOrUnion) </span><span class="s2">and </span><span class="s1">tp.partial:</span>
            <span class="s0"># use the function()'s sizes and offsets to guide the</span>
            <span class="s0"># layout of the struct</span>
            <span class="s1">totalsize = layout[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">totalalignment = layout[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">fieldofs = layout[</span><span class="s4">2</span><span class="s1">::</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">fieldsize = layout[</span><span class="s4">3</span><span class="s1">::</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">tp.force_flatten()</span>
            <span class="s2">assert </span><span class="s1">len(fieldofs) == len(fieldsize) == len(tp.fldnames)</span>
            <span class="s1">tp.fixedlayout = fieldofs</span><span class="s2">, </span><span class="s1">fieldsize</span><span class="s2">, </span><span class="s1">totalsize</span><span class="s2">, </span><span class="s1">totalalignment</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cname = (</span><span class="s3">'%s %s' </span><span class="s1">% (prefix</span><span class="s2">, </span><span class="s1">name)).strip()</span>
            <span class="s1">self._struct_pending_verification[tp] = layout</span><span class="s2">, </span><span class="s1">cname</span>

    <span class="s2">def </span><span class="s1">_loaded_struct_or_union(self</span><span class="s2">, </span><span class="s1">tp):</span>
        <span class="s2">if </span><span class="s1">tp.fldnames </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return     </span><span class="s0"># nothing to do with opaque structs</span>
        <span class="s1">self.ffi._get_cached_btype(tp)   </span><span class="s0"># force 'fixedlayout' to be considered</span>

        <span class="s2">if </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self._struct_pending_verification:</span>
            <span class="s0"># check that the layout sizes and offsets match the real ones</span>
            <span class="s2">def </span><span class="s1">check(realvalue</span><span class="s2">, </span><span class="s1">expectedvalue</span><span class="s2">, </span><span class="s1">msg):</span>
                <span class="s2">if </span><span class="s1">realvalue != expectedvalue:</span>
                    <span class="s2">raise </span><span class="s1">VerificationError(</span>
                        <span class="s3">&quot;%s (we have %d, but C compiler says %d)&quot;</span>
                        <span class="s1">% (msg</span><span class="s2">, </span><span class="s1">expectedvalue</span><span class="s2">, </span><span class="s1">realvalue))</span>
            <span class="s1">ffi = self.ffi</span>
            <span class="s1">BStruct = ffi._get_cached_btype(tp)</span>
            <span class="s1">layout</span><span class="s2">, </span><span class="s1">cname = self._struct_pending_verification.pop(tp)</span>
            <span class="s1">check(layout[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ffi.sizeof(BStruct)</span><span class="s2">, </span><span class="s3">&quot;wrong total size&quot;</span><span class="s1">)</span>
            <span class="s1">check(layout[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ffi.alignof(BStruct)</span><span class="s2">, </span><span class="s3">&quot;wrong total alignment&quot;</span><span class="s1">)</span>
            <span class="s1">i = </span><span class="s4">2</span>
            <span class="s2">for </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">ftype</span><span class="s2">, </span><span class="s1">fbitsize</span><span class="s2">, </span><span class="s1">fqual </span><span class="s2">in </span><span class="s1">tp.enumfields():</span>
                <span class="s2">if </span><span class="s1">fbitsize &gt;= </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">continue        </span><span class="s0"># xxx ignore fbitsize for now</span>
                <span class="s1">check(layout[i]</span><span class="s2">, </span><span class="s1">ffi.offsetof(BStruct</span><span class="s2">, </span><span class="s1">fname)</span><span class="s2">,</span>
                      <span class="s3">&quot;wrong offset for field %r&quot; </span><span class="s1">% (fname</span><span class="s2">,</span><span class="s1">))</span>
                <span class="s2">if </span><span class="s1">layout[i+</span><span class="s4">1</span><span class="s1">] != </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">BField = ffi._get_cached_btype(ftype)</span>
                    <span class="s1">check(layout[i+</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ffi.sizeof(BField)</span><span class="s2">,</span>
                          <span class="s3">&quot;wrong size for field %r&quot; </span><span class="s1">% (fname</span><span class="s2">,</span><span class="s1">))</span>
                <span class="s1">i += </span><span class="s4">2</span>
            <span class="s2">assert </span><span class="s1">i == len(layout)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># 'anonymous' declarations.  These are produced for anonymous structs</span>
    <span class="s0"># or unions; the 'name' is obtained by a typedef.</span>

    <span class="s1">_generate_cpy_anonymous_collecttype = _generate_nothing</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_anonymous_decl(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.EnumType):</span>
            <span class="s1">self._generate_cpy_enum_decl(tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._generate_struct_or_union_decl(tp</span><span class="s2">, </span><span class="s3">''</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_anonymous_method(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if not </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.EnumType):</span>
            <span class="s1">self._generate_struct_or_union_method(tp</span><span class="s2">, </span><span class="s3">''</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s2">def </span><span class="s1">_loading_cpy_anonymous(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module):</span>
        <span class="s2">if </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.EnumType):</span>
            <span class="s1">self._loading_cpy_enum(tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._loading_struct_or_union(tp</span><span class="s2">, </span><span class="s3">''</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module)</span>

    <span class="s2">def </span><span class="s1">_loaded_cpy_anonymous(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s2">if </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.EnumType):</span>
            <span class="s1">self._loaded_cpy_enum(tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._loaded_struct_or_union(tp)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># constants, likely declared with '#define'</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_const(self</span><span class="s2">, </span><span class="s1">is_int</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">tp=</span><span class="s2">None, </span><span class="s1">category=</span><span class="s3">'const'</span><span class="s2">,</span>
                            <span class="s1">vartp=</span><span class="s2">None, </span><span class="s1">delayed=</span><span class="s2">True, </span><span class="s1">size_too=</span><span class="s2">False,</span>
                            <span class="s1">check_value=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">prnt = self._prnt</span>
        <span class="s1">funcname = </span><span class="s3">'_cffi_%s_%s' </span><span class="s1">% (category</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s1">prnt(</span><span class="s3">'static int %s(PyObject *lib)' </span><span class="s1">% funcname)</span>
        <span class="s1">prnt(</span><span class="s3">'{'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  PyObject *o;'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  int res;'</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">is_int:</span>
            <span class="s1">prnt(</span><span class="s3">'  %s;' </span><span class="s1">% (vartp </span><span class="s2">or </span><span class="s1">tp).get_c_name(</span><span class="s3">' i'</span><span class="s2">, </span><span class="s1">name))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">category == </span><span class="s3">'const'</span>
        <span class="s0">#</span>
        <span class="s2">if </span><span class="s1">check_value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._check_int_constant_value(name</span><span class="s2">, </span><span class="s1">check_value)</span>
        <span class="s0">#</span>
        <span class="s2">if not </span><span class="s1">is_int:</span>
            <span class="s2">if </span><span class="s1">category == </span><span class="s3">'var'</span><span class="s1">:</span>
                <span class="s1">realexpr = </span><span class="s3">'&amp;' </span><span class="s1">+ name</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">realexpr = name</span>
            <span class="s1">prnt(</span><span class="s3">'  i = (%s);' </span><span class="s1">% (realexpr</span><span class="s2">,</span><span class="s1">))</span>
            <span class="s1">prnt(</span><span class="s3">'  o = %s;' </span><span class="s1">% (self._convert_expr_from_c(tp</span><span class="s2">, </span><span class="s3">'i'</span><span class="s2">,</span>
                                                          <span class="s3">'variable type'</span><span class="s1">)</span><span class="s2">,</span><span class="s1">))</span>
            <span class="s2">assert </span><span class="s1">delayed</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">prnt(</span><span class="s3">'  o = _cffi_from_c_int_const(%s);' </span><span class="s1">% name)</span>
        <span class="s1">prnt(</span><span class="s3">'  if (o == NULL)'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'    return -1;'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">size_too:</span>
            <span class="s1">prnt(</span><span class="s3">'  {'</span><span class="s1">)</span>
            <span class="s1">prnt(</span><span class="s3">'    PyObject *o1 = o;'</span><span class="s1">)</span>
            <span class="s1">prnt(</span><span class="s3">'    o = Py_BuildValue(&quot;On&quot;, o1, (Py_ssize_t)sizeof(%s));'</span>
                 <span class="s1">% (name</span><span class="s2">,</span><span class="s1">))</span>
            <span class="s1">prnt(</span><span class="s3">'    Py_DECREF(o1);'</span><span class="s1">)</span>
            <span class="s1">prnt(</span><span class="s3">'    if (o == NULL)'</span><span class="s1">)</span>
            <span class="s1">prnt(</span><span class="s3">'      return -1;'</span><span class="s1">)</span>
            <span class="s1">prnt(</span><span class="s3">'  }'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  res = PyObject_SetAttrString(lib, &quot;%s&quot;, o);' </span><span class="s1">% name)</span>
        <span class="s1">prnt(</span><span class="s3">'  Py_DECREF(o);'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  if (res &lt; 0)'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'    return -1;'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  return %s;' </span><span class="s1">% self._chained_list_constants[delayed])</span>
        <span class="s1">self._chained_list_constants[delayed] = funcname + </span><span class="s3">'(lib)'</span>
        <span class="s1">prnt(</span><span class="s3">'}'</span><span class="s1">)</span>
        <span class="s1">prnt()</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_constant_collecttype(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">is_int = isinstance(tp</span><span class="s2">, </span><span class="s1">model.PrimitiveType) </span><span class="s2">and </span><span class="s1">tp.is_integer_type()</span>
        <span class="s2">if not </span><span class="s1">is_int:</span>
            <span class="s1">self._do_collect_type(tp)</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_constant_decl(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">is_int = isinstance(tp</span><span class="s2">, </span><span class="s1">model.PrimitiveType) </span><span class="s2">and </span><span class="s1">tp.is_integer_type()</span>
        <span class="s1">self._generate_cpy_const(is_int</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">tp)</span>

    <span class="s1">_generate_cpy_constant_method = _generate_nothing</span>
    <span class="s1">_loading_cpy_constant = _loaded_noop</span>
    <span class="s1">_loaded_cpy_constant  = _loaded_noop</span>

    <span class="s0"># ----------</span>
    <span class="s0"># enums</span>

    <span class="s2">def </span><span class="s1">_check_int_constant_value(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">err_prefix=</span><span class="s3">''</span><span class="s1">):</span>
        <span class="s1">prnt = self._prnt</span>
        <span class="s2">if </span><span class="s1">value &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">prnt(</span><span class="s3">'  if ((%s) &gt; 0 || (long)(%s) != %dL) {' </span><span class="s1">% (</span>
                <span class="s1">name</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">prnt(</span><span class="s3">'  if ((%s) &lt;= 0 || (unsigned long)(%s) != %dUL) {' </span><span class="s1">% (</span>
                <span class="s1">name</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value))</span>
        <span class="s1">prnt(</span><span class="s3">'    char buf[64];'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'    if ((%s) &lt;= 0)' </span><span class="s1">% name)</span>
        <span class="s1">prnt(</span><span class="s3">'        snprintf(buf, 63, &quot;%%ld&quot;, (long)(%s));' </span><span class="s1">% name)</span>
        <span class="s1">prnt(</span><span class="s3">'    else'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'        snprintf(buf, 63, &quot;%%lu&quot;, (unsigned long)(%s));' </span><span class="s1">%</span>
             <span class="s1">name)</span>
        <span class="s1">prnt(</span><span class="s3">'    PyErr_Format(_cffi_VerificationError,'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'                 &quot;%s%s has the real value %s, not %s&quot;,'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'                 &quot;%s&quot;, &quot;%s&quot;, buf, &quot;%d&quot;);' </span><span class="s1">% (</span>
            <span class="s1">err_prefix</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value))</span>
        <span class="s1">prnt(</span><span class="s3">'    return -1;'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  }'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_enum_funcname(self</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0"># &quot;$enum_$1&quot; =&gt; &quot;___D_enum____D_1&quot;</span>
        <span class="s1">name = name.replace(</span><span class="s3">'$'</span><span class="s2">, </span><span class="s3">'___D_'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">'_cffi_e_%s_%s' </span><span class="s1">% (prefix</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_enum_decl(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s3">'enum'</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">tp.partial:</span>
            <span class="s2">for </span><span class="s1">enumerator </span><span class="s2">in </span><span class="s1">tp.enumerators:</span>
                <span class="s1">self._generate_cpy_const(</span><span class="s2">True, </span><span class="s1">enumerator</span><span class="s2">, </span><span class="s1">delayed=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">return</span>
        <span class="s0">#</span>
        <span class="s1">funcname = self._enum_funcname(prefix</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s1">prnt = self._prnt</span>
        <span class="s1">prnt(</span><span class="s3">'static int %s(PyObject *lib)' </span><span class="s1">% funcname)</span>
        <span class="s1">prnt(</span><span class="s3">'{'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">enumerator</span><span class="s2">, </span><span class="s1">enumvalue </span><span class="s2">in </span><span class="s1">zip(tp.enumerators</span><span class="s2">, </span><span class="s1">tp.enumvalues):</span>
            <span class="s1">self._check_int_constant_value(enumerator</span><span class="s2">, </span><span class="s1">enumvalue</span><span class="s2">,</span>
                                           <span class="s3">&quot;enum %s: &quot; </span><span class="s1">% name)</span>
        <span class="s1">prnt(</span><span class="s3">'  return %s;' </span><span class="s1">% self._chained_list_constants[</span><span class="s2">True</span><span class="s1">])</span>
        <span class="s1">self._chained_list_constants[</span><span class="s2">True</span><span class="s1">] = funcname + </span><span class="s3">'(lib)'</span>
        <span class="s1">prnt(</span><span class="s3">'}'</span><span class="s1">)</span>
        <span class="s1">prnt()</span>

    <span class="s1">_generate_cpy_enum_collecttype = _generate_nothing</span>
    <span class="s1">_generate_cpy_enum_method = _generate_nothing</span>

    <span class="s2">def </span><span class="s1">_loading_cpy_enum(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module):</span>
        <span class="s2">if </span><span class="s1">tp.partial:</span>
            <span class="s1">enumvalues = [getattr(module</span><span class="s2">, </span><span class="s1">enumerator)</span>
                          <span class="s2">for </span><span class="s1">enumerator </span><span class="s2">in </span><span class="s1">tp.enumerators]</span>
            <span class="s1">tp.enumvalues = tuple(enumvalues)</span>
            <span class="s1">tp.partial_resolved = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_loaded_cpy_enum(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">library):</span>
        <span class="s2">for </span><span class="s1">enumerator</span><span class="s2">, </span><span class="s1">enumvalue </span><span class="s2">in </span><span class="s1">zip(tp.enumerators</span><span class="s2">, </span><span class="s1">tp.enumvalues):</span>
            <span class="s1">setattr(library</span><span class="s2">, </span><span class="s1">enumerator</span><span class="s2">, </span><span class="s1">enumvalue)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># macros: for now only for integers</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_macro_decl(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">tp == </span><span class="s3">'...'</span><span class="s1">:</span>
            <span class="s1">check_value = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">check_value = tp     </span><span class="s0"># an integer</span>
        <span class="s1">self._generate_cpy_const(</span><span class="s2">True, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">check_value=check_value)</span>

    <span class="s1">_generate_cpy_macro_collecttype = _generate_nothing</span>
    <span class="s1">_generate_cpy_macro_method = _generate_nothing</span>
    <span class="s1">_loading_cpy_macro = _loaded_noop</span>
    <span class="s1">_loaded_cpy_macro  = _loaded_noop</span>

    <span class="s0"># ----------</span>
    <span class="s0"># global variables</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_variable_collecttype(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.ArrayType):</span>
            <span class="s1">tp_ptr = model.PointerType(tp.item)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tp_ptr = model.PointerType(tp)</span>
        <span class="s1">self._do_collect_type(tp_ptr)</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_variable_decl(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.ArrayType):</span>
            <span class="s1">tp_ptr = model.PointerType(tp.item)</span>
            <span class="s1">self._generate_cpy_const(</span><span class="s2">False, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">vartp=tp_ptr</span><span class="s2">,</span>
                                     <span class="s1">size_too = tp.length_is_unknown())</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tp_ptr = model.PointerType(tp)</span>
            <span class="s1">self._generate_cpy_const(</span><span class="s2">False, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">tp_ptr</span><span class="s2">, </span><span class="s1">category=</span><span class="s3">'var'</span><span class="s1">)</span>

    <span class="s1">_generate_cpy_variable_method = _generate_nothing</span>
    <span class="s1">_loading_cpy_variable = _loaded_noop</span>

    <span class="s2">def </span><span class="s1">_loaded_cpy_variable(self</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">library):</span>
        <span class="s1">value = getattr(library</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s2">if </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">model.ArrayType):   </span><span class="s0"># int a[5] is &quot;constant&quot; in the</span>
                                              <span class="s0"># sense that &quot;a=...&quot; is forbidden</span>
            <span class="s2">if </span><span class="s1">tp.length_is_unknown():</span>
                <span class="s2">assert </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">tuple)</span>
                <span class="s1">(value</span><span class="s2">, </span><span class="s1">size) = value</span>
                <span class="s1">BItemType = self.ffi._get_cached_btype(tp.item)</span>
                <span class="s1">length</span><span class="s2">, </span><span class="s1">rest = divmod(size</span><span class="s2">, </span><span class="s1">self.ffi.sizeof(BItemType))</span>
                <span class="s2">if </span><span class="s1">rest != </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">VerificationError(</span>
                        <span class="s3">&quot;bad size: %r does not seem to be an array of %s&quot; </span><span class="s1">%</span>
                        <span class="s1">(name</span><span class="s2">, </span><span class="s1">tp.item))</span>
                <span class="s1">tp = tp.resolve_length(length)</span>
            <span class="s0"># 'value' is a &lt;cdata 'type *'&gt; which we have to replace with</span>
            <span class="s0"># a &lt;cdata 'type[N]'&gt; if the N is actually known</span>
            <span class="s2">if </span><span class="s1">tp.length </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">BArray = self.ffi._get_cached_btype(tp)</span>
                <span class="s1">value = self.ffi.cast(BArray</span><span class="s2">, </span><span class="s1">value)</span>
                <span class="s1">setattr(library</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value)</span>
            <span class="s2">return</span>
        <span class="s0"># remove ptr=&lt;cdata 'int *'&gt; from the library instance, and replace</span>
        <span class="s0"># it by a property on the class, which reads/writes into ptr[0].</span>
        <span class="s1">ptr = value</span>
        <span class="s1">delattr(library</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s2">def </span><span class="s1">getter(library):</span>
            <span class="s2">return </span><span class="s1">ptr[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">def </span><span class="s1">setter(library</span><span class="s2">, </span><span class="s1">value):</span>
            <span class="s1">ptr[</span><span class="s4">0</span><span class="s1">] = value</span>
        <span class="s1">setattr(type(library)</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">property(getter</span><span class="s2">, </span><span class="s1">setter))</span>
        <span class="s1">type(library)._cffi_dir.append(name)</span>

    <span class="s0"># ----------</span>

    <span class="s2">def </span><span class="s1">_generate_setup_custom(self):</span>
        <span class="s1">prnt = self._prnt</span>
        <span class="s1">prnt(</span><span class="s3">'static int _cffi_setup_custom(PyObject *lib)'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'{'</span><span class="s1">)</span>
        <span class="s1">prnt(</span><span class="s3">'  return %s;' </span><span class="s1">% self._chained_list_constants[</span><span class="s2">True</span><span class="s1">])</span>
        <span class="s1">prnt(</span><span class="s3">'}'</span><span class="s1">)</span>

<span class="s1">cffimod_header = </span><span class="s3">r''' 
#include &lt;Python.h&gt; 
#include &lt;stddef.h&gt; 
 
/* this block of #ifs should be kept exactly identical between 
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py 
   and cffi/_cffi_include.h */ 
#if defined(_MSC_VER) 
# include &lt;malloc.h&gt;   /* for alloca() */ 
# if _MSC_VER &lt; 1600   /* MSVC &lt; 2010 */ 
   typedef __int8 int8_t; 
   typedef __int16 int16_t; 
   typedef __int32 int32_t; 
   typedef __int64 int64_t; 
   typedef unsigned __int8 uint8_t; 
   typedef unsigned __int16 uint16_t; 
   typedef unsigned __int32 uint32_t; 
   typedef unsigned __int64 uint64_t; 
   typedef __int8 int_least8_t; 
   typedef __int16 int_least16_t; 
   typedef __int32 int_least32_t; 
   typedef __int64 int_least64_t; 
   typedef unsigned __int8 uint_least8_t; 
   typedef unsigned __int16 uint_least16_t; 
   typedef unsigned __int32 uint_least32_t; 
   typedef unsigned __int64 uint_least64_t; 
   typedef __int8 int_fast8_t; 
   typedef __int16 int_fast16_t; 
   typedef __int32 int_fast32_t; 
   typedef __int64 int_fast64_t; 
   typedef unsigned __int8 uint_fast8_t; 
   typedef unsigned __int16 uint_fast16_t; 
   typedef unsigned __int32 uint_fast32_t; 
   typedef unsigned __int64 uint_fast64_t; 
   typedef __int64 intmax_t; 
   typedef unsigned __int64 uintmax_t; 
# else 
#  include &lt;stdint.h&gt; 
# endif 
# if _MSC_VER &lt; 1800   /* MSVC &lt; 2013 */ 
#  ifndef __cplusplus 
    typedef unsigned char _Bool; 
#  endif 
# endif 
#else 
# include &lt;stdint.h&gt; 
# if (defined (__SVR4) &amp;&amp; defined (__sun)) || defined(_AIX) || defined(__hpux) 
#  include &lt;alloca.h&gt; 
# endif 
#endif 
 
#if PY_MAJOR_VERSION &lt; 3 
# undef PyCapsule_CheckExact 
# undef PyCapsule_GetPointer 
# define PyCapsule_CheckExact(capsule) (PyCObject_Check(capsule)) 
# define PyCapsule_GetPointer(capsule, name) \ 
    (PyCObject_AsVoidPtr(capsule)) 
#endif 
 
#if PY_MAJOR_VERSION &gt;= 3 
# define PyInt_FromLong PyLong_FromLong 
#endif 
 
#define _cffi_from_c_double PyFloat_FromDouble 
#define _cffi_from_c_float PyFloat_FromDouble 
#define _cffi_from_c_long PyInt_FromLong 
#define _cffi_from_c_ulong PyLong_FromUnsignedLong 
#define _cffi_from_c_longlong PyLong_FromLongLong 
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong 
#define _cffi_from_c__Bool PyBool_FromLong 
 
#define _cffi_to_c_double PyFloat_AsDouble 
#define _cffi_to_c_float PyFloat_AsDouble 
 
#define _cffi_from_c_int_const(x)                                        \ 
    (((x) &gt; 0) ?                                                         \ 
        ((unsigned long long)(x) &lt;= (unsigned long long)LONG_MAX) ?      \ 
            PyInt_FromLong((long)(x)) :                                  \ 
            PyLong_FromUnsignedLongLong((unsigned long long)(x)) :       \ 
        ((long long)(x) &gt;= (long long)LONG_MIN) ?                        \ 
            PyInt_FromLong((long)(x)) :                                  \ 
            PyLong_FromLongLong((long long)(x))) 
 
#define _cffi_from_c_int(x, type)                                        \ 
    (((type)-1) &gt; 0 ? /* unsigned */                                     \ 
        (sizeof(type) &lt; sizeof(long) ?                                   \ 
            PyInt_FromLong((long)x) :                                    \ 
         sizeof(type) == sizeof(long) ?                                  \ 
            PyLong_FromUnsignedLong((unsigned long)x) :                  \ 
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \ 
        (sizeof(type) &lt;= sizeof(long) ?                                  \ 
            PyInt_FromLong((long)x) :                                    \ 
            PyLong_FromLongLong((long long)x))) 
 
#define _cffi_to_c_int(o, type)                                          \ 
    ((type)(                                                             \ 
     sizeof(type) == 1 ? (((type)-1) &gt; 0 ? (type)_cffi_to_c_u8(o)        \ 
                                         : (type)_cffi_to_c_i8(o)) :     \ 
     sizeof(type) == 2 ? (((type)-1) &gt; 0 ? (type)_cffi_to_c_u16(o)       \ 
                                         : (type)_cffi_to_c_i16(o)) :    \ 
     sizeof(type) == 4 ? (((type)-1) &gt; 0 ? (type)_cffi_to_c_u32(o)       \ 
                                         : (type)_cffi_to_c_i32(o)) :    \ 
     sizeof(type) == 8 ? (((type)-1) &gt; 0 ? (type)_cffi_to_c_u64(o)       \ 
                                         : (type)_cffi_to_c_i64(o)) :    \ 
     (Py_FatalError(&quot;unsupported size for type &quot; #type), (type)0))) 
 
#define _cffi_to_c_i8                                                    \ 
                 ((int(*)(PyObject *))_cffi_exports[1]) 
#define _cffi_to_c_u8                                                    \ 
                 ((int(*)(PyObject *))_cffi_exports[2]) 
#define _cffi_to_c_i16                                                   \ 
                 ((int(*)(PyObject *))_cffi_exports[3]) 
#define _cffi_to_c_u16                                                   \ 
                 ((int(*)(PyObject *))_cffi_exports[4]) 
#define _cffi_to_c_i32                                                   \ 
                 ((int(*)(PyObject *))_cffi_exports[5]) 
#define _cffi_to_c_u32                                                   \ 
                 ((unsigned int(*)(PyObject *))_cffi_exports[6]) 
#define _cffi_to_c_i64                                                   \ 
                 ((long long(*)(PyObject *))_cffi_exports[7]) 
#define _cffi_to_c_u64                                                   \ 
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8]) 
#define _cffi_to_c_char                                                  \ 
                 ((int(*)(PyObject *))_cffi_exports[9]) 
#define _cffi_from_c_pointer                                             \ 
    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[10]) 
#define _cffi_to_c_pointer                                               \ 
    ((char *(*)(PyObject *, CTypeDescrObject *))_cffi_exports[11]) 
#define _cffi_get_struct_layout                                          \ 
    ((PyObject *(*)(Py_ssize_t[]))_cffi_exports[12]) 
#define _cffi_restore_errno                                              \ 
    ((void(*)(void))_cffi_exports[13]) 
#define _cffi_save_errno                                                 \ 
    ((void(*)(void))_cffi_exports[14]) 
#define _cffi_from_c_char                                                \ 
    ((PyObject *(*)(char))_cffi_exports[15]) 
#define _cffi_from_c_deref                                               \ 
    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[16]) 
#define _cffi_to_c                                                       \ 
    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[17]) 
#define _cffi_from_c_struct                                              \ 
    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[18]) 
#define _cffi_to_c_wchar_t                                               \ 
    ((wchar_t(*)(PyObject *))_cffi_exports[19]) 
#define _cffi_from_c_wchar_t                                             \ 
    ((PyObject *(*)(wchar_t))_cffi_exports[20]) 
#define _cffi_to_c_long_double                                           \ 
    ((long double(*)(PyObject *))_cffi_exports[21]) 
#define _cffi_to_c__Bool                                                 \ 
    ((_Bool(*)(PyObject *))_cffi_exports[22]) 
#define _cffi_prepare_pointer_call_argument                              \ 
    ((Py_ssize_t(*)(CTypeDescrObject *, PyObject *, char **))_cffi_exports[23]) 
#define _cffi_convert_array_from_object                                  \ 
    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[24]) 
#define _CFFI_NUM_EXPORTS 25 
 
typedef struct _ctypedescr CTypeDescrObject; 
 
static void *_cffi_exports[_CFFI_NUM_EXPORTS]; 
static PyObject *_cffi_types, *_cffi_VerificationError; 
 
static int _cffi_setup_custom(PyObject *lib);   /* forward */ 
 
static PyObject *_cffi_setup(PyObject *self, PyObject *args) 
{ 
    PyObject *library; 
    int was_alive = (_cffi_types != NULL); 
    (void)self; /* unused */ 
    if (!PyArg_ParseTuple(args, &quot;OOO&quot;, &amp;_cffi_types, &amp;_cffi_VerificationError, 
                                       &amp;library)) 
        return NULL; 
    Py_INCREF(_cffi_types); 
    Py_INCREF(_cffi_VerificationError); 
    if (_cffi_setup_custom(library) &lt; 0) 
        return NULL; 
    return PyBool_FromLong(was_alive); 
} 
 
union _cffi_union_alignment_u { 
    unsigned char m_char; 
    unsigned short m_short; 
    unsigned int m_int; 
    unsigned long m_long; 
    unsigned long long m_longlong; 
    float m_float; 
    double m_double; 
    long double m_longdouble; 
}; 
 
struct _cffi_freeme_s { 
    struct _cffi_freeme_s *next; 
    union _cffi_union_alignment_u alignment; 
}; 
 
#ifdef __GNUC__ 
  __attribute__((unused)) 
#endif 
static int _cffi_convert_array_argument(CTypeDescrObject *ctptr, PyObject *arg, 
                                        char **output_data, Py_ssize_t datasize, 
                                        struct _cffi_freeme_s **freeme) 
{ 
    char *p; 
    if (datasize &lt; 0) 
        return -1; 
 
    p = *output_data; 
    if (p == NULL) { 
        struct _cffi_freeme_s *fp = (struct _cffi_freeme_s *)PyObject_Malloc( 
            offsetof(struct _cffi_freeme_s, alignment) + (size_t)datasize); 
        if (fp == NULL) 
            return -1; 
        fp-&gt;next = *freeme; 
        *freeme = fp; 
        p = *output_data = (char *)&amp;fp-&gt;alignment; 
    } 
    memset((void *)p, 0, (size_t)datasize); 
    return _cffi_convert_array_from_object(p, ctptr, arg); 
} 
 
#ifdef __GNUC__ 
  __attribute__((unused)) 
#endif 
static void _cffi_free_array_arguments(struct _cffi_freeme_s *freeme) 
{ 
    do { 
        void *p = (void *)freeme; 
        freeme = freeme-&gt;next; 
        PyObject_Free(p); 
    } while (freeme != NULL); 
} 
 
static int _cffi_init(void) 
{ 
    PyObject *module, *c_api_object = NULL; 
 
    module = PyImport_ImportModule(&quot;_cffi_backend&quot;); 
    if (module == NULL) 
        goto failure; 
 
    c_api_object = PyObject_GetAttrString(module, &quot;_C_API&quot;); 
    if (c_api_object == NULL) 
        goto failure; 
    if (!PyCapsule_CheckExact(c_api_object)) { 
        PyErr_SetNone(PyExc_ImportError); 
        goto failure; 
    } 
    memcpy(_cffi_exports, PyCapsule_GetPointer(c_api_object, &quot;cffi&quot;), 
           _CFFI_NUM_EXPORTS * sizeof(void *)); 
 
    Py_DECREF(module); 
    Py_DECREF(c_api_object); 
    return 0; 
 
  failure: 
    Py_XDECREF(module); 
    Py_XDECREF(c_api_object); 
    return -1; 
} 
 
#define _cffi_type(num) ((CTypeDescrObject *)PyList_GET_ITEM(_cffi_types, num)) 
 
/**********/ 
'''</span>
</pre>
</body>
</html>