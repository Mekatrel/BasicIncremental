<html>
<head>
<title>newbytes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
newbytes.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Pure-Python implementation of a Python 3-like bytes object for Python 2. 
 
Why do this? Without it, the Python 2 bytes object is a very, very 
different beast to the Python 3 bytes object. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Integral</span>
<span class="s2">import </span><span class="s1">string</span>
<span class="s2">import </span><span class="s1">copy</span>

<span class="s2">from </span><span class="s1">future.utils </span><span class="s2">import </span><span class="s1">istext</span><span class="s2">, </span><span class="s1">isbytes</span><span class="s2">, </span><span class="s1">PY2</span><span class="s2">, </span><span class="s1">PY3</span><span class="s2">, </span><span class="s1">with_metaclass</span>
<span class="s2">from </span><span class="s1">future.types </span><span class="s2">import </span><span class="s1">no</span><span class="s2">, </span><span class="s1">issubset</span>
<span class="s2">from </span><span class="s1">future.types.newobject </span><span class="s2">import </span><span class="s1">newobject</span>

<span class="s2">if </span><span class="s1">PY2:</span>
    <span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">Iterable</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">Iterable</span>


<span class="s1">_builtin_bytes = bytes</span>

<span class="s2">if </span><span class="s1">PY3:</span>
    <span class="s3"># We'll probably never use newstr on Py3 anyway...</span>
    <span class="s1">unicode = str</span>


<span class="s2">class </span><span class="s1">BaseNewBytes(type):</span>
    <span class="s2">def </span><span class="s1">__instancecheck__(cls</span><span class="s2">, </span><span class="s1">instance):</span>
        <span class="s2">if </span><span class="s1">cls == newbytes:</span>
            <span class="s2">return </span><span class="s1">isinstance(instance</span><span class="s2">, </span><span class="s1">_builtin_bytes)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">issubclass(instance.__class__</span><span class="s2">, </span><span class="s1">cls)</span>


<span class="s2">def </span><span class="s1">_newchr(x):</span>
    <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">str):  </span><span class="s3"># this happens on pypy</span>
        <span class="s2">return </span><span class="s1">x.encode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">chr(x)</span>


<span class="s2">class </span><span class="s1">newbytes(with_metaclass(BaseNewBytes</span><span class="s2">, </span><span class="s1">_builtin_bytes)):</span>
    <span class="s0">&quot;&quot;&quot; 
    A backport of the Python 3 bytes object to Py2 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__new__(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        From the Py3 bytes docstring: 
 
        bytes(iterable_of_ints) -&gt; bytes 
        bytes(string, encoding[, errors]) -&gt; bytes 
        bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer 
        bytes(int) -&gt; bytes object of size given by the parameter initialized with null bytes 
        bytes() -&gt; empty bytes object 
 
        Construct an immutable array of bytes from: 
          - an iterable yielding integers in range(256) 
          - a text string encoded using the specified encoding 
          - any object implementing the buffer API. 
          - an integer 
        &quot;&quot;&quot;</span>

        <span class="s1">encoding = </span><span class="s2">None</span>
        <span class="s1">errors = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">len(args) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">cls).__new__(cls)</span>
        <span class="s2">elif </span><span class="s1">len(args) &gt;= </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">args = list(args)</span>
            <span class="s2">if </span><span class="s1">len(args) == </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">errors = args.pop()</span>
            <span class="s1">encoding=args.pop()</span>
        <span class="s3"># Was: elif isinstance(args[0], newbytes):</span>
        <span class="s3"># We use type() instead of the above because we're redefining</span>
        <span class="s3"># this to be True for all unicode string subclasses. Warning:</span>
        <span class="s3"># This may render newstr un-subclassable.</span>
        <span class="s2">if </span><span class="s1">type(args[</span><span class="s5">0</span><span class="s1">]) == newbytes:</span>
            <span class="s3"># Special-case: for consistency with Py3.3, we return the same object</span>
            <span class="s3"># (with the same id) if a newbytes object is passed into the</span>
            <span class="s3"># newbytes constructor.</span>
            <span class="s2">return </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">isinstance(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">_builtin_bytes):</span>
            <span class="s1">value = args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">isinstance(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unicode):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s4">'encoding' </span><span class="s2">in </span><span class="s1">kwargs:</span>
                    <span class="s2">assert </span><span class="s1">encoding </span><span class="s2">is None</span>
                    <span class="s1">encoding = kwargs[</span><span class="s4">'encoding'</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s4">'errors' </span><span class="s2">in </span><span class="s1">kwargs:</span>
                    <span class="s2">assert </span><span class="s1">errors </span><span class="s2">is None</span>
                    <span class="s1">errors = kwargs[</span><span class="s4">'errors'</span><span class="s1">]</span>
            <span class="s2">except </span><span class="s1">AssertionError:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">'Argument given by name and position'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">'unicode string argument without an encoding'</span><span class="s1">)</span>
            <span class="s3">###</span>
            <span class="s3"># Was:   value = args[0].encode(**kwargs)</span>
            <span class="s3"># Python 2.6 string encode() method doesn't take kwargs:</span>
            <span class="s3"># Use this instead:</span>
            <span class="s1">newargs = [encoding]</span>
            <span class="s2">if </span><span class="s1">errors </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">newargs.append(errors)</span>
            <span class="s1">value = args[</span><span class="s5">0</span><span class="s1">].encode(*newargs)</span>
            <span class="s3">###</span>
        <span class="s2">elif </span><span class="s1">hasattr(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'__bytes__'</span><span class="s1">):</span>
            <span class="s1">value = args[</span><span class="s5">0</span><span class="s1">].__bytes__()</span>
        <span class="s2">elif </span><span class="s1">isinstance(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Iterable):</span>
            <span class="s2">if </span><span class="s1">len(args[</span><span class="s5">0</span><span class="s1">]) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3"># This could be an empty list or tuple. Return b'' as on Py3.</span>
                <span class="s1">value = </span><span class="s6">b''</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># Was: elif len(args[0])&gt;0 and isinstance(args[0][0], Integral):</span>
                <span class="s3">#      # It's a list of integers</span>
                <span class="s3"># But then we can't index into e.g. frozensets. Try to proceed</span>
                <span class="s3"># anyway.</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">value = bytearray([_newchr(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">]])</span>
                <span class="s2">except</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'bytes must be in range(0, 256)'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Integral):</span>
            <span class="s2">if </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'negative count'</span><span class="s1">)</span>
            <span class="s1">value = </span><span class="s6">b'</span><span class="s2">\x00</span><span class="s6">' </span><span class="s1">* args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">value = args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">type(value) == newbytes:</span>
            <span class="s3"># Above we use type(...) rather than isinstance(...) because the</span>
            <span class="s3"># newbytes metaclass overrides __instancecheck__.</span>
            <span class="s3"># oldbytes(value) gives the wrong thing on Py2: the same</span>
            <span class="s3"># result as str(value) on Py3, e.g. &quot;b'abc'&quot;. (Issue #193).</span>
            <span class="s3"># So we handle this case separately:</span>
            <span class="s2">return </span><span class="s1">copy.copy(value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">cls).__new__(cls</span><span class="s2">, </span><span class="s1">value)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'b' </span><span class="s1">+ super(newbytes</span><span class="s2">, </span><span class="s1">self).__repr__()</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s4">'b' </span><span class="s1">+ </span><span class="s4">&quot;'{0}'&quot;</span><span class="s1">.format(super(newbytes</span><span class="s2">, </span><span class="s1">self).__str__())</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s1">value = super(newbytes</span><span class="s2">, </span><span class="s1">self).__getitem__(y)</span>
        <span class="s2">if </span><span class="s1">isinstance(y</span><span class="s2">, </span><span class="s1">Integral):</span>
            <span class="s2">return </span><span class="s1">ord(value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">newbytes(value)</span>

    <span class="s2">def </span><span class="s1">__getslice__(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">self.__getitem__(slice(*args))</span>

    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s1">newbyteskey = newbytes([key])</span>
        <span class="s3"># Don't use isinstance() here because we only want to catch</span>
        <span class="s3"># newbytes, not Python 2 str:</span>
        <span class="s2">elif </span><span class="s1">type(key) == newbytes:</span>
            <span class="s1">newbyteskey = key</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">newbyteskey = newbytes(key)</span>
        <span class="s2">return </span><span class="s1">issubset(list(newbyteskey)</span><span class="s2">, </span><span class="s1">list(self))</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">newbytes(super(newbytes</span><span class="s2">, </span><span class="s1">self).__add__(other))</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">__radd__(self</span><span class="s2">, </span><span class="s1">left):</span>
        <span class="s2">return </span><span class="s1">newbytes(left) + self</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">__mul__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">newbytes(super(newbytes</span><span class="s2">, </span><span class="s1">self).__mul__(other))</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">__rmul__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">newbytes(super(newbytes</span><span class="s2">, </span><span class="s1">self).__rmul__(other))</span>

    <span class="s2">def </span><span class="s1">__mod__(self</span><span class="s2">, </span><span class="s1">vals):</span>
        <span class="s2">if </span><span class="s1">isinstance(vals</span><span class="s2">, </span><span class="s1">newbytes):</span>
            <span class="s1">vals = _builtin_bytes.__str__(vals)</span>

        <span class="s2">elif </span><span class="s1">isinstance(vals</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s1">newvals = []</span>
            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vals:</span>
                <span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">newbytes):</span>
                    <span class="s1">v = _builtin_bytes.__str__(v)</span>
                <span class="s1">newvals.append(v)</span>
            <span class="s1">vals = tuple(newvals)</span>

        <span class="s2">elif </span><span class="s1">(hasattr(vals.__class__</span><span class="s2">, </span><span class="s4">'__getitem__'</span><span class="s1">) </span><span class="s2">and</span>
                <span class="s1">hasattr(vals.__class__</span><span class="s2">, </span><span class="s4">'iteritems'</span><span class="s1">)):</span>
            <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vals.iteritems():</span>
                <span class="s2">if </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">newbytes):</span>
                    <span class="s1">vals[k] = _builtin_bytes.__str__(v)</span>

        <span class="s2">return </span><span class="s1">_builtin_bytes.__mod__(self</span><span class="s2">, </span><span class="s1">vals)</span>

    <span class="s2">def </span><span class="s1">__imod__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">self.__mod__(other)</span>

    <span class="s2">def </span><span class="s1">join(self</span><span class="s2">, </span><span class="s1">iterable_of_bytes):</span>
        <span class="s1">errmsg = </span><span class="s4">'sequence item {0}: expected bytes, {1} found'</span>
        <span class="s2">if </span><span class="s1">isbytes(iterable_of_bytes) </span><span class="s2">or </span><span class="s1">istext(iterable_of_bytes):</span>
            <span class="s2">raise </span><span class="s1">TypeError(errmsg.format(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">type(iterable_of_bytes)))</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">item </span><span class="s2">in </span><span class="s1">enumerate(iterable_of_bytes):</span>
            <span class="s2">if </span><span class="s1">istext(item):</span>
                <span class="s2">raise </span><span class="s1">TypeError(errmsg.format(i</span><span class="s2">, </span><span class="s1">type(item)))</span>
        <span class="s2">return </span><span class="s1">newbytes(super(newbytes</span><span class="s2">, </span><span class="s1">self).join(iterable_of_bytes))</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">fromhex(cls</span><span class="s2">, </span><span class="s1">string):</span>
        <span class="s3"># Only on Py2:</span>
        <span class="s2">return </span><span class="s1">cls(string.replace(</span><span class="s4">' '</span><span class="s2">, </span><span class="s4">''</span><span class="s1">).decode(</span><span class="s4">'hex'</span><span class="s1">))</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">find(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).find(sub</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">rfind(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).rfind(sub</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s1">@no(unicode</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">replace(self</span><span class="s2">, </span><span class="s1">old</span><span class="s2">, </span><span class="s1">new</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">newbytes(super(newbytes</span><span class="s2">, </span><span class="s1">self).replace(old</span><span class="s2">, </span><span class="s1">new</span><span class="s2">, </span><span class="s1">*args))</span>

    <span class="s2">def </span><span class="s1">encode(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s4">&quot;encode method has been disabled in newbytes&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">decode(self</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s4">'utf-8'</span><span class="s2">, </span><span class="s1">errors=</span><span class="s4">'strict'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a newstr (i.e. unicode subclass) 
 
        Decode B using the codec registered for encoding. Default encoding 
        is 'utf-8'. errors may be given to set a different error 
        handling scheme.  Default is 'strict' meaning that encoding errors raise 
        a UnicodeDecodeError.  Other possible values are 'ignore' and 'replace' 
        as well as any other name registered with codecs.register_error that is 
        able to handle UnicodeDecodeErrors. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Py2 str.encode() takes encoding and errors as optional parameter,</span>
        <span class="s3"># not keyword arguments as in Python 3 str.</span>

        <span class="s2">from </span><span class="s1">future.types.newstr </span><span class="s2">import </span><span class="s1">newstr</span>

        <span class="s2">if </span><span class="s1">errors == </span><span class="s4">'surrogateescape'</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">future.utils.surrogateescape </span><span class="s2">import </span><span class="s1">register_surrogateescape</span>
            <span class="s1">register_surrogateescape()</span>

        <span class="s2">return </span><span class="s1">newstr(super(newbytes</span><span class="s2">, </span><span class="s1">self).decode(encoding</span><span class="s2">, </span><span class="s1">errors))</span>

        <span class="s3"># This is currently broken:</span>
        <span class="s3"># # We implement surrogateescape error handling here in addition rather</span>
        <span class="s3"># # than relying on the custom error handler from</span>
        <span class="s3"># # future.utils.surrogateescape to be registered globally, even though</span>
        <span class="s3"># # that is fine in the case of decoding. (But not encoding: see the</span>
        <span class="s3"># # comments in newstr.encode()``.)</span>
        <span class="s3">#</span>
        <span class="s3"># if errors == 'surrogateescape':</span>
        <span class="s3">#     # Decode char by char</span>
        <span class="s3">#     mybytes = []</span>
        <span class="s3">#     for code in self:</span>
        <span class="s3">#         # Code is an int</span>
        <span class="s3">#         if 0x80 &lt;= code &lt;= 0xFF:</span>
        <span class="s3">#             b = 0xDC00 + code</span>
        <span class="s3">#         elif code &lt;= 0x7F:</span>
        <span class="s3">#             b = _unichr(c).decode(encoding=encoding)</span>
        <span class="s3">#         else:</span>
        <span class="s3">#             # # It may be a bad byte</span>
        <span class="s3">#             # FIXME: What to do in this case? See the Py3 docs / tests.</span>
        <span class="s3">#             # # Try swallowing it.</span>
        <span class="s3">#             # continue</span>
        <span class="s3">#             # print(&quot;RAISE!&quot;)</span>
        <span class="s3">#             raise NotASurrogateError</span>
        <span class="s3">#         mybytes.append(b)</span>
        <span class="s3">#     return newbytes(mybytes)</span>
        <span class="s3"># return newbytes(super(newstr, self).decode(encoding, errors))</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">startswith(self</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).startswith(prefix</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">endswith(self</span><span class="s2">, </span><span class="s1">prefix</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).endswith(prefix</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">split(self</span><span class="s2">, </span><span class="s1">sep=</span><span class="s2">None, </span><span class="s1">maxsplit=-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s3"># Py2 str.split() takes maxsplit as an optional parameter, not as a</span>
        <span class="s3"># keyword argument as in Python 3 bytes.</span>
        <span class="s1">parts = super(newbytes</span><span class="s2">, </span><span class="s1">self).split(sep</span><span class="s2">, </span><span class="s1">maxsplit)</span>
        <span class="s2">return </span><span class="s1">[newbytes(part) </span><span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">parts]</span>

    <span class="s2">def </span><span class="s1">splitlines(self</span><span class="s2">, </span><span class="s1">keepends=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        B.splitlines([keepends]) -&gt; list of lines 
 
        Return a list of the lines in B, breaking at line boundaries. 
        Line breaks are not included in the resulting list unless keepends 
        is given and true. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Py2 str.splitlines() takes keepends as an optional parameter,</span>
        <span class="s3"># not as a keyword argument as in Python 3 bytes.</span>
        <span class="s1">parts = super(newbytes</span><span class="s2">, </span><span class="s1">self).splitlines(keepends)</span>
        <span class="s2">return </span><span class="s1">[newbytes(part) </span><span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">parts]</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">rsplit(self</span><span class="s2">, </span><span class="s1">sep=</span><span class="s2">None, </span><span class="s1">maxsplit=-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s3"># Py2 str.rsplit() takes maxsplit as an optional parameter, not as a</span>
        <span class="s3"># keyword argument as in Python 3 bytes.</span>
        <span class="s1">parts = super(newbytes</span><span class="s2">, </span><span class="s1">self).rsplit(sep</span><span class="s2">, </span><span class="s1">maxsplit)</span>
        <span class="s2">return </span><span class="s1">[newbytes(part) </span><span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">parts]</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">partition(self</span><span class="s2">, </span><span class="s1">sep):</span>
        <span class="s1">parts = super(newbytes</span><span class="s2">, </span><span class="s1">self).partition(sep)</span>
        <span class="s2">return </span><span class="s1">tuple(newbytes(part) </span><span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">parts)</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">rpartition(self</span><span class="s2">, </span><span class="s1">sep):</span>
        <span class="s1">parts = super(newbytes</span><span class="s2">, </span><span class="s1">self).rpartition(sep)</span>
        <span class="s2">return </span><span class="s1">tuple(newbytes(part) </span><span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">parts)</span>

    <span class="s1">@no(unicode</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">rindex(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">''' 
        S.rindex(sub [,start [,end]]) -&gt; int 
 
        Like S.rfind() but raise ValueError when the substring is not found. 
        '''</span>
        <span class="s1">pos = self.rfind(sub</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">if </span><span class="s1">pos == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'substring not found'</span><span class="s1">)</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">index(self</span><span class="s2">, </span><span class="s1">sub</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">''' 
        Returns index of sub in bytes. 
        Raises ValueError if byte is not in bytes and TypeError if can't 
        be converted bytes or its length is not 1. 
        '''</span>
        <span class="s2">if </span><span class="s1">isinstance(sub</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s2">if </span><span class="s1">len(args) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">start</span><span class="s2">, </span><span class="s1">end = </span><span class="s5">0</span><span class="s2">, </span><span class="s1">len(self)</span>
            <span class="s2">elif </span><span class="s1">len(args) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">start = args[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">elif </span><span class="s1">len(args) == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">start</span><span class="s2">, </span><span class="s1">end = args</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">'takes at most 3 arguments'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">list(self)[start:end].index(sub)</span>
        <span class="s2">if not </span><span class="s1">isinstance(sub</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">sub = self.__class__(sub)</span>
            <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;can't convert sub to bytes&quot;</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).index(sub</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'substring not found'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">(_builtin_bytes</span><span class="s2">, </span><span class="s1">bytearray)):</span>
            <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).__eq__(other)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">_builtin_bytes):</span>
            <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).__ne__(other)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return True</span>

    <span class="s1">unorderable_err = </span><span class="s4">'unorderable types: bytes() and {0}'</span>

    <span class="s2">def </span><span class="s1">__lt__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">_builtin_bytes):</span>
            <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).__lt__(other)</span>
        <span class="s2">raise </span><span class="s1">TypeError(self.unorderable_err.format(type(other)))</span>

    <span class="s2">def </span><span class="s1">__le__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">_builtin_bytes):</span>
            <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).__le__(other)</span>
        <span class="s2">raise </span><span class="s1">TypeError(self.unorderable_err.format(type(other)))</span>

    <span class="s2">def </span><span class="s1">__gt__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">_builtin_bytes):</span>
            <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).__gt__(other)</span>
        <span class="s2">raise </span><span class="s1">TypeError(self.unorderable_err.format(type(other)))</span>

    <span class="s2">def </span><span class="s1">__ge__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">_builtin_bytes):</span>
            <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).__ge__(other)</span>
        <span class="s2">raise </span><span class="s1">TypeError(self.unorderable_err.format(type(other)))</span>

    <span class="s2">def </span><span class="s1">__native__(self):</span>
        <span class="s3"># We can't just feed a newbytes object into str(), because</span>
        <span class="s3"># newbytes.__str__() returns e.g. &quot;b'blah'&quot;, consistent with Py3 bytes.</span>
        <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).__str__()</span>

    <span class="s2">def </span><span class="s1">__getattribute__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0">&quot;&quot;&quot; 
        A trick to cause the ``hasattr`` builtin-fn to return False for 
        the 'encode' method on Py2. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'encode'</span><span class="s2">, </span><span class="s4">u'encode'</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s4">&quot;encode method has been disabled in newbytes&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">super(newbytes</span><span class="s2">, </span><span class="s1">self).__getattribute__(name)</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">rstrip(self</span><span class="s2">, </span><span class="s1">bytes_to_strip=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Strip trailing bytes contained in the argument. 
        If the argument is omitted, strip trailing ASCII whitespace. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">newbytes(super(newbytes</span><span class="s2">, </span><span class="s1">self).rstrip(bytes_to_strip))</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">strip(self</span><span class="s2">, </span><span class="s1">bytes_to_strip=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Strip leading and trailing bytes contained in the argument. 
        If the argument is omitted, strip trailing ASCII whitespace. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">newbytes(super(newbytes</span><span class="s2">, </span><span class="s1">self).strip(bytes_to_strip))</span>

    <span class="s2">def </span><span class="s1">lower(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        b.lower() -&gt; copy of b 
 
        Return a copy of b with all ASCII characters converted to lowercase. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">newbytes(super(newbytes</span><span class="s2">, </span><span class="s1">self).lower())</span>

    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">upper(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        b.upper() -&gt; copy of b 
 
        Return a copy of b with all ASCII characters converted to uppercase. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">newbytes(super(newbytes</span><span class="s2">, </span><span class="s1">self).upper())</span>

    <span class="s1">@classmethod</span>
    <span class="s1">@no(unicode)</span>
    <span class="s2">def </span><span class="s1">maketrans(cls</span><span class="s2">, </span><span class="s1">frm</span><span class="s2">, </span><span class="s1">to):</span>
        <span class="s0">&quot;&quot;&quot; 
        B.maketrans(frm, to) -&gt; translation table 
 
        Return a translation table (a bytes object of length 256) suitable 
        for use in the bytes or bytearray translate method where each byte 
        in frm is mapped to the byte at the same position in to. 
        The bytes objects frm and to must be of the same length. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">newbytes(string.maketrans(frm</span><span class="s2">, </span><span class="s1">to))</span>


<span class="s1">__all__ = [</span><span class="s4">'newbytes'</span><span class="s1">]</span>
</pre>
</body>
</html>