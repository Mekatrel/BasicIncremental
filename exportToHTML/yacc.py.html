<html>
<head>
<title>yacc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
yacc.py</font>
</center></td></tr></table>
<pre><span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># ply: yacc.py</span>
<span class="s0">#</span>
<span class="s0"># Copyright (C) 2001-2017</span>
<span class="s0"># David M. Beazley (Dabeaz LLC)</span>
<span class="s0"># All rights reserved.</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions are</span>
<span class="s0"># met:</span>
<span class="s0">#</span>
<span class="s0"># * Redistributions of source code must retain the above copyright notice,</span>
<span class="s0">#   this list of conditions and the following disclaimer.</span>
<span class="s0"># * Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="s0">#   this list of conditions and the following disclaimer in the documentation</span>
<span class="s0">#   and/or other materials provided with the distribution.</span>
<span class="s0"># * Neither the name of the David Beazley or Dabeaz LLC may be used to</span>
<span class="s0">#   endorse or promote products derived from this software without</span>
<span class="s0">#  specific prior written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="s0"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="s0"># A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="s0"># OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="s0"># SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="s0"># DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="s0"># THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="s0"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="s0"># OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># This implements an LR parser that is constructed from grammar rules defined</span>
<span class="s0"># as Python functions. The grammer is specified by supplying the BNF inside</span>
<span class="s0"># Python documentation strings.  The inspiration for this technique was borrowed</span>
<span class="s0"># from John Aycock's Spark parsing system.  PLY might be viewed as cross between</span>
<span class="s0"># Spark and the GNU bison utility.</span>
<span class="s0">#</span>
<span class="s0"># The current implementation is only somewhat object-oriented. The</span>
<span class="s0"># LR parser itself is defined in terms of an object (which allows multiple</span>
<span class="s0"># parsers to co-exist).  However, most of the variables used during table</span>
<span class="s0"># construction are defined in terms of global variables.  Users shouldn't</span>
<span class="s0"># notice unless they are trying to define multiple parsers at the same</span>
<span class="s0"># time using threads (in which case they should have their head examined).</span>
<span class="s0">#</span>
<span class="s0"># This implementation supports both SLR and LALR(1) parsing.  LALR(1)</span>
<span class="s0"># support was originally implemented by Elias Ioup (ezioup@alumni.uchicago.edu),</span>
<span class="s0"># using the algorithm found in Aho, Sethi, and Ullman &quot;Compilers: Principles,</span>
<span class="s0"># Techniques, and Tools&quot; (The Dragon Book).  LALR(1) has since been replaced</span>
<span class="s0"># by the more efficient DeRemer and Pennello algorithm.</span>
<span class="s0">#</span>
<span class="s0"># :::::::: WARNING :::::::</span>
<span class="s0">#</span>
<span class="s0"># Construction of LR parsing tables is fairly complicated and expensive.</span>
<span class="s0"># To make this module run fast, a *LOT* of work has been put into</span>
<span class="s0"># optimization---often at the expensive of readability and what might</span>
<span class="s0"># consider to be good Python &quot;coding style.&quot;   Modify the code at your</span>
<span class="s0"># own risk!</span>
<span class="s0"># ----------------------------------------------------------------------------</span>

<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os.path</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">base64</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s1">__version__    = </span><span class="s3">'3.10'</span>
<span class="s1">__tabversion__ = </span><span class="s3">'3.10'</span>

<span class="s0">#-----------------------------------------------------------------------------</span>
<span class="s0">#                     === User configurable parameters ===</span>
<span class="s0">#</span>
<span class="s0"># Change these to modify the default behavior of yacc (if you wish)</span>
<span class="s0">#-----------------------------------------------------------------------------</span>

<span class="s1">yaccdebug   = </span><span class="s2">True             </span><span class="s0"># Debugging mode.  If set, yacc generates a</span>
                               <span class="s0"># a 'parser.out' file in the current directory</span>

<span class="s1">debug_file  = </span><span class="s3">'parser.out'     </span><span class="s0"># Default name of the debugging file</span>
<span class="s1">tab_module  = </span><span class="s3">'parsetab'       </span><span class="s0"># Default name of the table module</span>
<span class="s1">default_lr  = </span><span class="s3">'LALR'           </span><span class="s0"># Default LR table generation method</span>

<span class="s1">error_count = </span><span class="s4">3                </span><span class="s0"># Number of symbols that must be shifted to leave recovery mode</span>

<span class="s1">yaccdevel   = </span><span class="s2">False            </span><span class="s0"># Set to True if developing yacc.  This turns off optimized</span>
                               <span class="s0"># implementations of certain functions.</span>

<span class="s1">resultlimit = </span><span class="s4">40               </span><span class="s0"># Size limit of results when running in debug mode.</span>

<span class="s1">pickle_protocol = </span><span class="s4">0            </span><span class="s0"># Protocol to use when writing pickle files</span>

<span class="s0"># String type-checking compatibility</span>
<span class="s2">if </span><span class="s1">sys.version_info[</span><span class="s4">0</span><span class="s1">] &lt; </span><span class="s4">3</span><span class="s1">:</span>
    <span class="s1">string_types = basestring</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s1">string_types = str</span>

<span class="s1">MAXINT = sys.maxsize</span>

<span class="s0"># This object is a stand-in for a logging object created by the</span>
<span class="s0"># logging module.   PLY will use this by default to create things</span>
<span class="s0"># such as the parser.out file.  If a user wants more detailed</span>
<span class="s0"># information, they can create their own logging object and pass</span>
<span class="s0"># it into PLY.</span>

<span class="s2">class </span><span class="s1">PlyLogger(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">f):</span>
        <span class="s1">self.f = f</span>

    <span class="s2">def </span><span class="s1">debug(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.f.write((msg % args) + </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

    <span class="s1">info = debug</span>

    <span class="s2">def </span><span class="s1">warning(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.f.write(</span><span class="s3">'WARNING: ' </span><span class="s1">+ (msg % args) + </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">error(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.f.write(</span><span class="s3">'ERROR: ' </span><span class="s1">+ (msg % args) + </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

    <span class="s1">critical = debug</span>

<span class="s0"># Null logger is used when no output is generated. Does nothing.</span>
<span class="s2">class </span><span class="s1">NullLogger(object):</span>
    <span class="s2">def </span><span class="s1">__getattribute__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self</span>

<span class="s0"># Exception raised for yacc-related errors</span>
<span class="s2">class </span><span class="s1">YaccError(Exception):</span>
    <span class="s2">pass</span>

<span class="s0"># Format the result message that the parser produces when running in debug mode.</span>
<span class="s2">def </span><span class="s1">format_result(r):</span>
    <span class="s1">repr_str = repr(r)</span>
    <span class="s2">if </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s2">in </span><span class="s1">repr_str:</span>
        <span class="s1">repr_str = repr(repr_str)</span>
    <span class="s2">if </span><span class="s1">len(repr_str) &gt; resultlimit:</span>
        <span class="s1">repr_str = repr_str[:resultlimit] + </span><span class="s3">' ...'</span>
    <span class="s1">result = </span><span class="s3">'&lt;%s @ 0x%x&gt; (%s)' </span><span class="s1">% (type(r).__name__</span><span class="s2">, </span><span class="s1">id(r)</span><span class="s2">, </span><span class="s1">repr_str)</span>
    <span class="s2">return </span><span class="s1">result</span>

<span class="s0"># Format stack entries when the parser is running in debug mode</span>
<span class="s2">def </span><span class="s1">format_stack_entry(r):</span>
    <span class="s1">repr_str = repr(r)</span>
    <span class="s2">if </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s2">in </span><span class="s1">repr_str:</span>
        <span class="s1">repr_str = repr(repr_str)</span>
    <span class="s2">if </span><span class="s1">len(repr_str) &lt; </span><span class="s4">16</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">repr_str</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">'&lt;%s @ 0x%x&gt;' </span><span class="s1">% (type(r).__name__</span><span class="s2">, </span><span class="s1">id(r))</span>

<span class="s0"># Panic mode error recovery support.   This feature is being reworked--much of the</span>
<span class="s0"># code here is to offer a deprecation/backwards compatible transition</span>

<span class="s1">_errok = </span><span class="s2">None</span>
<span class="s1">_token = </span><span class="s2">None</span>
<span class="s1">_restart = </span><span class="s2">None</span>
<span class="s1">_warnmsg = </span><span class="s3">'''PLY: Don't use global functions errok(), token(), and restart() in p_error(). 
Instead, invoke the methods on the associated parser instance: 
 
    def p_error(p): 
        ... 
        # Use parser.errok(), parser.token(), parser.restart() 
        ... 
 
    parser = yacc.yacc() 
'''</span>

<span class="s2">def </span><span class="s1">errok():</span>
    <span class="s1">warnings.warn(_warnmsg)</span>
    <span class="s2">return </span><span class="s1">_errok()</span>

<span class="s2">def </span><span class="s1">restart():</span>
    <span class="s1">warnings.warn(_warnmsg)</span>
    <span class="s2">return </span><span class="s1">_restart()</span>

<span class="s2">def </span><span class="s1">token():</span>
    <span class="s1">warnings.warn(_warnmsg)</span>
    <span class="s2">return </span><span class="s1">_token()</span>

<span class="s0"># Utility function to call the p_error() function with some deprecation hacks</span>
<span class="s2">def </span><span class="s1">call_errorfunc(errorfunc</span><span class="s2">, </span><span class="s1">token</span><span class="s2">, </span><span class="s1">parser):</span>
    <span class="s2">global </span><span class="s1">_errok</span><span class="s2">, </span><span class="s1">_token</span><span class="s2">, </span><span class="s1">_restart</span>
    <span class="s1">_errok = parser.errok</span>
    <span class="s1">_token = parser.token</span>
    <span class="s1">_restart = parser.restart</span>
    <span class="s1">r = errorfunc(token)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">del </span><span class="s1">_errok</span><span class="s2">, </span><span class="s1">_token</span><span class="s2">, </span><span class="s1">_restart</span>
    <span class="s2">except </span><span class="s1">NameError:</span>
        <span class="s2">pass</span>
    <span class="s2">return </span><span class="s1">r</span>

<span class="s0">#-----------------------------------------------------------------------------</span>
<span class="s0">#                        ===  LR Parsing Engine ===</span>
<span class="s0">#</span>
<span class="s0"># The following classes are used for the LR parser itself.  These are not</span>
<span class="s0"># used during table construction and are independent of the actual LR</span>
<span class="s0"># table generation algorithm</span>
<span class="s0">#-----------------------------------------------------------------------------</span>

<span class="s0"># This class is used to hold non-terminal grammar symbols during parsing.</span>
<span class="s0"># It normally has the following attributes set:</span>
<span class="s0">#        .type       = Grammar symbol type</span>
<span class="s0">#        .value      = Symbol value</span>
<span class="s0">#        .lineno     = Starting line number</span>
<span class="s0">#        .endlineno  = Ending line number (optional, set automatically)</span>
<span class="s0">#        .lexpos     = Starting lex position</span>
<span class="s0">#        .endlexpos  = Ending lex position (optional, set automatically)</span>

<span class="s2">class </span><span class="s1">YaccSymbol:</span>
    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">self.type</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">str(self)</span>

<span class="s0"># This class is a wrapper around the objects actually passed to each</span>
<span class="s0"># grammar rule.   Index lookup and assignment actually assign the</span>
<span class="s0"># .value attribute of the underlying YaccSymbol object.</span>
<span class="s0"># The lineno() method returns the line number of a given</span>
<span class="s0"># item (or 0 if not defined).   The linespan() method returns</span>
<span class="s0"># a tuple of (startline,endline) representing the range of lines</span>
<span class="s0"># for a symbol.  The lexspan() method returns a tuple (lexpos,endlexpos)</span>
<span class="s0"># representing the range of positional information for a symbol.</span>

<span class="s2">class </span><span class="s1">YaccProduction:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">stack=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.slice = s</span>
        <span class="s1">self.stack = stack</span>
        <span class="s1">self.lexer = </span><span class="s2">None</span>
        <span class="s1">self.parser = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">if </span><span class="s1">isinstance(n</span><span class="s2">, </span><span class="s1">slice):</span>
            <span class="s2">return </span><span class="s1">[s.value </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self.slice[n]]</span>
        <span class="s2">elif </span><span class="s1">n &gt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.slice[n].value</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.stack[n].value</span>

    <span class="s2">def </span><span class="s1">__setitem__(self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">v):</span>
        <span class="s1">self.slice[n].value = v</span>

    <span class="s2">def </span><span class="s1">__getslice__(self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j):</span>
        <span class="s2">return </span><span class="s1">[s.value </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self.slice[i:j]]</span>

    <span class="s2">def </span><span class="s1">__len__(self):</span>
        <span class="s2">return </span><span class="s1">len(self.slice)</span>

    <span class="s2">def </span><span class="s1">lineno(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">return </span><span class="s1">getattr(self.slice[n]</span><span class="s2">, </span><span class="s3">'lineno'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_lineno(self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">lineno):</span>
        <span class="s1">self.slice[n].lineno = lineno</span>

    <span class="s2">def </span><span class="s1">linespan(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s1">startline = getattr(self.slice[n]</span><span class="s2">, </span><span class="s3">'lineno'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">endline = getattr(self.slice[n]</span><span class="s2">, </span><span class="s3">'endlineno'</span><span class="s2">, </span><span class="s1">startline)</span>
        <span class="s2">return </span><span class="s1">startline</span><span class="s2">, </span><span class="s1">endline</span>

    <span class="s2">def </span><span class="s1">lexpos(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">return </span><span class="s1">getattr(self.slice[n]</span><span class="s2">, </span><span class="s3">'lexpos'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">lexspan(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s1">startpos = getattr(self.slice[n]</span><span class="s2">, </span><span class="s3">'lexpos'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">endpos = getattr(self.slice[n]</span><span class="s2">, </span><span class="s3">'endlexpos'</span><span class="s2">, </span><span class="s1">startpos)</span>
        <span class="s2">return </span><span class="s1">startpos</span><span class="s2">, </span><span class="s1">endpos</span>

    <span class="s2">def </span><span class="s1">error(self):</span>
        <span class="s2">raise </span><span class="s1">SyntaxError</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                               == LRParser ==</span>
<span class="s0">#</span>
<span class="s0"># The LR Parsing engine.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">LRParser:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">lrtab</span><span class="s2">, </span><span class="s1">errorf):</span>
        <span class="s1">self.productions = lrtab.lr_productions</span>
        <span class="s1">self.action = lrtab.lr_action</span>
        <span class="s1">self.goto = lrtab.lr_goto</span>
        <span class="s1">self.errorfunc = errorf</span>
        <span class="s1">self.set_defaulted_states()</span>
        <span class="s1">self.errorok = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">errok(self):</span>
        <span class="s1">self.errorok = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">restart(self):</span>
        <span class="s2">del </span><span class="s1">self.statestack[:]</span>
        <span class="s2">del </span><span class="s1">self.symstack[:]</span>
        <span class="s1">sym = YaccSymbol()</span>
        <span class="s1">sym.type = </span><span class="s3">'$end'</span>
        <span class="s1">self.symstack.append(sym)</span>
        <span class="s1">self.statestack.append(</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0"># Defaulted state support.</span>
    <span class="s0"># This method identifies parser states where there is only one possible reduction action.</span>
    <span class="s0"># For such states, the parser can make a choose to make a rule reduction without consuming</span>
    <span class="s0"># the next look-ahead token.  This delayed invocation of the tokenizer can be useful in</span>
    <span class="s0"># certain kinds of advanced parsing situations where the lexer and parser interact with</span>
    <span class="s0"># each other or change states (i.e., manipulation of scope, lexer states, etc.).</span>
    <span class="s0">#</span>
    <span class="s0"># See:  https://www.gnu.org/software/bison/manual/html_node/Default-Reductions.html#Default-Reductions</span>
    <span class="s2">def </span><span class="s1">set_defaulted_states(self):</span>
        <span class="s1">self.defaulted_states = {}</span>
        <span class="s2">for </span><span class="s1">state</span><span class="s2">, </span><span class="s1">actions </span><span class="s2">in </span><span class="s1">self.action.items():</span>
            <span class="s1">rules = list(actions.values())</span>
            <span class="s2">if </span><span class="s1">len(rules) == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">rules[</span><span class="s4">0</span><span class="s1">] &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self.defaulted_states[state] = rules[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">disable_defaulted_states(self):</span>
        <span class="s1">self.defaulted_states = {}</span>

    <span class="s2">def </span><span class="s1">parse(self</span><span class="s2">, </span><span class="s1">input=</span><span class="s2">None, </span><span class="s1">lexer=</span><span class="s2">None, </span><span class="s1">debug=</span><span class="s2">False, </span><span class="s1">tracking=</span><span class="s2">False, </span><span class="s1">tokenfunc=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">debug </span><span class="s2">or </span><span class="s1">yaccdevel:</span>
            <span class="s2">if </span><span class="s1">isinstance(debug</span><span class="s2">, </span><span class="s1">int):</span>
                <span class="s1">debug = PlyLogger(sys.stderr)</span>
            <span class="s2">return </span><span class="s1">self.parsedebug(input</span><span class="s2">, </span><span class="s1">lexer</span><span class="s2">, </span><span class="s1">debug</span><span class="s2">, </span><span class="s1">tracking</span><span class="s2">, </span><span class="s1">tokenfunc)</span>
        <span class="s2">elif </span><span class="s1">tracking:</span>
            <span class="s2">return </span><span class="s1">self.parseopt(input</span><span class="s2">, </span><span class="s1">lexer</span><span class="s2">, </span><span class="s1">debug</span><span class="s2">, </span><span class="s1">tracking</span><span class="s2">, </span><span class="s1">tokenfunc)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.parseopt_notrack(input</span><span class="s2">, </span><span class="s1">lexer</span><span class="s2">, </span><span class="s1">debug</span><span class="s2">, </span><span class="s1">tracking</span><span class="s2">, </span><span class="s1">tokenfunc)</span>


    <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
    <span class="s0"># parsedebug().</span>
    <span class="s0">#</span>
    <span class="s0"># This is the debugging enabled version of parse().  All changes made to the</span>
    <span class="s0"># parsing engine should be made here.   Optimized versions of this function</span>
    <span class="s0"># are automatically created by the ply/ygen.py script.  This script cuts out</span>
    <span class="s0"># sections enclosed in markers such as this:</span>
    <span class="s0">#</span>
    <span class="s0">#      #--! DEBUG</span>
    <span class="s0">#      statements</span>
    <span class="s0">#      #--! DEBUG</span>
    <span class="s0">#</span>
    <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

    <span class="s2">def </span><span class="s1">parsedebug(self</span><span class="s2">, </span><span class="s1">input=</span><span class="s2">None, </span><span class="s1">lexer=</span><span class="s2">None, </span><span class="s1">debug=</span><span class="s2">False, </span><span class="s1">tracking=</span><span class="s2">False, </span><span class="s1">tokenfunc=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">#--! parsedebug-start</span>
        <span class="s1">lookahead = </span><span class="s2">None                         </span><span class="s0"># Current lookahead symbol</span>
        <span class="s1">lookaheadstack = []                      </span><span class="s0"># Stack of lookahead symbols</span>
        <span class="s1">actions = self.action                    </span><span class="s0"># Local reference to action table (to avoid lookup on self.)</span>
        <span class="s1">goto    = self.goto                      </span><span class="s0"># Local reference to goto table (to avoid lookup on self.)</span>
        <span class="s1">prod    = self.productions               </span><span class="s0"># Local reference to production list (to avoid lookup on self.)</span>
        <span class="s1">defaulted_states = self.defaulted_states </span><span class="s0"># Local reference to defaulted states</span>
        <span class="s1">pslice  = YaccProduction(</span><span class="s2">None</span><span class="s1">)           </span><span class="s0"># Production object passed to grammar rules</span>
        <span class="s1">errorcount = </span><span class="s4">0                           </span><span class="s0"># Used during error recovery</span>

        <span class="s0">#--! DEBUG</span>
        <span class="s1">debug.info(</span><span class="s3">'PLY: PARSE DEBUG START'</span><span class="s1">)</span>
        <span class="s0">#--! DEBUG</span>

        <span class="s0"># If no lexer was given, we will try to use the lex module</span>
        <span class="s2">if not </span><span class="s1">lexer:</span>
            <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">lex</span>
            <span class="s1">lexer = lex.lexer</span>

        <span class="s0"># Set up the lexer and parser objects on pslice</span>
        <span class="s1">pslice.lexer = lexer</span>
        <span class="s1">pslice.parser = self</span>

        <span class="s0"># If input was supplied, pass to lexer</span>
        <span class="s2">if </span><span class="s1">input </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">lexer.input(input)</span>

        <span class="s2">if </span><span class="s1">tokenfunc </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># Tokenize function</span>
            <span class="s1">get_token = lexer.token</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">get_token = tokenfunc</span>

        <span class="s0"># Set the parser() token method (sometimes used in error recovery)</span>
        <span class="s1">self.token = get_token</span>

        <span class="s0"># Set up the state and symbol stacks</span>

        <span class="s1">statestack = []                </span><span class="s0"># Stack of parsing states</span>
        <span class="s1">self.statestack = statestack</span>
        <span class="s1">symstack   = []                </span><span class="s0"># Stack of grammar symbols</span>
        <span class="s1">self.symstack = symstack</span>

        <span class="s1">pslice.stack = symstack         </span><span class="s0"># Put in the production</span>
        <span class="s1">errtoken   = </span><span class="s2">None               </span><span class="s0"># Err token</span>

        <span class="s0"># The start state is assumed to be (0,$end)</span>

        <span class="s1">statestack.append(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">sym = YaccSymbol()</span>
        <span class="s1">sym.type = </span><span class="s3">'$end'</span>
        <span class="s1">symstack.append(sym)</span>
        <span class="s1">state = </span><span class="s4">0</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s0"># Get the next symbol on the input.  If a lookahead symbol</span>
            <span class="s0"># is already set, we just use that. Otherwise, we'll pull</span>
            <span class="s0"># the next token off of the lookaheadstack or from the lexer</span>

            <span class="s0">#--! DEBUG</span>
            <span class="s1">debug.debug(</span><span class="s3">''</span><span class="s1">)</span>
            <span class="s1">debug.debug(</span><span class="s3">'State  : %s'</span><span class="s2">, </span><span class="s1">state)</span>
            <span class="s0">#--! DEBUG</span>

            <span class="s2">if </span><span class="s1">state </span><span class="s2">not in </span><span class="s1">defaulted_states:</span>
                <span class="s2">if not </span><span class="s1">lookahead:</span>
                    <span class="s2">if not </span><span class="s1">lookaheadstack:</span>
                        <span class="s1">lookahead = get_token()     </span><span class="s0"># Get the next token</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">lookahead = lookaheadstack.pop()</span>
                    <span class="s2">if not </span><span class="s1">lookahead:</span>
                        <span class="s1">lookahead = YaccSymbol()</span>
                        <span class="s1">lookahead.type = </span><span class="s3">'$end'</span>

                <span class="s0"># Check the action table</span>
                <span class="s1">ltype = lookahead.type</span>
                <span class="s1">t = actions[state].get(ltype)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">t = defaulted_states[state]</span>
                <span class="s0">#--! DEBUG</span>
                <span class="s1">debug.debug(</span><span class="s3">'Defaulted state %s: Reduce using %d'</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">-t)</span>
                <span class="s0">#--! DEBUG</span>

            <span class="s0">#--! DEBUG</span>
            <span class="s1">debug.debug(</span><span class="s3">'Stack  : %s'</span><span class="s2">,</span>
                        <span class="s1">(</span><span class="s3">'%s . %s' </span><span class="s1">% (</span><span class="s3">' '</span><span class="s1">.join([xx.type </span><span class="s2">for </span><span class="s1">xx </span><span class="s2">in </span><span class="s1">symstack][</span><span class="s4">1</span><span class="s1">:])</span><span class="s2">, </span><span class="s1">str(lookahead))).lstrip())</span>
            <span class="s0">#--! DEBUG</span>

            <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">t &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s0"># shift a symbol on the stack</span>
                    <span class="s1">statestack.append(t)</span>
                    <span class="s1">state = t</span>

                    <span class="s0">#--! DEBUG</span>
                    <span class="s1">debug.debug(</span><span class="s3">'Action : Shift and goto state %s'</span><span class="s2">, </span><span class="s1">t)</span>
                    <span class="s0">#--! DEBUG</span>

                    <span class="s1">symstack.append(lookahead)</span>
                    <span class="s1">lookahead = </span><span class="s2">None</span>

                    <span class="s0"># Decrease error count on successful shift</span>
                    <span class="s2">if </span><span class="s1">errorcount:</span>
                        <span class="s1">errorcount -= </span><span class="s4">1</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">t &lt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s0"># reduce a symbol on the stack, emit a production</span>
                    <span class="s1">p = prod[-t]</span>
                    <span class="s1">pname = p.name</span>
                    <span class="s1">plen  = p.len</span>

                    <span class="s0"># Get production function</span>
                    <span class="s1">sym = YaccSymbol()</span>
                    <span class="s1">sym.type = pname       </span><span class="s0"># Production name</span>
                    <span class="s1">sym.value = </span><span class="s2">None</span>

                    <span class="s0">#--! DEBUG</span>
                    <span class="s2">if </span><span class="s1">plen:</span>
                        <span class="s1">debug.info(</span><span class="s3">'Action : Reduce rule [%s] with %s and goto state %d'</span><span class="s2">, </span><span class="s1">p.str</span><span class="s2">,</span>
                                   <span class="s3">'['</span><span class="s1">+</span><span class="s3">','</span><span class="s1">.join([format_stack_entry(_v.value) </span><span class="s2">for </span><span class="s1">_v </span><span class="s2">in </span><span class="s1">symstack[-plen:]])+</span><span class="s3">']'</span><span class="s2">,</span>
                                   <span class="s1">goto[statestack[-</span><span class="s4">1</span><span class="s1">-plen]][pname])</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">debug.info(</span><span class="s3">'Action : Reduce rule [%s] with %s and goto state %d'</span><span class="s2">, </span><span class="s1">p.str</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">,</span>
                                   <span class="s1">goto[statestack[-</span><span class="s4">1</span><span class="s1">]][pname])</span>

                    <span class="s0">#--! DEBUG</span>

                    <span class="s2">if </span><span class="s1">plen:</span>
                        <span class="s1">targ = symstack[-plen-</span><span class="s4">1</span><span class="s1">:]</span>
                        <span class="s1">targ[</span><span class="s4">0</span><span class="s1">] = sym</span>

                        <span class="s0">#--! TRACKING</span>
                        <span class="s2">if </span><span class="s1">tracking:</span>
                            <span class="s1">t1 = targ[</span><span class="s4">1</span><span class="s1">]</span>
                            <span class="s1">sym.lineno = t1.lineno</span>
                            <span class="s1">sym.lexpos = t1.lexpos</span>
                            <span class="s1">t1 = targ[-</span><span class="s4">1</span><span class="s1">]</span>
                            <span class="s1">sym.endlineno = getattr(t1</span><span class="s2">, </span><span class="s3">'endlineno'</span><span class="s2">, </span><span class="s1">t1.lineno)</span>
                            <span class="s1">sym.endlexpos = getattr(t1</span><span class="s2">, </span><span class="s3">'endlexpos'</span><span class="s2">, </span><span class="s1">t1.lexpos)</span>
                        <span class="s0">#--! TRACKING</span>

                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
                        <span class="s0"># The code enclosed in this section is duplicated</span>
                        <span class="s0"># below as a performance optimization.  Make sure</span>
                        <span class="s0"># changes get made in both locations.</span>

                        <span class="s1">pslice.slice = targ</span>

                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s0"># Call the grammar rule with our special slice object</span>
                            <span class="s2">del </span><span class="s1">symstack[-plen:]</span>
                            <span class="s1">self.state = state</span>
                            <span class="s1">p.callable(pslice)</span>
                            <span class="s2">del </span><span class="s1">statestack[-plen:]</span>
                            <span class="s0">#--! DEBUG</span>
                            <span class="s1">debug.info(</span><span class="s3">'Result : %s'</span><span class="s2">, </span><span class="s1">format_result(pslice[</span><span class="s4">0</span><span class="s1">]))</span>
                            <span class="s0">#--! DEBUG</span>
                            <span class="s1">symstack.append(sym)</span>
                            <span class="s1">state = goto[statestack[-</span><span class="s4">1</span><span class="s1">]][pname]</span>
                            <span class="s1">statestack.append(state)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError:</span>
                            <span class="s0"># If an error was set. Enter error recovery state</span>
                            <span class="s1">lookaheadstack.append(lookahead)    </span><span class="s0"># Save the current lookahead token</span>
                            <span class="s1">symstack.extend(targ[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">])         </span><span class="s0"># Put the production slice back on the stack</span>
                            <span class="s1">statestack.pop()                    </span><span class="s0"># Pop back one state (before the reduce)</span>
                            <span class="s1">state = statestack[-</span><span class="s4">1</span><span class="s1">]</span>
                            <span class="s1">sym.type = </span><span class="s3">'error'</span>
                            <span class="s1">sym.value = </span><span class="s3">'error'</span>
                            <span class="s1">lookahead = sym</span>
                            <span class="s1">errorcount = error_count</span>
                            <span class="s1">self.errorok = </span><span class="s2">False</span>

                        <span class="s2">continue</span>
                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

                    <span class="s2">else</span><span class="s1">:</span>

                        <span class="s0">#--! TRACKING</span>
                        <span class="s2">if </span><span class="s1">tracking:</span>
                            <span class="s1">sym.lineno = lexer.lineno</span>
                            <span class="s1">sym.lexpos = lexer.lexpos</span>
                        <span class="s0">#--! TRACKING</span>

                        <span class="s1">targ = [sym]</span>

                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
                        <span class="s0"># The code enclosed in this section is duplicated</span>
                        <span class="s0"># above as a performance optimization.  Make sure</span>
                        <span class="s0"># changes get made in both locations.</span>

                        <span class="s1">pslice.slice = targ</span>

                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s0"># Call the grammar rule with our special slice object</span>
                            <span class="s1">self.state = state</span>
                            <span class="s1">p.callable(pslice)</span>
                            <span class="s0">#--! DEBUG</span>
                            <span class="s1">debug.info(</span><span class="s3">'Result : %s'</span><span class="s2">, </span><span class="s1">format_result(pslice[</span><span class="s4">0</span><span class="s1">]))</span>
                            <span class="s0">#--! DEBUG</span>
                            <span class="s1">symstack.append(sym)</span>
                            <span class="s1">state = goto[statestack[-</span><span class="s4">1</span><span class="s1">]][pname]</span>
                            <span class="s1">statestack.append(state)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError:</span>
                            <span class="s0"># If an error was set. Enter error recovery state</span>
                            <span class="s1">lookaheadstack.append(lookahead)    </span><span class="s0"># Save the current lookahead token</span>
                            <span class="s1">statestack.pop()                    </span><span class="s0"># Pop back one state (before the reduce)</span>
                            <span class="s1">state = statestack[-</span><span class="s4">1</span><span class="s1">]</span>
                            <span class="s1">sym.type = </span><span class="s3">'error'</span>
                            <span class="s1">sym.value = </span><span class="s3">'error'</span>
                            <span class="s1">lookahead = sym</span>
                            <span class="s1">errorcount = error_count</span>
                            <span class="s1">self.errorok = </span><span class="s2">False</span>

                        <span class="s2">continue</span>
                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

                <span class="s2">if </span><span class="s1">t == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">n = symstack[-</span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s1">result = getattr(n</span><span class="s2">, </span><span class="s3">'value'</span><span class="s2">, None</span><span class="s1">)</span>
                    <span class="s0">#--! DEBUG</span>
                    <span class="s1">debug.info(</span><span class="s3">'Done   : Returning %s'</span><span class="s2">, </span><span class="s1">format_result(result))</span>
                    <span class="s1">debug.info(</span><span class="s3">'PLY: PARSE DEBUG END'</span><span class="s1">)</span>
                    <span class="s0">#--! DEBUG</span>
                    <span class="s2">return </span><span class="s1">result</span>

            <span class="s2">if </span><span class="s1">t </span><span class="s2">is None</span><span class="s1">:</span>

                <span class="s0">#--! DEBUG</span>
                <span class="s1">debug.error(</span><span class="s3">'Error  : %s'</span><span class="s2">,</span>
                            <span class="s1">(</span><span class="s3">'%s . %s' </span><span class="s1">% (</span><span class="s3">' '</span><span class="s1">.join([xx.type </span><span class="s2">for </span><span class="s1">xx </span><span class="s2">in </span><span class="s1">symstack][</span><span class="s4">1</span><span class="s1">:])</span><span class="s2">, </span><span class="s1">str(lookahead))).lstrip())</span>
                <span class="s0">#--! DEBUG</span>

                <span class="s0"># We have some kind of parsing error here.  To handle</span>
                <span class="s0"># this, we are going to push the current token onto</span>
                <span class="s0"># the tokenstack and replace it with an 'error' token.</span>
                <span class="s0"># If there are any synchronization rules, they may</span>
                <span class="s0"># catch it.</span>
                <span class="s0">#</span>
                <span class="s0"># In addition to pushing the error token, we call call</span>
                <span class="s0"># the user defined p_error() function if this is the</span>
                <span class="s0"># first syntax error.  This function is only called if</span>
                <span class="s0"># errorcount == 0.</span>
                <span class="s2">if </span><span class="s1">errorcount == </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">self.errorok:</span>
                    <span class="s1">errorcount = error_count</span>
                    <span class="s1">self.errorok = </span><span class="s2">False</span>
                    <span class="s1">errtoken = lookahead</span>
                    <span class="s2">if </span><span class="s1">errtoken.type == </span><span class="s3">'$end'</span><span class="s1">:</span>
                        <span class="s1">errtoken = </span><span class="s2">None               </span><span class="s0"># End of file!</span>
                    <span class="s2">if </span><span class="s1">self.errorfunc:</span>
                        <span class="s2">if </span><span class="s1">errtoken </span><span class="s2">and not </span><span class="s1">hasattr(errtoken</span><span class="s2">, </span><span class="s3">'lexer'</span><span class="s1">):</span>
                            <span class="s1">errtoken.lexer = lexer</span>
                        <span class="s1">self.state = state</span>
                        <span class="s1">tok = call_errorfunc(self.errorfunc</span><span class="s2">, </span><span class="s1">errtoken</span><span class="s2">, </span><span class="s1">self)</span>
                        <span class="s2">if </span><span class="s1">self.errorok:</span>
                            <span class="s0"># User must have done some kind of panic</span>
                            <span class="s0"># mode recovery on their own.  The</span>
                            <span class="s0"># returned token is the next lookahead</span>
                            <span class="s1">lookahead = tok</span>
                            <span class="s1">errtoken = </span><span class="s2">None</span>
                            <span class="s2">continue</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">errtoken:</span>
                            <span class="s2">if </span><span class="s1">hasattr(errtoken</span><span class="s2">, </span><span class="s3">'lineno'</span><span class="s1">):</span>
                                <span class="s1">lineno = lookahead.lineno</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">lineno = </span><span class="s4">0</span>
                            <span class="s2">if </span><span class="s1">lineno:</span>
                                <span class="s1">sys.stderr.write(</span><span class="s3">'yacc: Syntax error at line %d, token=%s</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">% (lineno</span><span class="s2">, </span><span class="s1">errtoken.type))</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">sys.stderr.write(</span><span class="s3">'yacc: Syntax error, token=%s' </span><span class="s1">% errtoken.type)</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">sys.stderr.write(</span><span class="s3">'yacc: Parse error in input. EOF</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
                            <span class="s2">return</span>

                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">errorcount = error_count</span>

                <span class="s0"># case 1:  the statestack only has 1 entry on it.  If we're in this state, the</span>
                <span class="s0"># entire parse has been rolled back and we're completely hosed.   The token is</span>
                <span class="s0"># discarded and we just keep going.</span>

                <span class="s2">if </span><span class="s1">len(statestack) &lt;= </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">lookahead.type != </span><span class="s3">'$end'</span><span class="s1">:</span>
                    <span class="s1">lookahead = </span><span class="s2">None</span>
                    <span class="s1">errtoken = </span><span class="s2">None</span>
                    <span class="s1">state = </span><span class="s4">0</span>
                    <span class="s0"># Nuke the pushback stack</span>
                    <span class="s2">del </span><span class="s1">lookaheadstack[:]</span>
                    <span class="s2">continue</span>

                <span class="s0"># case 2: the statestack has a couple of entries on it, but we're</span>
                <span class="s0"># at the end of the file. nuke the top entry and generate an error token</span>

                <span class="s0"># Start nuking entries on the stack</span>
                <span class="s2">if </span><span class="s1">lookahead.type == </span><span class="s3">'$end'</span><span class="s1">:</span>
                    <span class="s0"># Whoa. We're really hosed here. Bail out</span>
                    <span class="s2">return</span>

                <span class="s2">if </span><span class="s1">lookahead.type != </span><span class="s3">'error'</span><span class="s1">:</span>
                    <span class="s1">sym = symstack[-</span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s2">if </span><span class="s1">sym.type == </span><span class="s3">'error'</span><span class="s1">:</span>
                        <span class="s0"># Hmmm. Error is on top of stack, we'll just nuke input</span>
                        <span class="s0"># symbol and continue</span>
                        <span class="s0">#--! TRACKING</span>
                        <span class="s2">if </span><span class="s1">tracking:</span>
                            <span class="s1">sym.endlineno = getattr(lookahead</span><span class="s2">, </span><span class="s3">'lineno'</span><span class="s2">, </span><span class="s1">sym.lineno)</span>
                            <span class="s1">sym.endlexpos = getattr(lookahead</span><span class="s2">, </span><span class="s3">'lexpos'</span><span class="s2">, </span><span class="s1">sym.lexpos)</span>
                        <span class="s0">#--! TRACKING</span>
                        <span class="s1">lookahead = </span><span class="s2">None</span>
                        <span class="s2">continue</span>

                    <span class="s0"># Create the error symbol for the first time and make it the new lookahead symbol</span>
                    <span class="s1">t = YaccSymbol()</span>
                    <span class="s1">t.type = </span><span class="s3">'error'</span>

                    <span class="s2">if </span><span class="s1">hasattr(lookahead</span><span class="s2">, </span><span class="s3">'lineno'</span><span class="s1">):</span>
                        <span class="s1">t.lineno = t.endlineno = lookahead.lineno</span>
                    <span class="s2">if </span><span class="s1">hasattr(lookahead</span><span class="s2">, </span><span class="s3">'lexpos'</span><span class="s1">):</span>
                        <span class="s1">t.lexpos = t.endlexpos = lookahead.lexpos</span>
                    <span class="s1">t.value = lookahead</span>
                    <span class="s1">lookaheadstack.append(lookahead)</span>
                    <span class="s1">lookahead = t</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">sym = symstack.pop()</span>
                    <span class="s0">#--! TRACKING</span>
                    <span class="s2">if </span><span class="s1">tracking:</span>
                        <span class="s1">lookahead.lineno = sym.lineno</span>
                        <span class="s1">lookahead.lexpos = sym.lexpos</span>
                    <span class="s0">#--! TRACKING</span>
                    <span class="s1">statestack.pop()</span>
                    <span class="s1">state = statestack[-</span><span class="s4">1</span><span class="s1">]</span>

                <span class="s2">continue</span>

            <span class="s0"># Call an error function here</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'yacc: internal parser error!!!</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s0">#--! parsedebug-end</span>

    <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
    <span class="s0"># parseopt().</span>
    <span class="s0">#</span>
    <span class="s0"># Optimized version of parse() method.  DO NOT EDIT THIS CODE DIRECTLY!</span>
    <span class="s0"># This code is automatically generated by the ply/ygen.py script. Make</span>
    <span class="s0"># changes to the parsedebug() method instead.</span>
    <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

    <span class="s2">def </span><span class="s1">parseopt(self</span><span class="s2">, </span><span class="s1">input=</span><span class="s2">None, </span><span class="s1">lexer=</span><span class="s2">None, </span><span class="s1">debug=</span><span class="s2">False, </span><span class="s1">tracking=</span><span class="s2">False, </span><span class="s1">tokenfunc=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">#--! parseopt-start</span>
        <span class="s1">lookahead = </span><span class="s2">None                         </span><span class="s0"># Current lookahead symbol</span>
        <span class="s1">lookaheadstack = []                      </span><span class="s0"># Stack of lookahead symbols</span>
        <span class="s1">actions = self.action                    </span><span class="s0"># Local reference to action table (to avoid lookup on self.)</span>
        <span class="s1">goto    = self.goto                      </span><span class="s0"># Local reference to goto table (to avoid lookup on self.)</span>
        <span class="s1">prod    = self.productions               </span><span class="s0"># Local reference to production list (to avoid lookup on self.)</span>
        <span class="s1">defaulted_states = self.defaulted_states </span><span class="s0"># Local reference to defaulted states</span>
        <span class="s1">pslice  = YaccProduction(</span><span class="s2">None</span><span class="s1">)           </span><span class="s0"># Production object passed to grammar rules</span>
        <span class="s1">errorcount = </span><span class="s4">0                           </span><span class="s0"># Used during error recovery</span>


        <span class="s0"># If no lexer was given, we will try to use the lex module</span>
        <span class="s2">if not </span><span class="s1">lexer:</span>
            <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">lex</span>
            <span class="s1">lexer = lex.lexer</span>

        <span class="s0"># Set up the lexer and parser objects on pslice</span>
        <span class="s1">pslice.lexer = lexer</span>
        <span class="s1">pslice.parser = self</span>

        <span class="s0"># If input was supplied, pass to lexer</span>
        <span class="s2">if </span><span class="s1">input </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">lexer.input(input)</span>

        <span class="s2">if </span><span class="s1">tokenfunc </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># Tokenize function</span>
            <span class="s1">get_token = lexer.token</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">get_token = tokenfunc</span>

        <span class="s0"># Set the parser() token method (sometimes used in error recovery)</span>
        <span class="s1">self.token = get_token</span>

        <span class="s0"># Set up the state and symbol stacks</span>

        <span class="s1">statestack = []                </span><span class="s0"># Stack of parsing states</span>
        <span class="s1">self.statestack = statestack</span>
        <span class="s1">symstack   = []                </span><span class="s0"># Stack of grammar symbols</span>
        <span class="s1">self.symstack = symstack</span>

        <span class="s1">pslice.stack = symstack         </span><span class="s0"># Put in the production</span>
        <span class="s1">errtoken   = </span><span class="s2">None               </span><span class="s0"># Err token</span>

        <span class="s0"># The start state is assumed to be (0,$end)</span>

        <span class="s1">statestack.append(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">sym = YaccSymbol()</span>
        <span class="s1">sym.type = </span><span class="s3">'$end'</span>
        <span class="s1">symstack.append(sym)</span>
        <span class="s1">state = </span><span class="s4">0</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s0"># Get the next symbol on the input.  If a lookahead symbol</span>
            <span class="s0"># is already set, we just use that. Otherwise, we'll pull</span>
            <span class="s0"># the next token off of the lookaheadstack or from the lexer</span>


            <span class="s2">if </span><span class="s1">state </span><span class="s2">not in </span><span class="s1">defaulted_states:</span>
                <span class="s2">if not </span><span class="s1">lookahead:</span>
                    <span class="s2">if not </span><span class="s1">lookaheadstack:</span>
                        <span class="s1">lookahead = get_token()     </span><span class="s0"># Get the next token</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">lookahead = lookaheadstack.pop()</span>
                    <span class="s2">if not </span><span class="s1">lookahead:</span>
                        <span class="s1">lookahead = YaccSymbol()</span>
                        <span class="s1">lookahead.type = </span><span class="s3">'$end'</span>

                <span class="s0"># Check the action table</span>
                <span class="s1">ltype = lookahead.type</span>
                <span class="s1">t = actions[state].get(ltype)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">t = defaulted_states[state]</span>


            <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">t &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s0"># shift a symbol on the stack</span>
                    <span class="s1">statestack.append(t)</span>
                    <span class="s1">state = t</span>


                    <span class="s1">symstack.append(lookahead)</span>
                    <span class="s1">lookahead = </span><span class="s2">None</span>

                    <span class="s0"># Decrease error count on successful shift</span>
                    <span class="s2">if </span><span class="s1">errorcount:</span>
                        <span class="s1">errorcount -= </span><span class="s4">1</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">t &lt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s0"># reduce a symbol on the stack, emit a production</span>
                    <span class="s1">p = prod[-t]</span>
                    <span class="s1">pname = p.name</span>
                    <span class="s1">plen  = p.len</span>

                    <span class="s0"># Get production function</span>
                    <span class="s1">sym = YaccSymbol()</span>
                    <span class="s1">sym.type = pname       </span><span class="s0"># Production name</span>
                    <span class="s1">sym.value = </span><span class="s2">None</span>


                    <span class="s2">if </span><span class="s1">plen:</span>
                        <span class="s1">targ = symstack[-plen-</span><span class="s4">1</span><span class="s1">:]</span>
                        <span class="s1">targ[</span><span class="s4">0</span><span class="s1">] = sym</span>

                        <span class="s0">#--! TRACKING</span>
                        <span class="s2">if </span><span class="s1">tracking:</span>
                            <span class="s1">t1 = targ[</span><span class="s4">1</span><span class="s1">]</span>
                            <span class="s1">sym.lineno = t1.lineno</span>
                            <span class="s1">sym.lexpos = t1.lexpos</span>
                            <span class="s1">t1 = targ[-</span><span class="s4">1</span><span class="s1">]</span>
                            <span class="s1">sym.endlineno = getattr(t1</span><span class="s2">, </span><span class="s3">'endlineno'</span><span class="s2">, </span><span class="s1">t1.lineno)</span>
                            <span class="s1">sym.endlexpos = getattr(t1</span><span class="s2">, </span><span class="s3">'endlexpos'</span><span class="s2">, </span><span class="s1">t1.lexpos)</span>
                        <span class="s0">#--! TRACKING</span>

                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
                        <span class="s0"># The code enclosed in this section is duplicated</span>
                        <span class="s0"># below as a performance optimization.  Make sure</span>
                        <span class="s0"># changes get made in both locations.</span>

                        <span class="s1">pslice.slice = targ</span>

                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s0"># Call the grammar rule with our special slice object</span>
                            <span class="s2">del </span><span class="s1">symstack[-plen:]</span>
                            <span class="s1">self.state = state</span>
                            <span class="s1">p.callable(pslice)</span>
                            <span class="s2">del </span><span class="s1">statestack[-plen:]</span>
                            <span class="s1">symstack.append(sym)</span>
                            <span class="s1">state = goto[statestack[-</span><span class="s4">1</span><span class="s1">]][pname]</span>
                            <span class="s1">statestack.append(state)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError:</span>
                            <span class="s0"># If an error was set. Enter error recovery state</span>
                            <span class="s1">lookaheadstack.append(lookahead)    </span><span class="s0"># Save the current lookahead token</span>
                            <span class="s1">symstack.extend(targ[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">])         </span><span class="s0"># Put the production slice back on the stack</span>
                            <span class="s1">statestack.pop()                    </span><span class="s0"># Pop back one state (before the reduce)</span>
                            <span class="s1">state = statestack[-</span><span class="s4">1</span><span class="s1">]</span>
                            <span class="s1">sym.type = </span><span class="s3">'error'</span>
                            <span class="s1">sym.value = </span><span class="s3">'error'</span>
                            <span class="s1">lookahead = sym</span>
                            <span class="s1">errorcount = error_count</span>
                            <span class="s1">self.errorok = </span><span class="s2">False</span>

                        <span class="s2">continue</span>
                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

                    <span class="s2">else</span><span class="s1">:</span>

                        <span class="s0">#--! TRACKING</span>
                        <span class="s2">if </span><span class="s1">tracking:</span>
                            <span class="s1">sym.lineno = lexer.lineno</span>
                            <span class="s1">sym.lexpos = lexer.lexpos</span>
                        <span class="s0">#--! TRACKING</span>

                        <span class="s1">targ = [sym]</span>

                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
                        <span class="s0"># The code enclosed in this section is duplicated</span>
                        <span class="s0"># above as a performance optimization.  Make sure</span>
                        <span class="s0"># changes get made in both locations.</span>

                        <span class="s1">pslice.slice = targ</span>

                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s0"># Call the grammar rule with our special slice object</span>
                            <span class="s1">self.state = state</span>
                            <span class="s1">p.callable(pslice)</span>
                            <span class="s1">symstack.append(sym)</span>
                            <span class="s1">state = goto[statestack[-</span><span class="s4">1</span><span class="s1">]][pname]</span>
                            <span class="s1">statestack.append(state)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError:</span>
                            <span class="s0"># If an error was set. Enter error recovery state</span>
                            <span class="s1">lookaheadstack.append(lookahead)    </span><span class="s0"># Save the current lookahead token</span>
                            <span class="s1">statestack.pop()                    </span><span class="s0"># Pop back one state (before the reduce)</span>
                            <span class="s1">state = statestack[-</span><span class="s4">1</span><span class="s1">]</span>
                            <span class="s1">sym.type = </span><span class="s3">'error'</span>
                            <span class="s1">sym.value = </span><span class="s3">'error'</span>
                            <span class="s1">lookahead = sym</span>
                            <span class="s1">errorcount = error_count</span>
                            <span class="s1">self.errorok = </span><span class="s2">False</span>

                        <span class="s2">continue</span>
                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

                <span class="s2">if </span><span class="s1">t == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">n = symstack[-</span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s1">result = getattr(n</span><span class="s2">, </span><span class="s3">'value'</span><span class="s2">, None</span><span class="s1">)</span>
                    <span class="s2">return </span><span class="s1">result</span>

            <span class="s2">if </span><span class="s1">t </span><span class="s2">is None</span><span class="s1">:</span>


                <span class="s0"># We have some kind of parsing error here.  To handle</span>
                <span class="s0"># this, we are going to push the current token onto</span>
                <span class="s0"># the tokenstack and replace it with an 'error' token.</span>
                <span class="s0"># If there are any synchronization rules, they may</span>
                <span class="s0"># catch it.</span>
                <span class="s0">#</span>
                <span class="s0"># In addition to pushing the error token, we call call</span>
                <span class="s0"># the user defined p_error() function if this is the</span>
                <span class="s0"># first syntax error.  This function is only called if</span>
                <span class="s0"># errorcount == 0.</span>
                <span class="s2">if </span><span class="s1">errorcount == </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">self.errorok:</span>
                    <span class="s1">errorcount = error_count</span>
                    <span class="s1">self.errorok = </span><span class="s2">False</span>
                    <span class="s1">errtoken = lookahead</span>
                    <span class="s2">if </span><span class="s1">errtoken.type == </span><span class="s3">'$end'</span><span class="s1">:</span>
                        <span class="s1">errtoken = </span><span class="s2">None               </span><span class="s0"># End of file!</span>
                    <span class="s2">if </span><span class="s1">self.errorfunc:</span>
                        <span class="s2">if </span><span class="s1">errtoken </span><span class="s2">and not </span><span class="s1">hasattr(errtoken</span><span class="s2">, </span><span class="s3">'lexer'</span><span class="s1">):</span>
                            <span class="s1">errtoken.lexer = lexer</span>
                        <span class="s1">self.state = state</span>
                        <span class="s1">tok = call_errorfunc(self.errorfunc</span><span class="s2">, </span><span class="s1">errtoken</span><span class="s2">, </span><span class="s1">self)</span>
                        <span class="s2">if </span><span class="s1">self.errorok:</span>
                            <span class="s0"># User must have done some kind of panic</span>
                            <span class="s0"># mode recovery on their own.  The</span>
                            <span class="s0"># returned token is the next lookahead</span>
                            <span class="s1">lookahead = tok</span>
                            <span class="s1">errtoken = </span><span class="s2">None</span>
                            <span class="s2">continue</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">errtoken:</span>
                            <span class="s2">if </span><span class="s1">hasattr(errtoken</span><span class="s2">, </span><span class="s3">'lineno'</span><span class="s1">):</span>
                                <span class="s1">lineno = lookahead.lineno</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">lineno = </span><span class="s4">0</span>
                            <span class="s2">if </span><span class="s1">lineno:</span>
                                <span class="s1">sys.stderr.write(</span><span class="s3">'yacc: Syntax error at line %d, token=%s</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">% (lineno</span><span class="s2">, </span><span class="s1">errtoken.type))</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">sys.stderr.write(</span><span class="s3">'yacc: Syntax error, token=%s' </span><span class="s1">% errtoken.type)</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">sys.stderr.write(</span><span class="s3">'yacc: Parse error in input. EOF</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
                            <span class="s2">return</span>

                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">errorcount = error_count</span>

                <span class="s0"># case 1:  the statestack only has 1 entry on it.  If we're in this state, the</span>
                <span class="s0"># entire parse has been rolled back and we're completely hosed.   The token is</span>
                <span class="s0"># discarded and we just keep going.</span>

                <span class="s2">if </span><span class="s1">len(statestack) &lt;= </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">lookahead.type != </span><span class="s3">'$end'</span><span class="s1">:</span>
                    <span class="s1">lookahead = </span><span class="s2">None</span>
                    <span class="s1">errtoken = </span><span class="s2">None</span>
                    <span class="s1">state = </span><span class="s4">0</span>
                    <span class="s0"># Nuke the pushback stack</span>
                    <span class="s2">del </span><span class="s1">lookaheadstack[:]</span>
                    <span class="s2">continue</span>

                <span class="s0"># case 2: the statestack has a couple of entries on it, but we're</span>
                <span class="s0"># at the end of the file. nuke the top entry and generate an error token</span>

                <span class="s0"># Start nuking entries on the stack</span>
                <span class="s2">if </span><span class="s1">lookahead.type == </span><span class="s3">'$end'</span><span class="s1">:</span>
                    <span class="s0"># Whoa. We're really hosed here. Bail out</span>
                    <span class="s2">return</span>

                <span class="s2">if </span><span class="s1">lookahead.type != </span><span class="s3">'error'</span><span class="s1">:</span>
                    <span class="s1">sym = symstack[-</span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s2">if </span><span class="s1">sym.type == </span><span class="s3">'error'</span><span class="s1">:</span>
                        <span class="s0"># Hmmm. Error is on top of stack, we'll just nuke input</span>
                        <span class="s0"># symbol and continue</span>
                        <span class="s0">#--! TRACKING</span>
                        <span class="s2">if </span><span class="s1">tracking:</span>
                            <span class="s1">sym.endlineno = getattr(lookahead</span><span class="s2">, </span><span class="s3">'lineno'</span><span class="s2">, </span><span class="s1">sym.lineno)</span>
                            <span class="s1">sym.endlexpos = getattr(lookahead</span><span class="s2">, </span><span class="s3">'lexpos'</span><span class="s2">, </span><span class="s1">sym.lexpos)</span>
                        <span class="s0">#--! TRACKING</span>
                        <span class="s1">lookahead = </span><span class="s2">None</span>
                        <span class="s2">continue</span>

                    <span class="s0"># Create the error symbol for the first time and make it the new lookahead symbol</span>
                    <span class="s1">t = YaccSymbol()</span>
                    <span class="s1">t.type = </span><span class="s3">'error'</span>

                    <span class="s2">if </span><span class="s1">hasattr(lookahead</span><span class="s2">, </span><span class="s3">'lineno'</span><span class="s1">):</span>
                        <span class="s1">t.lineno = t.endlineno = lookahead.lineno</span>
                    <span class="s2">if </span><span class="s1">hasattr(lookahead</span><span class="s2">, </span><span class="s3">'lexpos'</span><span class="s1">):</span>
                        <span class="s1">t.lexpos = t.endlexpos = lookahead.lexpos</span>
                    <span class="s1">t.value = lookahead</span>
                    <span class="s1">lookaheadstack.append(lookahead)</span>
                    <span class="s1">lookahead = t</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">sym = symstack.pop()</span>
                    <span class="s0">#--! TRACKING</span>
                    <span class="s2">if </span><span class="s1">tracking:</span>
                        <span class="s1">lookahead.lineno = sym.lineno</span>
                        <span class="s1">lookahead.lexpos = sym.lexpos</span>
                    <span class="s0">#--! TRACKING</span>
                    <span class="s1">statestack.pop()</span>
                    <span class="s1">state = statestack[-</span><span class="s4">1</span><span class="s1">]</span>

                <span class="s2">continue</span>

            <span class="s0"># Call an error function here</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'yacc: internal parser error!!!</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s0">#--! parseopt-end</span>

    <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
    <span class="s0"># parseopt_notrack().</span>
    <span class="s0">#</span>
    <span class="s0"># Optimized version of parseopt() with line number tracking removed.</span>
    <span class="s0"># DO NOT EDIT THIS CODE DIRECTLY. This code is automatically generated</span>
    <span class="s0"># by the ply/ygen.py script. Make changes to the parsedebug() method instead.</span>
    <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

    <span class="s2">def </span><span class="s1">parseopt_notrack(self</span><span class="s2">, </span><span class="s1">input=</span><span class="s2">None, </span><span class="s1">lexer=</span><span class="s2">None, </span><span class="s1">debug=</span><span class="s2">False, </span><span class="s1">tracking=</span><span class="s2">False, </span><span class="s1">tokenfunc=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">#--! parseopt-notrack-start</span>
        <span class="s1">lookahead = </span><span class="s2">None                         </span><span class="s0"># Current lookahead symbol</span>
        <span class="s1">lookaheadstack = []                      </span><span class="s0"># Stack of lookahead symbols</span>
        <span class="s1">actions = self.action                    </span><span class="s0"># Local reference to action table (to avoid lookup on self.)</span>
        <span class="s1">goto    = self.goto                      </span><span class="s0"># Local reference to goto table (to avoid lookup on self.)</span>
        <span class="s1">prod    = self.productions               </span><span class="s0"># Local reference to production list (to avoid lookup on self.)</span>
        <span class="s1">defaulted_states = self.defaulted_states </span><span class="s0"># Local reference to defaulted states</span>
        <span class="s1">pslice  = YaccProduction(</span><span class="s2">None</span><span class="s1">)           </span><span class="s0"># Production object passed to grammar rules</span>
        <span class="s1">errorcount = </span><span class="s4">0                           </span><span class="s0"># Used during error recovery</span>


        <span class="s0"># If no lexer was given, we will try to use the lex module</span>
        <span class="s2">if not </span><span class="s1">lexer:</span>
            <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">lex</span>
            <span class="s1">lexer = lex.lexer</span>

        <span class="s0"># Set up the lexer and parser objects on pslice</span>
        <span class="s1">pslice.lexer = lexer</span>
        <span class="s1">pslice.parser = self</span>

        <span class="s0"># If input was supplied, pass to lexer</span>
        <span class="s2">if </span><span class="s1">input </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">lexer.input(input)</span>

        <span class="s2">if </span><span class="s1">tokenfunc </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># Tokenize function</span>
            <span class="s1">get_token = lexer.token</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">get_token = tokenfunc</span>

        <span class="s0"># Set the parser() token method (sometimes used in error recovery)</span>
        <span class="s1">self.token = get_token</span>

        <span class="s0"># Set up the state and symbol stacks</span>

        <span class="s1">statestack = []                </span><span class="s0"># Stack of parsing states</span>
        <span class="s1">self.statestack = statestack</span>
        <span class="s1">symstack   = []                </span><span class="s0"># Stack of grammar symbols</span>
        <span class="s1">self.symstack = symstack</span>

        <span class="s1">pslice.stack = symstack         </span><span class="s0"># Put in the production</span>
        <span class="s1">errtoken   = </span><span class="s2">None               </span><span class="s0"># Err token</span>

        <span class="s0"># The start state is assumed to be (0,$end)</span>

        <span class="s1">statestack.append(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">sym = YaccSymbol()</span>
        <span class="s1">sym.type = </span><span class="s3">'$end'</span>
        <span class="s1">symstack.append(sym)</span>
        <span class="s1">state = </span><span class="s4">0</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s0"># Get the next symbol on the input.  If a lookahead symbol</span>
            <span class="s0"># is already set, we just use that. Otherwise, we'll pull</span>
            <span class="s0"># the next token off of the lookaheadstack or from the lexer</span>


            <span class="s2">if </span><span class="s1">state </span><span class="s2">not in </span><span class="s1">defaulted_states:</span>
                <span class="s2">if not </span><span class="s1">lookahead:</span>
                    <span class="s2">if not </span><span class="s1">lookaheadstack:</span>
                        <span class="s1">lookahead = get_token()     </span><span class="s0"># Get the next token</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">lookahead = lookaheadstack.pop()</span>
                    <span class="s2">if not </span><span class="s1">lookahead:</span>
                        <span class="s1">lookahead = YaccSymbol()</span>
                        <span class="s1">lookahead.type = </span><span class="s3">'$end'</span>

                <span class="s0"># Check the action table</span>
                <span class="s1">ltype = lookahead.type</span>
                <span class="s1">t = actions[state].get(ltype)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">t = defaulted_states[state]</span>


            <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">t &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s0"># shift a symbol on the stack</span>
                    <span class="s1">statestack.append(t)</span>
                    <span class="s1">state = t</span>


                    <span class="s1">symstack.append(lookahead)</span>
                    <span class="s1">lookahead = </span><span class="s2">None</span>

                    <span class="s0"># Decrease error count on successful shift</span>
                    <span class="s2">if </span><span class="s1">errorcount:</span>
                        <span class="s1">errorcount -= </span><span class="s4">1</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">t &lt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s0"># reduce a symbol on the stack, emit a production</span>
                    <span class="s1">p = prod[-t]</span>
                    <span class="s1">pname = p.name</span>
                    <span class="s1">plen  = p.len</span>

                    <span class="s0"># Get production function</span>
                    <span class="s1">sym = YaccSymbol()</span>
                    <span class="s1">sym.type = pname       </span><span class="s0"># Production name</span>
                    <span class="s1">sym.value = </span><span class="s2">None</span>


                    <span class="s2">if </span><span class="s1">plen:</span>
                        <span class="s1">targ = symstack[-plen-</span><span class="s4">1</span><span class="s1">:]</span>
                        <span class="s1">targ[</span><span class="s4">0</span><span class="s1">] = sym</span>


                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
                        <span class="s0"># The code enclosed in this section is duplicated</span>
                        <span class="s0"># below as a performance optimization.  Make sure</span>
                        <span class="s0"># changes get made in both locations.</span>

                        <span class="s1">pslice.slice = targ</span>

                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s0"># Call the grammar rule with our special slice object</span>
                            <span class="s2">del </span><span class="s1">symstack[-plen:]</span>
                            <span class="s1">self.state = state</span>
                            <span class="s1">p.callable(pslice)</span>
                            <span class="s2">del </span><span class="s1">statestack[-plen:]</span>
                            <span class="s1">symstack.append(sym)</span>
                            <span class="s1">state = goto[statestack[-</span><span class="s4">1</span><span class="s1">]][pname]</span>
                            <span class="s1">statestack.append(state)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError:</span>
                            <span class="s0"># If an error was set. Enter error recovery state</span>
                            <span class="s1">lookaheadstack.append(lookahead)    </span><span class="s0"># Save the current lookahead token</span>
                            <span class="s1">symstack.extend(targ[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">])         </span><span class="s0"># Put the production slice back on the stack</span>
                            <span class="s1">statestack.pop()                    </span><span class="s0"># Pop back one state (before the reduce)</span>
                            <span class="s1">state = statestack[-</span><span class="s4">1</span><span class="s1">]</span>
                            <span class="s1">sym.type = </span><span class="s3">'error'</span>
                            <span class="s1">sym.value = </span><span class="s3">'error'</span>
                            <span class="s1">lookahead = sym</span>
                            <span class="s1">errorcount = error_count</span>
                            <span class="s1">self.errorok = </span><span class="s2">False</span>

                        <span class="s2">continue</span>
                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

                    <span class="s2">else</span><span class="s1">:</span>


                        <span class="s1">targ = [sym]</span>

                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
                        <span class="s0"># The code enclosed in this section is duplicated</span>
                        <span class="s0"># above as a performance optimization.  Make sure</span>
                        <span class="s0"># changes get made in both locations.</span>

                        <span class="s1">pslice.slice = targ</span>

                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s0"># Call the grammar rule with our special slice object</span>
                            <span class="s1">self.state = state</span>
                            <span class="s1">p.callable(pslice)</span>
                            <span class="s1">symstack.append(sym)</span>
                            <span class="s1">state = goto[statestack[-</span><span class="s4">1</span><span class="s1">]][pname]</span>
                            <span class="s1">statestack.append(state)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError:</span>
                            <span class="s0"># If an error was set. Enter error recovery state</span>
                            <span class="s1">lookaheadstack.append(lookahead)    </span><span class="s0"># Save the current lookahead token</span>
                            <span class="s1">statestack.pop()                    </span><span class="s0"># Pop back one state (before the reduce)</span>
                            <span class="s1">state = statestack[-</span><span class="s4">1</span><span class="s1">]</span>
                            <span class="s1">sym.type = </span><span class="s3">'error'</span>
                            <span class="s1">sym.value = </span><span class="s3">'error'</span>
                            <span class="s1">lookahead = sym</span>
                            <span class="s1">errorcount = error_count</span>
                            <span class="s1">self.errorok = </span><span class="s2">False</span>

                        <span class="s2">continue</span>
                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

                <span class="s2">if </span><span class="s1">t == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">n = symstack[-</span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s1">result = getattr(n</span><span class="s2">, </span><span class="s3">'value'</span><span class="s2">, None</span><span class="s1">)</span>
                    <span class="s2">return </span><span class="s1">result</span>

            <span class="s2">if </span><span class="s1">t </span><span class="s2">is None</span><span class="s1">:</span>


                <span class="s0"># We have some kind of parsing error here.  To handle</span>
                <span class="s0"># this, we are going to push the current token onto</span>
                <span class="s0"># the tokenstack and replace it with an 'error' token.</span>
                <span class="s0"># If there are any synchronization rules, they may</span>
                <span class="s0"># catch it.</span>
                <span class="s0">#</span>
                <span class="s0"># In addition to pushing the error token, we call call</span>
                <span class="s0"># the user defined p_error() function if this is the</span>
                <span class="s0"># first syntax error.  This function is only called if</span>
                <span class="s0"># errorcount == 0.</span>
                <span class="s2">if </span><span class="s1">errorcount == </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">self.errorok:</span>
                    <span class="s1">errorcount = error_count</span>
                    <span class="s1">self.errorok = </span><span class="s2">False</span>
                    <span class="s1">errtoken = lookahead</span>
                    <span class="s2">if </span><span class="s1">errtoken.type == </span><span class="s3">'$end'</span><span class="s1">:</span>
                        <span class="s1">errtoken = </span><span class="s2">None               </span><span class="s0"># End of file!</span>
                    <span class="s2">if </span><span class="s1">self.errorfunc:</span>
                        <span class="s2">if </span><span class="s1">errtoken </span><span class="s2">and not </span><span class="s1">hasattr(errtoken</span><span class="s2">, </span><span class="s3">'lexer'</span><span class="s1">):</span>
                            <span class="s1">errtoken.lexer = lexer</span>
                        <span class="s1">self.state = state</span>
                        <span class="s1">tok = call_errorfunc(self.errorfunc</span><span class="s2">, </span><span class="s1">errtoken</span><span class="s2">, </span><span class="s1">self)</span>
                        <span class="s2">if </span><span class="s1">self.errorok:</span>
                            <span class="s0"># User must have done some kind of panic</span>
                            <span class="s0"># mode recovery on their own.  The</span>
                            <span class="s0"># returned token is the next lookahead</span>
                            <span class="s1">lookahead = tok</span>
                            <span class="s1">errtoken = </span><span class="s2">None</span>
                            <span class="s2">continue</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">errtoken:</span>
                            <span class="s2">if </span><span class="s1">hasattr(errtoken</span><span class="s2">, </span><span class="s3">'lineno'</span><span class="s1">):</span>
                                <span class="s1">lineno = lookahead.lineno</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">lineno = </span><span class="s4">0</span>
                            <span class="s2">if </span><span class="s1">lineno:</span>
                                <span class="s1">sys.stderr.write(</span><span class="s3">'yacc: Syntax error at line %d, token=%s</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">% (lineno</span><span class="s2">, </span><span class="s1">errtoken.type))</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">sys.stderr.write(</span><span class="s3">'yacc: Syntax error, token=%s' </span><span class="s1">% errtoken.type)</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">sys.stderr.write(</span><span class="s3">'yacc: Parse error in input. EOF</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
                            <span class="s2">return</span>

                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">errorcount = error_count</span>

                <span class="s0"># case 1:  the statestack only has 1 entry on it.  If we're in this state, the</span>
                <span class="s0"># entire parse has been rolled back and we're completely hosed.   The token is</span>
                <span class="s0"># discarded and we just keep going.</span>

                <span class="s2">if </span><span class="s1">len(statestack) &lt;= </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">lookahead.type != </span><span class="s3">'$end'</span><span class="s1">:</span>
                    <span class="s1">lookahead = </span><span class="s2">None</span>
                    <span class="s1">errtoken = </span><span class="s2">None</span>
                    <span class="s1">state = </span><span class="s4">0</span>
                    <span class="s0"># Nuke the pushback stack</span>
                    <span class="s2">del </span><span class="s1">lookaheadstack[:]</span>
                    <span class="s2">continue</span>

                <span class="s0"># case 2: the statestack has a couple of entries on it, but we're</span>
                <span class="s0"># at the end of the file. nuke the top entry and generate an error token</span>

                <span class="s0"># Start nuking entries on the stack</span>
                <span class="s2">if </span><span class="s1">lookahead.type == </span><span class="s3">'$end'</span><span class="s1">:</span>
                    <span class="s0"># Whoa. We're really hosed here. Bail out</span>
                    <span class="s2">return</span>

                <span class="s2">if </span><span class="s1">lookahead.type != </span><span class="s3">'error'</span><span class="s1">:</span>
                    <span class="s1">sym = symstack[-</span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s2">if </span><span class="s1">sym.type == </span><span class="s3">'error'</span><span class="s1">:</span>
                        <span class="s0"># Hmmm. Error is on top of stack, we'll just nuke input</span>
                        <span class="s0"># symbol and continue</span>
                        <span class="s1">lookahead = </span><span class="s2">None</span>
                        <span class="s2">continue</span>

                    <span class="s0"># Create the error symbol for the first time and make it the new lookahead symbol</span>
                    <span class="s1">t = YaccSymbol()</span>
                    <span class="s1">t.type = </span><span class="s3">'error'</span>

                    <span class="s2">if </span><span class="s1">hasattr(lookahead</span><span class="s2">, </span><span class="s3">'lineno'</span><span class="s1">):</span>
                        <span class="s1">t.lineno = t.endlineno = lookahead.lineno</span>
                    <span class="s2">if </span><span class="s1">hasattr(lookahead</span><span class="s2">, </span><span class="s3">'lexpos'</span><span class="s1">):</span>
                        <span class="s1">t.lexpos = t.endlexpos = lookahead.lexpos</span>
                    <span class="s1">t.value = lookahead</span>
                    <span class="s1">lookaheadstack.append(lookahead)</span>
                    <span class="s1">lookahead = t</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">sym = symstack.pop()</span>
                    <span class="s1">statestack.pop()</span>
                    <span class="s1">state = statestack[-</span><span class="s4">1</span><span class="s1">]</span>

                <span class="s2">continue</span>

            <span class="s0"># Call an error function here</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'yacc: internal parser error!!!</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s0">#--! parseopt-notrack-end</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                          === Grammar Representation ===</span>
<span class="s0">#</span>
<span class="s0"># The following functions, classes, and variables are used to represent and</span>
<span class="s0"># manipulate the rules that make up a grammar.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s0"># regex matching identifiers</span>
<span class="s1">_is_identifier = re.compile(</span><span class="s3">r'^[a-zA-Z0-9_-]+$'</span><span class="s1">)</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># class Production:</span>
<span class="s0">#</span>
<span class="s0"># This class stores the raw information about a single production or grammar rule.</span>
<span class="s0"># A grammar rule refers to a specification such as this:</span>
<span class="s0">#</span>
<span class="s0">#       expr : expr PLUS term</span>
<span class="s0">#</span>
<span class="s0"># Here are the basic attributes defined on all productions</span>
<span class="s0">#</span>
<span class="s0">#       name     - Name of the production.  For example 'expr'</span>
<span class="s0">#       prod     - A list of symbols on the right side ['expr','PLUS','term']</span>
<span class="s0">#       prec     - Production precedence level</span>
<span class="s0">#       number   - Production number.</span>
<span class="s0">#       func     - Function that executes on reduce</span>
<span class="s0">#       file     - File where production function is defined</span>
<span class="s0">#       lineno   - Line number where production function is defined</span>
<span class="s0">#</span>
<span class="s0"># The following attributes are defined or optional.</span>
<span class="s0">#</span>
<span class="s0">#       len       - Length of the production (number of symbols on right hand side)</span>
<span class="s0">#       usyms     - Set of unique symbols found in the production</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">Production(object):</span>
    <span class="s1">reduced = </span><span class="s4">0</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">number</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">prod</span><span class="s2">, </span><span class="s1">precedence=(</span><span class="s3">'right'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">func=</span><span class="s2">None, </span><span class="s1">file=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">line=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">self.name     = name</span>
        <span class="s1">self.prod     = tuple(prod)</span>
        <span class="s1">self.number   = number</span>
        <span class="s1">self.func     = func</span>
        <span class="s1">self.callable = </span><span class="s2">None</span>
        <span class="s1">self.file     = file</span>
        <span class="s1">self.line     = line</span>
        <span class="s1">self.prec     = precedence</span>

        <span class="s0"># Internal settings used during table construction</span>

        <span class="s1">self.len  = len(self.prod)   </span><span class="s0"># Length of the production</span>

        <span class="s0"># Create a list of unique production symbols used in the production</span>
        <span class="s1">self.usyms = []</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self.prod:</span>
            <span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">self.usyms:</span>
                <span class="s1">self.usyms.append(s)</span>

        <span class="s0"># List of all LR items for the production</span>
        <span class="s1">self.lr_items = []</span>
        <span class="s1">self.lr_next = </span><span class="s2">None</span>

        <span class="s0"># Create a string representation</span>
        <span class="s2">if </span><span class="s1">self.prod:</span>
            <span class="s1">self.str = </span><span class="s3">'%s -&gt; %s' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">.join(self.prod))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.str = </span><span class="s3">'%s -&gt; &lt;empty&gt;' </span><span class="s1">% self.name</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">self.str</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s3">'Production(' </span><span class="s1">+ str(self) + </span><span class="s3">')'</span>

    <span class="s2">def </span><span class="s1">__len__(self):</span>
        <span class="s2">return </span><span class="s1">len(self.prod)</span>

    <span class="s2">def </span><span class="s1">__nonzero__(self):</span>
        <span class="s2">return </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">index):</span>
        <span class="s2">return </span><span class="s1">self.prod[index]</span>

    <span class="s0"># Return the nth lr_item from the production (or None if at the end)</span>
    <span class="s2">def </span><span class="s1">lr_item(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">if </span><span class="s1">n &gt; len(self.prod):</span>
            <span class="s2">return None</span>
        <span class="s1">p = LRItem(self</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s0"># Precompute the list of productions immediately following.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">p.lr_after = Prodnames[p.prod[n+</span><span class="s4">1</span><span class="s1">]]</span>
        <span class="s2">except </span><span class="s1">(IndexError</span><span class="s2">, </span><span class="s1">KeyError):</span>
            <span class="s1">p.lr_after = []</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">p.lr_before = p.prod[n-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">IndexError:</span>
            <span class="s1">p.lr_before = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">p</span>

    <span class="s0"># Bind the production function name to a callable</span>
    <span class="s2">def </span><span class="s1">bind(self</span><span class="s2">, </span><span class="s1">pdict):</span>
        <span class="s2">if </span><span class="s1">self.func:</span>
            <span class="s1">self.callable = pdict[self.func]</span>

<span class="s0"># This class serves as a minimal standin for Production objects when</span>
<span class="s0"># reading table data from files.   It only contains information</span>
<span class="s0"># actually used by the LR parsing engine, plus some additional</span>
<span class="s0"># debugging information.</span>
<span class="s2">class </span><span class="s1">MiniProduction(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">len</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">line):</span>
        <span class="s1">self.name     = name</span>
        <span class="s1">self.len      = len</span>
        <span class="s1">self.func     = func</span>
        <span class="s1">self.callable = </span><span class="s2">None</span>
        <span class="s1">self.file     = file</span>
        <span class="s1">self.line     = line</span>
        <span class="s1">self.str      = str</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">self.str</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s3">'MiniProduction(%s)' </span><span class="s1">% self.str</span>

    <span class="s0"># Bind the production function name to a callable</span>
    <span class="s2">def </span><span class="s1">bind(self</span><span class="s2">, </span><span class="s1">pdict):</span>
        <span class="s2">if </span><span class="s1">self.func:</span>
            <span class="s1">self.callable = pdict[self.func]</span>


<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># class LRItem</span>
<span class="s0">#</span>
<span class="s0"># This class represents a specific stage of parsing a production rule.  For</span>
<span class="s0"># example:</span>
<span class="s0">#</span>
<span class="s0">#       expr : expr . PLUS term</span>
<span class="s0">#</span>
<span class="s0"># In the above, the &quot;.&quot; represents the current location of the parse.  Here</span>
<span class="s0"># basic attributes:</span>
<span class="s0">#</span>
<span class="s0">#       name       - Name of the production.  For example 'expr'</span>
<span class="s0">#       prod       - A list of symbols on the right side ['expr','.', 'PLUS','term']</span>
<span class="s0">#       number     - Production number.</span>
<span class="s0">#</span>
<span class="s0">#       lr_next      Next LR item. Example, if we are ' expr -&gt; expr . PLUS term'</span>
<span class="s0">#                    then lr_next refers to 'expr -&gt; expr PLUS . term'</span>
<span class="s0">#       lr_index   - LR item index (location of the &quot;.&quot;) in the prod list.</span>
<span class="s0">#       lookaheads - LALR lookahead symbols for this item</span>
<span class="s0">#       len        - Length of the production (number of symbols on right hand side)</span>
<span class="s0">#       lr_after    - List of all productions that immediately follow</span>
<span class="s0">#       lr_before   - Grammar symbol immediately before</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">LRItem(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s1">self.name       = p.name</span>
        <span class="s1">self.prod       = list(p.prod)</span>
        <span class="s1">self.number     = p.number</span>
        <span class="s1">self.lr_index   = n</span>
        <span class="s1">self.lookaheads = {}</span>
        <span class="s1">self.prod.insert(n</span><span class="s2">, </span><span class="s3">'.'</span><span class="s1">)</span>
        <span class="s1">self.prod       = tuple(self.prod)</span>
        <span class="s1">self.len        = len(self.prod)</span>
        <span class="s1">self.usyms      = p.usyms</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">if </span><span class="s1">self.prod:</span>
            <span class="s1">s = </span><span class="s3">'%s -&gt; %s' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">.join(self.prod))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">s = </span><span class="s3">'%s -&gt; &lt;empty&gt;' </span><span class="s1">% self.name</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s3">'LRItem(' </span><span class="s1">+ str(self) + </span><span class="s3">')'</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># rightmost_terminal()</span>
<span class="s0">#</span>
<span class="s0"># Return the rightmost terminal from a list of symbols.  Used in add_production()</span>
<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s2">def </span><span class="s1">rightmost_terminal(symbols</span><span class="s2">, </span><span class="s1">terminals):</span>
    <span class="s1">i = len(symbols) - </span><span class="s4">1</span>
    <span class="s2">while </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">symbols[i] </span><span class="s2">in </span><span class="s1">terminals:</span>
            <span class="s2">return </span><span class="s1">symbols[i]</span>
        <span class="s1">i -= </span><span class="s4">1</span>
    <span class="s2">return None</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                           === GRAMMAR CLASS ===</span>
<span class="s0">#</span>
<span class="s0"># The following class represents the contents of the specified grammar along</span>
<span class="s0"># with various computed properties such as first sets, follow sets, LR items, etc.</span>
<span class="s0"># This data is used for critical parts of the table generation process later.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">GrammarError(YaccError):</span>
    <span class="s2">pass</span>

<span class="s2">class </span><span class="s1">Grammar(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">terminals):</span>
        <span class="s1">self.Productions  = [</span><span class="s2">None</span><span class="s1">]  </span><span class="s0"># A list of all of the productions.  The first</span>
                                    <span class="s0"># entry is always reserved for the purpose of</span>
                                    <span class="s0"># building an augmented grammar</span>

        <span class="s1">self.Prodnames    = {}      </span><span class="s0"># A dictionary mapping the names of nonterminals to a list of all</span>
                                    <span class="s0"># productions of that nonterminal.</span>

        <span class="s1">self.Prodmap      = {}      </span><span class="s0"># A dictionary that is only used to detect duplicate</span>
                                    <span class="s0"># productions.</span>

        <span class="s1">self.Terminals    = {}      </span><span class="s0"># A dictionary mapping the names of terminal symbols to a</span>
                                    <span class="s0"># list of the rules where they are used.</span>

        <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">terminals:</span>
            <span class="s1">self.Terminals[term] = []</span>

        <span class="s1">self.Terminals[</span><span class="s3">'error'</span><span class="s1">] = []</span>

        <span class="s1">self.Nonterminals = {}      </span><span class="s0"># A dictionary mapping names of nonterminals to a list</span>
                                    <span class="s0"># of rule numbers where they are used.</span>

        <span class="s1">self.First        = {}      </span><span class="s0"># A dictionary of precomputed FIRST(x) symbols</span>

        <span class="s1">self.Follow       = {}      </span><span class="s0"># A dictionary of precomputed FOLLOW(x) symbols</span>

        <span class="s1">self.Precedence   = {}      </span><span class="s0"># Precedence rules for each terminal. Contains tuples of the</span>
                                    <span class="s0"># form ('right',level) or ('nonassoc', level) or ('left',level)</span>

        <span class="s1">self.UsedPrecedence = set() </span><span class="s0"># Precedence rules that were actually used by the grammer.</span>
                                    <span class="s0"># This is only used to provide error checking and to generate</span>
                                    <span class="s0"># a warning about unused precedence rules.</span>

        <span class="s1">self.Start = </span><span class="s2">None           </span><span class="s0"># Starting symbol for the grammar</span>


    <span class="s2">def </span><span class="s1">__len__(self):</span>
        <span class="s2">return </span><span class="s1">len(self.Productions)</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">index):</span>
        <span class="s2">return </span><span class="s1">self.Productions[index]</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># set_precedence()</span>
    <span class="s0">#</span>
    <span class="s0"># Sets the precedence for a given terminal. assoc is the associativity such as</span>
    <span class="s0"># 'left','right', or 'nonassoc'.  level is a numeric level.</span>
    <span class="s0">#</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">set_precedence(self</span><span class="s2">, </span><span class="s1">term</span><span class="s2">, </span><span class="s1">assoc</span><span class="s2">, </span><span class="s1">level):</span>
        <span class="s2">assert </span><span class="s1">self.Productions == [</span><span class="s2">None</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'Must call set_precedence() before add_production()'</span>
        <span class="s2">if </span><span class="s1">term </span><span class="s2">in </span><span class="s1">self.Precedence:</span>
            <span class="s2">raise </span><span class="s1">GrammarError(</span><span class="s3">'Precedence already specified for terminal %r' </span><span class="s1">% term)</span>
        <span class="s2">if </span><span class="s1">assoc </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">'left'</span><span class="s2">, </span><span class="s3">'right'</span><span class="s2">, </span><span class="s3">'nonassoc'</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">GrammarError(</span><span class="s3">&quot;Associativity must be one of 'left','right', or 'nonassoc'&quot;</span><span class="s1">)</span>
        <span class="s1">self.Precedence[term] = (assoc</span><span class="s2">, </span><span class="s1">level)</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># add_production()</span>
    <span class="s0">#</span>
    <span class="s0"># Given an action function, this function assembles a production rule and</span>
    <span class="s0"># computes its precedence level.</span>
    <span class="s0">#</span>
    <span class="s0"># The production rule is supplied as a list of symbols.   For example,</span>
    <span class="s0"># a rule such as 'expr : expr PLUS term' has a production name of 'expr' and</span>
    <span class="s0"># symbols ['expr','PLUS','term'].</span>
    <span class="s0">#</span>
    <span class="s0"># Precedence is determined by the precedence of the right-most non-terminal</span>
    <span class="s0"># or the precedence of a terminal specified by %prec.</span>
    <span class="s0">#</span>
    <span class="s0"># A variety of error checks are performed to make sure production symbols</span>
    <span class="s0"># are valid and that %prec is used correctly.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">add_production(self</span><span class="s2">, </span><span class="s1">prodname</span><span class="s2">, </span><span class="s1">syms</span><span class="s2">, </span><span class="s1">func=</span><span class="s2">None, </span><span class="s1">file=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">line=</span><span class="s4">0</span><span class="s1">):</span>

        <span class="s2">if </span><span class="s1">prodname </span><span class="s2">in </span><span class="s1">self.Terminals:</span>
            <span class="s2">raise </span><span class="s1">GrammarError(</span><span class="s3">'%s:%d: Illegal rule name %r. Already defined as a token' </span><span class="s1">% (file</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">prodname))</span>
        <span class="s2">if </span><span class="s1">prodname == </span><span class="s3">'error'</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">GrammarError(</span><span class="s3">'%s:%d: Illegal rule name %r. error is a reserved word' </span><span class="s1">% (file</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">prodname))</span>
        <span class="s2">if not </span><span class="s1">_is_identifier.match(prodname):</span>
            <span class="s2">raise </span><span class="s1">GrammarError(</span><span class="s3">'%s:%d: Illegal rule name %r' </span><span class="s1">% (file</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">prodname))</span>

        <span class="s0"># Look for literal tokens</span>
        <span class="s2">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">enumerate(syms):</span>
            <span class="s2">if </span><span class="s1">s[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">in </span><span class="s3">&quot;'</span><span class="s2">\&quot;</span><span class="s3">&quot;</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">c = eval(s)</span>
                    <span class="s2">if </span><span class="s1">(len(c) &gt; </span><span class="s4">1</span><span class="s1">):</span>
                        <span class="s2">raise </span><span class="s1">GrammarError(</span><span class="s3">'%s:%d: Literal token %s in rule %r may only be a single character' </span><span class="s1">%</span>
                                           <span class="s1">(file</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prodname))</span>
                    <span class="s2">if </span><span class="s1">c </span><span class="s2">not in </span><span class="s1">self.Terminals:</span>
                        <span class="s1">self.Terminals[c] = []</span>
                    <span class="s1">syms[n] = c</span>
                    <span class="s2">continue</span>
                <span class="s2">except </span><span class="s1">SyntaxError:</span>
                    <span class="s2">pass</span>
            <span class="s2">if not </span><span class="s1">_is_identifier.match(s) </span><span class="s2">and </span><span class="s1">s != </span><span class="s3">'%prec'</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">GrammarError(</span><span class="s3">'%s:%d: Illegal name %r in rule %r' </span><span class="s1">% (file</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prodname))</span>

        <span class="s0"># Determine the precedence level</span>
        <span class="s2">if </span><span class="s3">'%prec' </span><span class="s2">in </span><span class="s1">syms:</span>
            <span class="s2">if </span><span class="s1">syms[-</span><span class="s4">1</span><span class="s1">] == </span><span class="s3">'%prec'</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">GrammarError(</span><span class="s3">'%s:%d: Syntax error. Nothing follows %%prec' </span><span class="s1">% (file</span><span class="s2">, </span><span class="s1">line))</span>
            <span class="s2">if </span><span class="s1">syms[-</span><span class="s4">2</span><span class="s1">] != </span><span class="s3">'%prec'</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">GrammarError(</span><span class="s3">'%s:%d: Syntax error. %%prec can only appear at the end of a grammar rule' </span><span class="s1">%</span>
                                   <span class="s1">(file</span><span class="s2">, </span><span class="s1">line))</span>
            <span class="s1">precname = syms[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">prodprec = self.Precedence.get(precname)</span>
            <span class="s2">if not </span><span class="s1">prodprec:</span>
                <span class="s2">raise </span><span class="s1">GrammarError(</span><span class="s3">'%s:%d: Nothing known about the precedence of %r' </span><span class="s1">% (file</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">precname))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.UsedPrecedence.add(precname)</span>
            <span class="s2">del </span><span class="s1">syms[-</span><span class="s4">2</span><span class="s1">:]     </span><span class="s0"># Drop %prec from the rule</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># If no %prec, precedence is determined by the rightmost terminal symbol</span>
            <span class="s1">precname = rightmost_terminal(syms</span><span class="s2">, </span><span class="s1">self.Terminals)</span>
            <span class="s1">prodprec = self.Precedence.get(precname</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'right'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>

        <span class="s0"># See if the rule is already in the rulemap</span>
        <span class="s1">map = </span><span class="s3">'%s -&gt; %s' </span><span class="s1">% (prodname</span><span class="s2">, </span><span class="s1">syms)</span>
        <span class="s2">if </span><span class="s1">map </span><span class="s2">in </span><span class="s1">self.Prodmap:</span>
            <span class="s1">m = self.Prodmap[map]</span>
            <span class="s2">raise </span><span class="s1">GrammarError(</span><span class="s3">'%s:%d: Duplicate rule %s. ' </span><span class="s1">% (file</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">m) +</span>
                               <span class="s3">'Previous definition at %s:%d' </span><span class="s1">% (m.file</span><span class="s2">, </span><span class="s1">m.line))</span>

        <span class="s0"># From this point on, everything is valid.  Create a new Production instance</span>
        <span class="s1">pnumber  = len(self.Productions)</span>
        <span class="s2">if </span><span class="s1">prodname </span><span class="s2">not in </span><span class="s1">self.Nonterminals:</span>
            <span class="s1">self.Nonterminals[prodname] = []</span>

        <span class="s0"># Add the production number to Terminals and Nonterminals</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">syms:</span>
            <span class="s2">if </span><span class="s1">t </span><span class="s2">in </span><span class="s1">self.Terminals:</span>
                <span class="s1">self.Terminals[t].append(pnumber)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">t </span><span class="s2">not in </span><span class="s1">self.Nonterminals:</span>
                    <span class="s1">self.Nonterminals[t] = []</span>
                <span class="s1">self.Nonterminals[t].append(pnumber)</span>

        <span class="s0"># Create a production and add it to the list of productions</span>
        <span class="s1">p = Production(pnumber</span><span class="s2">, </span><span class="s1">prodname</span><span class="s2">, </span><span class="s1">syms</span><span class="s2">, </span><span class="s1">prodprec</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">line)</span>
        <span class="s1">self.Productions.append(p)</span>
        <span class="s1">self.Prodmap[map] = p</span>

        <span class="s0"># Add to the global productions list</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.Prodnames[prodname].append(p)</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s1">self.Prodnames[prodname] = [p]</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># set_start()</span>
    <span class="s0">#</span>
    <span class="s0"># Sets the starting symbol and creates the augmented grammar.  Production</span>
    <span class="s0"># rule 0 is S' -&gt; start where start is the start symbol.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">set_start(self</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if not </span><span class="s1">start:</span>
            <span class="s1">start = self.Productions[</span><span class="s4">1</span><span class="s1">].name</span>
        <span class="s2">if </span><span class="s1">start </span><span class="s2">not in </span><span class="s1">self.Nonterminals:</span>
            <span class="s2">raise </span><span class="s1">GrammarError(</span><span class="s3">'start symbol %s undefined' </span><span class="s1">% start)</span>
        <span class="s1">self.Productions[</span><span class="s4">0</span><span class="s1">] = Production(</span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;S'&quot;</span><span class="s2">, </span><span class="s1">[start])</span>
        <span class="s1">self.Nonterminals[start].append(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.Start = start</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># find_unreachable()</span>
    <span class="s0">#</span>
    <span class="s0"># Find all of the nonterminal symbols that can't be reached from the starting</span>
    <span class="s0"># symbol.  Returns a list of nonterminals that can't be reached.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">find_unreachable(self):</span>

        <span class="s0"># Mark all symbols that are reachable from a symbol s</span>
        <span class="s2">def </span><span class="s1">mark_reachable_from(s):</span>
            <span class="s2">if </span><span class="s1">s </span><span class="s2">in </span><span class="s1">reachable:</span>
                <span class="s2">return</span>
            <span class="s1">reachable.add(s)</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.Prodnames.get(s</span><span class="s2">, </span><span class="s1">[]):</span>
                <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">p.prod:</span>
                    <span class="s1">mark_reachable_from(r)</span>

        <span class="s1">reachable = set()</span>
        <span class="s1">mark_reachable_from(self.Productions[</span><span class="s4">0</span><span class="s1">].prod[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">[s </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self.Nonterminals </span><span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">reachable]</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># infinite_cycles()</span>
    <span class="s0">#</span>
    <span class="s0"># This function looks at the various parsing rules and tries to detect</span>
    <span class="s0"># infinite recursion cycles (grammar rules where there is no possible way</span>
    <span class="s0"># to derive a string of only terminals).</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">infinite_cycles(self):</span>
        <span class="s1">terminates = {}</span>

        <span class="s0"># Terminals:</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">self.Terminals:</span>
            <span class="s1">terminates[t] = </span><span class="s2">True</span>

        <span class="s1">terminates[</span><span class="s3">'$end'</span><span class="s1">] = </span><span class="s2">True</span>

        <span class="s0"># Nonterminals:</span>

        <span class="s0"># Initialize to false:</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.Nonterminals:</span>
            <span class="s1">terminates[n] = </span><span class="s2">False</span>

        <span class="s0"># Then propagate termination until no change:</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">some_change = </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">(n</span><span class="s2">, </span><span class="s1">pl) </span><span class="s2">in </span><span class="s1">self.Prodnames.items():</span>
                <span class="s0"># Nonterminal n terminates iff any of its productions terminates.</span>
                <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">pl:</span>
                    <span class="s0"># Production p terminates iff all of its rhs symbols terminate.</span>
                    <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">p.prod:</span>
                        <span class="s2">if not </span><span class="s1">terminates[s]:</span>
                            <span class="s0"># The symbol s does not terminate,</span>
                            <span class="s0"># so production p does not terminate.</span>
                            <span class="s1">p_terminates = </span><span class="s2">False</span>
                            <span class="s2">break</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s0"># didn't break from the loop,</span>
                        <span class="s0"># so every symbol s terminates</span>
                        <span class="s0"># so production p terminates.</span>
                        <span class="s1">p_terminates = </span><span class="s2">True</span>

                    <span class="s2">if </span><span class="s1">p_terminates:</span>
                        <span class="s0"># symbol n terminates!</span>
                        <span class="s2">if not </span><span class="s1">terminates[n]:</span>
                            <span class="s1">terminates[n] = </span><span class="s2">True</span>
                            <span class="s1">some_change = </span><span class="s2">True</span>
                        <span class="s0"># Don't need to consider any more productions for this n.</span>
                        <span class="s2">break</span>

            <span class="s2">if not </span><span class="s1">some_change:</span>
                <span class="s2">break</span>

        <span class="s1">infinite = []</span>
        <span class="s2">for </span><span class="s1">(s</span><span class="s2">, </span><span class="s1">term) </span><span class="s2">in </span><span class="s1">terminates.items():</span>
            <span class="s2">if not </span><span class="s1">term:</span>
                <span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">self.Prodnames </span><span class="s2">and </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">self.Terminals </span><span class="s2">and </span><span class="s1">s != </span><span class="s3">'error'</span><span class="s1">:</span>
                    <span class="s0"># s is used-but-not-defined, and we've already warned of that,</span>
                    <span class="s0"># so it would be overkill to say that it's also non-terminating.</span>
                    <span class="s2">pass</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">infinite.append(s)</span>

        <span class="s2">return </span><span class="s1">infinite</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># undefined_symbols()</span>
    <span class="s0">#</span>
    <span class="s0"># Find all symbols that were used the grammar, but not defined as tokens or</span>
    <span class="s0"># grammar rules.  Returns a list of tuples (sym, prod) where sym in the symbol</span>
    <span class="s0"># and prod is the production where the symbol was used.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">undefined_symbols(self):</span>
        <span class="s1">result = []</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.Productions:</span>
            <span class="s2">if not </span><span class="s1">p:</span>
                <span class="s2">continue</span>

            <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">p.prod:</span>
                <span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">self.Prodnames </span><span class="s2">and </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">self.Terminals </span><span class="s2">and </span><span class="s1">s != </span><span class="s3">'error'</span><span class="s1">:</span>
                    <span class="s1">result.append((s</span><span class="s2">, </span><span class="s1">p))</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># unused_terminals()</span>
    <span class="s0">#</span>
    <span class="s0"># Find all terminals that were defined, but not used by the grammar.  Returns</span>
    <span class="s0"># a list of all symbols.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">unused_terminals(self):</span>
        <span class="s1">unused_tok = []</span>
        <span class="s2">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.Terminals.items():</span>
            <span class="s2">if </span><span class="s1">s != </span><span class="s3">'error' </span><span class="s2">and not </span><span class="s1">v:</span>
                <span class="s1">unused_tok.append(s)</span>

        <span class="s2">return </span><span class="s1">unused_tok</span>

    <span class="s0"># ------------------------------------------------------------------------------</span>
    <span class="s0"># unused_rules()</span>
    <span class="s0">#</span>
    <span class="s0"># Find all grammar rules that were defined,  but not used (maybe not reachable)</span>
    <span class="s0"># Returns a list of productions.</span>
    <span class="s0"># ------------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">unused_rules(self):</span>
        <span class="s1">unused_prod = []</span>
        <span class="s2">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.Nonterminals.items():</span>
            <span class="s2">if not </span><span class="s1">v:</span>
                <span class="s1">p = self.Prodnames[s][</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">unused_prod.append(p)</span>
        <span class="s2">return </span><span class="s1">unused_prod</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># unused_precedence()</span>
    <span class="s0">#</span>
    <span class="s0"># Returns a list of tuples (term,precedence) corresponding to precedence</span>
    <span class="s0"># rules that were never used by the grammar.  term is the name of the terminal</span>
    <span class="s0"># on which precedence was applied and precedence is a string such as 'left' or</span>
    <span class="s0"># 'right' corresponding to the type of precedence.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">unused_precedence(self):</span>
        <span class="s1">unused = []</span>
        <span class="s2">for </span><span class="s1">termname </span><span class="s2">in </span><span class="s1">self.Precedence:</span>
            <span class="s2">if not </span><span class="s1">(termname </span><span class="s2">in </span><span class="s1">self.Terminals </span><span class="s2">or </span><span class="s1">termname </span><span class="s2">in </span><span class="s1">self.UsedPrecedence):</span>
                <span class="s1">unused.append((termname</span><span class="s2">, </span><span class="s1">self.Precedence[termname][</span><span class="s4">0</span><span class="s1">]))</span>

        <span class="s2">return </span><span class="s1">unused</span>

    <span class="s0"># -------------------------------------------------------------------------</span>
    <span class="s0"># _first()</span>
    <span class="s0">#</span>
    <span class="s0"># Compute the value of FIRST1(beta) where beta is a tuple of symbols.</span>
    <span class="s0">#</span>
    <span class="s0"># During execution of compute_first1, the result may be incomplete.</span>
    <span class="s0"># Afterward (e.g., when called from compute_follow()), it will be complete.</span>
    <span class="s0"># -------------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">_first(self</span><span class="s2">, </span><span class="s1">beta):</span>

        <span class="s0"># We are computing First(x1,x2,x3,...,xn)</span>
        <span class="s1">result = []</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">beta:</span>
            <span class="s1">x_produces_empty = </span><span class="s2">False</span>

            <span class="s0"># Add all the non-&lt;empty&gt; symbols of First[x] to the result.</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.First[x]:</span>
                <span class="s2">if </span><span class="s1">f == </span><span class="s3">'&lt;empty&gt;'</span><span class="s1">:</span>
                    <span class="s1">x_produces_empty = </span><span class="s2">True</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">result:</span>
                        <span class="s1">result.append(f)</span>

            <span class="s2">if </span><span class="s1">x_produces_empty:</span>
                <span class="s0"># We have to consider the next x in beta,</span>
                <span class="s0"># i.e. stay in the loop.</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># We don't have to consider any further symbols in beta.</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># There was no 'break' from the loop,</span>
            <span class="s0"># so x_produces_empty was true for all x in beta,</span>
            <span class="s0"># so beta produces empty as well.</span>
            <span class="s1">result.append(</span><span class="s3">'&lt;empty&gt;'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s0"># -------------------------------------------------------------------------</span>
    <span class="s0"># compute_first()</span>
    <span class="s0">#</span>
    <span class="s0"># Compute the value of FIRST1(X) for all symbols</span>
    <span class="s0"># -------------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">compute_first(self):</span>
        <span class="s2">if </span><span class="s1">self.First:</span>
            <span class="s2">return </span><span class="s1">self.First</span>

        <span class="s0"># Terminals:</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">self.Terminals:</span>
            <span class="s1">self.First[t] = [t]</span>

        <span class="s1">self.First[</span><span class="s3">'$end'</span><span class="s1">] = [</span><span class="s3">'$end'</span><span class="s1">]</span>

        <span class="s0"># Nonterminals:</span>

        <span class="s0"># Initialize to the empty set:</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.Nonterminals:</span>
            <span class="s1">self.First[n] = []</span>

        <span class="s0"># Then propagate symbols until no change:</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">some_change = </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.Nonterminals:</span>
                <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.Prodnames[n]:</span>
                    <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self._first(p.prod):</span>
                        <span class="s2">if </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">self.First[n]:</span>
                            <span class="s1">self.First[n].append(f)</span>
                            <span class="s1">some_change = </span><span class="s2">True</span>
            <span class="s2">if not </span><span class="s1">some_change:</span>
                <span class="s2">break</span>

        <span class="s2">return </span><span class="s1">self.First</span>

    <span class="s0"># ---------------------------------------------------------------------</span>
    <span class="s0"># compute_follow()</span>
    <span class="s0">#</span>
    <span class="s0"># Computes all of the follow sets for every non-terminal symbol.  The</span>
    <span class="s0"># follow set is the set of all symbols that might follow a given</span>
    <span class="s0"># non-terminal.  See the Dragon book, 2nd Ed. p. 189.</span>
    <span class="s0"># ---------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">compute_follow(self</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># If already computed, return the result</span>
        <span class="s2">if </span><span class="s1">self.Follow:</span>
            <span class="s2">return </span><span class="s1">self.Follow</span>

        <span class="s0"># If first sets not computed yet, do that first.</span>
        <span class="s2">if not </span><span class="s1">self.First:</span>
            <span class="s1">self.compute_first()</span>

        <span class="s0"># Add '$end' to the follow list of the start symbol</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self.Nonterminals:</span>
            <span class="s1">self.Follow[k] = []</span>

        <span class="s2">if not </span><span class="s1">start:</span>
            <span class="s1">start = self.Productions[</span><span class="s4">1</span><span class="s1">].name</span>

        <span class="s1">self.Follow[start] = [</span><span class="s3">'$end'</span><span class="s1">]</span>

        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">didadd = </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.Productions[</span><span class="s4">1</span><span class="s1">:]:</span>
                <span class="s0"># Here is the production set</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">B </span><span class="s2">in </span><span class="s1">enumerate(p.prod):</span>
                    <span class="s2">if </span><span class="s1">B </span><span class="s2">in </span><span class="s1">self.Nonterminals:</span>
                        <span class="s0"># Okay. We got a non-terminal in a production</span>
                        <span class="s1">fst = self._first(p.prod[i+</span><span class="s4">1</span><span class="s1">:])</span>
                        <span class="s1">hasempty = </span><span class="s2">False</span>
                        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fst:</span>
                            <span class="s2">if </span><span class="s1">f != </span><span class="s3">'&lt;empty&gt;' </span><span class="s2">and </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">self.Follow[B]:</span>
                                <span class="s1">self.Follow[B].append(f)</span>
                                <span class="s1">didadd = </span><span class="s2">True</span>
                            <span class="s2">if </span><span class="s1">f == </span><span class="s3">'&lt;empty&gt;'</span><span class="s1">:</span>
                                <span class="s1">hasempty = </span><span class="s2">True</span>
                        <span class="s2">if </span><span class="s1">hasempty </span><span class="s2">or </span><span class="s1">i == (len(p.prod)-</span><span class="s4">1</span><span class="s1">):</span>
                            <span class="s0"># Add elements of follow(a) to follow(b)</span>
                            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.Follow[p.name]:</span>
                                <span class="s2">if </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">self.Follow[B]:</span>
                                    <span class="s1">self.Follow[B].append(f)</span>
                                    <span class="s1">didadd = </span><span class="s2">True</span>
            <span class="s2">if not </span><span class="s1">didadd:</span>
                <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">self.Follow</span>


    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># build_lritems()</span>
    <span class="s0">#</span>
    <span class="s0"># This function walks the list of productions and builds a complete set of the</span>
    <span class="s0"># LR items.  The LR items are stored in two ways:  First, they are uniquely</span>
    <span class="s0"># numbered and placed in the list _lritems.  Second, a linked list of LR items</span>
    <span class="s0"># is built for each production.  For example:</span>
    <span class="s0">#</span>
    <span class="s0">#   E -&gt; E PLUS E</span>
    <span class="s0">#</span>
    <span class="s0"># Creates the list</span>
    <span class="s0">#</span>
    <span class="s0">#  [E -&gt; . E PLUS E, E -&gt; E . PLUS E, E -&gt; E PLUS . E, E -&gt; E PLUS E . ]</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">build_lritems(self):</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.Productions:</span>
            <span class="s1">lastlri = p</span>
            <span class="s1">i = </span><span class="s4">0</span>
            <span class="s1">lr_items = []</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">i &gt; len(p):</span>
                    <span class="s1">lri = </span><span class="s2">None</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">lri = LRItem(p</span><span class="s2">, </span><span class="s1">i)</span>
                    <span class="s0"># Precompute the list of productions immediately following</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">lri.lr_after = self.Prodnames[lri.prod[i+</span><span class="s4">1</span><span class="s1">]]</span>
                    <span class="s2">except </span><span class="s1">(IndexError</span><span class="s2">, </span><span class="s1">KeyError):</span>
                        <span class="s1">lri.lr_after = []</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">lri.lr_before = lri.prod[i-</span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s2">except </span><span class="s1">IndexError:</span>
                        <span class="s1">lri.lr_before = </span><span class="s2">None</span>

                <span class="s1">lastlri.lr_next = lri</span>
                <span class="s2">if not </span><span class="s1">lri:</span>
                    <span class="s2">break</span>
                <span class="s1">lr_items.append(lri)</span>
                <span class="s1">lastlri = lri</span>
                <span class="s1">i += </span><span class="s4">1</span>
            <span class="s1">p.lr_items = lr_items</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                            == Class LRTable ==</span>
<span class="s0">#</span>
<span class="s0"># This basic class represents a basic table of LR parsing information.</span>
<span class="s0"># Methods for generating the tables are not defined here.  They are defined</span>
<span class="s0"># in the derived class LRGeneratedTable.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">VersionError(YaccError):</span>
    <span class="s2">pass</span>

<span class="s2">class </span><span class="s1">LRTable(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.lr_action = </span><span class="s2">None</span>
        <span class="s1">self.lr_goto = </span><span class="s2">None</span>
        <span class="s1">self.lr_productions = </span><span class="s2">None</span>
        <span class="s1">self.lr_method = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">read_table(self</span><span class="s2">, </span><span class="s1">module):</span>
        <span class="s2">if </span><span class="s1">isinstance(module</span><span class="s2">, </span><span class="s1">types.ModuleType):</span>
            <span class="s1">parsetab = module</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">exec(</span><span class="s3">'import %s' </span><span class="s1">% module)</span>
            <span class="s1">parsetab = sys.modules[module]</span>

        <span class="s2">if </span><span class="s1">parsetab._tabversion != __tabversion__:</span>
            <span class="s2">raise </span><span class="s1">VersionError(</span><span class="s3">'yacc table file version is out of date'</span><span class="s1">)</span>

        <span class="s1">self.lr_action = parsetab._lr_action</span>
        <span class="s1">self.lr_goto = parsetab._lr_goto</span>

        <span class="s1">self.lr_productions = []</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">parsetab._lr_productions:</span>
            <span class="s1">self.lr_productions.append(MiniProduction(*p))</span>

        <span class="s1">self.lr_method = parsetab._lr_method</span>
        <span class="s2">return </span><span class="s1">parsetab._lr_signature</span>

    <span class="s2">def </span><span class="s1">read_pickle(self</span><span class="s2">, </span><span class="s1">filename):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">cPickle </span><span class="s2">as </span><span class="s1">pickle</span>
        <span class="s2">except </span><span class="s1">ImportError:</span>
            <span class="s2">import </span><span class="s1">pickle</span>

        <span class="s2">if not </span><span class="s1">os.path.exists(filename):</span>
          <span class="s2">raise </span><span class="s1">ImportError</span>

        <span class="s1">in_f = open(filename</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>

        <span class="s1">tabversion = pickle.load(in_f)</span>
        <span class="s2">if </span><span class="s1">tabversion != __tabversion__:</span>
            <span class="s2">raise </span><span class="s1">VersionError(</span><span class="s3">'yacc table file version is out of date'</span><span class="s1">)</span>
        <span class="s1">self.lr_method = pickle.load(in_f)</span>
        <span class="s1">signature      = pickle.load(in_f)</span>
        <span class="s1">self.lr_action = pickle.load(in_f)</span>
        <span class="s1">self.lr_goto   = pickle.load(in_f)</span>
        <span class="s1">productions    = pickle.load(in_f)</span>

        <span class="s1">self.lr_productions = []</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">productions:</span>
            <span class="s1">self.lr_productions.append(MiniProduction(*p))</span>

        <span class="s1">in_f.close()</span>
        <span class="s2">return </span><span class="s1">signature</span>

    <span class="s0"># Bind all production function names to callable objects in pdict</span>
    <span class="s2">def </span><span class="s1">bind_callables(self</span><span class="s2">, </span><span class="s1">pdict):</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.lr_productions:</span>
            <span class="s1">p.bind(pdict)</span>


<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                           === LR Generator ===</span>
<span class="s0">#</span>
<span class="s0"># The following classes and functions are used to generate LR parsing tables on</span>
<span class="s0"># a grammar.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># digraph()</span>
<span class="s0"># traverse()</span>
<span class="s0">#</span>
<span class="s0"># The following two functions are used to compute set valued functions</span>
<span class="s0"># of the form:</span>
<span class="s0">#</span>
<span class="s0">#     F(x) = F'(x) U U{F(y) | x R y}</span>
<span class="s0">#</span>
<span class="s0"># This is used to compute the values of Read() sets as well as FOLLOW sets</span>
<span class="s0"># in LALR(1) generation.</span>
<span class="s0">#</span>
<span class="s0"># Inputs:  X    - An input set</span>
<span class="s0">#          R    - A relation</span>
<span class="s0">#          FP   - Set-valued function</span>
<span class="s0"># ------------------------------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">digraph(X</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">FP):</span>
    <span class="s1">N = {}</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">X:</span>
        <span class="s1">N[x] = </span><span class="s4">0</span>
    <span class="s1">stack = []</span>
    <span class="s1">F = {}</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">X:</span>
        <span class="s2">if </span><span class="s1">N[x] == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">traverse(x</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">stack</span><span class="s2">, </span><span class="s1">F</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">FP)</span>
    <span class="s2">return </span><span class="s1">F</span>

<span class="s2">def </span><span class="s1">traverse(x</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">stack</span><span class="s2">, </span><span class="s1">F</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">FP):</span>
    <span class="s1">stack.append(x)</span>
    <span class="s1">d = len(stack)</span>
    <span class="s1">N[x] = d</span>
    <span class="s1">F[x] = FP(x)             </span><span class="s0"># F(X) &lt;- F'(x)</span>

    <span class="s1">rel = R(x)               </span><span class="s0"># Get y's related to x</span>
    <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">rel:</span>
        <span class="s2">if </span><span class="s1">N[y] == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">traverse(y</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">stack</span><span class="s2">, </span><span class="s1">F</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">FP)</span>
        <span class="s1">N[x] = min(N[x]</span><span class="s2">, </span><span class="s1">N[y])</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">F.get(y</span><span class="s2">, </span><span class="s1">[]):</span>
            <span class="s2">if </span><span class="s1">a </span><span class="s2">not in </span><span class="s1">F[x]:</span>
                <span class="s1">F[x].append(a)</span>
    <span class="s2">if </span><span class="s1">N[x] == d:</span>
        <span class="s1">N[stack[-</span><span class="s4">1</span><span class="s1">]] = MAXINT</span>
        <span class="s1">F[stack[-</span><span class="s4">1</span><span class="s1">]] = F[x]</span>
        <span class="s1">element = stack.pop()</span>
        <span class="s2">while </span><span class="s1">element != x:</span>
            <span class="s1">N[stack[-</span><span class="s4">1</span><span class="s1">]] = MAXINT</span>
            <span class="s1">F[stack[-</span><span class="s4">1</span><span class="s1">]] = F[x]</span>
            <span class="s1">element = stack.pop()</span>

<span class="s2">class </span><span class="s1">LALRError(YaccError):</span>
    <span class="s2">pass</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                             == LRGeneratedTable ==</span>
<span class="s0">#</span>
<span class="s0"># This class implements the LR table generation algorithm.  There are no</span>
<span class="s0"># public methods except for write()</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">LRGeneratedTable(LRTable):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">grammar</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'LALR'</span><span class="s2">, </span><span class="s1">log=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">'SLR'</span><span class="s2">, </span><span class="s3">'LALR'</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">LALRError(</span><span class="s3">'Unsupported method %s' </span><span class="s1">% method)</span>

        <span class="s1">self.grammar = grammar</span>
        <span class="s1">self.lr_method = method</span>

        <span class="s0"># Set up the logger</span>
        <span class="s2">if not </span><span class="s1">log:</span>
            <span class="s1">log = NullLogger()</span>
        <span class="s1">self.log = log</span>

        <span class="s0"># Internal attributes</span>
        <span class="s1">self.lr_action     = {}        </span><span class="s0"># Action table</span>
        <span class="s1">self.lr_goto       = {}        </span><span class="s0"># Goto table</span>
        <span class="s1">self.lr_productions  = grammar.Productions    </span><span class="s0"># Copy of grammar Production array</span>
        <span class="s1">self.lr_goto_cache = {}        </span><span class="s0"># Cache of computed gotos</span>
        <span class="s1">self.lr0_cidhash   = {}        </span><span class="s0"># Cache of closures</span>

        <span class="s1">self._add_count    = </span><span class="s4">0         </span><span class="s0"># Internal counter used to detect cycles</span>

        <span class="s0"># Diagonistic information filled in by the table generator</span>
        <span class="s1">self.sr_conflict   = </span><span class="s4">0</span>
        <span class="s1">self.rr_conflict   = </span><span class="s4">0</span>
        <span class="s1">self.conflicts     = []        </span><span class="s0"># List of conflicts</span>

        <span class="s1">self.sr_conflicts  = []</span>
        <span class="s1">self.rr_conflicts  = []</span>

        <span class="s0"># Build the tables</span>
        <span class="s1">self.grammar.build_lritems()</span>
        <span class="s1">self.grammar.compute_first()</span>
        <span class="s1">self.grammar.compute_follow()</span>
        <span class="s1">self.lr_parse_table()</span>

    <span class="s0"># Compute the LR(0) closure operation on I, where I is a set of LR(0) items.</span>

    <span class="s2">def </span><span class="s1">lr0_closure(self</span><span class="s2">, </span><span class="s1">I):</span>
        <span class="s1">self._add_count += </span><span class="s4">1</span>

        <span class="s0"># Add everything in I to J</span>
        <span class="s1">J = I[:]</span>
        <span class="s1">didadd = </span><span class="s2">True</span>
        <span class="s2">while </span><span class="s1">didadd:</span>
            <span class="s1">didadd = </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">J:</span>
                <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">j.lr_after:</span>
                    <span class="s2">if </span><span class="s1">getattr(x</span><span class="s2">, </span><span class="s3">'lr0_added'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) == self._add_count:</span>
                        <span class="s2">continue</span>
                    <span class="s0"># Add B --&gt; .G to J</span>
                    <span class="s1">J.append(x.lr_next)</span>
                    <span class="s1">x.lr0_added = self._add_count</span>
                    <span class="s1">didadd = </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">J</span>

    <span class="s0"># Compute the LR(0) goto function goto(I,X) where I is a set</span>
    <span class="s0"># of LR(0) items and X is a grammar symbol.   This function is written</span>
    <span class="s0"># in a way that guarantees uniqueness of the generated goto sets</span>
    <span class="s0"># (i.e. the same goto set will never be returned as two different Python</span>
    <span class="s0"># objects).  With uniqueness, we can later do fast set comparisons using</span>
    <span class="s0"># id(obj) instead of element-wise comparison.</span>

    <span class="s2">def </span><span class="s1">lr0_goto(self</span><span class="s2">, </span><span class="s1">I</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0"># First we look for a previously cached entry</span>
        <span class="s1">g = self.lr_goto_cache.get((id(I)</span><span class="s2">, </span><span class="s1">x))</span>
        <span class="s2">if </span><span class="s1">g:</span>
            <span class="s2">return </span><span class="s1">g</span>

        <span class="s0"># Now we generate the goto set in a way that guarantees uniqueness</span>
        <span class="s0"># of the result</span>

        <span class="s1">s = self.lr_goto_cache.get(x)</span>
        <span class="s2">if not </span><span class="s1">s:</span>
            <span class="s1">s = {}</span>
            <span class="s1">self.lr_goto_cache[x] = s</span>

        <span class="s1">gs = []</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">I:</span>
            <span class="s1">n = p.lr_next</span>
            <span class="s2">if </span><span class="s1">n </span><span class="s2">and </span><span class="s1">n.lr_before == x:</span>
                <span class="s1">s1 = s.get(id(n))</span>
                <span class="s2">if not </span><span class="s1">s1:</span>
                    <span class="s1">s1 = {}</span>
                    <span class="s1">s[id(n)] = s1</span>
                <span class="s1">gs.append(n)</span>
                <span class="s1">s = s1</span>
        <span class="s1">g = s.get(</span><span class="s3">'$end'</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">g:</span>
            <span class="s2">if </span><span class="s1">gs:</span>
                <span class="s1">g = self.lr0_closure(gs)</span>
                <span class="s1">s[</span><span class="s3">'$end'</span><span class="s1">] = g</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">s[</span><span class="s3">'$end'</span><span class="s1">] = gs</span>
        <span class="s1">self.lr_goto_cache[(id(I)</span><span class="s2">, </span><span class="s1">x)] = g</span>
        <span class="s2">return </span><span class="s1">g</span>

    <span class="s0"># Compute the LR(0) sets of item function</span>
    <span class="s2">def </span><span class="s1">lr0_items(self):</span>
        <span class="s1">C = [self.lr0_closure([self.grammar.Productions[</span><span class="s4">0</span><span class="s1">].lr_next])]</span>
        <span class="s1">i = </span><span class="s4">0</span>
        <span class="s2">for </span><span class="s1">I </span><span class="s2">in </span><span class="s1">C:</span>
            <span class="s1">self.lr0_cidhash[id(I)] = i</span>
            <span class="s1">i += </span><span class="s4">1</span>

        <span class="s0"># Loop over the items in C and each grammar symbols</span>
        <span class="s1">i = </span><span class="s4">0</span>
        <span class="s2">while </span><span class="s1">i &lt; len(C):</span>
            <span class="s1">I = C[i]</span>
            <span class="s1">i += </span><span class="s4">1</span>

            <span class="s0"># Collect all of the symbols that could possibly be in the goto(I,X) sets</span>
            <span class="s1">asyms = {}</span>
            <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">I:</span>
                <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">ii.usyms:</span>
                    <span class="s1">asyms[s] = </span><span class="s2">None</span>

            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">asyms:</span>
                <span class="s1">g = self.lr0_goto(I</span><span class="s2">, </span><span class="s1">x)</span>
                <span class="s2">if not </span><span class="s1">g </span><span class="s2">or </span><span class="s1">id(g) </span><span class="s2">in </span><span class="s1">self.lr0_cidhash:</span>
                    <span class="s2">continue</span>
                <span class="s1">self.lr0_cidhash[id(g)] = len(C)</span>
                <span class="s1">C.append(g)</span>

        <span class="s2">return </span><span class="s1">C</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0">#                       ==== LALR(1) Parsing ====</span>
    <span class="s0">#</span>
    <span class="s0"># LALR(1) parsing is almost exactly the same as SLR except that instead of</span>
    <span class="s0"># relying upon Follow() sets when performing reductions, a more selective</span>
    <span class="s0"># lookahead set that incorporates the state of the LR(0) machine is utilized.</span>
    <span class="s0"># Thus, we mainly just have to focus on calculating the lookahead sets.</span>
    <span class="s0">#</span>
    <span class="s0"># The method used here is due to DeRemer and Pennelo (1982).</span>
    <span class="s0">#</span>
    <span class="s0"># DeRemer, F. L., and T. J. Pennelo: &quot;Efficient Computation of LALR(1)</span>
    <span class="s0">#     Lookahead Sets&quot;, ACM Transactions on Programming Languages and Systems,</span>
    <span class="s0">#     Vol. 4, No. 4, Oct. 1982, pp. 615-649</span>
    <span class="s0">#</span>
    <span class="s0"># Further details can also be found in:</span>
    <span class="s0">#</span>
    <span class="s0">#  J. Tremblay and P. Sorenson, &quot;The Theory and Practice of Compiler Writing&quot;,</span>
    <span class="s0">#      McGraw-Hill Book Company, (1985).</span>
    <span class="s0">#</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># compute_nullable_nonterminals()</span>
    <span class="s0">#</span>
    <span class="s0"># Creates a dictionary containing all of the non-terminals that might produce</span>
    <span class="s0"># an empty production.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">compute_nullable_nonterminals(self):</span>
        <span class="s1">nullable = set()</span>
        <span class="s1">num_nullable = </span><span class="s4">0</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.grammar.Productions[</span><span class="s4">1</span><span class="s1">:]:</span>
                <span class="s2">if </span><span class="s1">p.len == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">nullable.add(p.name)</span>
                    <span class="s2">continue</span>
                <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">p.prod:</span>
                    <span class="s2">if </span><span class="s1">t </span><span class="s2">not in </span><span class="s1">nullable:</span>
                        <span class="s2">break</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">nullable.add(p.name)</span>
            <span class="s2">if </span><span class="s1">len(nullable) == num_nullable:</span>
                <span class="s2">break</span>
            <span class="s1">num_nullable = len(nullable)</span>
        <span class="s2">return </span><span class="s1">nullable</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># find_nonterminal_trans(C)</span>
    <span class="s0">#</span>
    <span class="s0"># Given a set of LR(0) items, this functions finds all of the non-terminal</span>
    <span class="s0"># transitions.    These are transitions in which a dot appears immediately before</span>
    <span class="s0"># a non-terminal.   Returns a list of tuples of the form (state,N) where state</span>
    <span class="s0"># is the state number and N is the nonterminal symbol.</span>
    <span class="s0">#</span>
    <span class="s0"># The input C is the set of LR(0) items.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">find_nonterminal_transitions(self</span><span class="s2">, </span><span class="s1">C):</span>
        <span class="s1">trans = []</span>
        <span class="s2">for </span><span class="s1">stateno</span><span class="s2">, </span><span class="s1">state </span><span class="s2">in </span><span class="s1">enumerate(C):</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">state:</span>
                <span class="s2">if </span><span class="s1">p.lr_index &lt; p.len - </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">t = (stateno</span><span class="s2">, </span><span class="s1">p.prod[p.lr_index+</span><span class="s4">1</span><span class="s1">])</span>
                    <span class="s2">if </span><span class="s1">t[</span><span class="s4">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">self.grammar.Nonterminals:</span>
                        <span class="s2">if </span><span class="s1">t </span><span class="s2">not in </span><span class="s1">trans:</span>
                            <span class="s1">trans.append(t)</span>
        <span class="s2">return </span><span class="s1">trans</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># dr_relation()</span>
    <span class="s0">#</span>
    <span class="s0"># Computes the DR(p,A) relationships for non-terminal transitions.  The input</span>
    <span class="s0"># is a tuple (state,N) where state is a number and N is a nonterminal symbol.</span>
    <span class="s0">#</span>
    <span class="s0"># Returns a list of terminals.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">dr_relation(self</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">nullable):</span>
        <span class="s1">dr_set = {}</span>
        <span class="s1">state</span><span class="s2">, </span><span class="s1">N = trans</span>
        <span class="s1">terms = []</span>

        <span class="s1">g = self.lr0_goto(C[state]</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">g:</span>
            <span class="s2">if </span><span class="s1">p.lr_index &lt; p.len - </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">a = p.prod[p.lr_index+</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self.grammar.Terminals:</span>
                    <span class="s2">if </span><span class="s1">a </span><span class="s2">not in </span><span class="s1">terms:</span>
                        <span class="s1">terms.append(a)</span>

        <span class="s0"># This extra bit is to handle the start state</span>
        <span class="s2">if </span><span class="s1">state == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">N == self.grammar.Productions[</span><span class="s4">0</span><span class="s1">].prod[</span><span class="s4">0</span><span class="s1">]:</span>
            <span class="s1">terms.append(</span><span class="s3">'$end'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">terms</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># reads_relation()</span>
    <span class="s0">#</span>
    <span class="s0"># Computes the READS() relation (p,A) READS (t,C).</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">reads_relation(self</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">empty):</span>
        <span class="s0"># Look for empty transitions</span>
        <span class="s1">rel = []</span>
        <span class="s1">state</span><span class="s2">, </span><span class="s1">N = trans</span>

        <span class="s1">g = self.lr0_goto(C[state]</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s1">j = self.lr0_cidhash.get(id(g)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">g:</span>
            <span class="s2">if </span><span class="s1">p.lr_index &lt; p.len - </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">a = p.prod[p.lr_index + </span><span class="s4">1</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">a </span><span class="s2">in </span><span class="s1">empty:</span>
                    <span class="s1">rel.append((j</span><span class="s2">, </span><span class="s1">a))</span>

        <span class="s2">return </span><span class="s1">rel</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># compute_lookback_includes()</span>
    <span class="s0">#</span>
    <span class="s0"># Determines the lookback and includes relations</span>
    <span class="s0">#</span>
    <span class="s0"># LOOKBACK:</span>
    <span class="s0">#</span>
    <span class="s0"># This relation is determined by running the LR(0) state machine forward.</span>
    <span class="s0"># For example, starting with a production &quot;N : . A B C&quot;, we run it forward</span>
    <span class="s0"># to obtain &quot;N : A B C .&quot;   We then build a relationship between this final</span>
    <span class="s0"># state and the starting state.   These relationships are stored in a dictionary</span>
    <span class="s0"># lookdict.</span>
    <span class="s0">#</span>
    <span class="s0"># INCLUDES:</span>
    <span class="s0">#</span>
    <span class="s0"># Computes the INCLUDE() relation (p,A) INCLUDES (p',B).</span>
    <span class="s0">#</span>
    <span class="s0"># This relation is used to determine non-terminal transitions that occur</span>
    <span class="s0"># inside of other non-terminal transition states.   (p,A) INCLUDES (p', B)</span>
    <span class="s0"># if the following holds:</span>
    <span class="s0">#</span>
    <span class="s0">#       B -&gt; LAT, where T -&gt; epsilon and p' -L-&gt; p</span>
    <span class="s0">#</span>
    <span class="s0"># L is essentially a prefix (which may be empty), T is a suffix that must be</span>
    <span class="s0"># able to derive an empty string.  State p' must lead to state p with the string L.</span>
    <span class="s0">#</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">compute_lookback_includes(self</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">nullable):</span>
        <span class="s1">lookdict = {}          </span><span class="s0"># Dictionary of lookback relations</span>
        <span class="s1">includedict = {}       </span><span class="s0"># Dictionary of include relations</span>

        <span class="s0"># Make a dictionary of non-terminal transitions</span>
        <span class="s1">dtrans = {}</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">trans:</span>
            <span class="s1">dtrans[t] = </span><span class="s4">1</span>

        <span class="s0"># Loop over all transitions and compute lookbacks and includes</span>
        <span class="s2">for </span><span class="s1">state</span><span class="s2">, </span><span class="s1">N </span><span class="s2">in </span><span class="s1">trans:</span>
            <span class="s1">lookb = []</span>
            <span class="s1">includes = []</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">C[state]:</span>
                <span class="s2">if </span><span class="s1">p.name != N:</span>
                    <span class="s2">continue</span>

                <span class="s0"># Okay, we have a name match.  We now follow the production all the way</span>
                <span class="s0"># through the state machine until we get the . on the right hand side</span>

                <span class="s1">lr_index = p.lr_index</span>
                <span class="s1">j = state</span>
                <span class="s2">while </span><span class="s1">lr_index &lt; p.len - </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">lr_index = lr_index + </span><span class="s4">1</span>
                    <span class="s1">t = p.prod[lr_index]</span>

                    <span class="s0"># Check to see if this symbol and state are a non-terminal transition</span>
                    <span class="s2">if </span><span class="s1">(j</span><span class="s2">, </span><span class="s1">t) </span><span class="s2">in </span><span class="s1">dtrans:</span>
                        <span class="s0"># Yes.  Okay, there is some chance that this is an includes relation</span>
                        <span class="s0"># the only way to know for certain is whether the rest of the</span>
                        <span class="s0"># production derives empty</span>

                        <span class="s1">li = lr_index + </span><span class="s4">1</span>
                        <span class="s2">while </span><span class="s1">li &lt; p.len:</span>
                            <span class="s2">if </span><span class="s1">p.prod[li] </span><span class="s2">in </span><span class="s1">self.grammar.Terminals:</span>
                                <span class="s2">break      </span><span class="s0"># No forget it</span>
                            <span class="s2">if </span><span class="s1">p.prod[li] </span><span class="s2">not in </span><span class="s1">nullable:</span>
                                <span class="s2">break</span>
                            <span class="s1">li = li + </span><span class="s4">1</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s0"># Appears to be a relation between (j,t) and (state,N)</span>
                            <span class="s1">includes.append((j</span><span class="s2">, </span><span class="s1">t))</span>

                    <span class="s1">g = self.lr0_goto(C[j]</span><span class="s2">, </span><span class="s1">t)               </span><span class="s0"># Go to next set</span>
                    <span class="s1">j = self.lr0_cidhash.get(id(g)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)      </span><span class="s0"># Go to next state</span>

                <span class="s0"># When we get here, j is the final state, now we have to locate the production</span>
                <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">C[j]:</span>
                    <span class="s2">if </span><span class="s1">r.name != p.name:</span>
                        <span class="s2">continue</span>
                    <span class="s2">if </span><span class="s1">r.len != p.len:</span>
                        <span class="s2">continue</span>
                    <span class="s1">i = </span><span class="s4">0</span>
                    <span class="s0"># This look is comparing a production &quot;. A B C&quot; with &quot;A B C .&quot;</span>
                    <span class="s2">while </span><span class="s1">i &lt; r.lr_index:</span>
                        <span class="s2">if </span><span class="s1">r.prod[i] != p.prod[i+</span><span class="s4">1</span><span class="s1">]:</span>
                            <span class="s2">break</span>
                        <span class="s1">i = i + </span><span class="s4">1</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">lookb.append((j</span><span class="s2">, </span><span class="s1">r))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">includes:</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">includedict:</span>
                    <span class="s1">includedict[i] = []</span>
                <span class="s1">includedict[i].append((state</span><span class="s2">, </span><span class="s1">N))</span>
            <span class="s1">lookdict[(state</span><span class="s2">, </span><span class="s1">N)] = lookb</span>

        <span class="s2">return </span><span class="s1">lookdict</span><span class="s2">, </span><span class="s1">includedict</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># compute_read_sets()</span>
    <span class="s0">#</span>
    <span class="s0"># Given a set of LR(0) items, this function computes the read sets.</span>
    <span class="s0">#</span>
    <span class="s0"># Inputs:  C        =  Set of LR(0) items</span>
    <span class="s0">#          ntrans   = Set of nonterminal transitions</span>
    <span class="s0">#          nullable = Set of empty transitions</span>
    <span class="s0">#</span>
    <span class="s0"># Returns a set containing the read sets</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">compute_read_sets(self</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">ntrans</span><span class="s2">, </span><span class="s1">nullable):</span>
        <span class="s1">FP = </span><span class="s2">lambda </span><span class="s1">x: self.dr_relation(C</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">nullable)</span>
        <span class="s1">R =  </span><span class="s2">lambda </span><span class="s1">x: self.reads_relation(C</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">nullable)</span>
        <span class="s1">F = digraph(ntrans</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">FP)</span>
        <span class="s2">return </span><span class="s1">F</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># compute_follow_sets()</span>
    <span class="s0">#</span>
    <span class="s0"># Given a set of LR(0) items, a set of non-terminal transitions, a readset,</span>
    <span class="s0"># and an include set, this function computes the follow sets</span>
    <span class="s0">#</span>
    <span class="s0"># Follow(p,A) = Read(p,A) U U {Follow(p',B) | (p,A) INCLUDES (p',B)}</span>
    <span class="s0">#</span>
    <span class="s0"># Inputs:</span>
    <span class="s0">#            ntrans     = Set of nonterminal transitions</span>
    <span class="s0">#            readsets   = Readset (previously computed)</span>
    <span class="s0">#            inclsets   = Include sets (previously computed)</span>
    <span class="s0">#</span>
    <span class="s0"># Returns a set containing the follow sets</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">compute_follow_sets(self</span><span class="s2">, </span><span class="s1">ntrans</span><span class="s2">, </span><span class="s1">readsets</span><span class="s2">, </span><span class="s1">inclsets):</span>
        <span class="s1">FP = </span><span class="s2">lambda </span><span class="s1">x: readsets[x]</span>
        <span class="s1">R  = </span><span class="s2">lambda </span><span class="s1">x: inclsets.get(x</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s1">F = digraph(ntrans</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">FP)</span>
        <span class="s2">return </span><span class="s1">F</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># add_lookaheads()</span>
    <span class="s0">#</span>
    <span class="s0"># Attaches the lookahead symbols to grammar rules.</span>
    <span class="s0">#</span>
    <span class="s0"># Inputs:    lookbacks         -  Set of lookback relations</span>
    <span class="s0">#            followset         -  Computed follow set</span>
    <span class="s0">#</span>
    <span class="s0"># This function directly attaches the lookaheads to productions contained</span>
    <span class="s0"># in the lookbacks set</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">add_lookaheads(self</span><span class="s2">, </span><span class="s1">lookbacks</span><span class="s2">, </span><span class="s1">followset):</span>
        <span class="s2">for </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">lb </span><span class="s2">in </span><span class="s1">lookbacks.items():</span>
            <span class="s0"># Loop over productions in lookback</span>
            <span class="s2">for </span><span class="s1">state</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">lb:</span>
                <span class="s2">if </span><span class="s1">state </span><span class="s2">not in </span><span class="s1">p.lookaheads:</span>
                    <span class="s1">p.lookaheads[state] = []</span>
                <span class="s1">f = followset.get(trans</span><span class="s2">, </span><span class="s1">[])</span>
                <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">f:</span>
                    <span class="s2">if </span><span class="s1">a </span><span class="s2">not in </span><span class="s1">p.lookaheads[state]:</span>
                        <span class="s1">p.lookaheads[state].append(a)</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># add_lalr_lookaheads()</span>
    <span class="s0">#</span>
    <span class="s0"># This function does all of the work of adding lookahead information for use</span>
    <span class="s0"># with LALR parsing</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">add_lalr_lookaheads(self</span><span class="s2">, </span><span class="s1">C):</span>
        <span class="s0"># Determine all of the nullable nonterminals</span>
        <span class="s1">nullable = self.compute_nullable_nonterminals()</span>

        <span class="s0"># Find all non-terminal transitions</span>
        <span class="s1">trans = self.find_nonterminal_transitions(C)</span>

        <span class="s0"># Compute read sets</span>
        <span class="s1">readsets = self.compute_read_sets(C</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">nullable)</span>

        <span class="s0"># Compute lookback/includes relations</span>
        <span class="s1">lookd</span><span class="s2">, </span><span class="s1">included = self.compute_lookback_includes(C</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">nullable)</span>

        <span class="s0"># Compute LALR FOLLOW sets</span>
        <span class="s1">followsets = self.compute_follow_sets(trans</span><span class="s2">, </span><span class="s1">readsets</span><span class="s2">, </span><span class="s1">included)</span>

        <span class="s0"># Add all of the lookaheads</span>
        <span class="s1">self.add_lookaheads(lookd</span><span class="s2">, </span><span class="s1">followsets)</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># lr_parse_table()</span>
    <span class="s0">#</span>
    <span class="s0"># This function constructs the parse tables for SLR or LALR</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">lr_parse_table(self):</span>
        <span class="s1">Productions = self.grammar.Productions</span>
        <span class="s1">Precedence  = self.grammar.Precedence</span>
        <span class="s1">goto   = self.lr_goto         </span><span class="s0"># Goto array</span>
        <span class="s1">action = self.lr_action       </span><span class="s0"># Action array</span>
        <span class="s1">log    = self.log             </span><span class="s0"># Logger for output</span>

        <span class="s1">actionp = {}                  </span><span class="s0"># Action production array (temporary)</span>

        <span class="s1">log.info(</span><span class="s3">'Parsing method: %s'</span><span class="s2">, </span><span class="s1">self.lr_method)</span>

        <span class="s0"># Step 1: Construct C = { I0, I1, ... IN}, collection of LR(0) items</span>
        <span class="s0"># This determines the number of states</span>

        <span class="s1">C = self.lr0_items()</span>

        <span class="s2">if </span><span class="s1">self.lr_method == </span><span class="s3">'LALR'</span><span class="s1">:</span>
            <span class="s1">self.add_lalr_lookaheads(C)</span>

        <span class="s0"># Build the parser table, state by state</span>
        <span class="s1">st = </span><span class="s4">0</span>
        <span class="s2">for </span><span class="s1">I </span><span class="s2">in </span><span class="s1">C:</span>
            <span class="s0"># Loop over each production in I</span>
            <span class="s1">actlist = []              </span><span class="s0"># List of actions</span>
            <span class="s1">st_action  = {}</span>
            <span class="s1">st_actionp = {}</span>
            <span class="s1">st_goto    = {}</span>
            <span class="s1">log.info(</span><span class="s3">''</span><span class="s1">)</span>
            <span class="s1">log.info(</span><span class="s3">'state %d'</span><span class="s2">, </span><span class="s1">st)</span>
            <span class="s1">log.info(</span><span class="s3">''</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">I:</span>
                <span class="s1">log.info(</span><span class="s3">'    (%d) %s'</span><span class="s2">, </span><span class="s1">p.number</span><span class="s2">, </span><span class="s1">p)</span>
            <span class="s1">log.info(</span><span class="s3">''</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">I:</span>
                    <span class="s2">if </span><span class="s1">p.len == p.lr_index + </span><span class="s4">1</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">p.name == </span><span class="s3">&quot;S'&quot;</span><span class="s1">:</span>
                            <span class="s0"># Start symbol. Accept!</span>
                            <span class="s1">st_action[</span><span class="s3">'$end'</span><span class="s1">] = </span><span class="s4">0</span>
                            <span class="s1">st_actionp[</span><span class="s3">'$end'</span><span class="s1">] = p</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s0"># We are at the end of a production.  Reduce!</span>
                            <span class="s2">if </span><span class="s1">self.lr_method == </span><span class="s3">'LALR'</span><span class="s1">:</span>
                                <span class="s1">laheads = p.lookaheads[st]</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">laheads = self.grammar.Follow[p.name]</span>
                            <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">laheads:</span>
                                <span class="s1">actlist.append((a</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s3">'reduce using rule %d (%s)' </span><span class="s1">% (p.number</span><span class="s2">, </span><span class="s1">p)))</span>
                                <span class="s1">r = st_action.get(a)</span>
                                <span class="s2">if </span><span class="s1">r </span><span class="s2">is not None</span><span class="s1">:</span>
                                    <span class="s0"># Whoa. Have a shift/reduce or reduce/reduce conflict</span>
                                    <span class="s2">if </span><span class="s1">r &gt; </span><span class="s4">0</span><span class="s1">:</span>
                                        <span class="s0"># Need to decide on shift or reduce here</span>
                                        <span class="s0"># By default we favor shifting. Need to add</span>
                                        <span class="s0"># some precedence rules here.</span>

                                        <span class="s0"># Shift precedence comes from the token</span>
                                        <span class="s1">sprec</span><span class="s2">, </span><span class="s1">slevel = Precedence.get(a</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'right'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>

                                        <span class="s0"># Reduce precedence comes from rule being reduced (p)</span>
                                        <span class="s1">rprec</span><span class="s2">, </span><span class="s1">rlevel = Productions[p.number].prec</span>

                                        <span class="s2">if </span><span class="s1">(slevel &lt; rlevel) </span><span class="s2">or </span><span class="s1">((slevel == rlevel) </span><span class="s2">and </span><span class="s1">(rprec == </span><span class="s3">'left'</span><span class="s1">)):</span>
                                            <span class="s0"># We really need to reduce here.</span>
                                            <span class="s1">st_action[a] = -p.number</span>
                                            <span class="s1">st_actionp[a] = p</span>
                                            <span class="s2">if not </span><span class="s1">slevel </span><span class="s2">and not </span><span class="s1">rlevel:</span>
                                                <span class="s1">log.info(</span><span class="s3">'  ! shift/reduce conflict for %s resolved as reduce'</span><span class="s2">, </span><span class="s1">a)</span>
                                                <span class="s1">self.sr_conflicts.append((st</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s3">'reduce'</span><span class="s1">))</span>
                                            <span class="s1">Productions[p.number].reduced += </span><span class="s4">1</span>
                                        <span class="s2">elif </span><span class="s1">(slevel == rlevel) </span><span class="s2">and </span><span class="s1">(rprec == </span><span class="s3">'nonassoc'</span><span class="s1">):</span>
                                            <span class="s1">st_action[a] = </span><span class="s2">None</span>
                                        <span class="s2">else</span><span class="s1">:</span>
                                            <span class="s0"># Hmmm. Guess we'll keep the shift</span>
                                            <span class="s2">if not </span><span class="s1">rlevel:</span>
                                                <span class="s1">log.info(</span><span class="s3">'  ! shift/reduce conflict for %s resolved as shift'</span><span class="s2">, </span><span class="s1">a)</span>
                                                <span class="s1">self.sr_conflicts.append((st</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s3">'shift'</span><span class="s1">))</span>
                                    <span class="s2">elif </span><span class="s1">r &lt; </span><span class="s4">0</span><span class="s1">:</span>
                                        <span class="s0"># Reduce/reduce conflict.   In this case, we favor the rule</span>
                                        <span class="s0"># that was defined first in the grammar file</span>
                                        <span class="s1">oldp = Productions[-r]</span>
                                        <span class="s1">pp = Productions[p.number]</span>
                                        <span class="s2">if </span><span class="s1">oldp.line &gt; pp.line:</span>
                                            <span class="s1">st_action[a] = -p.number</span>
                                            <span class="s1">st_actionp[a] = p</span>
                                            <span class="s1">chosenp</span><span class="s2">, </span><span class="s1">rejectp = pp</span><span class="s2">, </span><span class="s1">oldp</span>
                                            <span class="s1">Productions[p.number].reduced += </span><span class="s4">1</span>
                                            <span class="s1">Productions[oldp.number].reduced -= </span><span class="s4">1</span>
                                        <span class="s2">else</span><span class="s1">:</span>
                                            <span class="s1">chosenp</span><span class="s2">, </span><span class="s1">rejectp = oldp</span><span class="s2">, </span><span class="s1">pp</span>
                                        <span class="s1">self.rr_conflicts.append((st</span><span class="s2">, </span><span class="s1">chosenp</span><span class="s2">, </span><span class="s1">rejectp))</span>
                                        <span class="s1">log.info(</span><span class="s3">'  ! reduce/reduce conflict for %s resolved using rule %d (%s)'</span><span class="s2">,</span>
                                                 <span class="s1">a</span><span class="s2">, </span><span class="s1">st_actionp[a].number</span><span class="s2">, </span><span class="s1">st_actionp[a])</span>
                                    <span class="s2">else</span><span class="s1">:</span>
                                        <span class="s2">raise </span><span class="s1">LALRError(</span><span class="s3">'Unknown conflict in state %d' </span><span class="s1">% st)</span>
                                <span class="s2">else</span><span class="s1">:</span>
                                    <span class="s1">st_action[a] = -p.number</span>
                                    <span class="s1">st_actionp[a] = p</span>
                                    <span class="s1">Productions[p.number].reduced += </span><span class="s4">1</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">i = p.lr_index</span>
                        <span class="s1">a = p.prod[i+</span><span class="s4">1</span><span class="s1">]       </span><span class="s0"># Get symbol right after the &quot;.&quot;</span>
                        <span class="s2">if </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self.grammar.Terminals:</span>
                            <span class="s1">g = self.lr0_goto(I</span><span class="s2">, </span><span class="s1">a)</span>
                            <span class="s1">j = self.lr0_cidhash.get(id(g)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
                            <span class="s2">if </span><span class="s1">j &gt;= </span><span class="s4">0</span><span class="s1">:</span>
                                <span class="s0"># We are in a shift state</span>
                                <span class="s1">actlist.append((a</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s3">'shift and go to state %d' </span><span class="s1">% j))</span>
                                <span class="s1">r = st_action.get(a)</span>
                                <span class="s2">if </span><span class="s1">r </span><span class="s2">is not None</span><span class="s1">:</span>
                                    <span class="s0"># Whoa have a shift/reduce or shift/shift conflict</span>
                                    <span class="s2">if </span><span class="s1">r &gt; </span><span class="s4">0</span><span class="s1">:</span>
                                        <span class="s2">if </span><span class="s1">r != j:</span>
                                            <span class="s2">raise </span><span class="s1">LALRError(</span><span class="s3">'Shift/shift conflict in state %d' </span><span class="s1">% st)</span>
                                    <span class="s2">elif </span><span class="s1">r &lt; </span><span class="s4">0</span><span class="s1">:</span>
                                        <span class="s0"># Do a precedence check.</span>
                                        <span class="s0">#   -  if precedence of reduce rule is higher, we reduce.</span>
                                        <span class="s0">#   -  if precedence of reduce is same and left assoc, we reduce.</span>
                                        <span class="s0">#   -  otherwise we shift</span>

                                        <span class="s0"># Shift precedence comes from the token</span>
                                        <span class="s1">sprec</span><span class="s2">, </span><span class="s1">slevel = Precedence.get(a</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'right'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>

                                        <span class="s0"># Reduce precedence comes from the rule that could have been reduced</span>
                                        <span class="s1">rprec</span><span class="s2">, </span><span class="s1">rlevel = Productions[st_actionp[a].number].prec</span>

                                        <span class="s2">if </span><span class="s1">(slevel &gt; rlevel) </span><span class="s2">or </span><span class="s1">((slevel == rlevel) </span><span class="s2">and </span><span class="s1">(rprec == </span><span class="s3">'right'</span><span class="s1">)):</span>
                                            <span class="s0"># We decide to shift here... highest precedence to shift</span>
                                            <span class="s1">Productions[st_actionp[a].number].reduced -= </span><span class="s4">1</span>
                                            <span class="s1">st_action[a] = j</span>
                                            <span class="s1">st_actionp[a] = p</span>
                                            <span class="s2">if not </span><span class="s1">rlevel:</span>
                                                <span class="s1">log.info(</span><span class="s3">'  ! shift/reduce conflict for %s resolved as shift'</span><span class="s2">, </span><span class="s1">a)</span>
                                                <span class="s1">self.sr_conflicts.append((st</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s3">'shift'</span><span class="s1">))</span>
                                        <span class="s2">elif </span><span class="s1">(slevel == rlevel) </span><span class="s2">and </span><span class="s1">(rprec == </span><span class="s3">'nonassoc'</span><span class="s1">):</span>
                                            <span class="s1">st_action[a] = </span><span class="s2">None</span>
                                        <span class="s2">else</span><span class="s1">:</span>
                                            <span class="s0"># Hmmm. Guess we'll keep the reduce</span>
                                            <span class="s2">if not </span><span class="s1">slevel </span><span class="s2">and not </span><span class="s1">rlevel:</span>
                                                <span class="s1">log.info(</span><span class="s3">'  ! shift/reduce conflict for %s resolved as reduce'</span><span class="s2">, </span><span class="s1">a)</span>
                                                <span class="s1">self.sr_conflicts.append((st</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s3">'reduce'</span><span class="s1">))</span>

                                    <span class="s2">else</span><span class="s1">:</span>
                                        <span class="s2">raise </span><span class="s1">LALRError(</span><span class="s3">'Unknown conflict in state %d' </span><span class="s1">% st)</span>
                                <span class="s2">else</span><span class="s1">:</span>
                                    <span class="s1">st_action[a] = j</span>
                                    <span class="s1">st_actionp[a] = p</span>

            <span class="s0"># Print the actions associated with each terminal</span>
            <span class="s1">_actprint = {}</span>
            <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">m </span><span class="s2">in </span><span class="s1">actlist:</span>
                <span class="s2">if </span><span class="s1">a </span><span class="s2">in </span><span class="s1">st_action:</span>
                    <span class="s2">if </span><span class="s1">p </span><span class="s2">is </span><span class="s1">st_actionp[a]:</span>
                        <span class="s1">log.info(</span><span class="s3">'    %-15s %s'</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">m)</span>
                        <span class="s1">_actprint[(a</span><span class="s2">, </span><span class="s1">m)] = </span><span class="s4">1</span>
            <span class="s1">log.info(</span><span class="s3">''</span><span class="s1">)</span>
            <span class="s0"># Print the actions that were not used. (debugging)</span>
            <span class="s1">not_used = </span><span class="s4">0</span>
            <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">m </span><span class="s2">in </span><span class="s1">actlist:</span>
                <span class="s2">if </span><span class="s1">a </span><span class="s2">in </span><span class="s1">st_action:</span>
                    <span class="s2">if </span><span class="s1">p </span><span class="s2">is not </span><span class="s1">st_actionp[a]:</span>
                        <span class="s2">if not </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">m) </span><span class="s2">in </span><span class="s1">_actprint:</span>
                            <span class="s1">log.debug(</span><span class="s3">'  ! %-15s [ %s ]'</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">m)</span>
                            <span class="s1">not_used = </span><span class="s4">1</span>
                            <span class="s1">_actprint[(a</span><span class="s2">, </span><span class="s1">m)] = </span><span class="s4">1</span>
            <span class="s2">if </span><span class="s1">not_used:</span>
                <span class="s1">log.debug(</span><span class="s3">''</span><span class="s1">)</span>

            <span class="s0"># Construct the goto table for this state</span>

            <span class="s1">nkeys = {}</span>
            <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">I:</span>
                <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">ii.usyms:</span>
                    <span class="s2">if </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self.grammar.Nonterminals:</span>
                        <span class="s1">nkeys[s] = </span><span class="s2">None</span>
            <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">nkeys:</span>
                <span class="s1">g = self.lr0_goto(I</span><span class="s2">, </span><span class="s1">n)</span>
                <span class="s1">j = self.lr0_cidhash.get(id(g)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">j &gt;= </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">st_goto[n] = j</span>
                    <span class="s1">log.info(</span><span class="s3">'    %-30s shift and go to state %d'</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">j)</span>

            <span class="s1">action[st] = st_action</span>
            <span class="s1">actionp[st] = st_actionp</span>
            <span class="s1">goto[st] = st_goto</span>
            <span class="s1">st += </span><span class="s4">1</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># write()</span>
    <span class="s0">#</span>
    <span class="s0"># This function writes the LR parsing tables to a file</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">write_table(self</span><span class="s2">, </span><span class="s1">tabmodule</span><span class="s2">, </span><span class="s1">outputdir=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">signature=</span><span class="s3">''</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">isinstance(tabmodule</span><span class="s2">, </span><span class="s1">types.ModuleType):</span>
            <span class="s2">raise </span><span class="s1">IOError(</span><span class="s3">&quot;Won't overwrite existing tabmodule&quot;</span><span class="s1">)</span>

        <span class="s1">basemodulename = tabmodule.split(</span><span class="s3">'.'</span><span class="s1">)[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">filename = os.path.join(outputdir</span><span class="s2">, </span><span class="s1">basemodulename) + </span><span class="s3">'.py'</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">f = open(filename</span><span class="s2">, </span><span class="s3">'w'</span><span class="s1">)</span>

            <span class="s1">f.write(</span><span class="s3">''' 
# %s 
# This file is automatically generated. Do not edit. 
_tabversion = %r 
 
_lr_method = %r 
 
_lr_signature = %r 
    ''' </span><span class="s1">% (os.path.basename(filename)</span><span class="s2">, </span><span class="s1">__tabversion__</span><span class="s2">, </span><span class="s1">self.lr_method</span><span class="s2">, </span><span class="s1">signature))</span>

            <span class="s0"># Change smaller to 0 to go back to original tables</span>
            <span class="s1">smaller = </span><span class="s4">1</span>

            <span class="s0"># Factor out names to try and make smaller</span>
            <span class="s2">if </span><span class="s1">smaller:</span>
                <span class="s1">items = {}</span>

                <span class="s2">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">nd </span><span class="s2">in </span><span class="s1">self.lr_action.items():</span>
                    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">nd.items():</span>
                        <span class="s1">i = items.get(name)</span>
                        <span class="s2">if not </span><span class="s1">i:</span>
                            <span class="s1">i = ([]</span><span class="s2">, </span><span class="s1">[])</span>
                            <span class="s1">items[name] = i</span>
                        <span class="s1">i[</span><span class="s4">0</span><span class="s1">].append(s)</span>
                        <span class="s1">i[</span><span class="s4">1</span><span class="s1">].append(v)</span>

                <span class="s1">f.write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">_lr_action_items = {'</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">items.items():</span>
                    <span class="s1">f.write(</span><span class="s3">'%r:([' </span><span class="s1">% k)</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">v[</span><span class="s4">0</span><span class="s1">]:</span>
                        <span class="s1">f.write(</span><span class="s3">'%r,' </span><span class="s1">% i)</span>
                    <span class="s1">f.write(</span><span class="s3">'],['</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">v[</span><span class="s4">1</span><span class="s1">]:</span>
                        <span class="s1">f.write(</span><span class="s3">'%r,' </span><span class="s1">% i)</span>

                    <span class="s1">f.write(</span><span class="s3">']),'</span><span class="s1">)</span>
                <span class="s1">f.write(</span><span class="s3">'}</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

                <span class="s1">f.write(</span><span class="s3">''' 
_lr_action = {} 
for _k, _v in _lr_action_items.items(): 
   for _x,_y in zip(_v[0],_v[1]): 
      if not _x in _lr_action:  _lr_action[_x] = {} 
      _lr_action[_x][_k] = _y 
del _lr_action_items 
'''</span><span class="s1">)</span>

            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">f.write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">_lr_action = { '</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.lr_action.items():</span>
                    <span class="s1">f.write(</span><span class="s3">'(%r,%r):%r,' </span><span class="s1">% (k[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">k[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">v))</span>
                <span class="s1">f.write(</span><span class="s3">'}</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">smaller:</span>
                <span class="s0"># Factor out names to try and make smaller</span>
                <span class="s1">items = {}</span>

                <span class="s2">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">nd </span><span class="s2">in </span><span class="s1">self.lr_goto.items():</span>
                    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">nd.items():</span>
                        <span class="s1">i = items.get(name)</span>
                        <span class="s2">if not </span><span class="s1">i:</span>
                            <span class="s1">i = ([]</span><span class="s2">, </span><span class="s1">[])</span>
                            <span class="s1">items[name] = i</span>
                        <span class="s1">i[</span><span class="s4">0</span><span class="s1">].append(s)</span>
                        <span class="s1">i[</span><span class="s4">1</span><span class="s1">].append(v)</span>

                <span class="s1">f.write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">_lr_goto_items = {'</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">items.items():</span>
                    <span class="s1">f.write(</span><span class="s3">'%r:([' </span><span class="s1">% k)</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">v[</span><span class="s4">0</span><span class="s1">]:</span>
                        <span class="s1">f.write(</span><span class="s3">'%r,' </span><span class="s1">% i)</span>
                    <span class="s1">f.write(</span><span class="s3">'],['</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">v[</span><span class="s4">1</span><span class="s1">]:</span>
                        <span class="s1">f.write(</span><span class="s3">'%r,' </span><span class="s1">% i)</span>

                    <span class="s1">f.write(</span><span class="s3">']),'</span><span class="s1">)</span>
                <span class="s1">f.write(</span><span class="s3">'}</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

                <span class="s1">f.write(</span><span class="s3">''' 
_lr_goto = {} 
for _k, _v in _lr_goto_items.items(): 
   for _x, _y in zip(_v[0], _v[1]): 
       if not _x in _lr_goto: _lr_goto[_x] = {} 
       _lr_goto[_x][_k] = _y 
del _lr_goto_items 
'''</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">f.write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">_lr_goto = { '</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.lr_goto.items():</span>
                    <span class="s1">f.write(</span><span class="s3">'(%r,%r):%r,' </span><span class="s1">% (k[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">k[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">v))</span>
                <span class="s1">f.write(</span><span class="s3">'}</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

            <span class="s0"># Write production table</span>
            <span class="s1">f.write(</span><span class="s3">'_lr_productions = [</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.lr_productions:</span>
                <span class="s2">if </span><span class="s1">p.func:</span>
                    <span class="s1">f.write(</span><span class="s3">'  (%r,%r,%d,%r,%r,%d),</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">% (p.str</span><span class="s2">, </span><span class="s1">p.name</span><span class="s2">, </span><span class="s1">p.len</span><span class="s2">,</span>
                                                          <span class="s1">p.func</span><span class="s2">, </span><span class="s1">os.path.basename(p.file)</span><span class="s2">, </span><span class="s1">p.line))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">f.write(</span><span class="s3">'  (%r,%r,%d,None,None,None),</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">% (str(p)</span><span class="s2">, </span><span class="s1">p.name</span><span class="s2">, </span><span class="s1">p.len))</span>
            <span class="s1">f.write(</span><span class="s3">']</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
            <span class="s1">f.close()</span>

        <span class="s2">except </span><span class="s1">IOError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise</span>


    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># pickle_table()</span>
    <span class="s0">#</span>
    <span class="s0"># This function pickles the LR parsing tables to a supplied file object</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">pickle_table(self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">signature=</span><span class="s3">''</span><span class="s1">):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">cPickle </span><span class="s2">as </span><span class="s1">pickle</span>
        <span class="s2">except </span><span class="s1">ImportError:</span>
            <span class="s2">import </span><span class="s1">pickle</span>
        <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">outf:</span>
            <span class="s1">pickle.dump(__tabversion__</span><span class="s2">, </span><span class="s1">outf</span><span class="s2">, </span><span class="s1">pickle_protocol)</span>
            <span class="s1">pickle.dump(self.lr_method</span><span class="s2">, </span><span class="s1">outf</span><span class="s2">, </span><span class="s1">pickle_protocol)</span>
            <span class="s1">pickle.dump(signature</span><span class="s2">, </span><span class="s1">outf</span><span class="s2">, </span><span class="s1">pickle_protocol)</span>
            <span class="s1">pickle.dump(self.lr_action</span><span class="s2">, </span><span class="s1">outf</span><span class="s2">, </span><span class="s1">pickle_protocol)</span>
            <span class="s1">pickle.dump(self.lr_goto</span><span class="s2">, </span><span class="s1">outf</span><span class="s2">, </span><span class="s1">pickle_protocol)</span>

            <span class="s1">outp = []</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.lr_productions:</span>
                <span class="s2">if </span><span class="s1">p.func:</span>
                    <span class="s1">outp.append((p.str</span><span class="s2">, </span><span class="s1">p.name</span><span class="s2">, </span><span class="s1">p.len</span><span class="s2">, </span><span class="s1">p.func</span><span class="s2">, </span><span class="s1">os.path.basename(p.file)</span><span class="s2">, </span><span class="s1">p.line))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">outp.append((str(p)</span><span class="s2">, </span><span class="s1">p.name</span><span class="s2">, </span><span class="s1">p.len</span><span class="s2">, None, None, None</span><span class="s1">))</span>
            <span class="s1">pickle.dump(outp</span><span class="s2">, </span><span class="s1">outf</span><span class="s2">, </span><span class="s1">pickle_protocol)</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                            === INTROSPECTION ===</span>
<span class="s0">#</span>
<span class="s0"># The following functions and classes are used to implement the PLY</span>
<span class="s0"># introspection features followed by the yacc() function itself.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># get_caller_module_dict()</span>
<span class="s0">#</span>
<span class="s0"># This function returns a dictionary containing all of the symbols defined within</span>
<span class="s0"># a caller further down the call stack.  This is used to get the environment</span>
<span class="s0"># associated with the yacc() call if none was provided.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">get_caller_module_dict(levels):</span>
    <span class="s1">f = sys._getframe(levels)</span>
    <span class="s1">ldict = f.f_globals.copy()</span>
    <span class="s2">if </span><span class="s1">f.f_globals != f.f_locals:</span>
        <span class="s1">ldict.update(f.f_locals)</span>
    <span class="s2">return </span><span class="s1">ldict</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># parse_grammar()</span>
<span class="s0">#</span>
<span class="s0"># This takes a raw grammar rule string and parses it into production data</span>
<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s2">def </span><span class="s1">parse_grammar(doc</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">line):</span>
    <span class="s1">grammar = []</span>
    <span class="s0"># Split the doc string into lines</span>
    <span class="s1">pstrings = doc.splitlines()</span>
    <span class="s1">lastp = </span><span class="s2">None</span>
    <span class="s1">dline = line</span>
    <span class="s2">for </span><span class="s1">ps </span><span class="s2">in </span><span class="s1">pstrings:</span>
        <span class="s1">dline += </span><span class="s4">1</span>
        <span class="s1">p = ps.split()</span>
        <span class="s2">if not </span><span class="s1">p:</span>
            <span class="s2">continue</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">p[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">'|'</span><span class="s1">:</span>
                <span class="s0"># This is a continuation of a previous rule</span>
                <span class="s2">if not </span><span class="s1">lastp:</span>
                    <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">&quot;%s:%d: Misplaced '|'&quot; </span><span class="s1">% (file</span><span class="s2">, </span><span class="s1">dline))</span>
                <span class="s1">prodname = lastp</span>
                <span class="s1">syms = p[</span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">prodname = p[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">lastp = prodname</span>
                <span class="s1">syms   = p[</span><span class="s4">2</span><span class="s1">:]</span>
                <span class="s1">assign = p[</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">assign != </span><span class="s3">':' </span><span class="s2">and </span><span class="s1">assign != </span><span class="s3">'::='</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">&quot;%s:%d: Syntax error. Expected ':'&quot; </span><span class="s1">% (file</span><span class="s2">, </span><span class="s1">dline))</span>

            <span class="s1">grammar.append((file</span><span class="s2">, </span><span class="s1">dline</span><span class="s2">, </span><span class="s1">prodname</span><span class="s2">, </span><span class="s1">syms))</span>
        <span class="s2">except </span><span class="s1">SyntaxError:</span>
            <span class="s2">raise</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s2">raise </span><span class="s1">SyntaxError(</span><span class="s3">'%s:%d: Syntax error in rule %r' </span><span class="s1">% (file</span><span class="s2">, </span><span class="s1">dline</span><span class="s2">, </span><span class="s1">ps.strip()))</span>

    <span class="s2">return </span><span class="s1">grammar</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># ParserReflect()</span>
<span class="s0">#</span>
<span class="s0"># This class represents information extracted for building a parser including</span>
<span class="s0"># start symbol, error function, tokens, precedence list, action functions,</span>
<span class="s0"># etc.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s2">class </span><span class="s1">ParserReflect(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pdict</span><span class="s2">, </span><span class="s1">log=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.pdict      = pdict</span>
        <span class="s1">self.start      = </span><span class="s2">None</span>
        <span class="s1">self.error_func = </span><span class="s2">None</span>
        <span class="s1">self.tokens     = </span><span class="s2">None</span>
        <span class="s1">self.modules    = set()</span>
        <span class="s1">self.grammar    = []</span>
        <span class="s1">self.error      = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">log </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.log = PlyLogger(sys.stderr)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.log = log</span>

    <span class="s0"># Get all of the basic information</span>
    <span class="s2">def </span><span class="s1">get_all(self):</span>
        <span class="s1">self.get_start()</span>
        <span class="s1">self.get_error_func()</span>
        <span class="s1">self.get_tokens()</span>
        <span class="s1">self.get_precedence()</span>
        <span class="s1">self.get_pfunctions()</span>

    <span class="s0"># Validate all of the information</span>
    <span class="s2">def </span><span class="s1">validate_all(self):</span>
        <span class="s1">self.validate_start()</span>
        <span class="s1">self.validate_error_func()</span>
        <span class="s1">self.validate_tokens()</span>
        <span class="s1">self.validate_precedence()</span>
        <span class="s1">self.validate_pfunctions()</span>
        <span class="s1">self.validate_modules()</span>
        <span class="s2">return </span><span class="s1">self.error</span>

    <span class="s0"># Compute a signature over the grammar</span>
    <span class="s2">def </span><span class="s1">signature(self):</span>
        <span class="s1">parts = []</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.start:</span>
                <span class="s1">parts.append(self.start)</span>
            <span class="s2">if </span><span class="s1">self.prec:</span>
                <span class="s1">parts.append(</span><span class="s3">''</span><span class="s1">.join([</span><span class="s3">''</span><span class="s1">.join(p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self.prec]))</span>
            <span class="s2">if </span><span class="s1">self.tokens:</span>
                <span class="s1">parts.append(</span><span class="s3">' '</span><span class="s1">.join(self.tokens))</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.pfuncs:</span>
                <span class="s2">if </span><span class="s1">f[</span><span class="s4">3</span><span class="s1">]:</span>
                    <span class="s1">parts.append(f[</span><span class="s4">3</span><span class="s1">])</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
            <span class="s2">pass</span>
        <span class="s2">return </span><span class="s3">''</span><span class="s1">.join(parts)</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># validate_modules()</span>
    <span class="s0">#</span>
    <span class="s0"># This method checks to see if there are duplicated p_rulename() functions</span>
    <span class="s0"># in the parser module file.  Without this function, it is really easy for</span>
    <span class="s0"># users to make mistakes by cutting and pasting code fragments (and it's a real</span>
    <span class="s0"># bugger to try and figure out why the resulting parser doesn't work).  Therefore,</span>
    <span class="s0"># we just do a little regular expression pattern matching of def statements</span>
    <span class="s0"># to try and detect duplicates.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">validate_modules(self):</span>
        <span class="s0"># Match def p_funcname(</span>
        <span class="s1">fre = re.compile(</span><span class="s3">r'\s*def\s+(p_[a-zA-Z_0-9]*)\('</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">module </span><span class="s2">in </span><span class="s1">self.modules:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">lines</span><span class="s2">, </span><span class="s1">linen = inspect.getsourcelines(module)</span>
            <span class="s2">except </span><span class="s1">IOError:</span>
                <span class="s2">continue</span>

            <span class="s1">counthash = {}</span>
            <span class="s2">for </span><span class="s1">linen</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">enumerate(lines):</span>
                <span class="s1">linen += </span><span class="s4">1</span>
                <span class="s1">m = fre.match(line)</span>
                <span class="s2">if </span><span class="s1">m:</span>
                    <span class="s1">name = m.group(</span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s1">prev = counthash.get(name)</span>
                    <span class="s2">if not </span><span class="s1">prev:</span>
                        <span class="s1">counthash[name] = linen</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">filename = inspect.getsourcefile(module)</span>
                        <span class="s1">self.log.warning(</span><span class="s3">'%s:%d: Function %s redefined. Previously defined on line %d'</span><span class="s2">,</span>
                                         <span class="s1">filename</span><span class="s2">, </span><span class="s1">linen</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">prev)</span>

    <span class="s0"># Get the start symbol</span>
    <span class="s2">def </span><span class="s1">get_start(self):</span>
        <span class="s1">self.start = self.pdict.get(</span><span class="s3">'start'</span><span class="s1">)</span>

    <span class="s0"># Validate the start symbol</span>
    <span class="s2">def </span><span class="s1">validate_start(self):</span>
        <span class="s2">if </span><span class="s1">self.start </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">isinstance(self.start</span><span class="s2">, </span><span class="s1">string_types):</span>
                <span class="s1">self.log.error(</span><span class="s3">&quot;'start' must be a string&quot;</span><span class="s1">)</span>

    <span class="s0"># Look for error handler</span>
    <span class="s2">def </span><span class="s1">get_error_func(self):</span>
        <span class="s1">self.error_func = self.pdict.get(</span><span class="s3">'p_error'</span><span class="s1">)</span>

    <span class="s0"># Validate the error function</span>
    <span class="s2">def </span><span class="s1">validate_error_func(self):</span>
        <span class="s2">if </span><span class="s1">self.error_func:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.error_func</span><span class="s2">, </span><span class="s1">types.FunctionType):</span>
                <span class="s1">ismethod = </span><span class="s4">0</span>
            <span class="s2">elif </span><span class="s1">isinstance(self.error_func</span><span class="s2">, </span><span class="s1">types.MethodType):</span>
                <span class="s1">ismethod = </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.log.error(</span><span class="s3">&quot;'p_error' defined, but is not a function or method&quot;</span><span class="s1">)</span>
                <span class="s1">self.error = </span><span class="s2">True</span>
                <span class="s2">return</span>

            <span class="s1">eline = self.error_func.__code__.co_firstlineno</span>
            <span class="s1">efile = self.error_func.__code__.co_filename</span>
            <span class="s1">module = inspect.getmodule(self.error_func)</span>
            <span class="s1">self.modules.add(module)</span>

            <span class="s1">argcount = self.error_func.__code__.co_argcount - ismethod</span>
            <span class="s2">if </span><span class="s1">argcount != </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self.log.error(</span><span class="s3">'%s:%d: p_error() requires 1 argument'</span><span class="s2">, </span><span class="s1">efile</span><span class="s2">, </span><span class="s1">eline)</span>
                <span class="s1">self.error = </span><span class="s2">True</span>

    <span class="s0"># Get the tokens map</span>
    <span class="s2">def </span><span class="s1">get_tokens(self):</span>
        <span class="s1">tokens = self.pdict.get(</span><span class="s3">'tokens'</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">tokens:</span>
            <span class="s1">self.log.error(</span><span class="s3">'No token list is defined'</span><span class="s1">)</span>
            <span class="s1">self.error = </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s2">if not </span><span class="s1">isinstance(tokens</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
            <span class="s1">self.log.error(</span><span class="s3">'tokens must be a list or tuple'</span><span class="s1">)</span>
            <span class="s1">self.error = </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s2">if not </span><span class="s1">tokens:</span>
            <span class="s1">self.log.error(</span><span class="s3">'tokens is empty'</span><span class="s1">)</span>
            <span class="s1">self.error = </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s1">self.tokens = tokens</span>

    <span class="s0"># Validate the tokens</span>
    <span class="s2">def </span><span class="s1">validate_tokens(self):</span>
        <span class="s0"># Validate the tokens.</span>
        <span class="s2">if </span><span class="s3">'error' </span><span class="s2">in </span><span class="s1">self.tokens:</span>
            <span class="s1">self.log.error(</span><span class="s3">&quot;Illegal token name 'error'. Is a reserved word&quot;</span><span class="s1">)</span>
            <span class="s1">self.error = </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s1">terminals = set()</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.tokens:</span>
            <span class="s2">if </span><span class="s1">n </span><span class="s2">in </span><span class="s1">terminals:</span>
                <span class="s1">self.log.warning(</span><span class="s3">'Token %r multiply defined'</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">terminals.add(n)</span>

    <span class="s0"># Get the precedence map (if any)</span>
    <span class="s2">def </span><span class="s1">get_precedence(self):</span>
        <span class="s1">self.prec = self.pdict.get(</span><span class="s3">'precedence'</span><span class="s1">)</span>

    <span class="s0"># Validate and parse the precedence map</span>
    <span class="s2">def </span><span class="s1">validate_precedence(self):</span>
        <span class="s1">preclist = []</span>
        <span class="s2">if </span><span class="s1">self.prec:</span>
            <span class="s2">if not </span><span class="s1">isinstance(self.prec</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
                <span class="s1">self.log.error(</span><span class="s3">'precedence must be a list or tuple'</span><span class="s1">)</span>
                <span class="s1">self.error = </span><span class="s2">True</span>
                <span class="s2">return</span>
            <span class="s2">for </span><span class="s1">level</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">enumerate(self.prec):</span>
                <span class="s2">if not </span><span class="s1">isinstance(p</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
                    <span class="s1">self.log.error(</span><span class="s3">'Bad precedence table'</span><span class="s1">)</span>
                    <span class="s1">self.error = </span><span class="s2">True</span>
                    <span class="s2">return</span>

                <span class="s2">if </span><span class="s1">len(p) &lt; </span><span class="s4">2</span><span class="s1">:</span>
                    <span class="s1">self.log.error(</span><span class="s3">'Malformed precedence entry %s. Must be (assoc, term, ..., term)'</span><span class="s2">, </span><span class="s1">p)</span>
                    <span class="s1">self.error = </span><span class="s2">True</span>
                    <span class="s2">return</span>
                <span class="s1">assoc = p[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">if not </span><span class="s1">isinstance(assoc</span><span class="s2">, </span><span class="s1">string_types):</span>
                    <span class="s1">self.log.error(</span><span class="s3">'precedence associativity must be a string'</span><span class="s1">)</span>
                    <span class="s1">self.error = </span><span class="s2">True</span>
                    <span class="s2">return</span>
                <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">p[</span><span class="s4">1</span><span class="s1">:]:</span>
                    <span class="s2">if not </span><span class="s1">isinstance(term</span><span class="s2">, </span><span class="s1">string_types):</span>
                        <span class="s1">self.log.error(</span><span class="s3">'precedence items must be strings'</span><span class="s1">)</span>
                        <span class="s1">self.error = </span><span class="s2">True</span>
                        <span class="s2">return</span>
                    <span class="s1">preclist.append((term</span><span class="s2">, </span><span class="s1">assoc</span><span class="s2">, </span><span class="s1">level+</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">self.preclist = preclist</span>

    <span class="s0"># Get all p_functions from the grammar</span>
    <span class="s2">def </span><span class="s1">get_pfunctions(self):</span>
        <span class="s1">p_functions = []</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self.pdict.items():</span>
            <span class="s2">if not </span><span class="s1">name.startswith(</span><span class="s3">'p_'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">name == </span><span class="s3">'p_error'</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">(types.FunctionType</span><span class="s2">, </span><span class="s1">types.MethodType)):</span>
                <span class="s1">line = getattr(item</span><span class="s2">, </span><span class="s3">'co_firstlineno'</span><span class="s2">, </span><span class="s1">item.__code__.co_firstlineno)</span>
                <span class="s1">module = inspect.getmodule(item)</span>
                <span class="s1">p_functions.append((line</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">item.__doc__))</span>

        <span class="s0"># Sort all of the actions by line number; make sure to stringify</span>
        <span class="s0"># modules to make them sortable, since `line` may not uniquely sort all</span>
        <span class="s0"># p functions</span>
        <span class="s1">p_functions.sort(key=</span><span class="s2">lambda </span><span class="s1">p_function: (</span>
            <span class="s1">p_function[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">str(p_function[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">p_function[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">p_function[</span><span class="s4">3</span><span class="s1">]))</span>
        <span class="s1">self.pfuncs = p_functions</span>

    <span class="s0"># Validate all of the p_functions</span>
    <span class="s2">def </span><span class="s1">validate_pfunctions(self):</span>
        <span class="s1">grammar = []</span>
        <span class="s0"># Check for non-empty symbols</span>
        <span class="s2">if </span><span class="s1">len(self.pfuncs) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.log.error(</span><span class="s3">'no rules of the form p_rulename are defined'</span><span class="s1">)</span>
            <span class="s1">self.error = </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">line</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">doc </span><span class="s2">in </span><span class="s1">self.pfuncs:</span>
            <span class="s1">file = inspect.getsourcefile(module)</span>
            <span class="s1">func = self.pdict[name]</span>
            <span class="s2">if </span><span class="s1">isinstance(func</span><span class="s2">, </span><span class="s1">types.MethodType):</span>
                <span class="s1">reqargs = </span><span class="s4">2</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">reqargs = </span><span class="s4">1</span>
            <span class="s2">if </span><span class="s1">func.__code__.co_argcount &gt; reqargs:</span>
                <span class="s1">self.log.error(</span><span class="s3">'%s:%d: Rule %r has too many arguments'</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">func.__name__)</span>
                <span class="s1">self.error = </span><span class="s2">True</span>
            <span class="s2">elif </span><span class="s1">func.__code__.co_argcount &lt; reqargs:</span>
                <span class="s1">self.log.error(</span><span class="s3">'%s:%d: Rule %r requires an argument'</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">func.__name__)</span>
                <span class="s1">self.error = </span><span class="s2">True</span>
            <span class="s2">elif not </span><span class="s1">func.__doc__:</span>
                <span class="s1">self.log.warning(</span><span class="s3">'%s:%d: No documentation string specified in function %r (ignored)'</span><span class="s2">,</span>
                                 <span class="s1">file</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">func.__name__)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">parsed_g = parse_grammar(doc</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">line)</span>
                    <span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">parsed_g:</span>
                        <span class="s1">grammar.append((name</span><span class="s2">, </span><span class="s1">g))</span>
                <span class="s2">except </span><span class="s1">SyntaxError </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s1">self.log.error(str(e))</span>
                    <span class="s1">self.error = </span><span class="s2">True</span>

                <span class="s0"># Looks like a valid grammar rule</span>
                <span class="s0"># Mark the file in which defined.</span>
                <span class="s1">self.modules.add(module)</span>

        <span class="s0"># Secondary validation step that looks for p_ definitions that are not functions</span>
        <span class="s0"># or functions that look like they might be grammar rules.</span>

        <span class="s2">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.pdict.items():</span>
            <span class="s2">if </span><span class="s1">n.startswith(</span><span class="s3">'p_'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">isinstance(v</span><span class="s2">, </span><span class="s1">(types.FunctionType</span><span class="s2">, </span><span class="s1">types.MethodType)):</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">n.startswith(</span><span class="s3">'t_'</span><span class="s1">):</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">n.startswith(</span><span class="s3">'p_'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">n != </span><span class="s3">'p_error'</span><span class="s1">:</span>
                <span class="s1">self.log.warning(</span><span class="s3">'%r not defined as a function'</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s2">if </span><span class="s1">((isinstance(v</span><span class="s2">, </span><span class="s1">types.FunctionType) </span><span class="s2">and </span><span class="s1">v.__code__.co_argcount == </span><span class="s4">1</span><span class="s1">) </span><span class="s2">or</span>
                   <span class="s1">(isinstance(v</span><span class="s2">, </span><span class="s1">types.MethodType) </span><span class="s2">and </span><span class="s1">v.__func__.__code__.co_argcount == </span><span class="s4">2</span><span class="s1">)):</span>
                <span class="s2">if </span><span class="s1">v.__doc__:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">doc = v.__doc__.split(</span><span class="s3">' '</span><span class="s1">)</span>
                        <span class="s2">if </span><span class="s1">doc[</span><span class="s4">1</span><span class="s1">] == </span><span class="s3">':'</span><span class="s1">:</span>
                            <span class="s1">self.log.warning(</span><span class="s3">'%s:%d: Possible grammar rule %r defined without p_ prefix'</span><span class="s2">,</span>
                                             <span class="s1">v.__code__.co_filename</span><span class="s2">, </span><span class="s1">v.__code__.co_firstlineno</span><span class="s2">, </span><span class="s1">n)</span>
                    <span class="s2">except </span><span class="s1">IndexError:</span>
                        <span class="s2">pass</span>

        <span class="s1">self.grammar = grammar</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># yacc(module)</span>
<span class="s0">#</span>
<span class="s0"># Build a parser</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">yacc(method=</span><span class="s3">'LALR'</span><span class="s2">, </span><span class="s1">debug=yaccdebug</span><span class="s2">, </span><span class="s1">module=</span><span class="s2">None, </span><span class="s1">tabmodule=tab_module</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None,</span>
         <span class="s1">check_recursion=</span><span class="s2">True, </span><span class="s1">optimize=</span><span class="s2">False, </span><span class="s1">write_tables=</span><span class="s2">True, </span><span class="s1">debugfile=debug_file</span><span class="s2">,</span>
         <span class="s1">outputdir=</span><span class="s2">None, </span><span class="s1">debuglog=</span><span class="s2">None, </span><span class="s1">errorlog=</span><span class="s2">None, </span><span class="s1">picklefile=</span><span class="s2">None</span><span class="s1">):</span>

    <span class="s2">if </span><span class="s1">tabmodule </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">tabmodule = tab_module</span>

    <span class="s0"># Reference to the parsing method of the last built parser</span>
    <span class="s2">global </span><span class="s1">parse</span>

    <span class="s0"># If pickling is enabled, table files are not created</span>
    <span class="s2">if </span><span class="s1">picklefile:</span>
        <span class="s1">write_tables = </span><span class="s4">0</span>

    <span class="s2">if </span><span class="s1">errorlog </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">errorlog = PlyLogger(sys.stderr)</span>

    <span class="s0"># Get the module dictionary used for the parser</span>
    <span class="s2">if </span><span class="s1">module:</span>
        <span class="s1">_items = [(k</span><span class="s2">, </span><span class="s1">getattr(module</span><span class="s2">, </span><span class="s1">k)) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">dir(module)]</span>
        <span class="s1">pdict = dict(_items)</span>
        <span class="s0"># If no __file__ attribute is available, try to obtain it from the __module__ instead</span>
        <span class="s2">if </span><span class="s3">'__file__' </span><span class="s2">not in </span><span class="s1">pdict:</span>
            <span class="s1">pdict[</span><span class="s3">'__file__'</span><span class="s1">] = sys.modules[pdict[</span><span class="s3">'__module__'</span><span class="s1">]].__file__</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">pdict = get_caller_module_dict(</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">outputdir </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s0"># If no output directory is set, the location of the output files</span>
        <span class="s0"># is determined according to the following rules:</span>
        <span class="s0">#     - If tabmodule specifies a package, files go into that package directory</span>
        <span class="s0">#     - Otherwise, files go in the same directory as the specifying module</span>
        <span class="s2">if </span><span class="s1">isinstance(tabmodule</span><span class="s2">, </span><span class="s1">types.ModuleType):</span>
            <span class="s1">srcfile = tabmodule.__file__</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s3">'.' </span><span class="s2">not in </span><span class="s1">tabmodule:</span>
                <span class="s1">srcfile = pdict[</span><span class="s3">'__file__'</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">parts = tabmodule.split(</span><span class="s3">'.'</span><span class="s1">)</span>
                <span class="s1">pkgname = </span><span class="s3">'.'</span><span class="s1">.join(parts[:-</span><span class="s4">1</span><span class="s1">])</span>
                <span class="s1">exec(</span><span class="s3">'import %s' </span><span class="s1">% pkgname)</span>
                <span class="s1">srcfile = getattr(sys.modules[pkgname]</span><span class="s2">, </span><span class="s3">'__file__'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">outputdir = os.path.dirname(srcfile)</span>

    <span class="s0"># Determine if the module is package of a package or not.</span>
    <span class="s0"># If so, fix the tabmodule setting so that tables load correctly</span>
    <span class="s1">pkg = pdict.get(</span><span class="s3">'__package__'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">pkg </span><span class="s2">and </span><span class="s1">isinstance(tabmodule</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">if </span><span class="s3">'.' </span><span class="s2">not in </span><span class="s1">tabmodule:</span>
            <span class="s1">tabmodule = pkg + </span><span class="s3">'.' </span><span class="s1">+ tabmodule</span>



    <span class="s0"># Set start symbol if it's specified directly using an argument</span>
    <span class="s2">if </span><span class="s1">start </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">pdict[</span><span class="s3">'start'</span><span class="s1">] = start</span>

    <span class="s0"># Collect parser information from the dictionary</span>
    <span class="s1">pinfo = ParserReflect(pdict</span><span class="s2">, </span><span class="s1">log=errorlog)</span>
    <span class="s1">pinfo.get_all()</span>

    <span class="s2">if </span><span class="s1">pinfo.error:</span>
        <span class="s2">raise </span><span class="s1">YaccError(</span><span class="s3">'Unable to build parser'</span><span class="s1">)</span>

    <span class="s0"># Check signature against table files (if any)</span>
    <span class="s1">signature = pinfo.signature()</span>

    <span class="s0"># Read the tables</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">lr = LRTable()</span>
        <span class="s2">if </span><span class="s1">picklefile:</span>
            <span class="s1">read_signature = lr.read_pickle(picklefile)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">read_signature = lr.read_table(tabmodule)</span>
        <span class="s2">if </span><span class="s1">optimize </span><span class="s2">or </span><span class="s1">(read_signature == signature):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">lr.bind_callables(pinfo.pdict)</span>
                <span class="s1">parser = LRParser(lr</span><span class="s2">, </span><span class="s1">pinfo.error_func)</span>
                <span class="s1">parse = parser.parse</span>
                <span class="s2">return </span><span class="s1">parser</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">errorlog.warning(</span><span class="s3">'There was a problem loading the table file: %r'</span><span class="s2">, </span><span class="s1">e)</span>
    <span class="s2">except </span><span class="s1">VersionError </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s1">errorlog.warning(str(e))</span>
    <span class="s2">except </span><span class="s1">ImportError:</span>
        <span class="s2">pass</span>

    <span class="s2">if </span><span class="s1">debuglog </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">debug:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">debuglog = PlyLogger(open(os.path.join(outputdir</span><span class="s2">, </span><span class="s1">debugfile)</span><span class="s2">, </span><span class="s3">'w'</span><span class="s1">))</span>
            <span class="s2">except </span><span class="s1">IOError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">errorlog.warning(</span><span class="s3">&quot;Couldn't open %r. %s&quot; </span><span class="s1">% (debugfile</span><span class="s2">, </span><span class="s1">e))</span>
                <span class="s1">debuglog = NullLogger()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">debuglog = NullLogger()</span>

    <span class="s1">debuglog.info(</span><span class="s3">'Created by PLY version %s (http://www.dabeaz.com/ply)'</span><span class="s2">, </span><span class="s1">__version__)</span>

    <span class="s1">errors = </span><span class="s2">False</span>

    <span class="s0"># Validate the parser information</span>
    <span class="s2">if </span><span class="s1">pinfo.validate_all():</span>
        <span class="s2">raise </span><span class="s1">YaccError(</span><span class="s3">'Unable to build parser'</span><span class="s1">)</span>

    <span class="s2">if not </span><span class="s1">pinfo.error_func:</span>
        <span class="s1">errorlog.warning(</span><span class="s3">'no p_error() function is defined'</span><span class="s1">)</span>

    <span class="s0"># Create a grammar object</span>
    <span class="s1">grammar = Grammar(pinfo.tokens)</span>

    <span class="s0"># Set precedence level for terminals</span>
    <span class="s2">for </span><span class="s1">term</span><span class="s2">, </span><span class="s1">assoc</span><span class="s2">, </span><span class="s1">level </span><span class="s2">in </span><span class="s1">pinfo.preclist:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">grammar.set_precedence(term</span><span class="s2">, </span><span class="s1">assoc</span><span class="s2">, </span><span class="s1">level)</span>
        <span class="s2">except </span><span class="s1">GrammarError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">errorlog.warning(</span><span class="s3">'%s'</span><span class="s2">, </span><span class="s1">e)</span>

    <span class="s0"># Add productions to the grammar</span>
    <span class="s2">for </span><span class="s1">funcname</span><span class="s2">, </span><span class="s1">gram </span><span class="s2">in </span><span class="s1">pinfo.grammar:</span>
        <span class="s1">file</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">prodname</span><span class="s2">, </span><span class="s1">syms = gram</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">grammar.add_production(prodname</span><span class="s2">, </span><span class="s1">syms</span><span class="s2">, </span><span class="s1">funcname</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">line)</span>
        <span class="s2">except </span><span class="s1">GrammarError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">errorlog.error(</span><span class="s3">'%s'</span><span class="s2">, </span><span class="s1">e)</span>
            <span class="s1">errors = </span><span class="s2">True</span>

    <span class="s0"># Set the grammar start symbols</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">start </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">grammar.set_start(pinfo.start)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">grammar.set_start(start)</span>
    <span class="s2">except </span><span class="s1">GrammarError </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s1">errorlog.error(str(e))</span>
        <span class="s1">errors = </span><span class="s2">True</span>

    <span class="s2">if </span><span class="s1">errors:</span>
        <span class="s2">raise </span><span class="s1">YaccError(</span><span class="s3">'Unable to build parser'</span><span class="s1">)</span>

    <span class="s0"># Verify the grammar structure</span>
    <span class="s1">undefined_symbols = grammar.undefined_symbols()</span>
    <span class="s2">for </span><span class="s1">sym</span><span class="s2">, </span><span class="s1">prod </span><span class="s2">in </span><span class="s1">undefined_symbols:</span>
        <span class="s1">errorlog.error(</span><span class="s3">'%s:%d: Symbol %r used, but not defined as a token or a rule'</span><span class="s2">, </span><span class="s1">prod.file</span><span class="s2">, </span><span class="s1">prod.line</span><span class="s2">, </span><span class="s1">sym)</span>
        <span class="s1">errors = </span><span class="s2">True</span>

    <span class="s1">unused_terminals = grammar.unused_terminals()</span>
    <span class="s2">if </span><span class="s1">unused_terminals:</span>
        <span class="s1">debuglog.info(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">debuglog.info(</span><span class="s3">'Unused terminals:'</span><span class="s1">)</span>
        <span class="s1">debuglog.info(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">unused_terminals:</span>
            <span class="s1">errorlog.warning(</span><span class="s3">'Token %r defined, but not used'</span><span class="s2">, </span><span class="s1">term)</span>
            <span class="s1">debuglog.info(</span><span class="s3">'    %s'</span><span class="s2">, </span><span class="s1">term)</span>

    <span class="s0"># Print out all productions to the debug log</span>
    <span class="s2">if </span><span class="s1">debug:</span>
        <span class="s1">debuglog.info(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">debuglog.info(</span><span class="s3">'Grammar'</span><span class="s1">)</span>
        <span class="s1">debuglog.info(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">enumerate(grammar.Productions):</span>
            <span class="s1">debuglog.info(</span><span class="s3">'Rule %-5d %s'</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p)</span>

    <span class="s0"># Find unused non-terminals</span>
    <span class="s1">unused_rules = grammar.unused_rules()</span>
    <span class="s2">for </span><span class="s1">prod </span><span class="s2">in </span><span class="s1">unused_rules:</span>
        <span class="s1">errorlog.warning(</span><span class="s3">'%s:%d: Rule %r defined, but not used'</span><span class="s2">, </span><span class="s1">prod.file</span><span class="s2">, </span><span class="s1">prod.line</span><span class="s2">, </span><span class="s1">prod.name)</span>

    <span class="s2">if </span><span class="s1">len(unused_terminals) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">errorlog.warning(</span><span class="s3">'There is 1 unused token'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">len(unused_terminals) &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">errorlog.warning(</span><span class="s3">'There are %d unused tokens'</span><span class="s2">, </span><span class="s1">len(unused_terminals))</span>

    <span class="s2">if </span><span class="s1">len(unused_rules) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">errorlog.warning(</span><span class="s3">'There is 1 unused rule'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">len(unused_rules) &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">errorlog.warning(</span><span class="s3">'There are %d unused rules'</span><span class="s2">, </span><span class="s1">len(unused_rules))</span>

    <span class="s2">if </span><span class="s1">debug:</span>
        <span class="s1">debuglog.info(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">debuglog.info(</span><span class="s3">'Terminals, with rules where they appear'</span><span class="s1">)</span>
        <span class="s1">debuglog.info(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">terms = list(grammar.Terminals)</span>
        <span class="s1">terms.sort()</span>
        <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">terms:</span>
            <span class="s1">debuglog.info(</span><span class="s3">'%-20s : %s'</span><span class="s2">, </span><span class="s1">term</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">.join([str(s) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">grammar.Terminals[term]]))</span>

        <span class="s1">debuglog.info(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">debuglog.info(</span><span class="s3">'Nonterminals, with rules where they appear'</span><span class="s1">)</span>
        <span class="s1">debuglog.info(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">nonterms = list(grammar.Nonterminals)</span>
        <span class="s1">nonterms.sort()</span>
        <span class="s2">for </span><span class="s1">nonterm </span><span class="s2">in </span><span class="s1">nonterms:</span>
            <span class="s1">debuglog.info(</span><span class="s3">'%-20s : %s'</span><span class="s2">, </span><span class="s1">nonterm</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">.join([str(s) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">grammar.Nonterminals[nonterm]]))</span>
        <span class="s1">debuglog.info(</span><span class="s3">''</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">check_recursion:</span>
        <span class="s1">unreachable = grammar.find_unreachable()</span>
        <span class="s2">for </span><span class="s1">u </span><span class="s2">in </span><span class="s1">unreachable:</span>
            <span class="s1">errorlog.warning(</span><span class="s3">'Symbol %r is unreachable'</span><span class="s2">, </span><span class="s1">u)</span>

        <span class="s1">infinite = grammar.infinite_cycles()</span>
        <span class="s2">for </span><span class="s1">inf </span><span class="s2">in </span><span class="s1">infinite:</span>
            <span class="s1">errorlog.error(</span><span class="s3">'Infinite recursion detected for symbol %r'</span><span class="s2">, </span><span class="s1">inf)</span>
            <span class="s1">errors = </span><span class="s2">True</span>

    <span class="s1">unused_prec = grammar.unused_precedence()</span>
    <span class="s2">for </span><span class="s1">term</span><span class="s2">, </span><span class="s1">assoc </span><span class="s2">in </span><span class="s1">unused_prec:</span>
        <span class="s1">errorlog.error(</span><span class="s3">'Precedence rule %r defined for unknown symbol %r'</span><span class="s2">, </span><span class="s1">assoc</span><span class="s2">, </span><span class="s1">term)</span>
        <span class="s1">errors = </span><span class="s2">True</span>

    <span class="s2">if </span><span class="s1">errors:</span>
        <span class="s2">raise </span><span class="s1">YaccError(</span><span class="s3">'Unable to build parser'</span><span class="s1">)</span>

    <span class="s0"># Run the LRGeneratedTable on the grammar</span>
    <span class="s2">if </span><span class="s1">debug:</span>
        <span class="s1">errorlog.debug(</span><span class="s3">'Generating %s tables'</span><span class="s2">, </span><span class="s1">method)</span>

    <span class="s1">lr = LRGeneratedTable(grammar</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">debuglog)</span>

    <span class="s2">if </span><span class="s1">debug:</span>
        <span class="s1">num_sr = len(lr.sr_conflicts)</span>

        <span class="s0"># Report shift/reduce and reduce/reduce conflicts</span>
        <span class="s2">if </span><span class="s1">num_sr == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">errorlog.warning(</span><span class="s3">'1 shift/reduce conflict'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">num_sr &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">errorlog.warning(</span><span class="s3">'%d shift/reduce conflicts'</span><span class="s2">, </span><span class="s1">num_sr)</span>

        <span class="s1">num_rr = len(lr.rr_conflicts)</span>
        <span class="s2">if </span><span class="s1">num_rr == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">errorlog.warning(</span><span class="s3">'1 reduce/reduce conflict'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">num_rr &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">errorlog.warning(</span><span class="s3">'%d reduce/reduce conflicts'</span><span class="s2">, </span><span class="s1">num_rr)</span>

    <span class="s0"># Write out conflicts to the output file</span>
    <span class="s2">if </span><span class="s1">debug </span><span class="s2">and </span><span class="s1">(lr.sr_conflicts </span><span class="s2">or </span><span class="s1">lr.rr_conflicts):</span>
        <span class="s1">debuglog.warning(</span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">debuglog.warning(</span><span class="s3">'Conflicts:'</span><span class="s1">)</span>
        <span class="s1">debuglog.warning(</span><span class="s3">''</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">state</span><span class="s2">, </span><span class="s1">tok</span><span class="s2">, </span><span class="s1">resolution </span><span class="s2">in </span><span class="s1">lr.sr_conflicts:</span>
            <span class="s1">debuglog.warning(</span><span class="s3">'shift/reduce conflict for %s in state %d resolved as %s'</span><span class="s2">,  </span><span class="s1">tok</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">resolution)</span>

        <span class="s1">already_reported = set()</span>
        <span class="s2">for </span><span class="s1">state</span><span class="s2">, </span><span class="s1">rule</span><span class="s2">, </span><span class="s1">rejected </span><span class="s2">in </span><span class="s1">lr.rr_conflicts:</span>
            <span class="s2">if </span><span class="s1">(state</span><span class="s2">, </span><span class="s1">id(rule)</span><span class="s2">, </span><span class="s1">id(rejected)) </span><span class="s2">in </span><span class="s1">already_reported:</span>
                <span class="s2">continue</span>
            <span class="s1">debuglog.warning(</span><span class="s3">'reduce/reduce conflict in state %d resolved using rule (%s)'</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">rule)</span>
            <span class="s1">debuglog.warning(</span><span class="s3">'rejected rule (%s) in state %d'</span><span class="s2">, </span><span class="s1">rejected</span><span class="s2">, </span><span class="s1">state)</span>
            <span class="s1">errorlog.warning(</span><span class="s3">'reduce/reduce conflict in state %d resolved using rule (%s)'</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">rule)</span>
            <span class="s1">errorlog.warning(</span><span class="s3">'rejected rule (%s) in state %d'</span><span class="s2">, </span><span class="s1">rejected</span><span class="s2">, </span><span class="s1">state)</span>
            <span class="s1">already_reported.add((state</span><span class="s2">, </span><span class="s1">id(rule)</span><span class="s2">, </span><span class="s1">id(rejected)))</span>

        <span class="s1">warned_never = []</span>
        <span class="s2">for </span><span class="s1">state</span><span class="s2">, </span><span class="s1">rule</span><span class="s2">, </span><span class="s1">rejected </span><span class="s2">in </span><span class="s1">lr.rr_conflicts:</span>
            <span class="s2">if not </span><span class="s1">rejected.reduced </span><span class="s2">and </span><span class="s1">(rejected </span><span class="s2">not in </span><span class="s1">warned_never):</span>
                <span class="s1">debuglog.warning(</span><span class="s3">'Rule (%s) is never reduced'</span><span class="s2">, </span><span class="s1">rejected)</span>
                <span class="s1">errorlog.warning(</span><span class="s3">'Rule (%s) is never reduced'</span><span class="s2">, </span><span class="s1">rejected)</span>
                <span class="s1">warned_never.append(rejected)</span>

    <span class="s0"># Write the table file if requested</span>
    <span class="s2">if </span><span class="s1">write_tables:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">lr.write_table(tabmodule</span><span class="s2">, </span><span class="s1">outputdir</span><span class="s2">, </span><span class="s1">signature)</span>
        <span class="s2">except </span><span class="s1">IOError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">errorlog.warning(</span><span class="s3">&quot;Couldn't create %r. %s&quot; </span><span class="s1">% (tabmodule</span><span class="s2">, </span><span class="s1">e))</span>

    <span class="s0"># Write a pickled version of the tables</span>
    <span class="s2">if </span><span class="s1">picklefile:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">lr.pickle_table(picklefile</span><span class="s2">, </span><span class="s1">signature)</span>
        <span class="s2">except </span><span class="s1">IOError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">errorlog.warning(</span><span class="s3">&quot;Couldn't create %r. %s&quot; </span><span class="s1">% (picklefile</span><span class="s2">, </span><span class="s1">e))</span>

    <span class="s0"># Build the parser</span>
    <span class="s1">lr.bind_callables(pinfo.pdict)</span>
    <span class="s1">parser = LRParser(lr</span><span class="s2">, </span><span class="s1">pinfo.error_func)</span>

    <span class="s1">parse = parser.parse</span>
    <span class="s2">return </span><span class="s1">parser</span>
</pre>
</body>
</html>