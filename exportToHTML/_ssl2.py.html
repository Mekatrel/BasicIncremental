<html>
<head>
<title>_ssl2.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_ssl2.py</font>
</center></td></tr></table>
<pre><span class="s0"># (No idea where this comes from; it warns about 'configuration')</span>
<span class="s0"># pylint:disable=invalid-all-format</span>
<span class="s0"># Wrapper module for _ssl. Written by Bill Janssen.</span>
<span class="s0"># Ported to gevent by Denis Bilenko.</span>
<span class="s2">&quot;&quot;&quot; 
SSL wrapper for socket objects on Python 2.7.8 and below. 
 
For the documentation, refer to :mod:`ssl` module manual. 
 
This module implements cooperative SSL socket wrappers. 
 
.. deprecated:: 1.3 
   This module is not secure. Support for Python versions 
   with only this level of SSL will be dropped in gevent 1.4. 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">absolute_import</span>
<span class="s0"># Our import magic sadly makes this warning useless</span>
<span class="s0"># pylint: disable=undefined-variable,arguments-differ,no-member</span>

<span class="s3">import </span><span class="s1">ssl </span><span class="s3">as </span><span class="s1">__ssl__</span>

<span class="s1">_ssl = __ssl__._ssl</span>

<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">from </span><span class="s1">gevent._socket2 </span><span class="s3">import </span><span class="s1">socket</span>
<span class="s3">from </span><span class="s1">gevent.socket </span><span class="s3">import </span><span class="s1">_fileobject</span><span class="s3">, </span><span class="s1">timeout_default</span>
<span class="s3">from </span><span class="s1">gevent.socket </span><span class="s3">import </span><span class="s1">error </span><span class="s3">as </span><span class="s1">socket_error</span><span class="s3">, </span><span class="s1">EWOULDBLOCK</span>
<span class="s3">from </span><span class="s1">gevent.socket </span><span class="s3">import </span><span class="s1">timeout </span><span class="s3">as </span><span class="s1">_socket_timeout</span>
<span class="s3">from </span><span class="s1">gevent._compat </span><span class="s3">import </span><span class="s1">PYPY</span>
<span class="s3">from </span><span class="s1">gevent._util </span><span class="s3">import </span><span class="s1">copy_globals</span>


<span class="s1">__implements__ = [</span>
    <span class="s4">'SSLSocket'</span><span class="s3">,</span>
    <span class="s4">'wrap_socket'</span><span class="s3">,</span>
    <span class="s4">'get_server_certificate'</span><span class="s3">,</span>
    <span class="s4">'sslwrap_simple'</span><span class="s3">,</span>
<span class="s1">]</span>

<span class="s0"># Import all symbols from Python's ssl.py, except those that we are implementing</span>
<span class="s0"># and &quot;private&quot; symbols.</span>
<span class="s1">__imports__ = copy_globals(__ssl__</span><span class="s3">, </span><span class="s1">globals()</span><span class="s3">,</span>
                           <span class="s0"># SSLSocket *must* subclass gevent.socket.socket; see issue 597</span>
                           <span class="s1">names_to_ignore=__implements__ + [</span><span class="s4">'socket'</span><span class="s1">]</span><span class="s3">,</span>
                           <span class="s1">dunder_names_to_keep=())</span>


<span class="s0"># Py2.6 can get RAND_status added twice</span>
<span class="s1">__all__ = list(set(__implements__) | set(__imports__))</span>
<span class="s3">if </span><span class="s4">'namedtuple' </span><span class="s3">in </span><span class="s1">__all__:</span>
    <span class="s1">__all__.remove(</span><span class="s4">'namedtuple'</span><span class="s1">)</span>

<span class="s3">class </span><span class="s1">SSLSocket(socket):</span>
    <span class="s2">&quot;&quot;&quot; 
    gevent `ssl.SSLSocket &lt;https://docs.python.org/2.6/library/ssl.html#sslsocket-objects&gt;`_ 
    for Pythons &lt; 2.7.9. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">sock</span><span class="s3">, </span><span class="s1">keyfile=</span><span class="s3">None, </span><span class="s1">certfile=</span><span class="s3">None,</span>
                 <span class="s1">server_side=</span><span class="s3">False, </span><span class="s1">cert_reqs=CERT_NONE</span><span class="s3">,</span>
                 <span class="s1">ssl_version=PROTOCOL_SSLv23</span><span class="s3">, </span><span class="s1">ca_certs=</span><span class="s3">None,</span>
                 <span class="s1">do_handshake_on_connect=</span><span class="s3">True,</span>
                 <span class="s1">suppress_ragged_eofs=</span><span class="s3">True,</span>
                 <span class="s1">ciphers=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">socket.__init__(self</span><span class="s3">, </span><span class="s1">_sock=sock)</span>

        <span class="s3">if </span><span class="s1">PYPY:</span>
            <span class="s1">sock._drop()</span>

        <span class="s3">if </span><span class="s1">certfile </span><span class="s3">and not </span><span class="s1">keyfile:</span>
            <span class="s1">keyfile = certfile</span>
        <span class="s0"># see if it's connected</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">socket.getpeername(self)</span>
        <span class="s3">except </span><span class="s1">socket_error </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">if </span><span class="s1">e.args[</span><span class="s5">0</span><span class="s1">] != errno.ENOTCONN:</span>
                <span class="s3">raise</span>
            <span class="s0"># no, no connection yet</span>
            <span class="s1">self._sslobj = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># yes, create the SSL object</span>
            <span class="s3">if </span><span class="s1">ciphers </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">self._sslobj = _ssl.sslwrap(self._sock</span><span class="s3">, </span><span class="s1">server_side</span><span class="s3">,</span>
                                            <span class="s1">keyfile</span><span class="s3">, </span><span class="s1">certfile</span><span class="s3">,</span>
                                            <span class="s1">cert_reqs</span><span class="s3">, </span><span class="s1">ssl_version</span><span class="s3">, </span><span class="s1">ca_certs)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._sslobj = _ssl.sslwrap(self._sock</span><span class="s3">, </span><span class="s1">server_side</span><span class="s3">,</span>
                                            <span class="s1">keyfile</span><span class="s3">, </span><span class="s1">certfile</span><span class="s3">,</span>
                                            <span class="s1">cert_reqs</span><span class="s3">, </span><span class="s1">ssl_version</span><span class="s3">, </span><span class="s1">ca_certs</span><span class="s3">,</span>
                                            <span class="s1">ciphers)</span>
            <span class="s3">if </span><span class="s1">do_handshake_on_connect:</span>
                <span class="s1">self.do_handshake()</span>
        <span class="s1">self.keyfile = keyfile</span>
        <span class="s1">self.certfile = certfile</span>
        <span class="s1">self.cert_reqs = cert_reqs</span>
        <span class="s1">self.ssl_version = ssl_version</span>
        <span class="s1">self.ca_certs = ca_certs</span>
        <span class="s1">self.ciphers = ciphers</span>
        <span class="s1">self.do_handshake_on_connect = do_handshake_on_connect</span>
        <span class="s1">self.suppress_ragged_eofs = suppress_ragged_eofs</span>
        <span class="s1">self._makefile_refs = </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">read(self</span><span class="s3">, </span><span class="s1">len=</span><span class="s5">1024</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Read up to LEN bytes and return them. 
        Return zero-length string on EOF.&quot;&quot;&quot;</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._sslobj.read(len)</span>
            <span class="s3">except </span><span class="s1">SSLError </span><span class="s3">as </span><span class="s1">ex:</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_EOF </span><span class="s3">and </span><span class="s1">self.suppress_ragged_eofs:</span>
                    <span class="s3">return </span><span class="s4">''</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_READ:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">sys.exc_clear()</span>
                    <span class="s1">self._wait(self._read_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorReadTimeout)</span>
                <span class="s3">elif </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_WRITE:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">sys.exc_clear()</span>
                    <span class="s0"># note: using _SSLErrorReadTimeout rather than _SSLErrorWriteTimeout below is intentional</span>
                    <span class="s1">self._wait(self._write_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorReadTimeout)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">write(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s2">&quot;&quot;&quot;Write DATA to the underlying SSL channel.  Returns 
        number of bytes of DATA actually transmitted.&quot;&quot;&quot;</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._sslobj.write(data)</span>
            <span class="s3">except </span><span class="s1">SSLError </span><span class="s3">as </span><span class="s1">ex:</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_READ:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">sys.exc_clear()</span>
                    <span class="s1">self._wait(self._read_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorWriteTimeout)</span>
                <span class="s3">elif </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_WRITE:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">sys.exc_clear()</span>
                    <span class="s1">self._wait(self._write_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorWriteTimeout)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">getpeercert(self</span><span class="s3">, </span><span class="s1">binary_form=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Returns a formatted version of the data in the 
        certificate provided by the other end of the SSL channel. 
        Return None if no certificate was provided, {} if a 
        certificate was provided, but not validated.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._sslobj.peer_certificate(binary_form)</span>

    <span class="s3">def </span><span class="s1">cipher(self):</span>
        <span class="s3">if not </span><span class="s1">self._sslobj:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">self._sslobj.cipher()</span>

    <span class="s3">def </span><span class="s1">send(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">timeout=timeout_default):</span>
        <span class="s3">if </span><span class="s1">timeout </span><span class="s3">is </span><span class="s1">timeout_default:</span>
            <span class="s1">timeout = self.timeout</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">if </span><span class="s1">flags != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;non-zero flags not allowed in calls to send() on %s&quot; </span><span class="s1">%</span>
                    <span class="s1">self.__class__)</span>
            <span class="s3">while True</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">v = self._sslobj.write(data)</span>
                <span class="s3">except </span><span class="s1">SSLError </span><span class="s3">as </span><span class="s1">x:</span>
                    <span class="s3">if </span><span class="s1">x.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_READ:</span>
                        <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                            <span class="s3">return </span><span class="s5">0</span>
                        <span class="s1">sys.exc_clear()</span>
                        <span class="s1">self._wait(self._read_event)</span>
                    <span class="s3">elif </span><span class="s1">x.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_WRITE:</span>
                        <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                            <span class="s3">return </span><span class="s5">0</span>
                        <span class="s1">sys.exc_clear()</span>
                        <span class="s1">self._wait(self._write_event)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">v</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">socket.send(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">timeout)</span>
    <span class="s0"># is it possible for sendall() to send some data without encryption if another end shut down SSL?</span>

    <span class="s3">def </span><span class="s1">sendall(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">socket.sendall(self</span><span class="s3">, </span><span class="s1">data)</span>
        <span class="s3">except </span><span class="s1">_socket_timeout </span><span class="s3">as </span><span class="s1">ex:</span>
            <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                <span class="s0"># Python 2 simply *hangs* in this case, which is bad, but</span>
                <span class="s0"># Python 3 raises SSLWantWriteError. We do the same.</span>
                <span class="s3">raise </span><span class="s1">SSLError(SSL_ERROR_WANT_WRITE)</span>
            <span class="s0"># Convert the socket.timeout back to the sslerror</span>
            <span class="s3">raise </span><span class="s1">SSLError(*ex.args)</span>

    <span class="s3">def </span><span class="s1">sendto(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;sendto not allowed on instances of %s&quot; </span><span class="s1">%</span>
                             <span class="s1">self.__class__)</span>
        <span class="s3">return </span><span class="s1">socket.sendto(self</span><span class="s3">, </span><span class="s1">*args)</span>

    <span class="s3">def </span><span class="s1">recv(self</span><span class="s3">, </span><span class="s1">buflen=</span><span class="s5">1024</span><span class="s3">, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">if </span><span class="s1">flags != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;non-zero flags not allowed in calls to recv() on %s&quot; </span><span class="s1">%</span>
                    <span class="s1">self.__class__)</span>
            <span class="s0"># QQQ Shouldn't we wrap the SSL_WANT_READ errors as socket.timeout errors to match socket.recv's behavior?</span>
            <span class="s3">return </span><span class="s1">self.read(buflen)</span>
        <span class="s3">return </span><span class="s1">socket.recv(self</span><span class="s3">, </span><span class="s1">buflen</span><span class="s3">, </span><span class="s1">flags)</span>

    <span class="s3">def </span><span class="s1">recv_into(self</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">nbytes=</span><span class="s3">None, </span><span class="s1">flags=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">buffer </span><span class="s3">and </span><span class="s1">(nbytes </span><span class="s3">is None</span><span class="s1">):</span>
            <span class="s1">nbytes = len(buffer)</span>
        <span class="s3">elif </span><span class="s1">nbytes </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">nbytes = </span><span class="s5">1024</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">if </span><span class="s1">flags != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;non-zero flags not allowed in calls to recv_into() on %s&quot; </span><span class="s1">%</span>
                    <span class="s1">self.__class__)</span>
            <span class="s3">while True</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">tmp_buffer = self.read(nbytes)</span>
                    <span class="s1">v = len(tmp_buffer)</span>
                    <span class="s1">buffer[:v] = tmp_buffer</span>
                    <span class="s3">return </span><span class="s1">v</span>
                <span class="s3">except </span><span class="s1">SSLError </span><span class="s3">as </span><span class="s1">x:</span>
                    <span class="s3">if </span><span class="s1">x.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_READ:</span>
                        <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                            <span class="s3">raise</span>
                        <span class="s1">sys.exc_clear()</span>
                        <span class="s1">self._wait(self._read_event)</span>
                        <span class="s3">continue</span>
                    <span class="s3">raise</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">socket.recv_into(self</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">nbytes</span><span class="s3">, </span><span class="s1">flags)</span>

    <span class="s3">def </span><span class="s1">recvfrom(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;recvfrom not allowed on instances of %s&quot; </span><span class="s1">%</span>
                             <span class="s1">self.__class__)</span>
        <span class="s3">return </span><span class="s1">socket.recvfrom(self</span><span class="s3">, </span><span class="s1">*args)</span>

    <span class="s3">def </span><span class="s1">recvfrom_into(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;recvfrom_into not allowed on instances of %s&quot; </span><span class="s1">%</span>
                             <span class="s1">self.__class__)</span>
        <span class="s3">return </span><span class="s1">socket.recvfrom_into(self</span><span class="s3">, </span><span class="s1">*args)</span>

    <span class="s3">def </span><span class="s1">pending(self):</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">return </span><span class="s1">self._sslobj.pending()</span>
        <span class="s3">return </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">_sslobj_shutdown(self):</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._sslobj.shutdown()</span>
            <span class="s3">except </span><span class="s1">SSLError </span><span class="s3">as </span><span class="s1">ex:</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_EOF </span><span class="s3">and </span><span class="s1">self.suppress_ragged_eofs:</span>
                    <span class="s3">return </span><span class="s4">''</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_READ:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">sys.exc_clear()</span>
                    <span class="s1">self._wait(self._read_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorReadTimeout)</span>
                <span class="s3">elif </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_WRITE:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">sys.exc_clear()</span>
                    <span class="s1">self._wait(self._write_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorWriteTimeout)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">unwrap(self):</span>
        <span class="s3">if not </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;No SSL wrapper around &quot; </span><span class="s1">+ str(self))</span>
        <span class="s1">s = self._sslobj_shutdown()</span>
        <span class="s1">self._sslobj = </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">socket(_sock=s)</span>

    <span class="s3">def </span><span class="s1">shutdown(self</span><span class="s3">, </span><span class="s1">how):</span>
        <span class="s1">self._sslobj = </span><span class="s3">None</span>
        <span class="s1">socket.shutdown(self</span><span class="s3">, </span><span class="s1">how)</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s3">if </span><span class="s1">self._makefile_refs &lt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self._sslobj = </span><span class="s3">None</span>
            <span class="s1">socket.close(self)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._makefile_refs -= </span><span class="s5">1</span>

    <span class="s3">if </span><span class="s1">PYPY:</span>

        <span class="s3">def </span><span class="s1">_reuse(self):</span>
            <span class="s1">self._makefile_refs += </span><span class="s5">1</span>

        <span class="s3">def </span><span class="s1">_drop(self):</span>
            <span class="s3">if </span><span class="s1">self._makefile_refs &lt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">self.close()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._makefile_refs -= </span><span class="s5">1</span>

    <span class="s3">def </span><span class="s1">do_handshake(self):</span>
        <span class="s2">&quot;&quot;&quot;Perform a TLS/SSL handshake.&quot;&quot;&quot;</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._sslobj.do_handshake()</span>
            <span class="s3">except </span><span class="s1">SSLError </span><span class="s3">as </span><span class="s1">ex:</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_READ:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">sys.exc_clear()</span>
                    <span class="s1">self._wait(self._read_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorHandshakeTimeout)</span>
                <span class="s3">elif </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] == SSL_ERROR_WANT_WRITE:</span>
                    <span class="s3">if </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                        <span class="s3">raise</span>
                    <span class="s1">sys.exc_clear()</span>
                    <span class="s1">self._wait(self._write_event</span><span class="s3">, </span><span class="s1">timeout_exc=_SSLErrorHandshakeTimeout)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">connect(self</span><span class="s3">, </span><span class="s1">addr): </span><span class="s0"># renamed addr -&gt; address in Python 3 pylint:disable=arguments-renamed</span>
        <span class="s2">&quot;&quot;&quot;Connects to remote ADDR, and then wraps the connection in 
        an SSL channel.&quot;&quot;&quot;</span>
        <span class="s0"># Here we assume that the socket is client-side, and not</span>
        <span class="s0"># connected at the time of the call.  We connect it, then wrap it.</span>
        <span class="s3">if </span><span class="s1">self._sslobj:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;attempt to connect already-connected SSLSocket!&quot;</span><span class="s1">)</span>
        <span class="s1">socket.connect(self</span><span class="s3">, </span><span class="s1">addr)</span>
        <span class="s3">if </span><span class="s1">self.ciphers </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self._sslobj = _ssl.sslwrap(self._sock</span><span class="s3">, False, </span><span class="s1">self.keyfile</span><span class="s3">, </span><span class="s1">self.certfile</span><span class="s3">,</span>
                                        <span class="s1">self.cert_reqs</span><span class="s3">, </span><span class="s1">self.ssl_version</span><span class="s3">,</span>
                                        <span class="s1">self.ca_certs)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._sslobj = _ssl.sslwrap(self._sock</span><span class="s3">, False, </span><span class="s1">self.keyfile</span><span class="s3">, </span><span class="s1">self.certfile</span><span class="s3">,</span>
                                        <span class="s1">self.cert_reqs</span><span class="s3">, </span><span class="s1">self.ssl_version</span><span class="s3">,</span>
                                        <span class="s1">self.ca_certs</span><span class="s3">, </span><span class="s1">self.ciphers)</span>
        <span class="s3">if </span><span class="s1">self.do_handshake_on_connect:</span>
            <span class="s1">self.do_handshake()</span>

    <span class="s3">def </span><span class="s1">accept(self):</span>
        <span class="s2">&quot;&quot;&quot;Accepts a new connection from a remote client, and returns 
        a tuple containing that new connection wrapped with a server-side 
        SSL channel, and the address of the remote client.&quot;&quot;&quot;</span>
        <span class="s1">sock = self._sock</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">client_socket</span><span class="s3">, </span><span class="s1">address = sock.accept()</span>
                <span class="s3">break</span>
            <span class="s3">except </span><span class="s1">socket_error </span><span class="s3">as </span><span class="s1">ex:</span>
                <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] != EWOULDBLOCK </span><span class="s3">or </span><span class="s1">self.timeout == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s3">raise</span>
                <span class="s1">sys.exc_clear()</span>
            <span class="s1">self._wait(self._read_event)</span>

        <span class="s1">sslobj = SSLSocket(client_socket</span><span class="s3">,</span>
                           <span class="s1">keyfile=self.keyfile</span><span class="s3">,</span>
                           <span class="s1">certfile=self.certfile</span><span class="s3">,</span>
                           <span class="s1">server_side=</span><span class="s3">True,</span>
                           <span class="s1">cert_reqs=self.cert_reqs</span><span class="s3">,</span>
                           <span class="s1">ssl_version=self.ssl_version</span><span class="s3">,</span>
                           <span class="s1">ca_certs=self.ca_certs</span><span class="s3">,</span>
                           <span class="s1">do_handshake_on_connect=self.do_handshake_on_connect</span><span class="s3">,</span>
                           <span class="s1">suppress_ragged_eofs=self.suppress_ragged_eofs</span><span class="s3">,</span>
                           <span class="s1">ciphers=self.ciphers)</span>

        <span class="s3">return </span><span class="s1">sslobj</span><span class="s3">, </span><span class="s1">address</span>

    <span class="s3">def </span><span class="s1">makefile(self</span><span class="s3">, </span><span class="s1">mode=</span><span class="s4">'r'</span><span class="s3">, </span><span class="s1">bufsize=-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Make and return a file-like object that 
        works with the SSL connection.  Just use the code 
        from the socket module.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">PYPY:</span>
            <span class="s1">self._makefile_refs += </span><span class="s5">1</span>
        <span class="s0"># close=True so as to decrement the reference count when done with</span>
        <span class="s0"># the file-like object.</span>
        <span class="s3">return </span><span class="s1">_fileobject(self</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">bufsize</span><span class="s3">, </span><span class="s1">close=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s3">if </span><span class="s1">PYPY </span><span class="s3">or not </span><span class="s1">hasattr(SSLSocket</span><span class="s3">, </span><span class="s4">'timeout'</span><span class="s1">):</span>
    <span class="s0"># PyPy (and certain versions of CPython) doesn't have a direct</span>
    <span class="s0"># 'timeout' property on raw sockets, because that's not part of</span>
    <span class="s0"># the documented specification. We may wind up wrapping a raw</span>
    <span class="s0"># socket (when ssl is used with PyWSGI) or a gevent socket, which</span>
    <span class="s0"># does have a read/write timeout property as an alias for</span>
    <span class="s0"># get/settimeout, so make sure that's always the case because</span>
    <span class="s0"># pywsgi can depend on that.</span>
    <span class="s1">SSLSocket.timeout = property(</span><span class="s3">lambda </span><span class="s1">self: self.gettimeout()</span><span class="s3">,</span>
                                 <span class="s3">lambda </span><span class="s1">self</span><span class="s3">, </span><span class="s1">value: self.settimeout(value))</span>


<span class="s1">_SSLErrorReadTimeout = SSLError(</span><span class="s4">'The read operation timed out'</span><span class="s1">)</span>
<span class="s1">_SSLErrorWriteTimeout = SSLError(</span><span class="s4">'The write operation timed out'</span><span class="s1">)</span>
<span class="s1">_SSLErrorHandshakeTimeout = SSLError(</span><span class="s4">'The handshake operation timed out'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">wrap_socket(sock</span><span class="s3">, </span><span class="s1">keyfile=</span><span class="s3">None, </span><span class="s1">certfile=</span><span class="s3">None,</span>
                <span class="s1">server_side=</span><span class="s3">False, </span><span class="s1">cert_reqs=CERT_NONE</span><span class="s3">,</span>
                <span class="s1">ssl_version=PROTOCOL_SSLv23</span><span class="s3">, </span><span class="s1">ca_certs=</span><span class="s3">None,</span>
                <span class="s1">do_handshake_on_connect=</span><span class="s3">True,</span>
                <span class="s1">suppress_ragged_eofs=</span><span class="s3">True, </span><span class="s1">ciphers=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Create a new :class:`SSLSocket` instance.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">SSLSocket(sock</span><span class="s3">, </span><span class="s1">keyfile=keyfile</span><span class="s3">, </span><span class="s1">certfile=certfile</span><span class="s3">,</span>
                     <span class="s1">server_side=server_side</span><span class="s3">, </span><span class="s1">cert_reqs=cert_reqs</span><span class="s3">,</span>
                     <span class="s1">ssl_version=ssl_version</span><span class="s3">, </span><span class="s1">ca_certs=ca_certs</span><span class="s3">,</span>
                     <span class="s1">do_handshake_on_connect=do_handshake_on_connect</span><span class="s3">,</span>
                     <span class="s1">suppress_ragged_eofs=suppress_ragged_eofs</span><span class="s3">,</span>
                     <span class="s1">ciphers=ciphers)</span>


<span class="s3">def </span><span class="s1">get_server_certificate(addr</span><span class="s3">, </span><span class="s1">ssl_version=PROTOCOL_SSLv23</span><span class="s3">, </span><span class="s1">ca_certs=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Retrieve the certificate from the server at the specified address, 
    and return it as a PEM-encoded string. 
    If 'ca_certs' is specified, validate the server cert against it. 
    If 'ssl_version' is specified, use it in the connection attempt.&quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">ca_certs </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">cert_reqs = CERT_REQUIRED</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">cert_reqs = CERT_NONE</span>
    <span class="s1">s = wrap_socket(socket()</span><span class="s3">, </span><span class="s1">ssl_version=ssl_version</span><span class="s3">,</span>
                    <span class="s1">cert_reqs=cert_reqs</span><span class="s3">, </span><span class="s1">ca_certs=ca_certs)</span>
    <span class="s1">s.connect(addr)</span>
    <span class="s1">dercert = s.getpeercert(</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">s.close()</span>
    <span class="s3">return </span><span class="s1">DER_cert_to_PEM_cert(dercert)</span>


<span class="s3">def </span><span class="s1">sslwrap_simple(sock</span><span class="s3">, </span><span class="s1">keyfile=</span><span class="s3">None, </span><span class="s1">certfile=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;A replacement for the old socket.ssl function.  Designed 
    for compatibility with Python 2.5 and earlier.  Will disappear in 
    Python 3.0.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">SSLSocket(sock</span><span class="s3">, </span><span class="s1">keyfile</span><span class="s3">, </span><span class="s1">certfile)</span>
</pre>
</body>
</html>