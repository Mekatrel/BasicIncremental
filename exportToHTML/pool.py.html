<html>
<head>
<title>pool.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pool.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2009-2011 Denis Bilenko. See LICENSE for details.</span>
<span class="s2">&quot;&quot;&quot; 
Managing greenlets in a group. 
 
The :class:`Group` class in this module abstracts a group of running 
greenlets. When a greenlet dies, it's automatically removed from the 
group. All running greenlets in a group can be waited on with 
:meth:`Group.join`, or all running greenlets can be killed with 
:meth:`Group.kill`. 
 
The :class:`Pool` class, which is a subclass of :class:`Group`, 
provides a way to limit concurrency: its :meth:`spawn &lt;Pool.spawn&gt;` 
method blocks if the number of greenlets in the pool has already 
reached the limit, until there is a free slot. 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">print_function</span><span class="s3">, </span><span class="s1">absolute_import</span><span class="s3">, </span><span class="s1">division</span>


<span class="s3">from </span><span class="s1">gevent.hub </span><span class="s3">import </span><span class="s1">GreenletExit</span><span class="s3">, </span><span class="s1">getcurrent</span><span class="s3">, </span><span class="s1">kill </span><span class="s3">as </span><span class="s1">_kill</span>
<span class="s3">from </span><span class="s1">gevent.greenlet </span><span class="s3">import </span><span class="s1">joinall</span><span class="s3">, </span><span class="s1">Greenlet</span>
<span class="s3">from </span><span class="s1">gevent.queue </span><span class="s3">import </span><span class="s1">Full </span><span class="s3">as </span><span class="s1">QueueFull</span>
<span class="s3">from </span><span class="s1">gevent.timeout </span><span class="s3">import </span><span class="s1">Timeout</span>
<span class="s3">from </span><span class="s1">gevent.event </span><span class="s3">import </span><span class="s1">Event</span>
<span class="s3">from </span><span class="s1">gevent.lock </span><span class="s3">import </span><span class="s1">Semaphore</span><span class="s3">, </span><span class="s1">DummySemaphore</span>

<span class="s3">from </span><span class="s1">gevent._compat </span><span class="s3">import </span><span class="s1">izip</span>
<span class="s3">from </span><span class="s1">gevent._imap </span><span class="s3">import </span><span class="s1">IMap</span>
<span class="s3">from </span><span class="s1">gevent._imap </span><span class="s3">import </span><span class="s1">IMapUnordered</span>

<span class="s1">__all__ = [</span>
    <span class="s4">'Group'</span><span class="s3">,</span>
    <span class="s4">'Pool'</span><span class="s3">,</span>
    <span class="s4">'PoolFull'</span><span class="s3">,</span>
<span class="s1">]</span>




<span class="s3">class </span><span class="s1">GroupMappingMixin(object):</span>
    <span class="s0"># Internal, non-public API class.</span>
    <span class="s0"># Provides mixin methods for implementing mapping pools. Subclasses must define:</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s3">def </span><span class="s1">spawn(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        A function that runs *func* with *args* and *kwargs*, potentially 
        asynchronously. Return a value with a ``get`` method that blocks 
        until the results of func are available, and a ``rawlink`` method 
        that calls a callback when the results are available. 
 
        If this object has an upper bound on how many asyncronously executing 
        tasks can exist, this method may block until a slot becomes available. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_apply_immediately(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        should the function passed to apply be called immediately, 
        synchronously? 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_apply_async_use_greenlet(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Should apply_async directly call Greenlet.spawn(), bypassing 
        `spawn`? 
 
        Return true when self.spawn would block. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_apply_async_cb_spawn(self</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">result):</span>
        <span class="s2">&quot;&quot;&quot; 
        Run the given callback function, possibly 
        asynchronously, possibly synchronously. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">apply_cb(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">args=</span><span class="s3">None, </span><span class="s1">kwds=</span><span class="s3">None, </span><span class="s1">callback=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        :meth:`apply` the given *func(\\*args, \\*\\*kwds)*, and, if a *callback* is given, run it with the 
        results of *func* (unless an exception was raised.) 
 
        The *callback* may be called synchronously or asynchronously. If called 
        asynchronously, it will not be tracked by this group. (:class:`Group` and :class:`Pool` 
        call it asynchronously in a new greenlet; :class:`~gevent.threadpool.ThreadPool` calls 
        it synchronously in the current greenlet.) 
        &quot;&quot;&quot;</span>
        <span class="s1">result = self.apply(func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwds)</span>
        <span class="s3">if </span><span class="s1">callback </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._apply_async_cb_spawn(callback</span><span class="s3">, </span><span class="s1">result)</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">apply_async(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">args=</span><span class="s3">None, </span><span class="s1">kwds=</span><span class="s3">None, </span><span class="s1">callback=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        A variant of the :meth:`apply` method which returns a :class:`~.Greenlet` object. 
 
        When the returned greenlet gets to run, it *will* call :meth:`apply`, 
        passing in *func*, *args* and *kwds*. 
 
        If *callback* is specified, then it should be a callable which 
        accepts a single argument. When the result becomes ready 
        callback is applied to it (unless the call failed). 
 
        This method will never block, even if this group is full (that is, 
        even if :meth:`spawn` would block, this method will not). 
 
        .. caution:: The returned greenlet may or may not be tracked 
           as part of this group, so :meth:`joining &lt;join&gt;` this group is 
           not a reliable way to wait for the results to be available or 
           for the returned greenlet to run; instead, join the returned 
           greenlet. 
 
        .. tip:: Because :class:`~.ThreadPool` objects do not track greenlets, the returned 
           greenlet will never be a part of it. To reduce overhead and improve performance, 
           :class:`Group` and :class:`Pool` may choose to track the returned 
           greenlet. These are implementation details that may change. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">args </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">args = ()</span>
        <span class="s3">if </span><span class="s1">kwds </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">kwds = {}</span>
        <span class="s3">if </span><span class="s1">self._apply_async_use_greenlet():</span>
            <span class="s0"># cannot call self.spawn() directly because it will block</span>
            <span class="s0"># XXX: This is always the case for ThreadPool, but for Group/Pool</span>
            <span class="s0"># of greenlets, this is only the case when they are full...hence</span>
            <span class="s0"># the weasely language about &quot;may or may not be tracked&quot;. Should we make</span>
            <span class="s0"># Group/Pool always return true as well so it's never tracked by any</span>
            <span class="s0"># implementation? That would simplify that logic, but could increase</span>
            <span class="s0"># the total number of greenlets in the system and add a layer of</span>
            <span class="s0"># overhead for the simple cases when the pool isn't full.</span>
            <span class="s3">return </span><span class="s1">Greenlet.spawn(self.apply_cb</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwds</span><span class="s3">, </span><span class="s1">callback)</span>

        <span class="s1">greenlet = self.spawn(func</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwds)</span>
        <span class="s3">if </span><span class="s1">callback </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">greenlet.link(pass_value(callback))</span>
        <span class="s3">return </span><span class="s1">greenlet</span>

    <span class="s3">def </span><span class="s1">apply(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">args=</span><span class="s3">None, </span><span class="s1">kwds=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Rough quivalent of the :func:`apply()` builtin function blocking until 
        the result is ready and returning it. 
 
        The ``func`` will *usually*, but not *always*, be run in a way 
        that allows the current greenlet to switch out (for example, 
        in a new greenlet or thread, depending on implementation). But 
        if the current greenlet or thread is already one that was 
        spawned by this pool, the pool may choose to immediately run 
        the `func` synchronously. 
 
        Any exception ``func`` raises will be propagated to the caller of ``apply`` (that is, 
        this method will raise the exception that ``func`` raised). 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">args </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">args = ()</span>
        <span class="s3">if </span><span class="s1">kwds </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">kwds = {}</span>
        <span class="s3">if </span><span class="s1">self._apply_immediately():</span>
            <span class="s3">return </span><span class="s1">func(*args</span><span class="s3">, </span><span class="s1">**kwds)</span>
        <span class="s3">return </span><span class="s1">self.spawn(func</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwds).get()</span>

    <span class="s3">def </span><span class="s1">__map(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">iterable):</span>
        <span class="s3">return </span><span class="s1">[g.get() </span><span class="s3">for </span><span class="s1">g </span><span class="s3">in</span>
                <span class="s1">[self.spawn(func</span><span class="s3">, </span><span class="s1">i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">iterable]]</span>

    <span class="s3">def </span><span class="s1">map(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">iterable):</span>
        <span class="s2">&quot;&quot;&quot;Return a list made by applying the *func* to each element of 
        the iterable. 
 
        .. seealso:: :meth:`imap` 
        &quot;&quot;&quot;</span>
        <span class="s0"># We can't return until they're all done and in order. It</span>
        <span class="s0"># wouldn't seem to much matter what order we wait on them in,</span>
        <span class="s0"># so the simple, fast (50% faster than imap) solution would be:</span>

        <span class="s0"># return [g.get() for g in</span>
        <span class="s0">#           [self.spawn(func, i) for i in iterable]]</span>

        <span class="s0"># If the pool size is unlimited (or more than the len(iterable)), this</span>
        <span class="s0"># is equivalent to imap (spawn() will never block, all of them run concurrently,</span>
        <span class="s0"># we call get() in the order the iterable was given).</span>

        <span class="s0"># Now lets imagine the pool if is limited size. Suppose the</span>
        <span class="s0"># func is time.sleep, our pool is limited to 3 threads, and</span>
        <span class="s0"># our input is [10, 1, 10, 1, 1] We would start three threads,</span>
        <span class="s0"># one to sleep for 10, one to sleep for 1, and the last to</span>
        <span class="s0"># sleep for 10. We would block starting the fourth thread. At</span>
        <span class="s0"># time 1, we would finish the second thread and start another</span>
        <span class="s0"># one for time 1. At time 2, we would finish that one and</span>
        <span class="s0"># start the last thread, and then begin executing get() on the first</span>
        <span class="s0"># thread.</span>

        <span class="s0"># Because it's spawn that blocks, this is *also* equivalent to what</span>
        <span class="s0"># imap would do.</span>

        <span class="s0"># The one remaining difference is that imap runs in its own</span>
        <span class="s0"># greenlet, potentially changing the way the event loop runs.</span>
        <span class="s0"># That's easy enough to do.</span>

        <span class="s1">g = Greenlet.spawn(self.__map</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">iterable)</span>
        <span class="s3">return </span><span class="s1">g.get()</span>

    <span class="s3">def </span><span class="s1">map_cb(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">callback=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">result = self.map(func</span><span class="s3">, </span><span class="s1">iterable)</span>
        <span class="s3">if </span><span class="s1">callback </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">callback(result) </span><span class="s0"># pylint:disable=not-callable</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">map_async(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">callback=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        A variant of the map() method which returns a Greenlet object that is executing 
        the map function. 
 
        If callback is specified then it should be a callable which accepts a 
        single argument. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Greenlet.spawn(self.map_cb</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">callback)</span>

    <span class="s3">def </span><span class="s1">__imap(self</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">*iterables</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># Python 2 doesn't support the syntax that lets us mix varargs and</span>
        <span class="s0"># a named kwarg, so we have to unpack manually</span>
        <span class="s1">maxsize = kwargs.pop(</span><span class="s4">'maxsize'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">kwargs:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Unsupported keyword arguments&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">cls.spawn(func</span><span class="s3">, </span><span class="s1">izip(*iterables)</span><span class="s3">, </span><span class="s1">spawn=self.spawn</span><span class="s3">,</span>
                         <span class="s1">_zipped=</span><span class="s3">True, </span><span class="s1">maxsize=maxsize)</span>

    <span class="s3">def </span><span class="s1">imap(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">*iterables</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        imap(func, *iterables, maxsize=None) -&gt; iterable 
 
        An equivalent of :func:`itertools.imap`, operating in parallel. 
        The *func* is applied to each element yielded from each 
        iterable in *iterables* in turn, collecting the result. 
 
        If this object has a bound on the number of active greenlets it can 
        contain (such as :class:`Pool`), then at most that number of tasks will operate 
        in parallel. 
 
        :keyword int maxsize: If given and not-None, specifies the maximum number of 
            finished results that will be allowed to accumulate awaiting the reader; 
            more than that number of results will cause map function greenlets to begin 
            to block. This is most useful if there is a great disparity in the speed of 
            the mapping code and the consumer and the results consume a great deal of resources. 
 
            .. note:: This is separate from any bound on the number of active parallel 
               tasks, though they may have some interaction (for example, limiting the 
               number of parallel tasks to the smallest bound). 
 
            .. note:: Using a bound is slightly more computationally expensive than not using a bound. 
 
            .. tip:: The :meth:`imap_unordered` method makes much better 
                use of this parameter. Some additional, unspecified, 
                number of objects may be required to be kept in memory 
                to maintain order by this function. 
 
        :return: An iterable object. 
 
        .. versionchanged:: 1.1b3 
            Added the *maxsize* keyword parameter. 
        .. versionchanged:: 1.1a1 
            Accept multiple *iterables* to iterate in parallel. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.__imap(IMap</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">*iterables</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">imap_unordered(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">*iterables</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        imap_unordered(func, *iterables, maxsize=None) -&gt; iterable 
 
        The same as :meth:`imap` except that the ordering of the results 
        from the returned iterator should be considered in arbitrary 
        order. 
 
        This is lighter weight than :meth:`imap` and should be preferred if order 
        doesn't matter. 
 
        .. seealso:: :meth:`imap` for more details. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.__imap(IMapUnordered</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">*iterables</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s3">class </span><span class="s1">Group(GroupMappingMixin):</span>
    <span class="s2">&quot;&quot;&quot; 
    Maintain a group of greenlets that are still running, without 
    limiting their number. 
 
    Links to each item and removes it upon notification. 
 
    Groups can be iterated to discover what greenlets they are tracking, 
    they can be tested to see if they contain a greenlet, and they know the 
    number (len) of greenlets they are tracking. If they are not tracking any 
    greenlets, they are False in a boolean context. 
 
    .. attribute:: greenlet_class 
 
        Either :class:`gevent.Greenlet` (the default) or a subclass. 
        These are the type of 
        object we will :meth:`spawn`. This can be 
        changed on an instance or in a subclass. 
    &quot;&quot;&quot;</span>

    <span class="s1">greenlet_class = Greenlet</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">assert </span><span class="s1">len(args) &lt;= </span><span class="s5">1</span><span class="s3">, </span><span class="s1">args</span>
        <span class="s1">self.greenlets = set(*args)</span>
        <span class="s3">if </span><span class="s1">args:</span>
            <span class="s3">for </span><span class="s1">greenlet </span><span class="s3">in </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">]:</span>
                <span class="s1">greenlet.rawlink(self._discard)</span>
        <span class="s0"># each item we kill we place in dying, to avoid killing the same greenlet twice</span>
        <span class="s1">self.dying = set()</span>
        <span class="s1">self._empty_event = Event()</span>
        <span class="s1">self._empty_event.set()</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">'&lt;%s at 0x%x %s&gt;' </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">id(self)</span><span class="s3">, </span><span class="s1">self.greenlets)</span>

    <span class="s3">def </span><span class="s1">__len__(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Answer how many greenlets we are tracking. Note that if we are empty, 
        we are False in a boolean context. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">len(self.greenlets)</span>

    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">item):</span>
        <span class="s2">&quot;&quot;&quot; 
        Answer if we are tracking the given greenlet. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">item </span><span class="s3">in </span><span class="s1">self.greenlets</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Iterate across all the greenlets we are tracking, in no particular order. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">iter(self.greenlets)</span>

    <span class="s3">def </span><span class="s1">add(self</span><span class="s3">, </span><span class="s1">greenlet):</span>
        <span class="s2">&quot;&quot;&quot; 
        Begin tracking the *greenlet*. 
 
        If this group is :meth:`full`, then this method may block 
        until it is possible to track the greenlet. 
 
        Typically the *greenlet* should **not** be started when 
        it is added because if this object blocks in this method, 
        then the *greenlet* may run to completion before it is tracked. 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">rawlink = greenlet.rawlink</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">pass  </span><span class="s0"># non-Greenlet greenlet, like MAIN</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">rawlink(self._discard)</span>
        <span class="s1">self.greenlets.add(greenlet)</span>
        <span class="s1">self._empty_event.clear()</span>

    <span class="s3">def </span><span class="s1">_discard(self</span><span class="s3">, </span><span class="s1">greenlet):</span>
        <span class="s1">self.greenlets.discard(greenlet)</span>
        <span class="s1">self.dying.discard(greenlet)</span>
        <span class="s3">if not </span><span class="s1">self.greenlets:</span>
            <span class="s1">self._empty_event.set()</span>

    <span class="s3">def </span><span class="s1">discard(self</span><span class="s3">, </span><span class="s1">greenlet):</span>
        <span class="s2">&quot;&quot;&quot; 
        Stop tracking the greenlet. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._discard(greenlet)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">unlink = greenlet.unlink</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">pass  </span><span class="s0"># non-Greenlet greenlet, like MAIN</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">unlink(self._discard)</span>

    <span class="s3">def </span><span class="s1">start(self</span><span class="s3">, </span><span class="s1">greenlet):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add the **unstarted** *greenlet* to the collection of greenlets 
        this group is monitoring, and then start it. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.add(greenlet)</span>
        <span class="s1">greenlet.start()</span>

    <span class="s3">def </span><span class="s1">spawn(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs): </span><span class="s0"># pylint:disable=arguments-differ</span>
        <span class="s2">&quot;&quot;&quot; 
        Begin a new greenlet with the given arguments (which are passed 
        to the greenlet constructor) and add it to the collection of greenlets 
        this group is monitoring. 
 
        :return: The newly started greenlet. 
        &quot;&quot;&quot;</span>
        <span class="s1">greenlet = self.greenlet_class(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.start(greenlet)</span>
        <span class="s3">return </span><span class="s1">greenlet</span>

<span class="s0">#     def close(self):</span>
<span class="s0">#         &quot;&quot;&quot;Prevents any more tasks from being submitted to the pool&quot;&quot;&quot;</span>
<span class="s0">#         self.add = RaiseException(&quot;This %s has been closed&quot; % self.__class__.__name__)</span>

    <span class="s3">def </span><span class="s1">join(self</span><span class="s3">, </span><span class="s1">timeout=</span><span class="s3">None, </span><span class="s1">raise_error=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Wait for this group to become empty *at least once*. 
 
        If there are no greenlets in the group, returns immediately. 
 
        .. note:: By the time the waiting code (the caller of this 
           method) regains control, a greenlet may have been added to 
           this group, and so this object may no longer be empty. (That 
           is, ``group.join(); assert len(group) == 0`` is not 
           guaranteed to hold.) This method only guarantees that the group 
           reached a ``len`` of 0 at some point. 
 
        :keyword bool raise_error: If True (*not* the default), if any 
            greenlet that finished while the join was in progress raised 
            an exception, that exception will be raised to the caller of 
            this method. If multiple greenlets raised exceptions, which 
            one gets re-raised is not determined. Only greenlets currently 
            in the group when this method is called are guaranteed to 
            be checked for exceptions. 
 
        :return bool: A value indicating whether this group became empty. 
           If the timeout is specified and the group did not become empty 
           during that timeout, then this will be a false value. Otherwise 
           it will be a true value. 
 
        .. versionchanged:: 1.2a1 
           Add the return value. 
        &quot;&quot;&quot;</span>
        <span class="s1">greenlets = list(self.greenlets) </span><span class="s3">if </span><span class="s1">raise_error </span><span class="s3">else </span><span class="s1">()</span>
        <span class="s1">result = self._empty_event.wait(timeout=timeout)</span>

        <span class="s3">for </span><span class="s1">greenlet </span><span class="s3">in </span><span class="s1">greenlets:</span>
            <span class="s3">if </span><span class="s1">greenlet.exception </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">hasattr(greenlet</span><span class="s3">, </span><span class="s4">'_raise_exception'</span><span class="s1">):</span>
                    <span class="s1">greenlet._raise_exception()</span>
                <span class="s3">raise </span><span class="s1">greenlet.exception</span>

        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">kill(self</span><span class="s3">, </span><span class="s1">exception=GreenletExit</span><span class="s3">, </span><span class="s1">block=</span><span class="s3">True, </span><span class="s1">timeout=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Kill all greenlets being tracked by this group. 
        &quot;&quot;&quot;</span>
        <span class="s1">timer = Timeout._start_new_or_dummy(timeout)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">while </span><span class="s1">self.greenlets:</span>
                <span class="s3">for </span><span class="s1">greenlet </span><span class="s3">in </span><span class="s1">list(self.greenlets):</span>
                    <span class="s3">if </span><span class="s1">greenlet </span><span class="s3">in </span><span class="s1">self.dying:</span>
                        <span class="s3">continue</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">kill = greenlet.kill</span>
                    <span class="s3">except </span><span class="s1">AttributeError:</span>
                        <span class="s1">_kill(greenlet</span><span class="s3">, </span><span class="s1">exception)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">kill(exception</span><span class="s3">, </span><span class="s1">block=</span><span class="s3">False</span><span class="s1">)</span>
                    <span class="s1">self.dying.add(greenlet)</span>
                <span class="s3">if not </span><span class="s1">block:</span>
                    <span class="s3">break</span>
                <span class="s1">joinall(self.greenlets)</span>
        <span class="s3">except </span><span class="s1">Timeout </span><span class="s3">as </span><span class="s1">ex:</span>
            <span class="s3">if </span><span class="s1">ex </span><span class="s3">is not </span><span class="s1">timer:</span>
                <span class="s3">raise</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">timer.cancel()</span>

    <span class="s3">def </span><span class="s1">killone(self</span><span class="s3">, </span><span class="s1">greenlet</span><span class="s3">, </span><span class="s1">exception=GreenletExit</span><span class="s3">, </span><span class="s1">block=</span><span class="s3">True, </span><span class="s1">timeout=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        If the given *greenlet* is running and being tracked by this group, 
        kill it. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">greenlet </span><span class="s3">not in </span><span class="s1">self.dying </span><span class="s3">and </span><span class="s1">greenlet </span><span class="s3">in </span><span class="s1">self.greenlets:</span>
            <span class="s1">greenlet.kill(exception</span><span class="s3">, </span><span class="s1">block=</span><span class="s3">False</span><span class="s1">)</span>
            <span class="s1">self.dying.add(greenlet)</span>
            <span class="s3">if </span><span class="s1">block:</span>
                <span class="s1">greenlet.join(timeout)</span>

    <span class="s3">def </span><span class="s1">full(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return a value indicating whether this group can track more greenlets. 
 
        In this implementation, because there are no limits on the number of 
        tracked greenlets, this will always return a ``False`` value. 
        &quot;&quot;&quot;</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">wait_available(self</span><span class="s3">, </span><span class="s1">timeout=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Block until it is possible to :meth:`spawn` a new greenlet. 
 
        In this implementation, because there are no limits on the number 
        of tracked greenlets, this will always return immediately. 
        &quot;&quot;&quot;</span>

    <span class="s0"># MappingMixin methods</span>

    <span class="s3">def </span><span class="s1">_apply_immediately(self):</span>
        <span class="s0"># If apply() is called from one of our own</span>
        <span class="s0"># worker greenlets, don't spawn a new one---if we're full, that</span>
        <span class="s0"># could deadlock.</span>
        <span class="s3">return </span><span class="s1">getcurrent() </span><span class="s3">in </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_apply_async_cb_spawn(self</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">result):</span>
        <span class="s1">Greenlet.spawn(callback</span><span class="s3">, </span><span class="s1">result)</span>

    <span class="s3">def </span><span class="s1">_apply_async_use_greenlet(self):</span>
        <span class="s0"># cannot call self.spawn() because it will block, so</span>
        <span class="s0"># use a fresh, untracked greenlet that when run will</span>
        <span class="s0"># (indirectly) call self.spawn() for us.</span>
        <span class="s3">return </span><span class="s1">self.full()</span>



<span class="s3">class </span><span class="s1">PoolFull(QueueFull):</span>
    <span class="s2">&quot;&quot;&quot; 
    Raised when a Pool is full and an attempt was made to 
    add a new greenlet to it in non-blocking mode. 
    &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">Pool(Group):</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">size=</span><span class="s3">None, </span><span class="s1">greenlet_class=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a new pool. 
 
        A pool is like a group, but the maximum number of members 
        is governed by the *size* parameter. 
 
        :keyword int size: If given, this non-negative integer is the 
            maximum count of active greenlets that will be allowed in 
            this pool. A few values have special significance: 
 
            * `None` (the default) places no limit on the number of 
              greenlets. This is useful when you want to track, but not limit, 
              greenlets. In general, a :class:`Group` 
              may be a more efficient way to achieve the same effect, but some things 
              need the additional abilities of this class (one example being the *spawn* 
              parameter of :class:`gevent.baseserver.BaseServer` and 
              its subclass :class:`gevent.pywsgi.WSGIServer`). 
 
            * ``0`` creates a pool that can never have any active greenlets. Attempting 
              to spawn in this pool will block forever. This is only useful 
              if an application uses :meth:`wait_available` with a timeout and checks 
              :meth:`free_count` before attempting to spawn. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">size </span><span class="s3">is not None and </span><span class="s1">size &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'size must not be negative: %r' </span><span class="s1">% (size</span><span class="s3">, </span><span class="s1">))</span>
        <span class="s1">Group.__init__(self)</span>
        <span class="s1">self.size = size</span>
        <span class="s3">if </span><span class="s1">greenlet_class </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.greenlet_class = greenlet_class</span>
        <span class="s3">if </span><span class="s1">size </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">factory = DummySemaphore</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">factory = Semaphore</span>
        <span class="s1">self._semaphore = factory(size)</span>

    <span class="s3">def </span><span class="s1">wait_available(self</span><span class="s3">, </span><span class="s1">timeout=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Wait until it's possible to spawn a greenlet in this pool. 
 
        :param float timeout: If given, only wait the specified number 
            of seconds. 
 
        .. warning:: If the pool was initialized with a size of 0, this 
           method will block forever unless a timeout is given. 
 
        :return: A number indicating how many new greenlets can be put into 
           the pool without blocking. 
 
        .. versionchanged:: 1.1a3 
            Added the ``timeout`` parameter. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._semaphore.wait(timeout=timeout)</span>

    <span class="s3">def </span><span class="s1">full(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return a boolean indicating whether this pool is full, e.g. if 
        :meth:`add` would block. 
 
        :return: False if there is room for new members, True if there isn't. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.free_count() &lt;= </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">free_count(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return a number indicating *approximately* how many more members 
        can be added to this pool. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.size </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s5">1</span>
        <span class="s3">return </span><span class="s1">max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">self.size - len(self))</span>

    <span class="s3">def </span><span class="s1">start(self</span><span class="s3">, </span><span class="s1">greenlet</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs): </span><span class="s0"># pylint:disable=arguments-differ</span>
        <span class="s2">&quot;&quot;&quot; 
        start(greenlet, blocking=True, timeout=None) -&gt; None 
 
        Add the **unstarted** *greenlet* to the collection of greenlets 
        this group is monitoring and then start it. 
 
        Parameters are as for :meth:`add`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.add(greenlet</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">greenlet.start()</span>

    <span class="s3">def </span><span class="s1">add(self</span><span class="s3">, </span><span class="s1">greenlet</span><span class="s3">, </span><span class="s1">blocking=</span><span class="s3">True, </span><span class="s1">timeout=</span><span class="s3">None</span><span class="s1">): </span><span class="s0"># pylint:disable=arguments-differ</span>
        <span class="s2">&quot;&quot;&quot; 
        Begin tracking the given **unstarted** greenlet, possibly blocking 
        until space is available. 
 
        Usually you should call :meth:`start` to track and start the greenlet 
        instead of using this lower-level method, or :meth:`spawn` to 
        also create the greenlet. 
 
        :keyword bool blocking: If True (the default), this function 
            will block until the pool has space or a timeout occurs.  If 
            False, this function will immediately raise a Timeout if the 
            pool is currently full. 
        :keyword float timeout: The maximum number of seconds this 
            method will block, if ``blocking`` is True.  (Ignored if 
            ``blocking`` is False.) 
        :raises PoolFull: if either ``blocking`` is False and the pool 
            was full, or if ``blocking`` is True and ``timeout`` was 
            exceeded. 
 
        ..  caution:: If the *greenlet* has already been started and 
            *blocking* is true, then the greenlet may run to completion 
            while the current greenlet blocks waiting to track it. This would 
            enable higher concurrency than desired. 
 
        ..  seealso:: :meth:`Group.add` 
 
        ..  versionchanged:: 1.3.0 Added the ``blocking`` and 
            ``timeout`` parameters. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self._semaphore.acquire(blocking=blocking</span><span class="s3">, </span><span class="s1">timeout=timeout):</span>
            <span class="s0"># We failed to acquire the semaphore.</span>
            <span class="s0"># If blocking was True, then there was a timeout. If blocking was</span>
            <span class="s0"># False, then there was no capacity. Either way, raise PoolFull.</span>
            <span class="s3">raise </span><span class="s1">PoolFull()</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">Group.add(self</span><span class="s3">, </span><span class="s1">greenlet)</span>
        <span class="s3">except</span><span class="s1">:</span>
            <span class="s1">self._semaphore.release()</span>
            <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">_discard(self</span><span class="s3">, </span><span class="s1">greenlet):</span>
        <span class="s1">Group._discard(self</span><span class="s3">, </span><span class="s1">greenlet)</span>
        <span class="s1">self._semaphore.release()</span>


<span class="s3">class </span><span class="s1">pass_value(object):</span>
    <span class="s1">__slots__ = [</span><span class="s4">'callback'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">callback):</span>
        <span class="s1">self.callback = callback</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">source):</span>
        <span class="s3">if </span><span class="s1">source.successful():</span>
            <span class="s1">self.callback(source.value)</span>

    <span class="s3">def </span><span class="s1">__hash__(self):</span>
        <span class="s3">return </span><span class="s1">hash(self.callback)</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return </span><span class="s1">self.callback == getattr(other</span><span class="s3">, </span><span class="s4">'callback'</span><span class="s3">, </span><span class="s1">other)</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s1">str(self.callback)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s1">repr(self.callback)</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">item):</span>
        <span class="s3">assert </span><span class="s1">item != </span><span class="s4">'callback'</span>
        <span class="s3">return </span><span class="s1">getattr(self.callback</span><span class="s3">, </span><span class="s1">item)</span>
</pre>
</body>
</html>