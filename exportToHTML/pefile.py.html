<html>
<head>
<title>pefile.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pefile.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/python</span>

<span class="s2">&quot;&quot;&quot;pefile, Portable Executable reader module 
 
All the PE file basic structures are available with their default names as 
attributes of the instance returned. 
 
Processed elements such as the import table are made available with lowercase 
names, to differentiate them from the upper case basic structure names. 
 
pefile has been tested against many edge cases such as corrupted and malformed 
PEs as well as malware, which often attempts to abuse the format way beyond its 
standard use. To the best of my knowledge most of the abuse is handled 
gracefully. 
 
Copyright (c) 2005-2023 Ero Carrera &lt;ero.carrera@gmail.com&gt; 
&quot;&quot;&quot;</span>

<span class="s1">__author__ = </span><span class="s3">&quot;Ero Carrera&quot;</span>
<span class="s1">__version__ = </span><span class="s3">&quot;2023.2.7&quot;</span>
<span class="s1">__contact__ = </span><span class="s3">&quot;ero.carrera@gmail.com&quot;</span>

<span class="s4">import </span><span class="s1">collections</span>
<span class="s4">import </span><span class="s1">os</span>
<span class="s4">import </span><span class="s1">struct</span>
<span class="s4">import </span><span class="s1">codecs</span>
<span class="s4">import </span><span class="s1">time</span>
<span class="s4">import </span><span class="s1">math</span>
<span class="s4">import </span><span class="s1">string</span>
<span class="s4">import </span><span class="s1">mmap</span>
<span class="s4">import </span><span class="s1">uuid</span>

<span class="s4">from </span><span class="s1">collections </span><span class="s4">import </span><span class="s1">Counter</span>
<span class="s4">from </span><span class="s1">typing </span><span class="s4">import </span><span class="s1">Union</span>
<span class="s4">from </span><span class="s1">hashlib </span><span class="s4">import </span><span class="s1">sha1</span>
<span class="s4">from </span><span class="s1">hashlib </span><span class="s4">import </span><span class="s1">sha256</span>
<span class="s4">from </span><span class="s1">hashlib </span><span class="s4">import </span><span class="s1">sha512</span>
<span class="s4">from </span><span class="s1">hashlib </span><span class="s4">import </span><span class="s1">md5</span>

<span class="s4">import </span><span class="s1">functools</span>
<span class="s4">import </span><span class="s1">copy </span><span class="s4">as </span><span class="s1">copymod</span>

<span class="s4">import </span><span class="s1">ordlookup</span>

<span class="s1">codecs.register_error(</span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s4">, </span><span class="s1">codecs.lookup_error(</span><span class="s3">&quot;backslashreplace&quot;</span><span class="s1">))</span>

<span class="s1">long = int</span>
<span class="s0"># lru_cache with a shallow copy of the objects returned (list, dicts, ..)</span>
<span class="s0"># we don't use deepcopy as it's _really_ slow and the data we retrieved using</span>
<span class="s0"># this is enough with copy.copy taken from</span>
<span class="s0"># https://stackoverflow.com/questions/54909357</span>
<span class="s4">def </span><span class="s1">lru_cache(maxsize=</span><span class="s5">128</span><span class="s4">, </span><span class="s1">typed=</span><span class="s4">False, </span><span class="s1">copy=</span><span class="s4">False</span><span class="s1">):</span>
    <span class="s4">if not </span><span class="s1">copy:</span>
        <span class="s4">return </span><span class="s1">functools.lru_cache(maxsize</span><span class="s4">, </span><span class="s1">typed)</span>

    <span class="s4">def </span><span class="s1">decorator(f):</span>
        <span class="s1">cached_func = functools.lru_cache(maxsize</span><span class="s4">, </span><span class="s1">typed)(f)</span>

        <span class="s1">@functools.wraps(f)</span>
        <span class="s4">def </span><span class="s1">wrapper(*args</span><span class="s4">, </span><span class="s1">**kwargs):</span>
            <span class="s0"># return copymod.deepcopy(cached_func(*args, **kwargs))</span>
            <span class="s4">return </span><span class="s1">copymod.copy(cached_func(*args</span><span class="s4">, </span><span class="s1">**kwargs))</span>

        <span class="s4">return </span><span class="s1">wrapper</span>

    <span class="s4">return </span><span class="s1">decorator</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s5">2048</span><span class="s1">)</span>
<span class="s4">def </span><span class="s1">cache_adjust_FileAlignment(val</span><span class="s4">, </span><span class="s1">file_alignment):</span>
    <span class="s4">if </span><span class="s1">file_alignment &lt; FILE_ALIGNMENT_HARDCODED_VALUE:</span>
        <span class="s4">return </span><span class="s1">val</span>
    <span class="s4">return </span><span class="s1">(int(val / </span><span class="s5">0x200</span><span class="s1">)) * </span><span class="s5">0x200</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s5">2048</span><span class="s1">)</span>
<span class="s4">def </span><span class="s1">cache_adjust_SectionAlignment(val</span><span class="s4">, </span><span class="s1">section_alignment</span><span class="s4">, </span><span class="s1">file_alignment):</span>
    <span class="s4">if </span><span class="s1">section_alignment &lt; </span><span class="s5">0x1000</span><span class="s1">:  </span><span class="s0"># page size</span>
        <span class="s1">section_alignment = file_alignment</span>

    <span class="s0"># 0x200 is the minimum valid FileAlignment according to the documentation</span>
    <span class="s0"># although ntoskrnl.exe has an alignment of 0x80 in some Windows versions</span>
    <span class="s0">#</span>
    <span class="s0"># elif section_alignment &lt; 0x80:</span>
    <span class="s0">#    section_alignment = 0x80</span>

    <span class="s4">if </span><span class="s1">section_alignment </span><span class="s4">and </span><span class="s1">val % section_alignment:</span>
        <span class="s4">return </span><span class="s1">section_alignment * (int(val / section_alignment))</span>
    <span class="s4">return </span><span class="s1">val</span>


<span class="s4">def </span><span class="s1">count_zeroes(data):</span>
    <span class="s4">return </span><span class="s1">data.count(</span><span class="s5">0</span><span class="s1">)</span>


<span class="s1">fast_load = </span><span class="s4">False</span>

<span class="s0"># This will set a maximum length of a string to be retrieved from the file.</span>
<span class="s0"># It's there to prevent loading massive amounts of data from memory mapped</span>
<span class="s0"># files. Strings longer than 1MB should be rather rare.</span>
<span class="s1">MAX_STRING_LENGTH = </span><span class="s5">0x100000  </span><span class="s0"># 2^20</span>

<span class="s0"># Maximum number of imports to parse.</span>
<span class="s1">MAX_IMPORT_SYMBOLS = </span><span class="s5">0x2000</span>

<span class="s0"># Limit maximum length for specific string types separately</span>
<span class="s1">MAX_IMPORT_NAME_LENGTH = </span><span class="s5">0x200</span>
<span class="s1">MAX_DLL_LENGTH = </span><span class="s5">0x200</span>
<span class="s1">MAX_SYMBOL_NAME_LENGTH = </span><span class="s5">0x200</span>

<span class="s0"># Limit maximum number of sections before processing of sections will stop</span>
<span class="s1">MAX_SECTIONS = </span><span class="s5">0x800</span>

<span class="s0"># The global maximum number of resource entries to parse per file</span>
<span class="s1">MAX_RESOURCE_ENTRIES = </span><span class="s5">0x8000</span>

<span class="s0"># The maximum depth of nested resource tables</span>
<span class="s1">MAX_RESOURCE_DEPTH = </span><span class="s5">32</span>

<span class="s0"># Limit number of exported symbols</span>
<span class="s1">MAX_SYMBOL_EXPORT_COUNT = </span><span class="s5">0x2000</span>

<span class="s1">IMAGE_DOS_SIGNATURE = </span><span class="s5">0x5A4D</span>
<span class="s1">IMAGE_DOSZM_SIGNATURE = </span><span class="s5">0x4D5A</span>
<span class="s1">IMAGE_NE_SIGNATURE = </span><span class="s5">0x454E</span>
<span class="s1">IMAGE_LE_SIGNATURE = </span><span class="s5">0x454C</span>
<span class="s1">IMAGE_LX_SIGNATURE = </span><span class="s5">0x584C</span>
<span class="s1">IMAGE_TE_SIGNATURE = </span><span class="s5">0x5A56  </span><span class="s0"># Terse Executables have a 'VZ' signature</span>

<span class="s1">IMAGE_NT_SIGNATURE = </span><span class="s5">0x00004550</span>
<span class="s1">IMAGE_NUMBEROF_DIRECTORY_ENTRIES = </span><span class="s5">16</span>
<span class="s1">IMAGE_ORDINAL_FLAG = </span><span class="s5">0x80000000</span>
<span class="s1">IMAGE_ORDINAL_FLAG64 = </span><span class="s5">0x8000000000000000</span>
<span class="s1">OPTIONAL_HEADER_MAGIC_PE = </span><span class="s5">0x10B</span>
<span class="s1">OPTIONAL_HEADER_MAGIC_PE_PLUS = </span><span class="s5">0x20B</span>


<span class="s4">def </span><span class="s1">two_way_dict(pairs):</span>
    <span class="s4">return </span><span class="s1">dict([(e[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">e[</span><span class="s5">0</span><span class="s1">]) </span><span class="s4">for </span><span class="s1">e </span><span class="s4">in </span><span class="s1">pairs] + pairs)</span>


<span class="s1">directory_entry_types = [</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_EXPORT&quot;</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_IMPORT&quot;</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_RESOURCE&quot;</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_EXCEPTION&quot;</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_SECURITY&quot;</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_BASERELOC&quot;</span><span class="s4">, </span><span class="s5">5</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_DEBUG&quot;</span><span class="s4">, </span><span class="s5">6</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s0"># Architecture on non-x86 platforms</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_COPYRIGHT&quot;</span><span class="s4">, </span><span class="s5">7</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_GLOBALPTR&quot;</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_TLS&quot;</span><span class="s4">, </span><span class="s5">9</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG&quot;</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT&quot;</span><span class="s4">, </span><span class="s5">11</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_IAT&quot;</span><span class="s4">, </span><span class="s5">12</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT&quot;</span><span class="s4">, </span><span class="s5">13</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR&quot;</span><span class="s4">, </span><span class="s5">14</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_RESERVED&quot;</span><span class="s4">, </span><span class="s5">15</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">DIRECTORY_ENTRY = two_way_dict(directory_entry_types)</span>

<span class="s1">image_characteristics = [</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_RELOCS_STRIPPED&quot;</span><span class="s4">, </span><span class="s5">0x0001</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_EXECUTABLE_IMAGE&quot;</span><span class="s4">, </span><span class="s5">0x0002</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_LINE_NUMS_STRIPPED&quot;</span><span class="s4">, </span><span class="s5">0x0004</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_LOCAL_SYMS_STRIPPED&quot;</span><span class="s4">, </span><span class="s5">0x0008</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_AGGRESIVE_WS_TRIM&quot;</span><span class="s4">, </span><span class="s5">0x0010</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_LARGE_ADDRESS_AWARE&quot;</span><span class="s4">, </span><span class="s5">0x0020</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_16BIT_MACHINE&quot;</span><span class="s4">, </span><span class="s5">0x0040</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_BYTES_REVERSED_LO&quot;</span><span class="s4">, </span><span class="s5">0x0080</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_32BIT_MACHINE&quot;</span><span class="s4">, </span><span class="s5">0x0100</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_DEBUG_STRIPPED&quot;</span><span class="s4">, </span><span class="s5">0x0200</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP&quot;</span><span class="s4">, </span><span class="s5">0x0400</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_NET_RUN_FROM_SWAP&quot;</span><span class="s4">, </span><span class="s5">0x0800</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_SYSTEM&quot;</span><span class="s4">, </span><span class="s5">0x1000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_DLL&quot;</span><span class="s4">, </span><span class="s5">0x2000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_UP_SYSTEM_ONLY&quot;</span><span class="s4">, </span><span class="s5">0x4000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_BYTES_REVERSED_HI&quot;</span><span class="s4">, </span><span class="s5">0x8000</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">IMAGE_CHARACTERISTICS = two_way_dict(image_characteristics)</span>


<span class="s1">section_characteristics = [</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_TYPE_REG&quot;</span><span class="s4">, </span><span class="s5">0x00000000</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># reserved</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_TYPE_DSECT&quot;</span><span class="s4">, </span><span class="s5">0x00000001</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># reserved</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_TYPE_NOLOAD&quot;</span><span class="s4">, </span><span class="s5">0x00000002</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># reserved</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_TYPE_GROUP&quot;</span><span class="s4">, </span><span class="s5">0x00000004</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># reserved</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_TYPE_NO_PAD&quot;</span><span class="s4">, </span><span class="s5">0x00000008</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># reserved</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_TYPE_COPY&quot;</span><span class="s4">, </span><span class="s5">0x00000010</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># reserved</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_CNT_CODE&quot;</span><span class="s4">, </span><span class="s5">0x00000020</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_CNT_INITIALIZED_DATA&quot;</span><span class="s4">, </span><span class="s5">0x00000040</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_CNT_UNINITIALIZED_DATA&quot;</span><span class="s4">, </span><span class="s5">0x00000080</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_LNK_OTHER&quot;</span><span class="s4">, </span><span class="s5">0x00000100</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_LNK_INFO&quot;</span><span class="s4">, </span><span class="s5">0x00000200</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_LNK_OVER&quot;</span><span class="s4">, </span><span class="s5">0x00000400</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># reserved</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_LNK_REMOVE&quot;</span><span class="s4">, </span><span class="s5">0x00000800</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_LNK_COMDAT&quot;</span><span class="s4">, </span><span class="s5">0x00001000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_PROTECTED&quot;</span><span class="s4">, </span><span class="s5">0x00004000</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># obsolete</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_NO_DEFER_SPEC_EXC&quot;</span><span class="s4">, </span><span class="s5">0x00004000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_GPREL&quot;</span><span class="s4">, </span><span class="s5">0x00008000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_FARDATA&quot;</span><span class="s4">, </span><span class="s5">0x00008000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_SYSHEAP&quot;</span><span class="s4">, </span><span class="s5">0x00010000</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># obsolete</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_PURGEABLE&quot;</span><span class="s4">, </span><span class="s5">0x00020000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_16BIT&quot;</span><span class="s4">, </span><span class="s5">0x00020000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_LOCKED&quot;</span><span class="s4">, </span><span class="s5">0x00040000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_PRELOAD&quot;</span><span class="s4">, </span><span class="s5">0x00080000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_1BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00100000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_2BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00200000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_4BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00300000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_8BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00400000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_16BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00500000</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># default alignment</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_32BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00600000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_64BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00700000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_128BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00800000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_256BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00900000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_512BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00A00000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_1024BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00B00000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_2048BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00C00000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_4096BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00D00000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_8192BYTES&quot;</span><span class="s4">, </span><span class="s5">0x00E00000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_ALIGN_MASK&quot;</span><span class="s4">, </span><span class="s5">0x00F00000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_LNK_NRELOC_OVFL&quot;</span><span class="s4">, </span><span class="s5">0x01000000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_DISCARDABLE&quot;</span><span class="s4">, </span><span class="s5">0x02000000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_NOT_CACHED&quot;</span><span class="s4">, </span><span class="s5">0x04000000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_NOT_PAGED&quot;</span><span class="s4">, </span><span class="s5">0x08000000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_SHARED&quot;</span><span class="s4">, </span><span class="s5">0x10000000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_EXECUTE&quot;</span><span class="s4">, </span><span class="s5">0x20000000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_READ&quot;</span><span class="s4">, </span><span class="s5">0x40000000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SCN_MEM_WRITE&quot;</span><span class="s4">, </span><span class="s5">0x80000000</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">SECTION_CHARACTERISTICS = two_way_dict(section_characteristics)</span>


<span class="s1">debug_types = [</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_UNKNOWN&quot;</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_COFF&quot;</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_CODEVIEW&quot;</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_FPO&quot;</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_MISC&quot;</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_EXCEPTION&quot;</span><span class="s4">, </span><span class="s5">5</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_FIXUP&quot;</span><span class="s4">, </span><span class="s5">6</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_OMAP_TO_SRC&quot;</span><span class="s4">, </span><span class="s5">7</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_OMAP_FROM_SRC&quot;</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_BORLAND&quot;</span><span class="s4">, </span><span class="s5">9</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_RESERVED10&quot;</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_CLSID&quot;</span><span class="s4">, </span><span class="s5">11</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_VC_FEATURE&quot;</span><span class="s4">, </span><span class="s5">12</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_POGO&quot;</span><span class="s4">, </span><span class="s5">13</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_ILTCG&quot;</span><span class="s4">, </span><span class="s5">14</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_MPX&quot;</span><span class="s4">, </span><span class="s5">15</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_REPRO&quot;</span><span class="s4">, </span><span class="s5">16</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS&quot;</span><span class="s4">, </span><span class="s5">20</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">DEBUG_TYPE = two_way_dict(debug_types)</span>


<span class="s1">subsystem_types = [</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_UNKNOWN&quot;</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_NATIVE&quot;</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_WINDOWS_GUI&quot;</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_WINDOWS_CUI&quot;</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_OS2_CUI&quot;</span><span class="s4">, </span><span class="s5">5</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_POSIX_CUI&quot;</span><span class="s4">, </span><span class="s5">7</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_NATIVE_WINDOWS&quot;</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_WINDOWS_CE_GUI&quot;</span><span class="s4">, </span><span class="s5">9</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_EFI_APPLICATION&quot;</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER&quot;</span><span class="s4">, </span><span class="s5">11</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER&quot;</span><span class="s4">, </span><span class="s5">12</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_EFI_ROM&quot;</span><span class="s4">, </span><span class="s5">13</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_XBOX&quot;</span><span class="s4">, </span><span class="s5">14</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION&quot;</span><span class="s4">, </span><span class="s5">16</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">SUBSYSTEM_TYPE = two_way_dict(subsystem_types)</span>


<span class="s1">machine_types = [</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_UNKNOWN&quot;</span><span class="s4">, </span><span class="s5">0x0</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_I386&quot;</span><span class="s4">, </span><span class="s5">0x014C</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_R3000&quot;</span><span class="s4">, </span><span class="s5">0x0162</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_R4000&quot;</span><span class="s4">, </span><span class="s5">0x0166</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_R10000&quot;</span><span class="s4">, </span><span class="s5">0x0168</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_WCEMIPSV2&quot;</span><span class="s4">, </span><span class="s5">0x0169</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_ALPHA&quot;</span><span class="s4">, </span><span class="s5">0x0184</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_SH3&quot;</span><span class="s4">, </span><span class="s5">0x01A2</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_SH3DSP&quot;</span><span class="s4">, </span><span class="s5">0x01A3</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_SH3E&quot;</span><span class="s4">, </span><span class="s5">0x01A4</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_SH4&quot;</span><span class="s4">, </span><span class="s5">0x01A6</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_SH5&quot;</span><span class="s4">, </span><span class="s5">0x01A8</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_ARM&quot;</span><span class="s4">, </span><span class="s5">0x01C0</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_THUMB&quot;</span><span class="s4">, </span><span class="s5">0x01C2</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_ARMNT&quot;</span><span class="s4">, </span><span class="s5">0x01C4</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_AM33&quot;</span><span class="s4">, </span><span class="s5">0x01D3</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_POWERPC&quot;</span><span class="s4">, </span><span class="s5">0x01F0</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_POWERPCFP&quot;</span><span class="s4">, </span><span class="s5">0x01F1</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_IA64&quot;</span><span class="s4">, </span><span class="s5">0x0200</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_MIPS16&quot;</span><span class="s4">, </span><span class="s5">0x0266</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_ALPHA64&quot;</span><span class="s4">, </span><span class="s5">0x0284</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_AXP64&quot;</span><span class="s4">, </span><span class="s5">0x0284</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># same</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_MIPSFPU&quot;</span><span class="s4">, </span><span class="s5">0x0366</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_MIPSFPU16&quot;</span><span class="s4">, </span><span class="s5">0x0466</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_TRICORE&quot;</span><span class="s4">, </span><span class="s5">0x0520</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_CEF&quot;</span><span class="s4">, </span><span class="s5">0x0CEF</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_EBC&quot;</span><span class="s4">, </span><span class="s5">0x0EBC</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_RISCV32&quot;</span><span class="s4">, </span><span class="s5">0x5032</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_RISCV64&quot;</span><span class="s4">, </span><span class="s5">0x5064</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_RISCV128&quot;</span><span class="s4">, </span><span class="s5">0x5128</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_LOONGARCH32&quot;</span><span class="s4">, </span><span class="s5">0x6232</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_LOONGARCH64&quot;</span><span class="s4">, </span><span class="s5">0x6264</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_AMD64&quot;</span><span class="s4">, </span><span class="s5">0x8664</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_M32R&quot;</span><span class="s4">, </span><span class="s5">0x9041</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_ARM64&quot;</span><span class="s4">, </span><span class="s5">0xAA64</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_FILE_MACHINE_CEE&quot;</span><span class="s4">, </span><span class="s5">0xC0EE</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">MACHINE_TYPE = two_way_dict(machine_types)</span>


<span class="s1">relocation_types = [</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_REL_BASED_ABSOLUTE&quot;</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_REL_BASED_HIGH&quot;</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_REL_BASED_LOW&quot;</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_REL_BASED_HIGHLOW&quot;</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_REL_BASED_HIGHADJ&quot;</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_REL_BASED_MIPS_JMPADDR&quot;</span><span class="s4">, </span><span class="s5">5</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_REL_BASED_SECTION&quot;</span><span class="s4">, </span><span class="s5">6</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_REL_BASED_REL&quot;</span><span class="s4">, </span><span class="s5">7</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_REL_BASED_MIPS_JMPADDR16&quot;</span><span class="s4">, </span><span class="s5">9</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_REL_BASED_IA64_IMM64&quot;</span><span class="s4">, </span><span class="s5">9</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_REL_BASED_DIR64&quot;</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_REL_BASED_HIGH3ADJ&quot;</span><span class="s4">, </span><span class="s5">11</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">RELOCATION_TYPE = two_way_dict(relocation_types)</span>


<span class="s1">dll_characteristics = [</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_LIBRARY_PROCESS_INIT&quot;</span><span class="s4">, </span><span class="s5">0x0001</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># reserved</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_LIBRARY_PROCESS_TERM&quot;</span><span class="s4">, </span><span class="s5">0x0002</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># reserved</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_LIBRARY_THREAD_INIT&quot;</span><span class="s4">, </span><span class="s5">0x0004</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># reserved</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_LIBRARY_THREAD_TERM&quot;</span><span class="s4">, </span><span class="s5">0x0008</span><span class="s1">)</span><span class="s4">,  </span><span class="s0"># reserved</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA&quot;</span><span class="s4">, </span><span class="s5">0x0020</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE&quot;</span><span class="s4">, </span><span class="s5">0x0040</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY&quot;</span><span class="s4">, </span><span class="s5">0x0080</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_NX_COMPAT&quot;</span><span class="s4">, </span><span class="s5">0x0100</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_NO_ISOLATION&quot;</span><span class="s4">, </span><span class="s5">0x0200</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_NO_SEH&quot;</span><span class="s4">, </span><span class="s5">0x0400</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_NO_BIND&quot;</span><span class="s4">, </span><span class="s5">0x0800</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_APPCONTAINER&quot;</span><span class="s4">, </span><span class="s5">0x1000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_WDM_DRIVER&quot;</span><span class="s4">, </span><span class="s5">0x2000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_GUARD_CF&quot;</span><span class="s4">, </span><span class="s5">0x4000</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE&quot;</span><span class="s4">, </span><span class="s5">0x8000</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">DLL_CHARACTERISTICS = two_way_dict(dll_characteristics)</span>

<span class="s1">FILE_ALIGNMENT_HARDCODED_VALUE = </span><span class="s5">0x200</span>


<span class="s0"># Unwind info-related enums</span>

<span class="s1">unwind_info_flags = [</span>
    <span class="s1">(</span><span class="s3">&quot;UNW_FLAG_EHANDLER&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;UNW_FLAG_UHANDLER&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;UNW_FLAG_CHAININFO&quot;</span><span class="s4">, </span><span class="s5">0x04</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">UNWIND_INFO_FLAGS = two_way_dict(unwind_info_flags)</span>

<span class="s1">registers = [</span>
    <span class="s1">(</span><span class="s3">&quot;RAX&quot;</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RCX&quot;</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RDX&quot;</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RBX&quot;</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RSP&quot;</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RBP&quot;</span><span class="s4">, </span><span class="s5">5</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RSI&quot;</span><span class="s4">, </span><span class="s5">6</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RDI&quot;</span><span class="s4">, </span><span class="s5">7</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;R8&quot;</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;R9&quot;</span><span class="s4">, </span><span class="s5">9</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;R10&quot;</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;R11&quot;</span><span class="s4">, </span><span class="s5">11</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;R12&quot;</span><span class="s4">, </span><span class="s5">12</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;R13&quot;</span><span class="s4">, </span><span class="s5">13</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;R14&quot;</span><span class="s4">, </span><span class="s5">14</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;R15&quot;</span><span class="s4">, </span><span class="s5">15</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">REGISTERS = two_way_dict(registers)</span>

<span class="s0"># enum _UNWIND_OP_CODES</span>
<span class="s1">UWOP_PUSH_NONVOL = </span><span class="s5">0</span>
<span class="s1">UWOP_ALLOC_LARGE = </span><span class="s5">1</span>
<span class="s1">UWOP_ALLOC_SMALL = </span><span class="s5">2</span>
<span class="s1">UWOP_SET_FPREG = </span><span class="s5">3</span>
<span class="s1">UWOP_SAVE_NONVOL = </span><span class="s5">4</span>
<span class="s1">UWOP_SAVE_NONVOL_FAR = </span><span class="s5">5</span>
<span class="s1">UWOP_EPILOG = </span><span class="s5">6</span>
<span class="s1">UWOP_SAVE_XMM128 = </span><span class="s5">8</span>
<span class="s1">UWOP_SAVE_XMM128_FAR = </span><span class="s5">9</span>
<span class="s1">UWOP_PUSH_MACHFRAME = </span><span class="s5">10</span>


<span class="s0"># Resource types</span>
<span class="s1">resource_type = [</span>
    <span class="s1">(</span><span class="s3">&quot;RT_CURSOR&quot;</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_BITMAP&quot;</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_ICON&quot;</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_MENU&quot;</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_DIALOG&quot;</span><span class="s4">, </span><span class="s5">5</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_STRING&quot;</span><span class="s4">, </span><span class="s5">6</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_FONTDIR&quot;</span><span class="s4">, </span><span class="s5">7</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_FONT&quot;</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_ACCELERATOR&quot;</span><span class="s4">, </span><span class="s5">9</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_RCDATA&quot;</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_MESSAGETABLE&quot;</span><span class="s4">, </span><span class="s5">11</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_GROUP_CURSOR&quot;</span><span class="s4">, </span><span class="s5">12</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_GROUP_ICON&quot;</span><span class="s4">, </span><span class="s5">14</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_VERSION&quot;</span><span class="s4">, </span><span class="s5">16</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_DLGINCLUDE&quot;</span><span class="s4">, </span><span class="s5">17</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_PLUGPLAY&quot;</span><span class="s4">, </span><span class="s5">19</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_VXD&quot;</span><span class="s4">, </span><span class="s5">20</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_ANICURSOR&quot;</span><span class="s4">, </span><span class="s5">21</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_ANIICON&quot;</span><span class="s4">, </span><span class="s5">22</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_HTML&quot;</span><span class="s4">, </span><span class="s5">23</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;RT_MANIFEST&quot;</span><span class="s4">, </span><span class="s5">24</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">RESOURCE_TYPE = two_way_dict(resource_type)</span>


<span class="s0"># Language definitions</span>
<span class="s1">lang = [</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_NEUTRAL&quot;</span><span class="s4">, </span><span class="s5">0x00</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_INVARIANT&quot;</span><span class="s4">, </span><span class="s5">0x7F</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_AFRIKAANS&quot;</span><span class="s4">, </span><span class="s5">0x36</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_ALBANIAN&quot;</span><span class="s4">, </span><span class="s5">0x1C</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_ARABIC&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_ARMENIAN&quot;</span><span class="s4">, </span><span class="s5">0x2B</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_ASSAMESE&quot;</span><span class="s4">, </span><span class="s5">0x4D</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_AZERI&quot;</span><span class="s4">, </span><span class="s5">0x2C</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_BASQUE&quot;</span><span class="s4">, </span><span class="s5">0x2D</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_BELARUSIAN&quot;</span><span class="s4">, </span><span class="s5">0x23</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_BENGALI&quot;</span><span class="s4">, </span><span class="s5">0x45</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_BULGARIAN&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_CATALAN&quot;</span><span class="s4">, </span><span class="s5">0x03</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_CHINESE&quot;</span><span class="s4">, </span><span class="s5">0x04</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_CROATIAN&quot;</span><span class="s4">, </span><span class="s5">0x1A</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_CZECH&quot;</span><span class="s4">, </span><span class="s5">0x05</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_DANISH&quot;</span><span class="s4">, </span><span class="s5">0x06</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_DIVEHI&quot;</span><span class="s4">, </span><span class="s5">0x65</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_DUTCH&quot;</span><span class="s4">, </span><span class="s5">0x13</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_ENGLISH&quot;</span><span class="s4">, </span><span class="s5">0x09</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_ESTONIAN&quot;</span><span class="s4">, </span><span class="s5">0x25</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_FAEROESE&quot;</span><span class="s4">, </span><span class="s5">0x38</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_FARSI&quot;</span><span class="s4">, </span><span class="s5">0x29</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_FINNISH&quot;</span><span class="s4">, </span><span class="s5">0x0B</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_FRENCH&quot;</span><span class="s4">, </span><span class="s5">0x0C</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_GALICIAN&quot;</span><span class="s4">, </span><span class="s5">0x56</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_GEORGIAN&quot;</span><span class="s4">, </span><span class="s5">0x37</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_GERMAN&quot;</span><span class="s4">, </span><span class="s5">0x07</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_GREEK&quot;</span><span class="s4">, </span><span class="s5">0x08</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_GUJARATI&quot;</span><span class="s4">, </span><span class="s5">0x47</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_HEBREW&quot;</span><span class="s4">, </span><span class="s5">0x0D</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_HINDI&quot;</span><span class="s4">, </span><span class="s5">0x39</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_HUNGARIAN&quot;</span><span class="s4">, </span><span class="s5">0x0E</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_ICELANDIC&quot;</span><span class="s4">, </span><span class="s5">0x0F</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_INDONESIAN&quot;</span><span class="s4">, </span><span class="s5">0x21</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_ITALIAN&quot;</span><span class="s4">, </span><span class="s5">0x10</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_JAPANESE&quot;</span><span class="s4">, </span><span class="s5">0x11</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_KANNADA&quot;</span><span class="s4">, </span><span class="s5">0x4B</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_KASHMIRI&quot;</span><span class="s4">, </span><span class="s5">0x60</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_KAZAK&quot;</span><span class="s4">, </span><span class="s5">0x3F</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_KONKANI&quot;</span><span class="s4">, </span><span class="s5">0x57</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_KOREAN&quot;</span><span class="s4">, </span><span class="s5">0x12</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_KYRGYZ&quot;</span><span class="s4">, </span><span class="s5">0x40</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_LATVIAN&quot;</span><span class="s4">, </span><span class="s5">0x26</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_LITHUANIAN&quot;</span><span class="s4">, </span><span class="s5">0x27</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_MACEDONIAN&quot;</span><span class="s4">, </span><span class="s5">0x2F</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_MALAY&quot;</span><span class="s4">, </span><span class="s5">0x3E</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_MALAYALAM&quot;</span><span class="s4">, </span><span class="s5">0x4C</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_MANIPURI&quot;</span><span class="s4">, </span><span class="s5">0x58</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_MARATHI&quot;</span><span class="s4">, </span><span class="s5">0x4E</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_MONGOLIAN&quot;</span><span class="s4">, </span><span class="s5">0x50</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_NEPALI&quot;</span><span class="s4">, </span><span class="s5">0x61</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_NORWEGIAN&quot;</span><span class="s4">, </span><span class="s5">0x14</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_ORIYA&quot;</span><span class="s4">, </span><span class="s5">0x48</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_POLISH&quot;</span><span class="s4">, </span><span class="s5">0x15</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_PORTUGUESE&quot;</span><span class="s4">, </span><span class="s5">0x16</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_PUNJABI&quot;</span><span class="s4">, </span><span class="s5">0x46</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_ROMANIAN&quot;</span><span class="s4">, </span><span class="s5">0x18</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_RUSSIAN&quot;</span><span class="s4">, </span><span class="s5">0x19</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_SANSKRIT&quot;</span><span class="s4">, </span><span class="s5">0x4F</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_SERBIAN&quot;</span><span class="s4">, </span><span class="s5">0x1A</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_SINDHI&quot;</span><span class="s4">, </span><span class="s5">0x59</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_SLOVAK&quot;</span><span class="s4">, </span><span class="s5">0x1B</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_SLOVENIAN&quot;</span><span class="s4">, </span><span class="s5">0x24</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_SPANISH&quot;</span><span class="s4">, </span><span class="s5">0x0A</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_SWAHILI&quot;</span><span class="s4">, </span><span class="s5">0x41</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_SWEDISH&quot;</span><span class="s4">, </span><span class="s5">0x1D</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_SYRIAC&quot;</span><span class="s4">, </span><span class="s5">0x5A</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_TAMIL&quot;</span><span class="s4">, </span><span class="s5">0x49</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_TATAR&quot;</span><span class="s4">, </span><span class="s5">0x44</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_TELUGU&quot;</span><span class="s4">, </span><span class="s5">0x4A</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_THAI&quot;</span><span class="s4">, </span><span class="s5">0x1E</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_TURKISH&quot;</span><span class="s4">, </span><span class="s5">0x1F</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_UKRAINIAN&quot;</span><span class="s4">, </span><span class="s5">0x22</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_URDU&quot;</span><span class="s4">, </span><span class="s5">0x20</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_UZBEK&quot;</span><span class="s4">, </span><span class="s5">0x43</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_VIETNAMESE&quot;</span><span class="s4">, </span><span class="s5">0x2A</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_GAELIC&quot;</span><span class="s4">, </span><span class="s5">0x3C</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_MALTESE&quot;</span><span class="s4">, </span><span class="s5">0x3A</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_MAORI&quot;</span><span class="s4">, </span><span class="s5">0x28</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_RHAETO_ROMANCE&quot;</span><span class="s4">, </span><span class="s5">0x17</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_SAAMI&quot;</span><span class="s4">, </span><span class="s5">0x3B</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_SORBIAN&quot;</span><span class="s4">, </span><span class="s5">0x2E</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_SUTU&quot;</span><span class="s4">, </span><span class="s5">0x30</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_TSONGA&quot;</span><span class="s4">, </span><span class="s5">0x31</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_TSWANA&quot;</span><span class="s4">, </span><span class="s5">0x32</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_VENDA&quot;</span><span class="s4">, </span><span class="s5">0x33</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_XHOSA&quot;</span><span class="s4">, </span><span class="s5">0x34</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_ZULU&quot;</span><span class="s4">, </span><span class="s5">0x35</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_ESPERANTO&quot;</span><span class="s4">, </span><span class="s5">0x8F</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_WALON&quot;</span><span class="s4">, </span><span class="s5">0x90</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_CORNISH&quot;</span><span class="s4">, </span><span class="s5">0x91</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_WELSH&quot;</span><span class="s4">, </span><span class="s5">0x92</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;LANG_BRETON&quot;</span><span class="s4">, </span><span class="s5">0x93</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">LANG = two_way_dict(lang)</span>


<span class="s0"># Sublanguage definitions</span>
<span class="s1">sublang = [</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_NEUTRAL&quot;</span><span class="s4">, </span><span class="s5">0x00</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_DEFAULT&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SYS_DEFAULT&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_SAUDI_ARABIA&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_IRAQ&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_EGYPT&quot;</span><span class="s4">, </span><span class="s5">0x03</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_LIBYA&quot;</span><span class="s4">, </span><span class="s5">0x04</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_ALGERIA&quot;</span><span class="s4">, </span><span class="s5">0x05</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_MOROCCO&quot;</span><span class="s4">, </span><span class="s5">0x06</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_TUNISIA&quot;</span><span class="s4">, </span><span class="s5">0x07</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_OMAN&quot;</span><span class="s4">, </span><span class="s5">0x08</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_YEMEN&quot;</span><span class="s4">, </span><span class="s5">0x09</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_SYRIA&quot;</span><span class="s4">, </span><span class="s5">0x0A</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_JORDAN&quot;</span><span class="s4">, </span><span class="s5">0x0B</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_LEBANON&quot;</span><span class="s4">, </span><span class="s5">0x0C</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_KUWAIT&quot;</span><span class="s4">, </span><span class="s5">0x0D</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_UAE&quot;</span><span class="s4">, </span><span class="s5">0x0E</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_BAHRAIN&quot;</span><span class="s4">, </span><span class="s5">0x0F</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ARABIC_QATAR&quot;</span><span class="s4">, </span><span class="s5">0x10</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_AZERI_LATIN&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_AZERI_CYRILLIC&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_CHINESE_TRADITIONAL&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_CHINESE_SIMPLIFIED&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_CHINESE_HONGKONG&quot;</span><span class="s4">, </span><span class="s5">0x03</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_CHINESE_SINGAPORE&quot;</span><span class="s4">, </span><span class="s5">0x04</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_CHINESE_MACAU&quot;</span><span class="s4">, </span><span class="s5">0x05</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_DUTCH&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_DUTCH_BELGIAN&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_US&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_UK&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_AUS&quot;</span><span class="s4">, </span><span class="s5">0x03</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_CAN&quot;</span><span class="s4">, </span><span class="s5">0x04</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_NZ&quot;</span><span class="s4">, </span><span class="s5">0x05</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_EIRE&quot;</span><span class="s4">, </span><span class="s5">0x06</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_SOUTH_AFRICA&quot;</span><span class="s4">, </span><span class="s5">0x07</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_JAMAICA&quot;</span><span class="s4">, </span><span class="s5">0x08</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_CARIBBEAN&quot;</span><span class="s4">, </span><span class="s5">0x09</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_BELIZE&quot;</span><span class="s4">, </span><span class="s5">0x0A</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_TRINIDAD&quot;</span><span class="s4">, </span><span class="s5">0x0B</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_ZIMBABWE&quot;</span><span class="s4">, </span><span class="s5">0x0C</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ENGLISH_PHILIPPINES&quot;</span><span class="s4">, </span><span class="s5">0x0D</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_FRENCH&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_FRENCH_BELGIAN&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_FRENCH_CANADIAN&quot;</span><span class="s4">, </span><span class="s5">0x03</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_FRENCH_SWISS&quot;</span><span class="s4">, </span><span class="s5">0x04</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_FRENCH_LUXEMBOURG&quot;</span><span class="s4">, </span><span class="s5">0x05</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_FRENCH_MONACO&quot;</span><span class="s4">, </span><span class="s5">0x06</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_GERMAN&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_GERMAN_SWISS&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_GERMAN_AUSTRIAN&quot;</span><span class="s4">, </span><span class="s5">0x03</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_GERMAN_LUXEMBOURG&quot;</span><span class="s4">, </span><span class="s5">0x04</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_GERMAN_LIECHTENSTEIN&quot;</span><span class="s4">, </span><span class="s5">0x05</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ITALIAN&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ITALIAN_SWISS&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_KASHMIRI_SASIA&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_KASHMIRI_INDIA&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_KOREAN&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_LITHUANIAN&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_MALAY_MALAYSIA&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_MALAY_BRUNEI_DARUSSALAM&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_NEPALI_INDIA&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_NORWEGIAN_BOKMAL&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_NORWEGIAN_NYNORSK&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_PORTUGUESE&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_PORTUGUESE_BRAZILIAN&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SERBIAN_LATIN&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SERBIAN_CYRILLIC&quot;</span><span class="s4">, </span><span class="s5">0x03</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_MEXICAN&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_MODERN&quot;</span><span class="s4">, </span><span class="s5">0x03</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_GUATEMALA&quot;</span><span class="s4">, </span><span class="s5">0x04</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_COSTA_RICA&quot;</span><span class="s4">, </span><span class="s5">0x05</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_PANAMA&quot;</span><span class="s4">, </span><span class="s5">0x06</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_DOMINICAN_REPUBLIC&quot;</span><span class="s4">, </span><span class="s5">0x07</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_VENEZUELA&quot;</span><span class="s4">, </span><span class="s5">0x08</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_COLOMBIA&quot;</span><span class="s4">, </span><span class="s5">0x09</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_PERU&quot;</span><span class="s4">, </span><span class="s5">0x0A</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_ARGENTINA&quot;</span><span class="s4">, </span><span class="s5">0x0B</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_ECUADOR&quot;</span><span class="s4">, </span><span class="s5">0x0C</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_CHILE&quot;</span><span class="s4">, </span><span class="s5">0x0D</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_URUGUAY&quot;</span><span class="s4">, </span><span class="s5">0x0E</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_PARAGUAY&quot;</span><span class="s4">, </span><span class="s5">0x0F</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_BOLIVIA&quot;</span><span class="s4">, </span><span class="s5">0x10</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_EL_SALVADOR&quot;</span><span class="s4">, </span><span class="s5">0x11</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_HONDURAS&quot;</span><span class="s4">, </span><span class="s5">0x12</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_NICARAGUA&quot;</span><span class="s4">, </span><span class="s5">0x13</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SPANISH_PUERTO_RICO&quot;</span><span class="s4">, </span><span class="s5">0x14</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SWEDISH&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_SWEDISH_FINLAND&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_URDU_PAKISTAN&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_URDU_INDIA&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_UZBEK_LATIN&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_UZBEK_CYRILLIC&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_DUTCH_SURINAM&quot;</span><span class="s4">, </span><span class="s5">0x03</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ROMANIAN&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_ROMANIAN_MOLDAVIA&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_RUSSIAN&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_RUSSIAN_MOLDAVIA&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_CROATIAN&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_LITHUANIAN_CLASSIC&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_GAELIC&quot;</span><span class="s4">, </span><span class="s5">0x01</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_GAELIC_SCOTTISH&quot;</span><span class="s4">, </span><span class="s5">0x02</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUBLANG_GAELIC_MANX&quot;</span><span class="s4">, </span><span class="s5">0x03</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">]</span>

<span class="s1">SUBLANG = two_way_dict(sublang)</span>

<span class="s0"># Initialize the dictionary with all the name-&gt;value pairs</span>
<span class="s1">SUBLANG = dict(sublang)</span>
<span class="s0"># Now add all the value-&gt;name information, handling duplicates appropriately</span>
<span class="s4">for </span><span class="s1">sublang_name</span><span class="s4">, </span><span class="s1">sublang_value </span><span class="s4">in </span><span class="s1">sublang:</span>
    <span class="s4">if </span><span class="s1">sublang_value </span><span class="s4">in </span><span class="s1">SUBLANG:</span>
        <span class="s1">SUBLANG[sublang_value].append(sublang_name)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">SUBLANG[sublang_value] = [sublang_name]</span>

<span class="s0"># Resolve a sublang name given the main lang name</span>
<span class="s0">#</span>
<span class="s4">def </span><span class="s1">get_sublang_name_for_lang(lang_value</span><span class="s4">, </span><span class="s1">sublang_value):</span>
    <span class="s1">lang_name = LANG.get(lang_value</span><span class="s4">, </span><span class="s3">&quot;*unknown*&quot;</span><span class="s1">)</span>
    <span class="s4">for </span><span class="s1">sublang_name </span><span class="s4">in </span><span class="s1">SUBLANG.get(sublang_value</span><span class="s4">, </span><span class="s1">[]):</span>
        <span class="s0"># if the main language is a substring of sublang's name, then</span>
        <span class="s0"># return that</span>
        <span class="s4">if </span><span class="s1">lang_name </span><span class="s4">in </span><span class="s1">sublang_name:</span>
            <span class="s4">return </span><span class="s1">sublang_name</span>
    <span class="s0"># otherwise return the first sublang name</span>
    <span class="s4">return </span><span class="s1">SUBLANG.get(sublang_value</span><span class="s4">, </span><span class="s1">[</span><span class="s3">&quot;*unknown*&quot;</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s0"># Ange Albertini's code to process resources' strings</span>
<span class="s0">#</span>
<span class="s4">def </span><span class="s1">parse_strings(data</span><span class="s4">, </span><span class="s1">counter</span><span class="s4">, </span><span class="s1">l):</span>
    <span class="s1">i = </span><span class="s5">0</span>
    <span class="s1">error_count = </span><span class="s5">0</span>
    <span class="s4">while </span><span class="s1">i &lt; len(data):</span>

        <span class="s1">data_slice = data[i : i + </span><span class="s5">2</span><span class="s1">]</span>
        <span class="s4">if </span><span class="s1">len(data_slice) &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4">break</span>

        <span class="s1">len_ = struct.unpack(</span><span class="s3">&quot;&lt;h&quot;</span><span class="s4">, </span><span class="s1">data_slice)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">i += </span><span class="s5">2</span>
        <span class="s4">if </span><span class="s1">len_ != </span><span class="s5">0 </span><span class="s4">and </span><span class="s5">0 </span><span class="s1">&lt;= len_ * </span><span class="s5">2 </span><span class="s1">&lt;= len(data):</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">l[counter] = b(data[i : i + len_ * </span><span class="s5">2</span><span class="s1">]).decode(</span><span class="s3">&quot;utf-16le&quot;</span><span class="s1">)</span>
            <span class="s4">except </span><span class="s1">UnicodeDecodeError:</span>
                <span class="s1">error_count += </span><span class="s5">1</span>
                <span class="s4">pass</span>
            <span class="s4">if </span><span class="s1">error_count &gt;= </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s4">break</span>
            <span class="s1">i += len_ * </span><span class="s5">2</span>
        <span class="s1">counter += </span><span class="s5">1</span>


<span class="s4">def </span><span class="s1">retrieve_flags(flag_dict</span><span class="s4">, </span><span class="s1">flag_filter):</span>
    <span class="s2">&quot;&quot;&quot;Read the flags from a dictionary and return them in a usable form. 
 
    Will return a list of (flag, value) for all flags in &quot;flag_dict&quot; 
    matching the filter &quot;flag_filter&quot;. 
    &quot;&quot;&quot;</span>

    <span class="s4">return </span><span class="s1">[</span>
        <span class="s1">(flag</span><span class="s4">, </span><span class="s1">flag_dict[flag])</span>
        <span class="s4">for </span><span class="s1">flag </span><span class="s4">in </span><span class="s1">flag_dict.keys()</span>
        <span class="s4">if </span><span class="s1">isinstance(flag</span><span class="s4">, </span><span class="s1">(str</span><span class="s4">, </span><span class="s1">bytes)) </span><span class="s4">and </span><span class="s1">flag.startswith(flag_filter)</span>
    <span class="s1">]</span>


<span class="s4">def </span><span class="s1">set_flags(obj</span><span class="s4">, </span><span class="s1">flag_field</span><span class="s4">, </span><span class="s1">flags):</span>
    <span class="s2">&quot;&quot;&quot;Will process the flags and set attributes in the object accordingly. 
 
    The object &quot;obj&quot; will gain attributes named after the flags provided in 
    &quot;flags&quot; and valued True/False, matching the results of applying each 
    flag value from &quot;flags&quot; to flag_field. 
    &quot;&quot;&quot;</span>

    <span class="s4">for </span><span class="s1">flag</span><span class="s4">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">flags:</span>
        <span class="s4">if </span><span class="s1">value &amp; flag_field:</span>
            <span class="s1">obj.__dict__[flag] = </span><span class="s4">True</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">obj.__dict__[flag] = </span><span class="s4">False</span>


<span class="s4">def </span><span class="s1">power_of_two(val):</span>
    <span class="s4">return </span><span class="s1">val != </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">(val &amp; (val - </span><span class="s5">1</span><span class="s1">)) == </span><span class="s5">0</span>


<span class="s4">def </span><span class="s1">b(x):</span>
    <span class="s4">if </span><span class="s1">isinstance(x</span><span class="s4">, </span><span class="s1">bytes):</span>
        <span class="s4">return </span><span class="s1">x</span>
    <span class="s4">elif </span><span class="s1">isinstance(x</span><span class="s4">, </span><span class="s1">bytearray):</span>
        <span class="s4">return </span><span class="s1">bytes(x)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">codecs.encode(x</span><span class="s4">, </span><span class="s3">&quot;cp1252&quot;</span><span class="s1">)</span>


<span class="s4">class </span><span class="s1">AddressSet(set):</span>
    <span class="s4">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.min = </span><span class="s4">None</span>
        <span class="s1">self.max = </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">add(self</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s1">super().add(value)</span>
        <span class="s1">self.min = value </span><span class="s4">if </span><span class="s1">self.min </span><span class="s4">is None else </span><span class="s1">min(self.min</span><span class="s4">, </span><span class="s1">value)</span>
        <span class="s1">self.max = value </span><span class="s4">if </span><span class="s1">self.max </span><span class="s4">is None else </span><span class="s1">max(self.max</span><span class="s4">, </span><span class="s1">value)</span>

    <span class="s4">def </span><span class="s1">diff(self):</span>
        <span class="s4">return </span><span class="s5">0 </span><span class="s4">if </span><span class="s1">self.min </span><span class="s4">is None or </span><span class="s1">self.max </span><span class="s4">is None else </span><span class="s1">self.max - self.min</span>


<span class="s4">class </span><span class="s1">UnicodeStringWrapperPostProcessor:</span>
    <span class="s2">&quot;&quot;&quot;This class attempts to help the process of identifying strings 
    that might be plain Unicode or Pascal. A list of strings will be 
    wrapped on it with the hope the overlappings will help make the 
    decision about their type.&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">pe</span><span class="s4">, </span><span class="s1">rva_ptr):</span>
        <span class="s1">self.pe = pe</span>
        <span class="s1">self.rva_ptr = rva_ptr</span>
        <span class="s1">self.string = </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">get_rva(self):</span>
        <span class="s2">&quot;&quot;&quot;Get the RVA of the string.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.rva_ptr</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the escaped UTF-8 representation of the string.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">decode(self</span><span class="s4">, </span><span class="s1">*args):</span>
        <span class="s4">if not </span><span class="s1">self.string:</span>
            <span class="s4">return </span><span class="s3">&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.string.decode(*args)</span>

    <span class="s4">def </span><span class="s1">invalidate(self):</span>
        <span class="s2">&quot;&quot;&quot;Make this instance None, to express it's no known string type.&quot;&quot;&quot;</span>
        <span class="s1">self = </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">render_pascal_16(self):</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">self.string = self.pe.get_string_u_at_rva(</span>
                <span class="s1">self.rva_ptr + </span><span class="s5">2</span><span class="s4">, </span><span class="s1">max_length=self.get_pascal_16_length()</span>
            <span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.pe.get_warnings().append(</span>
                <span class="s3">&quot;Failed rendering pascal string, &quot;</span>
                <span class="s3">&quot;attempting to read from RVA 0x{0:x}&quot;</span><span class="s1">.format(self.rva_ptr + </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">get_pascal_16_length(self):</span>
        <span class="s4">return </span><span class="s1">self.__get_word_value_at_rva(self.rva_ptr)</span>

    <span class="s4">def </span><span class="s1">__get_word_value_at_rva(self</span><span class="s4">, </span><span class="s1">rva):</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">data = self.pe.get_data(rva</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s4">return False</span>

        <span class="s4">if </span><span class="s1">len(data) &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4">return False</span>

        <span class="s4">return </span><span class="s1">struct.unpack(</span><span class="s3">&quot;&lt;H&quot;</span><span class="s4">, </span><span class="s1">data)[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s4">def </span><span class="s1">ask_unicode_16(self</span><span class="s4">, </span><span class="s1">next_rva_ptr):</span>
        <span class="s2">&quot;&quot;&quot;The next RVA is taken to be the one immediately following this one. 
 
        Such RVA could indicate the natural end of the string and will be checked 
        to see if there's a Unicode NULL character there. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self.__get_word_value_at_rva(next_rva_ptr - </span><span class="s5">2</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">self.length = next_rva_ptr - self.rva_ptr</span>
            <span class="s4">return True</span>

        <span class="s4">return False</span>

    <span class="s4">def </span><span class="s1">render_unicode_16(self):</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">self.string = self.pe.get_string_u_at_rva(self.rva_ptr)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.pe.get_warnings().append(</span>
                <span class="s3">&quot;Failed rendering unicode string, &quot;</span>
                <span class="s3">&quot;attempting to read from RVA 0x{0:x}&quot;</span><span class="s1">.format(self.rva_ptr)</span>
            <span class="s1">)</span>


<span class="s4">class </span><span class="s1">PEFormatError(Exception):</span>
    <span class="s2">&quot;&quot;&quot;Generic PE format error exception.&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">value):</span>
        <span class="s1">self.value = value</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s1">repr(self.value)</span>


<span class="s4">class </span><span class="s1">Dump:</span>
    <span class="s2">&quot;&quot;&quot;Convenience class for dumping the PE information.&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.text = []</span>

    <span class="s4">def </span><span class="s1">add_lines(self</span><span class="s4">, </span><span class="s1">txt</span><span class="s4">, </span><span class="s1">indent=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Adds a list of lines. 
 
        The list can be indented with the optional argument 'indent'. 
        &quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">line </span><span class="s4">in </span><span class="s1">txt:</span>
            <span class="s1">self.add_line(line</span><span class="s4">, </span><span class="s1">indent)</span>

    <span class="s4">def </span><span class="s1">add_line(self</span><span class="s4">, </span><span class="s1">txt</span><span class="s4">, </span><span class="s1">indent=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Adds a line. 
 
        The line can be indented with the optional argument 'indent'. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.add(txt + </span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s4">, </span><span class="s1">indent)</span>

    <span class="s4">def </span><span class="s1">add(self</span><span class="s4">, </span><span class="s1">txt</span><span class="s4">, </span><span class="s1">indent=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Adds some text, no newline will be appended. 
 
        The text can be indented with the optional argument 'indent'. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.text.append(</span><span class="s3">&quot;{0}{1}&quot;</span><span class="s1">.format(</span><span class="s3">&quot; &quot; </span><span class="s1">* indent</span><span class="s4">, </span><span class="s1">txt))</span>

    <span class="s4">def </span><span class="s1">add_header(self</span><span class="s4">, </span><span class="s1">txt):</span>
        <span class="s2">&quot;&quot;&quot;Adds a header element.&quot;&quot;&quot;</span>
        <span class="s1">self.add_line(</span><span class="s3">&quot;{0}{1}{0}</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s1">.format(</span><span class="s3">&quot;-&quot; </span><span class="s1">* </span><span class="s5">10</span><span class="s4">, </span><span class="s1">txt))</span>

    <span class="s4">def </span><span class="s1">add_newline(self):</span>
        <span class="s2">&quot;&quot;&quot;Adds a newline.&quot;&quot;&quot;</span>
        <span class="s1">self.text.append(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">get_text(self):</span>
        <span class="s2">&quot;&quot;&quot;Get the text in its current state.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s3">&quot;&quot;</span><span class="s1">.join(</span><span class="s3">&quot;{0}&quot;</span><span class="s1">.format(b) </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">self.text)</span>


<span class="s1">STRUCT_SIZEOF_TYPES = {</span>
    <span class="s3">&quot;x&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s4">,</span>
    <span class="s3">&quot;c&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s4">,</span>
    <span class="s3">&quot;b&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s4">,</span>
    <span class="s3">&quot;B&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s4">,</span>
    <span class="s3">&quot;h&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s4">,</span>
    <span class="s3">&quot;H&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s4">,</span>
    <span class="s3">&quot;i&quot;</span><span class="s1">: </span><span class="s5">4</span><span class="s4">,</span>
    <span class="s3">&quot;I&quot;</span><span class="s1">: </span><span class="s5">4</span><span class="s4">,</span>
    <span class="s3">&quot;l&quot;</span><span class="s1">: </span><span class="s5">4</span><span class="s4">,</span>
    <span class="s3">&quot;L&quot;</span><span class="s1">: </span><span class="s5">4</span><span class="s4">,</span>
    <span class="s3">&quot;f&quot;</span><span class="s1">: </span><span class="s5">4</span><span class="s4">,</span>
    <span class="s3">&quot;q&quot;</span><span class="s1">: </span><span class="s5">8</span><span class="s4">,</span>
    <span class="s3">&quot;Q&quot;</span><span class="s1">: </span><span class="s5">8</span><span class="s4">,</span>
    <span class="s3">&quot;d&quot;</span><span class="s1">: </span><span class="s5">8</span><span class="s4">,</span>
    <span class="s3">&quot;s&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s4">,</span>
<span class="s1">}</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s5">2048</span><span class="s1">)</span>
<span class="s4">def </span><span class="s1">sizeof_type(t):</span>
    <span class="s1">count = </span><span class="s5">1</span>
    <span class="s1">_t = t</span>
    <span class="s4">if </span><span class="s1">t[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">in </span><span class="s1">string.digits:</span>
        <span class="s0"># extract the count</span>
        <span class="s1">count = int(</span><span class="s3">&quot;&quot;</span><span class="s1">.join([d </span><span class="s4">for </span><span class="s1">d </span><span class="s4">in </span><span class="s1">t </span><span class="s4">if </span><span class="s1">d </span><span class="s4">in </span><span class="s1">string.digits]))</span>
        <span class="s1">_t = </span><span class="s3">&quot;&quot;</span><span class="s1">.join([d </span><span class="s4">for </span><span class="s1">d </span><span class="s4">in </span><span class="s1">t </span><span class="s4">if </span><span class="s1">d </span><span class="s4">not in </span><span class="s1">string.digits])</span>
    <span class="s4">return </span><span class="s1">STRUCT_SIZEOF_TYPES[_t] * count</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s5">2048</span><span class="s4">, </span><span class="s1">copy=</span><span class="s4">True</span><span class="s1">)</span>
<span class="s4">def </span><span class="s1">set_format(format):</span>

    <span class="s1">__format_str__ = </span><span class="s3">&quot;&lt;&quot;</span>
    <span class="s1">__unpacked_data_elms__ = []</span>
    <span class="s1">__field_offsets__ = {}</span>
    <span class="s1">__keys__ = []</span>
    <span class="s1">__format_length__ = </span><span class="s5">0</span>

    <span class="s1">offset = </span><span class="s5">0</span>
    <span class="s4">for </span><span class="s1">elm </span><span class="s4">in </span><span class="s1">format:</span>
        <span class="s4">if </span><span class="s3">&quot;,&quot; </span><span class="s4">in </span><span class="s1">elm:</span>
            <span class="s1">elm_type</span><span class="s4">, </span><span class="s1">elm_name = elm.split(</span><span class="s3">&quot;,&quot;</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">__format_str__ += elm_type</span>
            <span class="s1">__unpacked_data_elms__.append(</span><span class="s4">None</span><span class="s1">)</span>

            <span class="s1">elm_names = elm_name.split(</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
            <span class="s1">names = []</span>
            <span class="s4">for </span><span class="s1">elm_name </span><span class="s4">in </span><span class="s1">elm_names:</span>
                <span class="s4">if </span><span class="s1">elm_name </span><span class="s4">in </span><span class="s1">__keys__:</span>
                    <span class="s1">search_list = [x[: len(elm_name)] </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">__keys__]</span>
                    <span class="s1">occ_count = search_list.count(elm_name)</span>
                    <span class="s1">elm_name = </span><span class="s3">&quot;{0}_{1:d}&quot;</span><span class="s1">.format(elm_name</span><span class="s4">, </span><span class="s1">occ_count)</span>
                <span class="s1">names.append(elm_name)</span>
                <span class="s1">__field_offsets__[elm_name] = offset</span>

            <span class="s1">offset += sizeof_type(elm_type)</span>

            <span class="s0"># Some PE header structures have unions on them, so a certain</span>
            <span class="s0"># value might have different names, so each key has a list of</span>
            <span class="s0"># all the possible members referring to the data.</span>
            <span class="s1">__keys__.append(names)</span>

    <span class="s1">__format_length__ = struct.calcsize(__format_str__)</span>

    <span class="s4">return </span><span class="s1">(</span>
        <span class="s1">__format_str__</span><span class="s4">,</span>
        <span class="s1">__unpacked_data_elms__</span><span class="s4">,</span>
        <span class="s1">__field_offsets__</span><span class="s4">,</span>
        <span class="s1">__keys__</span><span class="s4">,</span>
        <span class="s1">__format_length__</span><span class="s4">,</span>
    <span class="s1">)</span>


<span class="s4">class </span><span class="s1">Structure:</span>
    <span class="s2">&quot;&quot;&quot;Prepare structure object to extract members from data. 
 
    Format is a list containing definitions for the elements 
    of the structure. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">format</span><span class="s4">, </span><span class="s1">name=</span><span class="s4">None, </span><span class="s1">file_offset=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s0"># Format is forced little endian, for big endian non Intel platforms</span>
        <span class="s1">self.__format_str__ = </span><span class="s3">&quot;&lt;&quot;</span>
        <span class="s1">self.__keys__ = []</span>
        <span class="s1">self.__format_length__ = </span><span class="s5">0</span>
        <span class="s1">self.__field_offsets__ = {}</span>
        <span class="s1">self.__unpacked_data_elms__ = []</span>

        <span class="s1">d = format[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0"># need a tuple to be hashable in set_format using lru cache</span>
        <span class="s4">if not </span><span class="s1">isinstance(d</span><span class="s4">, </span><span class="s1">tuple):</span>
            <span class="s1">d = tuple(d)</span>

        <span class="s1">(</span>
            <span class="s1">self.__format_str__</span><span class="s4">,</span>
            <span class="s1">self.__unpacked_data_elms__</span><span class="s4">,</span>
            <span class="s1">self.__field_offsets__</span><span class="s4">,</span>
            <span class="s1">self.__keys__</span><span class="s4">,</span>
            <span class="s1">self.__format_length__</span><span class="s4">,</span>
        <span class="s1">) = set_format(d)</span>

        <span class="s1">self.__all_zeroes__ = </span><span class="s4">False</span>
        <span class="s1">self.__file_offset__ = file_offset</span>
        <span class="s4">if </span><span class="s1">name:</span>
            <span class="s1">self.name = name</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.name = format[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s4">def </span><span class="s1">__get_format__(self) -&gt; str:</span>
        <span class="s4">return </span><span class="s1">self.__format_str__</span>

    <span class="s4">def </span><span class="s1">get_field_absolute_offset(self</span><span class="s4">, </span><span class="s1">field_name):</span>
        <span class="s2">&quot;&quot;&quot;Return the offset within the field for the requested field in the structure.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.__file_offset__ + self.__field_offsets__[field_name]</span>

    <span class="s4">def </span><span class="s1">get_field_relative_offset(self</span><span class="s4">, </span><span class="s1">field_name):</span>
        <span class="s2">&quot;&quot;&quot;Return the offset within the structure for the requested field.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.__field_offsets__[field_name]</span>

    <span class="s4">def </span><span class="s1">get_file_offset(self):</span>
        <span class="s4">return </span><span class="s1">self.__file_offset__</span>

    <span class="s4">def </span><span class="s1">set_file_offset(self</span><span class="s4">, </span><span class="s1">offset):</span>
        <span class="s1">self.__file_offset__ = offset</span>

    <span class="s4">def </span><span class="s1">all_zeroes(self):</span>
        <span class="s2">&quot;&quot;&quot;Returns true is the unpacked data is all zeros.&quot;&quot;&quot;</span>

        <span class="s4">return </span><span class="s1">self.__all_zeroes__</span>

    <span class="s4">def </span><span class="s1">sizeof(self):</span>
        <span class="s2">&quot;&quot;&quot;Return size of the structure.&quot;&quot;&quot;</span>

        <span class="s4">return </span><span class="s1">self.__format_length__</span>

    <span class="s4">def </span><span class="s1">__unpack__(self</span><span class="s4">, </span><span class="s1">data):</span>

        <span class="s1">data = b(data)</span>

        <span class="s4">if </span><span class="s1">len(data) &gt; self.__format_length__:</span>
            <span class="s1">data = data[: self.__format_length__]</span>

        <span class="s0"># OC Patch:</span>
        <span class="s0"># Some malware have incorrect header lengths.</span>
        <span class="s0"># Fail gracefully if this occurs</span>
        <span class="s0"># Buggy malware: a29b0118af8b7408444df81701ad5a7f</span>
        <span class="s0">#</span>
        <span class="s4">elif </span><span class="s1">len(data) &lt; self.__format_length__:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;Data length less than expected header length.&quot;</span><span class="s1">)</span>

        <span class="s4">if </span><span class="s1">count_zeroes(data) == len(data):</span>
            <span class="s1">self.__all_zeroes__ = </span><span class="s4">True</span>

        <span class="s1">self.__unpacked_data_elms__ = struct.unpack(self.__format_str__</span><span class="s4">, </span><span class="s1">data)</span>
        <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">val </span><span class="s4">in </span><span class="s1">enumerate(self.__unpacked_data_elms__):</span>
            <span class="s4">for </span><span class="s1">key </span><span class="s4">in </span><span class="s1">self.__keys__[idx]:</span>
                <span class="s1">setattr(self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">, </span><span class="s1">val)</span>

    <span class="s4">def </span><span class="s1">__pack__(self):</span>

        <span class="s1">new_values = []</span>

        <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">val </span><span class="s4">in </span><span class="s1">enumerate(self.__unpacked_data_elms__):</span>
            <span class="s1">new_val = </span><span class="s4">None</span>
            <span class="s4">for </span><span class="s1">key </span><span class="s4">in </span><span class="s1">self.__keys__[idx]:</span>
                <span class="s1">new_val = getattr(self</span><span class="s4">, </span><span class="s1">key)</span>
                <span class="s0"># In the case of unions, when the first changed value</span>
                <span class="s0"># is picked the loop is exited</span>
                <span class="s4">if </span><span class="s1">new_val != val:</span>
                    <span class="s4">break</span>
            <span class="s1">new_values.append(new_val)</span>

        <span class="s4">return </span><span class="s1">struct.pack(self.__format_str__</span><span class="s4">, </span><span class="s1">*new_values)</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s1">.join(self.dump())</span>

    <span class="s4">def </span><span class="s1">__repr__(self):</span>
        <span class="s4">return </span><span class="s3">&quot;&lt;Structure: %s&gt;&quot; </span><span class="s1">% (</span>
            <span class="s3">&quot; &quot;</span><span class="s1">.join([</span><span class="s3">&quot; &quot;</span><span class="s1">.join(s.split()) </span><span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">self.dump()])</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">dump(self</span><span class="s4">, </span><span class="s1">indentation=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Returns a string representation of the structure.&quot;&quot;&quot;</span>

        <span class="s1">dump = []</span>

        <span class="s1">dump.append(</span><span class="s3">&quot;[{0}]&quot;</span><span class="s1">.format(self.name))</span>

        <span class="s1">printable_bytes = [</span>
            <span class="s1">ord(i) </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">string.printable </span><span class="s4">if </span><span class="s1">i </span><span class="s4">not in </span><span class="s1">string.whitespace</span>
        <span class="s1">]</span>

        <span class="s0"># Refer to the __set_format__ method for an explanation</span>
        <span class="s0"># of the following construct.</span>
        <span class="s4">for </span><span class="s1">keys </span><span class="s4">in </span><span class="s1">self.__keys__:</span>
            <span class="s4">for </span><span class="s1">key </span><span class="s4">in </span><span class="s1">keys:</span>

                <span class="s1">val = getattr(self</span><span class="s4">, </span><span class="s1">key)</span>
                <span class="s4">if </span><span class="s1">isinstance(val</span><span class="s4">, </span><span class="s1">(int</span><span class="s4">, </span><span class="s1">long)):</span>
                    <span class="s4">if </span><span class="s1">key.startswith(</span><span class="s3">&quot;Signature_&quot;</span><span class="s1">):</span>
                        <span class="s1">val_str = </span><span class="s3">&quot;{:&lt;8X}&quot;</span><span class="s1">.format(val)</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">val_str = </span><span class="s3">&quot;0x{:&lt;8X}&quot;</span><span class="s1">.format(val)</span>
                    <span class="s4">if </span><span class="s1">key == </span><span class="s3">&quot;TimeDateStamp&quot; </span><span class="s4">or </span><span class="s1">key == </span><span class="s3">&quot;dwTimeStamp&quot;</span><span class="s1">:</span>
                        <span class="s4">try</span><span class="s1">:</span>
                            <span class="s1">val_str += </span><span class="s3">&quot; [%s UTC]&quot; </span><span class="s1">% time.asctime(time.gmtime(val))</span>
                        <span class="s4">except </span><span class="s1">ValueError:</span>
                            <span class="s1">val_str += </span><span class="s3">&quot; [INVALID TIME]&quot;</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">val_str = bytearray(val)</span>
                    <span class="s4">if </span><span class="s1">key.startswith(</span><span class="s3">&quot;Signature&quot;</span><span class="s1">):</span>
                        <span class="s1">val_str = </span><span class="s3">&quot;&quot;</span><span class="s1">.join(</span>
                            <span class="s1">[</span><span class="s3">&quot;{:02X}&quot;</span><span class="s1">.format(i) </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">val_str.rstrip(</span><span class="s6">b&quot;</span><span class="s4">\x00</span><span class="s6">&quot;</span><span class="s1">)]</span>
                        <span class="s1">)</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">val_str = </span><span class="s3">&quot;&quot;</span><span class="s1">.join(</span>
                            <span class="s1">[</span>
                                <span class="s1">chr(i)</span>
                                <span class="s4">if </span><span class="s1">(i </span><span class="s4">in </span><span class="s1">printable_bytes)</span>
                                <span class="s4">else </span><span class="s3">&quot;</span><span class="s4">\\</span><span class="s3">x{0:02x}&quot;</span><span class="s1">.format(i)</span>
                                <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">val_str.rstrip(</span><span class="s6">b&quot;</span><span class="s4">\x00</span><span class="s6">&quot;</span><span class="s1">)</span>
                            <span class="s1">]</span>
                        <span class="s1">)</span>

                <span class="s1">dump.append(</span>
                    <span class="s3">&quot;0x%-8X 0x%-3X %-30s %s&quot;</span>
                    <span class="s1">% (</span>
                        <span class="s1">self.__field_offsets__[key] + self.__file_offset__</span><span class="s4">,</span>
                        <span class="s1">self.__field_offsets__[key]</span><span class="s4">,</span>
                        <span class="s1">key + </span><span class="s3">&quot;:&quot;</span><span class="s4">,</span>
                        <span class="s1">val_str</span><span class="s4">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s4">return </span><span class="s1">dump</span>

    <span class="s4">def </span><span class="s1">dump_dict(self):</span>
        <span class="s2">&quot;&quot;&quot;Returns a dictionary representation of the structure.&quot;&quot;&quot;</span>

        <span class="s1">dump_dict = {}</span>

        <span class="s1">dump_dict[</span><span class="s3">&quot;Structure&quot;</span><span class="s1">] = self.name</span>

        <span class="s0"># Refer to the __set_format__ method for an explanation</span>
        <span class="s0"># of the following construct.</span>
        <span class="s4">for </span><span class="s1">keys </span><span class="s4">in </span><span class="s1">self.__keys__:</span>
            <span class="s4">for </span><span class="s1">key </span><span class="s4">in </span><span class="s1">keys:</span>

                <span class="s1">val = getattr(self</span><span class="s4">, </span><span class="s1">key)</span>
                <span class="s4">if </span><span class="s1">isinstance(val</span><span class="s4">, </span><span class="s1">(int</span><span class="s4">, </span><span class="s1">long)):</span>
                    <span class="s4">if </span><span class="s1">key == </span><span class="s3">&quot;TimeDateStamp&quot; </span><span class="s4">or </span><span class="s1">key == </span><span class="s3">&quot;dwTimeStamp&quot;</span><span class="s1">:</span>
                        <span class="s4">try</span><span class="s1">:</span>
                            <span class="s1">val = </span><span class="s3">&quot;0x%-8X [%s UTC]&quot; </span><span class="s1">% (</span>
                                <span class="s1">val</span><span class="s4">,</span>
                                <span class="s1">time.asctime(time.gmtime(val))</span><span class="s4">,</span>
                            <span class="s1">)</span>
                        <span class="s4">except </span><span class="s1">ValueError:</span>
                            <span class="s1">val = </span><span class="s3">&quot;0x%-8X [INVALID TIME]&quot; </span><span class="s1">% val</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">val = </span><span class="s3">&quot;&quot;</span><span class="s1">.join(</span>
                        <span class="s1">chr(d) </span><span class="s4">if </span><span class="s1">chr(d) </span><span class="s4">in </span><span class="s1">string.printable </span><span class="s4">else </span><span class="s3">&quot;</span><span class="s4">\\</span><span class="s3">x%02x&quot; </span><span class="s1">% d</span>
                        <span class="s4">for </span><span class="s1">d </span><span class="s4">in </span><span class="s1">[ord(c) </span><span class="s4">if not </span><span class="s1">isinstance(c</span><span class="s4">, </span><span class="s1">int) </span><span class="s4">else </span><span class="s1">c </span><span class="s4">for </span><span class="s1">c </span><span class="s4">in </span><span class="s1">val]</span>
                    <span class="s1">)</span>

                <span class="s1">dump_dict[key] = {</span>
                    <span class="s3">&quot;FileOffset&quot;</span><span class="s1">: self.__field_offsets__[key] + self.__file_offset__</span><span class="s4">,</span>
                    <span class="s3">&quot;Offset&quot;</span><span class="s1">: self.__field_offsets__[key]</span><span class="s4">,</span>
                    <span class="s3">&quot;Value&quot;</span><span class="s1">: val</span><span class="s4">,</span>
                <span class="s1">}</span>

        <span class="s4">return </span><span class="s1">dump_dict</span>


<span class="s4">class </span><span class="s1">SectionStructure(Structure):</span>
    <span class="s2">&quot;&quot;&quot;Convenience section handling class.&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">*argl</span><span class="s4">, </span><span class="s1">**argd):</span>
        <span class="s4">if </span><span class="s3">&quot;pe&quot; </span><span class="s4">in </span><span class="s1">argd:</span>
            <span class="s1">self.pe = argd[</span><span class="s3">&quot;pe&quot;</span><span class="s1">]</span>
            <span class="s4">del </span><span class="s1">argd[</span><span class="s3">&quot;pe&quot;</span><span class="s1">]</span>

        <span class="s1">self.PointerToRawData = </span><span class="s4">None</span>
        <span class="s1">self.VirtualAddress = </span><span class="s4">None</span>
        <span class="s1">self.SizeOfRawData = </span><span class="s4">None</span>
        <span class="s1">self.Misc_VirtualSize = </span><span class="s4">None</span>
        <span class="s1">Structure.__init__(self</span><span class="s4">, </span><span class="s1">*argl</span><span class="s4">, </span><span class="s1">**argd)</span>
        <span class="s1">self.PointerToRawData_adj = </span><span class="s4">None</span>
        <span class="s1">self.VirtualAddress_adj = </span><span class="s4">None</span>
        <span class="s1">self.section_min_addr = </span><span class="s4">None</span>
        <span class="s1">self.section_max_addr = </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">get_PointerToRawData_adj(self):</span>
        <span class="s4">if </span><span class="s1">self.PointerToRawData_adj </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self.PointerToRawData </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">self.PointerToRawData_adj = self.pe.adjust_FileAlignment(</span>
                    <span class="s1">self.PointerToRawData</span><span class="s4">, </span><span class="s1">self.pe.OPTIONAL_HEADER.FileAlignment</span>
                <span class="s1">)</span>
        <span class="s4">return </span><span class="s1">self.PointerToRawData_adj</span>

    <span class="s4">def </span><span class="s1">get_VirtualAddress_adj(self):</span>
        <span class="s4">if </span><span class="s1">self.VirtualAddress_adj </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self.VirtualAddress </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">self.VirtualAddress_adj = self.pe.adjust_SectionAlignment(</span>
                    <span class="s1">self.VirtualAddress</span><span class="s4">,</span>
                    <span class="s1">self.pe.OPTIONAL_HEADER.SectionAlignment</span><span class="s4">,</span>
                    <span class="s1">self.pe.OPTIONAL_HEADER.FileAlignment</span><span class="s4">,</span>
                <span class="s1">)</span>
        <span class="s4">return </span><span class="s1">self.VirtualAddress_adj</span>

    <span class="s4">def </span><span class="s1">get_data(self</span><span class="s4">, </span><span class="s1">start=</span><span class="s4">None, </span><span class="s1">length=</span><span class="s4">None, </span><span class="s1">ignore_padding=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Get data chunk from a section. 
 
        Allows to query data from the section by passing the 
        addresses where the PE file would be loaded by default. 
        It is then possible to retrieve code and data by their real 
        addresses as they would be if loaded. 
 
        Note that sections on disk can include padding that would 
        not be loaded to memory. That is the case if `section.SizeOfRawData` 
        is greater than `section.Misc_VirtualSize`, and that means 
        that data past `section.Misc_VirtualSize` is padding. 
        In case you are not interested in this padding, passing 
        `ignore_padding=True` will truncate the result in order 
        not to return the padding (if any). 
 
        Returns bytes() under Python 3.x and set() under Python 2.7 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">start </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">offset = self.get_PointerToRawData_adj()</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">offset = (</span>
                <span class="s1">start - self.get_VirtualAddress_adj()</span>
            <span class="s1">) + self.get_PointerToRawData_adj()</span>

        <span class="s4">if </span><span class="s1">length </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">end = offset + length</span>
        <span class="s4">elif </span><span class="s1">self.SizeOfRawData </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">end = offset + self.SizeOfRawData</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">end = offset</span>

        <span class="s4">if </span><span class="s1">ignore_padding </span><span class="s4">and </span><span class="s1">end </span><span class="s4">is not None and </span><span class="s1">offset </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">end = min(end</span><span class="s4">, </span><span class="s1">offset + self.Misc_VirtualSize)</span>

        <span class="s0"># PointerToRawData is not adjusted here as we might want to read any possible</span>
        <span class="s0"># extra bytes that might get cut off by aligning the start (and hence cutting</span>
        <span class="s0"># something off the end)</span>
        <span class="s4">if </span><span class="s1">self.PointerToRawData </span><span class="s4">is not None and </span><span class="s1">self.SizeOfRawData </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">end &gt; self.PointerToRawData + self.SizeOfRawData:</span>
                <span class="s1">end = self.PointerToRawData + self.SizeOfRawData</span>
        <span class="s4">return </span><span class="s1">self.pe.__data__[offset:end]</span>

    <span class="s4">def </span><span class="s1">__setattr__(self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">val):</span>

        <span class="s4">if </span><span class="s1">name == </span><span class="s3">&quot;Characteristics&quot;</span><span class="s1">:</span>
            <span class="s1">section_flags = retrieve_flags(SECTION_CHARACTERISTICS</span><span class="s4">, </span><span class="s3">&quot;IMAGE_SCN_&quot;</span><span class="s1">)</span>

            <span class="s0"># Set the section's flags according to the Characteristics member</span>
            <span class="s1">set_flags(self</span><span class="s4">, </span><span class="s1">val</span><span class="s4">, </span><span class="s1">section_flags)</span>

        <span class="s4">elif </span><span class="s3">&quot;IMAGE_SCN_&quot; </span><span class="s4">in </span><span class="s1">name </span><span class="s4">and </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s1">name):</span>
            <span class="s4">if </span><span class="s1">val:</span>
                <span class="s1">self.__dict__[</span><span class="s3">&quot;Characteristics&quot;</span><span class="s1">] |= SECTION_CHARACTERISTICS[name]</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">self.__dict__[</span><span class="s3">&quot;Characteristics&quot;</span><span class="s1">] ^= SECTION_CHARACTERISTICS[name]</span>

        <span class="s1">self.__dict__[name] = val</span>

    <span class="s4">def </span><span class="s1">get_rva_from_offset(self</span><span class="s4">, </span><span class="s1">offset):</span>
        <span class="s4">return </span><span class="s1">offset - self.get_PointerToRawData_adj() + self.get_VirtualAddress_adj()</span>

    <span class="s4">def </span><span class="s1">get_offset_from_rva(self</span><span class="s4">, </span><span class="s1">rva):</span>
        <span class="s4">return </span><span class="s1">rva - self.get_VirtualAddress_adj() + self.get_PointerToRawData_adj()</span>

    <span class="s4">def </span><span class="s1">contains_offset(self</span><span class="s4">, </span><span class="s1">offset):</span>
        <span class="s2">&quot;&quot;&quot;Check whether the section contains the file offset provided.&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self.PointerToRawData </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s0"># bss and other sections containing only uninitialized data must have 0</span>
            <span class="s0"># and do not take space in the file</span>
            <span class="s4">return False</span>
        <span class="s1">PointerToRawData_adj = self.get_PointerToRawData_adj()</span>
        <span class="s4">return </span><span class="s1">(</span>
            <span class="s1">PointerToRawData_adj &lt;= offset &lt; PointerToRawData_adj + self.SizeOfRawData</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">contains_rva(self</span><span class="s4">, </span><span class="s1">rva):</span>
        <span class="s2">&quot;&quot;&quot;Check whether the section contains the address provided.&quot;&quot;&quot;</span>

        <span class="s0"># speedup</span>
        <span class="s4">if </span><span class="s1">self.section_min_addr </span><span class="s4">is not None and </span><span class="s1">self.section_max_addr </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self.section_min_addr &lt;= rva &lt; self.section_max_addr</span>

        <span class="s1">VirtualAddress_adj = self.get_VirtualAddress_adj()</span>
        <span class="s0"># Check if the SizeOfRawData is realistic. If it's bigger than the size of</span>
        <span class="s0"># the whole PE file minus the start address of the section it could be</span>
        <span class="s0"># either truncated or the SizeOfRawData contains a misleading value.</span>
        <span class="s0"># In either of those cases we take the VirtualSize</span>
        <span class="s0">#</span>
        <span class="s4">if </span><span class="s1">len(self.pe.__data__) - self.get_PointerToRawData_adj() &lt; self.SizeOfRawData:</span>
            <span class="s0"># PECOFF documentation v8 says:</span>
            <span class="s0"># VirtualSize: The total size of the section when loaded into memory.</span>
            <span class="s0"># If this value is greater than SizeOfRawData, the section is zero-padded.</span>
            <span class="s0"># This field is valid only for executable images and should be set to zero</span>
            <span class="s0"># for object files.</span>
            <span class="s0">#</span>
            <span class="s1">size = self.Misc_VirtualSize</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">size = max(self.SizeOfRawData</span><span class="s4">, </span><span class="s1">self.Misc_VirtualSize)</span>

        <span class="s0"># Check whether there's any section after the current one that starts before</span>
        <span class="s0"># the calculated end for the current one. If so, cut the current section's size</span>
        <span class="s0"># to fit in the range up to where the next section starts.</span>
        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">self.next_section_virtual_address </span><span class="s4">is not None</span>
            <span class="s4">and </span><span class="s1">self.next_section_virtual_address &gt; self.VirtualAddress</span>
            <span class="s4">and </span><span class="s1">VirtualAddress_adj + size &gt; self.next_section_virtual_address</span>
        <span class="s1">):</span>
            <span class="s1">size = self.next_section_virtual_address - VirtualAddress_adj</span>

        <span class="s1">self.section_min_addr = VirtualAddress_adj</span>
        <span class="s1">self.section_max_addr = VirtualAddress_adj + size</span>
        <span class="s4">return </span><span class="s1">VirtualAddress_adj &lt;= rva &lt; VirtualAddress_adj + size</span>

    <span class="s4">def </span><span class="s1">contains(self</span><span class="s4">, </span><span class="s1">rva):</span>
        <span class="s4">return </span><span class="s1">self.contains_rva(rva)</span>

    <span class="s4">def </span><span class="s1">get_entropy(self):</span>
        <span class="s2">&quot;&quot;&quot;Calculate and return the entropy for the section.&quot;&quot;&quot;</span>

        <span class="s4">return </span><span class="s1">self.entropy_H(self.get_data())</span>

    <span class="s4">def </span><span class="s1">get_hash_sha1(self):</span>
        <span class="s2">&quot;&quot;&quot;Get the SHA-1 hex-digest of the section's data.&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">sha1 </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">sha1(self.get_data()).hexdigest()</span>

    <span class="s4">def </span><span class="s1">get_hash_sha256(self):</span>
        <span class="s2">&quot;&quot;&quot;Get the SHA-256 hex-digest of the section's data.&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">sha256 </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">sha256(self.get_data()).hexdigest()</span>

    <span class="s4">def </span><span class="s1">get_hash_sha512(self):</span>
        <span class="s2">&quot;&quot;&quot;Get the SHA-512 hex-digest of the section's data.&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">sha512 </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">sha512(self.get_data()).hexdigest()</span>

    <span class="s4">def </span><span class="s1">get_hash_md5(self):</span>
        <span class="s2">&quot;&quot;&quot;Get the MD5 hex-digest of the section's data.&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">md5 </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">md5(self.get_data()).hexdigest()</span>

    <span class="s4">def </span><span class="s1">entropy_H(self</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s2">&quot;&quot;&quot;Calculate the entropy of a chunk of data.&quot;&quot;&quot;</span>

        <span class="s4">if not </span><span class="s1">data:</span>
            <span class="s4">return </span><span class="s5">0.0</span>

        <span class="s1">occurences = Counter(bytearray(data))</span>

        <span class="s1">entropy = </span><span class="s5">0</span>
        <span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">occurences.values():</span>
            <span class="s1">p_x = float(x) / len(data)</span>
            <span class="s1">entropy -= p_x * math.log(p_x</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>

        <span class="s4">return </span><span class="s1">entropy</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s5">2048</span><span class="s4">, </span><span class="s1">copy=</span><span class="s4">False</span><span class="s1">)</span>
<span class="s4">def </span><span class="s1">set_bitfields_format(format):</span>
    <span class="s4">class </span><span class="s1">Accumulator:</span>
        <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">fmt</span><span class="s4">, </span><span class="s1">comp_fields):</span>
            <span class="s1">self._subfields = []</span>
            <span class="s0"># add a prefix to distinguish the artificially created compoud field</span>
            <span class="s0"># from regular fields</span>
            <span class="s1">self._name = </span><span class="s3">&quot;~&quot;</span>
            <span class="s1">self._type = </span><span class="s4">None</span>
            <span class="s1">self._bits_left = </span><span class="s5">0</span>
            <span class="s1">self._comp_fields = comp_fields</span>
            <span class="s1">self._format = fmt</span>

        <span class="s4">def </span><span class="s1">wrap_up(self):</span>
            <span class="s4">if </span><span class="s1">self._type </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s4">return</span>
            <span class="s1">self._format.append(self._type + </span><span class="s3">&quot;,&quot; </span><span class="s1">+ self._name)</span>
            <span class="s1">self._comp_fields[len(self._format) - </span><span class="s5">1</span><span class="s1">] = (self._type</span><span class="s4">, </span><span class="s1">self._subfields)</span>
            <span class="s1">self._name = </span><span class="s3">&quot;~&quot;</span>
            <span class="s1">self._type = </span><span class="s4">None</span>
            <span class="s1">self._subfields = []</span>

        <span class="s4">def </span><span class="s1">new_type(self</span><span class="s4">, </span><span class="s1">tp):</span>
            <span class="s1">self._bits_left = STRUCT_SIZEOF_TYPES[tp] * </span><span class="s5">8</span>
            <span class="s1">self._type = tp</span>

        <span class="s4">def </span><span class="s1">add_subfield(self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">bitcnt):</span>
            <span class="s1">self._name += name</span>
            <span class="s1">self._bits_left -= bitcnt</span>
            <span class="s1">self._subfields.append((name</span><span class="s4">, </span><span class="s1">bitcnt))</span>

        <span class="s4">def </span><span class="s1">get_type(self):</span>
            <span class="s4">return </span><span class="s1">self._type</span>

        <span class="s4">def </span><span class="s1">get_name(self):</span>
            <span class="s4">return </span><span class="s1">self._name</span>

        <span class="s4">def </span><span class="s1">get_bits_left(self):</span>
            <span class="s4">return </span><span class="s1">self._bits_left</span>

    <span class="s1">old_fmt = []</span>
    <span class="s1">comp_fields = {}</span>
    <span class="s1">ac = Accumulator(old_fmt</span><span class="s4">, </span><span class="s1">comp_fields)</span>

    <span class="s4">for </span><span class="s1">elm </span><span class="s4">in </span><span class="s1">format[</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s4">if not </span><span class="s3">&quot;:&quot; </span><span class="s4">in </span><span class="s1">elm:</span>
            <span class="s1">ac.wrap_up()</span>
            <span class="s1">old_fmt.append(elm)</span>
            <span class="s4">continue</span>

        <span class="s1">elm_type</span><span class="s4">, </span><span class="s1">elm_name = elm.split(</span><span class="s3">&quot;,&quot;</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s4">if </span><span class="s3">&quot;,&quot; </span><span class="s4">in </span><span class="s1">elm_name:</span>
            <span class="s4">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s3">&quot;Structures with bitfields do not support unions yet&quot;</span>
            <span class="s1">)</span>

        <span class="s1">elm_type</span><span class="s4">, </span><span class="s1">elm_bits = elm_type.split(</span><span class="s3">&quot;:&quot;</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">elm_bits = int(elm_bits)</span>
        <span class="s4">if </span><span class="s1">elm_type != ac.get_type() </span><span class="s4">or </span><span class="s1">elm_bits &gt; ac.get_bits_left():</span>
            <span class="s1">ac.wrap_up()</span>
            <span class="s1">ac.new_type(elm_type)</span>

        <span class="s1">ac.add_subfield(elm_name</span><span class="s4">, </span><span class="s1">elm_bits)</span>
    <span class="s1">ac.wrap_up()</span>

    <span class="s1">format_str</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">field_offsets</span><span class="s4">, </span><span class="s1">keys</span><span class="s4">, </span><span class="s1">format_length = set_format(tuple(old_fmt))</span>

    <span class="s1">extended_keys = []</span>
    <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">val </span><span class="s4">in </span><span class="s1">enumerate(keys):</span>
        <span class="s4">if not </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">comp_fields:</span>
            <span class="s1">extended_keys.append(val)</span>
            <span class="s4">continue</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">sbf = comp_fields[idx]</span>
        <span class="s1">bf_names = [[f[StructureWithBitfields.BTF_NAME_IDX]] </span><span class="s4">for </span><span class="s1">f </span><span class="s4">in </span><span class="s1">sbf]</span>
        <span class="s1">extended_keys.extend(bf_names)</span>
        <span class="s4">for </span><span class="s1">n </span><span class="s4">in </span><span class="s1">bf_names:</span>
            <span class="s1">field_offsets[n[</span><span class="s5">0</span><span class="s1">]] = field_offsets[val[</span><span class="s5">0</span><span class="s1">]]</span>

    <span class="s4">return </span><span class="s1">(format_str</span><span class="s4">, </span><span class="s1">format_length</span><span class="s4">, </span><span class="s1">field_offsets</span><span class="s4">, </span><span class="s1">keys</span><span class="s4">, </span><span class="s1">extended_keys</span><span class="s4">, </span><span class="s1">comp_fields)</span>


<span class="s4">class </span><span class="s1">StructureWithBitfields(Structure):</span>
    <span class="s2">&quot;&quot;&quot; 
    Extends Structure's functionality with support for bitfields such as: 
        ('B:4,LowerHalf', 'B:4,UpperHalf') 
    To this end, two lists are maintained: 
        * self.__keys__ that contains compound fields, for example 
          ('B,~LowerHalfUpperHalf'), and is used during packing/unpaking 
        * self.__keys_ext__ containing a separate key for each field (ex., LowerHalf, 
          UpperHalf) to simplify implementation of dump() 
    This way the implementation of unpacking/packing and dump() from Structure can be 
    reused. 
 
    In addition, we create a dictionary: 
        &lt;comound_field_index_in_keys&gt; --&gt; 
            (data type, [ (subfield name, length in bits)+ ] ) 
    that facilitates bitfield paking and unpacking. 
 
    With lru_cache() creating only once instance per format string, the memory 
    overhead is negligible. 
    &quot;&quot;&quot;</span>

    <span class="s1">BTF_NAME_IDX = </span><span class="s5">0</span>
    <span class="s1">BTF_BITCNT_IDX = </span><span class="s5">1</span>
    <span class="s1">CF_TYPE_IDX = </span><span class="s5">0</span>
    <span class="s1">CF_SUBFLD_IDX = </span><span class="s5">1</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">format</span><span class="s4">, </span><span class="s1">name=</span><span class="s4">None, </span><span class="s1">file_offset=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s1">(</span>
            <span class="s1">self.__format_str__</span><span class="s4">,</span>
            <span class="s1">self.__format_length__</span><span class="s4">,</span>
            <span class="s1">self.__field_offsets__</span><span class="s4">,</span>
            <span class="s1">self.__keys__</span><span class="s4">,</span>
            <span class="s1">self.__keys_ext__</span><span class="s4">,</span>
            <span class="s1">self.__compound_fields__</span><span class="s4">,</span>
        <span class="s1">) = set_bitfields_format(format)</span>
        <span class="s0"># create our own unpacked_data_elms to ensure they are not shared among</span>
        <span class="s0"># StructureWithBitfields instances with the same format string</span>
        <span class="s1">self.__unpacked_data_elms__ = [</span><span class="s4">None for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(self.__format_length__)]</span>
        <span class="s1">self.__all_zeroes__ = </span><span class="s4">False</span>
        <span class="s1">self.__file_offset__ = file_offset</span>
        <span class="s1">self.name = name </span><span class="s4">if </span><span class="s1">name != </span><span class="s4">None else </span><span class="s1">format[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s4">def </span><span class="s1">__unpack__(self</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s0"># calling the original routine to deal with special cases/spurious data</span>
        <span class="s0"># structures</span>
        <span class="s1">super(StructureWithBitfields</span><span class="s4">, </span><span class="s1">self).__unpack__(data)</span>
        <span class="s1">self._unpack_bitfield_attributes()</span>

    <span class="s4">def </span><span class="s1">__pack__(self):</span>
        <span class="s1">self._pack_bitfield_attributes()</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">data = super(StructureWithBitfields</span><span class="s4">, </span><span class="s1">self).__pack__()</span>
        <span class="s4">finally</span><span class="s1">:</span>
            <span class="s1">self._unpack_bitfield_attributes()</span>
        <span class="s4">return </span><span class="s1">data</span>

    <span class="s4">def </span><span class="s1">dump(self</span><span class="s4">, </span><span class="s1">indentation=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">tk = self.__keys__</span>
        <span class="s1">self.__keys__ = self.__keys_ext__</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">ret = super(StructureWithBitfields</span><span class="s4">, </span><span class="s1">self).dump(indentation)</span>
        <span class="s4">finally</span><span class="s1">:</span>
            <span class="s1">self.__keys__ = tk</span>
        <span class="s4">return </span><span class="s1">ret</span>

    <span class="s4">def </span><span class="s1">dump_dict(self):</span>
        <span class="s1">tk = self.__keys__</span>
        <span class="s1">self.__keys__ = self.__keys_ext__</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">ret = super(StructureWithBitfields</span><span class="s4">, </span><span class="s1">self).dump_dict()</span>
        <span class="s4">finally</span><span class="s1">:</span>
            <span class="s1">self.__keys__ = tk</span>
        <span class="s4">return </span><span class="s1">ret</span>

    <span class="s4">def </span><span class="s1">_unpack_bitfield_attributes(self):</span>
        <span class="s2">&quot;&quot;&quot;Replace compound attributes corresponding to bitfields with separate 
        sub-fields. 
        &quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">self.__compound_fields__.keys():</span>
            <span class="s1">cf_name = self.__keys__[i][</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">cval = getattr(self</span><span class="s4">, </span><span class="s1">cf_name)</span>
            <span class="s1">delattr(self</span><span class="s4">, </span><span class="s1">cf_name)</span>
            <span class="s1">offst = </span><span class="s5">0</span>
            <span class="s4">for </span><span class="s1">sf </span><span class="s4">in </span><span class="s1">self.__compound_fields__[i][StructureWithBitfields.CF_SUBFLD_IDX]:</span>
                <span class="s1">mask = (</span><span class="s5">1 </span><span class="s1">&lt;&lt; sf[StructureWithBitfields.BTF_BITCNT_IDX]) - </span><span class="s5">1</span>
                <span class="s1">mask &lt;&lt;= offst</span>
                <span class="s1">setattr(</span>
                    <span class="s1">self</span><span class="s4">,</span>
                    <span class="s1">sf[StructureWithBitfields.BTF_NAME_IDX]</span><span class="s4">,</span>
                    <span class="s1">(cval &amp; mask) &gt;&gt; offst</span><span class="s4">,</span>
                <span class="s1">)</span>
                <span class="s1">offst += sf[StructureWithBitfields.BTF_BITCNT_IDX]</span>

    <span class="s4">def </span><span class="s1">_pack_bitfield_attributes(self):</span>
        <span class="s2">&quot;&quot;&quot;Pack attributes into a compound bitfield&quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">self.__compound_fields__.keys():</span>
            <span class="s1">cf_name = self.__keys__[i][</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">offst</span><span class="s4">, </span><span class="s1">acc_val = </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span>
            <span class="s4">for </span><span class="s1">sf </span><span class="s4">in </span><span class="s1">self.__compound_fields__[i][StructureWithBitfields.CF_SUBFLD_IDX]:</span>
                <span class="s1">mask = (</span><span class="s5">1 </span><span class="s1">&lt;&lt; sf[StructureWithBitfields.BTF_BITCNT_IDX]) - </span><span class="s5">1</span>
                <span class="s1">field_val = (</span>
                    <span class="s1">getattr(self</span><span class="s4">, </span><span class="s1">sf[StructureWithBitfields.BTF_NAME_IDX]) &amp; mask</span>
                <span class="s1">)</span>
                <span class="s1">acc_val |= field_val &lt;&lt; offst</span>
                <span class="s1">offst += sf[StructureWithBitfields.BTF_BITCNT_IDX]</span>
            <span class="s1">setattr(self</span><span class="s4">, </span><span class="s1">cf_name</span><span class="s4">, </span><span class="s1">acc_val)</span>


<span class="s4">class </span><span class="s1">DataContainer:</span>
    <span class="s2">&quot;&quot;&quot;Generic data container.&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">**args):</span>
        <span class="s1">bare_setattr = super(DataContainer</span><span class="s4">, </span><span class="s1">self).__setattr__</span>
        <span class="s4">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">args.items():</span>
            <span class="s1">bare_setattr(key</span><span class="s4">, </span><span class="s1">value)</span>


<span class="s4">class </span><span class="s1">ImportDescData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds import descriptor information. 
 
    dll:        name of the imported DLL 
    imports:    list of imported symbols (ImportData instances) 
    struct:     IMAGE_IMPORT_DESCRIPTOR structure 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">ImportData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds imported symbol's information. 
 
    ordinal:    Ordinal of the symbol 
    name:       Name of the symbol 
    bound:      If the symbol is bound, this contains 
                the address. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__setattr__(self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">val):</span>

        <span class="s0"># If the instance doesn't yet have an ordinal attribute</span>
        <span class="s0"># it's not fully initialized so can't do any of the</span>
        <span class="s0"># following</span>
        <span class="s0">#</span>
        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span>
            <span class="s4">and </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;bound&quot;</span><span class="s1">)</span>
            <span class="s4">and </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>

            <span class="s4">if </span><span class="s1">name == </span><span class="s3">&quot;ordinal&quot;</span><span class="s1">:</span>

                <span class="s4">if </span><span class="s1">self.pe.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE:</span>
                    <span class="s1">ordinal_flag = IMAGE_ORDINAL_FLAG</span>
                <span class="s4">elif </span><span class="s1">self.pe.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE_PLUS:</span>
                    <span class="s1">ordinal_flag = IMAGE_ORDINAL_FLAG64</span>

                <span class="s0"># Set the ordinal and flag the entry as importing by ordinal</span>
                <span class="s1">self.struct_table.Ordinal = ordinal_flag | (val &amp; </span><span class="s5">0xFFFF</span><span class="s1">)</span>
                <span class="s1">self.struct_table.AddressOfData = self.struct_table.Ordinal</span>
                <span class="s1">self.struct_table.Function = self.struct_table.Ordinal</span>
                <span class="s1">self.struct_table.ForwarderString = self.struct_table.Ordinal</span>
            <span class="s4">elif </span><span class="s1">name == </span><span class="s3">&quot;bound&quot;</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">self.struct_iat </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s1">self.struct_iat.AddressOfData = val</span>
                    <span class="s1">self.struct_iat.AddressOfData = self.struct_iat.AddressOfData</span>
                    <span class="s1">self.struct_iat.Function = self.struct_iat.AddressOfData</span>
                    <span class="s1">self.struct_iat.ForwarderString = self.struct_iat.AddressOfData</span>
            <span class="s4">elif </span><span class="s1">name == </span><span class="s3">&quot;address&quot;</span><span class="s1">:</span>
                <span class="s1">self.struct_table.AddressOfData = val</span>
                <span class="s1">self.struct_table.Ordinal = self.struct_table.AddressOfData</span>
                <span class="s1">self.struct_table.Function = self.struct_table.AddressOfData</span>
                <span class="s1">self.struct_table.ForwarderString = self.struct_table.AddressOfData</span>
            <span class="s4">elif </span><span class="s1">name == </span><span class="s3">&quot;name&quot;</span><span class="s1">:</span>
                <span class="s0"># Make sure we reset the entry in case the import had been set to</span>
                <span class="s0"># import by ordinal</span>
                <span class="s4">if </span><span class="s1">self.name_offset:</span>

                    <span class="s1">name_rva = self.pe.get_rva_from_offset(self.name_offset)</span>
                    <span class="s1">self.pe.set_dword_at_offset(</span>
                        <span class="s1">self.ordinal_offset</span><span class="s4">, </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;&lt; </span><span class="s5">31</span><span class="s1">) | name_rva</span>
                    <span class="s1">)</span>

                    <span class="s0"># Complain if the length of the new name is longer than the</span>
                    <span class="s0"># existing one</span>
                    <span class="s4">if </span><span class="s1">len(val) &gt; len(self.name):</span>
                        <span class="s4">raise </span><span class="s1">PEFormatError(</span>
                            <span class="s3">&quot;The export name provided is longer than the existing one.&quot;</span>
                        <span class="s1">)</span>
                        <span class="s4">pass</span>
                    <span class="s1">self.pe.set_bytes_at_offset(self.name_offset</span><span class="s4">, </span><span class="s1">val)</span>

        <span class="s1">self.__dict__[name] = val</span>


<span class="s4">class </span><span class="s1">ExportDirData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds export directory information. 
 
    struct:     IMAGE_EXPORT_DIRECTORY structure 
    symbols:    list of exported symbols (ExportData instances)&quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">ExportData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds exported symbols' information. 
 
    ordinal:    ordinal of the symbol 
    address:    address of the symbol 
    name:       name of the symbol (None if the symbol is 
                exported by ordinal only) 
    forwarder:  if the symbol is forwarded it will 
                contain the name of the target symbol, 
                None otherwise. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__setattr__(self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">val):</span>

        <span class="s0"># If the instance doesn't yet have an ordinal attribute</span>
        <span class="s0"># it's not fully initialized so can't do any of the</span>
        <span class="s0"># following</span>
        <span class="s0">#</span>
        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;ordinal&quot;</span><span class="s1">)</span>
            <span class="s4">and </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;address&quot;</span><span class="s1">)</span>
            <span class="s4">and </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;forwarder&quot;</span><span class="s1">)</span>
            <span class="s4">and </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>

            <span class="s4">if </span><span class="s1">name == </span><span class="s3">&quot;ordinal&quot;</span><span class="s1">:</span>
                <span class="s1">self.pe.set_word_at_offset(self.ordinal_offset</span><span class="s4">, </span><span class="s1">val)</span>
            <span class="s4">elif </span><span class="s1">name == </span><span class="s3">&quot;address&quot;</span><span class="s1">:</span>
                <span class="s1">self.pe.set_dword_at_offset(self.address_offset</span><span class="s4">, </span><span class="s1">val)</span>
            <span class="s4">elif </span><span class="s1">name == </span><span class="s3">&quot;name&quot;</span><span class="s1">:</span>
                <span class="s0"># Complain if the length of the new name is longer than the</span>
                <span class="s0"># existing one</span>
                <span class="s4">if </span><span class="s1">len(val) &gt; len(self.name):</span>
                    <span class="s4">raise </span><span class="s1">PEFormatError(</span>
                        <span class="s3">&quot;The export name provided is longer than the existing one.&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">self.pe.set_bytes_at_offset(self.name_offset</span><span class="s4">, </span><span class="s1">val)</span>
            <span class="s4">elif </span><span class="s1">name == </span><span class="s3">&quot;forwarder&quot;</span><span class="s1">:</span>
                <span class="s0"># Complain if the length of the new name is longer than the</span>
                <span class="s0"># existing one</span>
                <span class="s4">if </span><span class="s1">len(val) &gt; len(self.forwarder):</span>
                    <span class="s4">raise </span><span class="s1">PEFormatError(</span>
                        <span class="s3">&quot;The forwarder name provided is longer than the existing one.&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">self.pe.set_bytes_at_offset(self.forwarder_offset</span><span class="s4">, </span><span class="s1">val)</span>

        <span class="s1">self.__dict__[name] = val</span>


<span class="s4">class </span><span class="s1">ResourceDirData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds resource directory information. 
 
    struct:     IMAGE_RESOURCE_DIRECTORY structure 
    entries:    list of entries (ResourceDirEntryData instances) 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">ResourceDirEntryData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds resource directory entry data. 
 
    struct:     IMAGE_RESOURCE_DIRECTORY_ENTRY structure 
    name:       If the resource is identified by name this 
                attribute will contain the name string. None 
                otherwise. If identified by id, the id is 
                available at 'struct.Id' 
    id:         the id, also in struct.Id 
    directory:  If this entry has a lower level directory 
                this attribute will point to the 
                ResourceDirData instance representing it. 
    data:       If this entry has no further lower directories 
                and points to the actual resource data, this 
                attribute will reference the corresponding 
                ResourceDataEntryData instance. 
    (Either of the 'directory' or 'data' attribute will exist, 
    but not both.) 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">ResourceDataEntryData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds resource data entry information. 
 
    struct:     IMAGE_RESOURCE_DATA_ENTRY structure 
    lang:       Primary language ID 
    sublang:    Sublanguage ID 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">DebugData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds debug information. 
 
    struct:     IMAGE_DEBUG_DIRECTORY structure 
    entries:    list of entries (IMAGE_DEBUG_TYPE instances) 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">DynamicRelocationData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds dynamic relocation information. 
 
    struct:        IMAGE_DYNAMIC_RELOCATION structure 
    symbol:        Symbol to which dynamic relocations must be applied 
    relocations:   List of dynamic relocations for this symbol (BaseRelocationData instances) 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">BaseRelocationData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds base relocation information. 
 
    struct:     IMAGE_BASE_RELOCATION structure 
    entries:    list of relocation data (RelocationData instances) 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">RelocationData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds relocation information. 
 
    type:       Type of relocation 
                The type string can be obtained by 
                RELOCATION_TYPE[type] 
    rva:        RVA of the relocation 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__setattr__(self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">val):</span>

        <span class="s0"># If the instance doesn't yet have a struct attribute</span>
        <span class="s0"># it's not fully initialized so can't do any of the</span>
        <span class="s0"># following</span>
        <span class="s0">#</span>
        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;struct&quot;</span><span class="s1">):</span>
            <span class="s0"># Get the word containing the type and data</span>
            <span class="s0">#</span>
            <span class="s1">word = self.struct.Data</span>

            <span class="s4">if </span><span class="s1">name == </span><span class="s3">&quot;type&quot;</span><span class="s1">:</span>
                <span class="s1">word = (val &lt;&lt; </span><span class="s5">12</span><span class="s1">) | (word &amp; </span><span class="s5">0xFFF</span><span class="s1">)</span>
            <span class="s4">elif </span><span class="s1">name == </span><span class="s3">&quot;rva&quot;</span><span class="s1">:</span>
                <span class="s1">offset = max(val - self.base_rva</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">word = (word &amp; </span><span class="s5">0xF000</span><span class="s1">) | (offset &amp; </span><span class="s5">0xFFF</span><span class="s1">)</span>

            <span class="s0"># Store the modified data</span>
            <span class="s0">#</span>
            <span class="s1">self.struct.Data = word</span>

        <span class="s1">self.__dict__[name] = val</span>


<span class="s4">class </span><span class="s1">TlsData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds TLS information. 
 
    struct:     IMAGE_TLS_DIRECTORY structure 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">BoundImportDescData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds bound import descriptor data. 
 
    This directory entry will provide information on the 
    DLLs this PE file has been bound to (if bound at all). 
    The structure will contain the name and timestamp of the 
    DLL at the time of binding so that the loader can know 
    whether it differs from the one currently present in the 
    system and must, therefore, re-bind the PE's imports. 
 
    struct:     IMAGE_BOUND_IMPORT_DESCRIPTOR structure 
    name:       DLL name 
    entries:    list of entries (BoundImportRefData instances) 
                the entries will exist if this DLL has forwarded 
                symbols. If so, the destination DLL will have an 
                entry in this list. 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">LoadConfigData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds Load Config data. 
 
    struct:     IMAGE_LOAD_CONFIG_DIRECTORY structure 
    name:       dll name 
    dynamic_relocations: dynamic relocation information, if present 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">BoundImportRefData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds bound import forwarder reference data. 
 
    Contains the same information as the bound descriptor but 
    for forwarded DLLs, if any. 
 
    struct:     IMAGE_BOUND_FORWARDER_REF structure 
    name:       dll name 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">ExceptionsDirEntryData(DataContainer):</span>
    <span class="s2">&quot;&quot;&quot;Holds the data related to SEH (and stack unwinding, in particular) 
 
    struct      an instance of RUNTIME_FUNTION 
    unwindinfo  an instance of UNWIND_INFO 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">UnwindInfo(StructureWithBitfields):</span>
    <span class="s2">&quot;&quot;&quot;Handles the complexities of UNWIND_INFO structure: 
    * variable number of UWIND_CODEs 
    * optional ExceptionHandler and FunctionEntry fields 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">file_offset=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">super(UnwindInfo</span><span class="s4">, </span><span class="s1">self).__init__(</span>
            <span class="s1">(</span>
                <span class="s3">&quot;UNWIND_INFO&quot;</span><span class="s4">,</span>
                <span class="s1">(</span>
                    <span class="s3">&quot;B:3,Version&quot;</span><span class="s4">,</span>
                    <span class="s3">&quot;B:5,Flags&quot;</span><span class="s4">,</span>
                    <span class="s3">&quot;B,SizeOfProlog&quot;</span><span class="s4">,</span>
                    <span class="s3">&quot;B,CountOfCodes&quot;</span><span class="s4">,</span>
                    <span class="s3">&quot;B:4,FrameRegister&quot;</span><span class="s4">,</span>
                    <span class="s3">&quot;B:4,FrameOffset&quot;</span><span class="s4">,</span>
                <span class="s1">)</span><span class="s4">,</span>
            <span class="s1">)</span><span class="s4">,</span>
            <span class="s1">file_offset=file_offset</span><span class="s4">,</span>
        <span class="s1">)</span>
        <span class="s1">self._full_size = super(UnwindInfo</span><span class="s4">, </span><span class="s1">self).sizeof()</span>
        <span class="s1">self._opt_field_name = </span><span class="s4">None</span>
        <span class="s1">self._code_info = StructureWithBitfields(</span>
            <span class="s1">(</span><span class="s3">&quot;UNWIND_CODE&quot;</span><span class="s4">, </span><span class="s1">(</span><span class="s3">&quot;B,CodeOffset&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,UnwindOp&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,OpInfo&quot;</span><span class="s1">))</span><span class="s4">,</span>
            <span class="s1">file_offset=</span><span class="s5">0</span><span class="s4">,</span>
        <span class="s1">)</span>
        <span class="s1">self._chained_entry = </span><span class="s4">None</span>
        <span class="s1">self._finished_unpacking = </span><span class="s4">False</span>

    <span class="s4">def </span><span class="s1">unpack_in_stages(self</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s2">&quot;&quot;&quot;Unpacks the UNWIND_INFO &quot;in two calls&quot;, with the first call establishing 
        a full size of the structure and the second, performing the actual unpacking. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self._finished_unpacking:</span>
            <span class="s4">return None</span>

        <span class="s1">super(UnwindInfo</span><span class="s4">, </span><span class="s1">self).__unpack__(data)</span>
        <span class="s1">codes_cnt_max = (self.CountOfCodes + </span><span class="s5">1</span><span class="s1">) &amp; ~</span><span class="s5">1</span>
        <span class="s1">hdlr_offset = (</span>
            <span class="s1">super(UnwindInfo</span><span class="s4">, </span><span class="s1">self).sizeof() + codes_cnt_max * self._code_info.sizeof()</span>
        <span class="s1">)</span>
        <span class="s1">self._full_size = hdlr_offset + (</span>
            <span class="s5">0 </span><span class="s4">if </span><span class="s1">self.Flags == </span><span class="s5">0 </span><span class="s4">else </span><span class="s1">STRUCT_SIZEOF_TYPES[</span><span class="s3">&quot;I&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s4">if </span><span class="s1">len(data) &lt; self._full_size:</span>
            <span class="s4">return None</span>

        <span class="s4">if </span><span class="s1">self.Version != </span><span class="s5">1 </span><span class="s4">and </span><span class="s1">self.Version != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s3">&quot;Unsupported version of UNWIND_INFO at &quot; </span><span class="s1">+ hex(self.__file_offset__)</span>

        <span class="s1">self.UnwindCodes = []</span>
        <span class="s1">ro = super(UnwindInfo</span><span class="s4">, </span><span class="s1">self).sizeof()</span>
        <span class="s1">codes_left = self.CountOfCodes</span>
        <span class="s4">while </span><span class="s1">codes_left &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">self._code_info.__unpack__(data[ro : ro + self._code_info.sizeof()])</span>
            <span class="s1">ucode = PrologEpilogOpsFactory.create(self._code_info)</span>
            <span class="s4">if </span><span class="s1">ucode </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s4">return </span><span class="s3">&quot;Unknown UNWIND_CODE at &quot; </span><span class="s1">+ hex(self.__file_offset__ + ro)</span>

            <span class="s1">len_in_codes = ucode.length_in_code_structures(self._code_info</span><span class="s4">, </span><span class="s1">self)</span>
            <span class="s1">opc_size = self._code_info.sizeof() * len_in_codes</span>
            <span class="s1">ucode.initialize(</span>
                <span class="s1">self._code_info</span><span class="s4">,</span>
                <span class="s1">data[ro : ro + opc_size]</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">,</span>
                <span class="s1">self.__file_offset__ + ro</span><span class="s4">,</span>
            <span class="s1">)</span>
            <span class="s1">ro += opc_size</span>
            <span class="s1">codes_left -= len_in_codes</span>
            <span class="s1">self.UnwindCodes.append(ucode)</span>

        <span class="s4">if </span><span class="s1">self.UNW_FLAG_EHANDLER </span><span class="s4">or </span><span class="s1">self.UNW_FLAG_UHANDLER:</span>
            <span class="s1">self._opt_field_name = </span><span class="s3">&quot;ExceptionHandler&quot;</span>

        <span class="s4">if </span><span class="s1">self.UNW_FLAG_CHAININFO:</span>
            <span class="s1">self._opt_field_name = </span><span class="s3">&quot;FunctionEntry&quot;</span>

        <span class="s4">if </span><span class="s1">self._opt_field_name != </span><span class="s4">None</span><span class="s1">:</span>
            <span class="s1">setattr(</span>
                <span class="s1">self</span><span class="s4">,</span>
                <span class="s1">self._opt_field_name</span><span class="s4">,</span>
                <span class="s1">struct.unpack(</span>
                    <span class="s3">&quot;&lt;I&quot;</span><span class="s4">, </span><span class="s1">data[hdlr_offset : hdlr_offset + STRUCT_SIZEOF_TYPES[</span><span class="s3">&quot;I&quot;</span><span class="s1">]]</span>
                <span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">,</span>
            <span class="s1">)</span>

        <span class="s1">self._finished_unpacking = </span><span class="s4">True</span>

        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">dump(self</span><span class="s4">, </span><span class="s1">indentation=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0"># Because __keys_ext__ are shared among all the instances with the same</span>
        <span class="s0"># format string, we have to add and sunsequently remove the optional field</span>
        <span class="s0"># each time.</span>
        <span class="s0"># It saves space (as compared to keeping a copy self.__keys_ext__ per</span>
        <span class="s0"># UnwindInfo instance), but makes our dump() implementation thread-unsafe.</span>
        <span class="s4">if </span><span class="s1">self._opt_field_name != </span><span class="s4">None</span><span class="s1">:</span>
            <span class="s1">self.__field_offsets__[self._opt_field_name] = (</span>
                <span class="s1">self._full_size - STRUCT_SIZEOF_TYPES[</span><span class="s3">&quot;I&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s1">self.__keys_ext__.append([self._opt_field_name])</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">dump = super(UnwindInfo</span><span class="s4">, </span><span class="s1">self).dump(indentation)</span>
        <span class="s4">finally</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self._opt_field_name != </span><span class="s4">None</span><span class="s1">:</span>
                <span class="s1">self.__keys_ext__.pop()</span>

        <span class="s1">dump.append(</span>
            <span class="s3">&quot;Flags: &quot;</span>
            <span class="s1">+ </span><span class="s3">&quot;, &quot;</span><span class="s1">.join([s[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">unwind_info_flags </span><span class="s4">if </span><span class="s1">getattr(self</span><span class="s4">, </span><span class="s1">s[</span><span class="s5">0</span><span class="s1">])])</span>
        <span class="s1">)</span>
        <span class="s1">dump.append(</span>
            <span class="s3">&quot;Unwind codes: &quot;</span>
            <span class="s1">+ </span><span class="s3">&quot;; &quot;</span><span class="s1">.join([str(c) </span><span class="s4">for </span><span class="s1">c </span><span class="s4">in </span><span class="s1">self.UnwindCodes </span><span class="s4">if </span><span class="s1">c.is_valid()])</span>
        <span class="s1">)</span>
        <span class="s4">return </span><span class="s1">dump</span>

    <span class="s4">def </span><span class="s1">dump_dict(self):</span>
        <span class="s4">if </span><span class="s1">self._opt_field_name != </span><span class="s4">None</span><span class="s1">:</span>
            <span class="s1">self.__field_offsets__[self._opt_field_name] = (</span>
                <span class="s1">self._full_size - STRUCT_SIZEOF_TYPES[</span><span class="s3">&quot;I&quot;</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s1">self.__keys_ext__.append([self._opt_field_name])</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">ret = super(UnwindInfo</span><span class="s4">, </span><span class="s1">self).dump_dict()</span>
        <span class="s4">finally</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self._opt_field_name != </span><span class="s4">None</span><span class="s1">:</span>
                <span class="s1">self.__keys_ext__.pop()</span>
        <span class="s4">return </span><span class="s1">ret</span>

    <span class="s4">def </span><span class="s1">__setattr__(self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">val):</span>
        <span class="s4">if </span><span class="s1">name == </span><span class="s3">&quot;Flags&quot;</span><span class="s1">:</span>
            <span class="s1">set_flags(self</span><span class="s4">, </span><span class="s1">val</span><span class="s4">, </span><span class="s1">unwind_info_flags)</span>
        <span class="s4">elif </span><span class="s3">&quot;UNW_FLAG_&quot; </span><span class="s4">in </span><span class="s1">name </span><span class="s4">and </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s1">name):</span>
            <span class="s4">if </span><span class="s1">val:</span>
                <span class="s1">self.__dict__[</span><span class="s3">&quot;Flags&quot;</span><span class="s1">] |= UNWIND_INFO_FLAGS[name]</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">self.__dict__[</span><span class="s3">&quot;Flags&quot;</span><span class="s1">] ^= UNWIND_INFO_FLAGS[name]</span>
        <span class="s1">self.__dict__[name] = val</span>

    <span class="s4">def </span><span class="s1">sizeof(self):</span>
        <span class="s4">return </span><span class="s1">self._full_size</span>

    <span class="s4">def </span><span class="s1">__pack__(self):</span>
        <span class="s1">data = bytearray(self._full_size)</span>
        <span class="s1">data[</span><span class="s5">0 </span><span class="s1">: super(UnwindInfo</span><span class="s4">, </span><span class="s1">self).sizeof()] = super(UnwindInfo</span><span class="s4">, </span><span class="s1">self).__pack__()</span>
        <span class="s1">cur_offset = super(UnwindInfo</span><span class="s4">, </span><span class="s1">self).sizeof()</span>

        <span class="s4">for </span><span class="s1">uc </span><span class="s4">in </span><span class="s1">self.UnwindCodes:</span>
            <span class="s4">if </span><span class="s1">cur_offset + uc.struct.sizeof() &gt; self._full_size:</span>
                <span class="s4">break</span>
            <span class="s1">data[cur_offset : cur_offset + uc.struct.sizeof()] = uc.struct.__pack__()</span>
            <span class="s1">cur_offset += uc.struct.sizeof()</span>

        <span class="s4">if </span><span class="s1">self._opt_field_name != </span><span class="s4">None</span><span class="s1">:</span>
            <span class="s1">data[</span>
                <span class="s1">self._full_size - STRUCT_SIZEOF_TYPES[</span><span class="s3">&quot;I&quot;</span><span class="s1">] : self._full_size</span>
            <span class="s1">] = struct.pack(</span><span class="s3">&quot;&lt;I&quot;</span><span class="s4">, </span><span class="s1">getattr(self</span><span class="s4">, </span><span class="s1">self._opt_field_name))</span>

        <span class="s4">return </span><span class="s1">data</span>

    <span class="s4">def </span><span class="s1">get_chained_function_entry(self):</span>
        <span class="s4">return </span><span class="s1">self._chained_entry</span>

    <span class="s4">def </span><span class="s1">set_chained_function_entry(self</span><span class="s4">, </span><span class="s1">entry):</span>
        <span class="s4">if </span><span class="s1">self._chained_entry != </span><span class="s4">None</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;Chained function entry cannot be changed&quot;</span><span class="s1">)</span>
        <span class="s1">self._chained_entry = entry</span>


<span class="s4">class </span><span class="s1">PrologEpilogOp:</span>
    <span class="s2">&quot;&quot;&quot;Meant as an abstract class representing a generic unwind code. 
    There is a subclass of PrologEpilogOp for each member of UNWIND_OP_CODES enum. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">initialize(self</span><span class="s4">, </span><span class="s1">unw_code</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">unw_info</span><span class="s4">, </span><span class="s1">file_offset):</span>
        <span class="s1">self.struct = StructureWithBitfields(</span>
            <span class="s1">self._get_format(unw_code)</span><span class="s4">, </span><span class="s1">file_offset=file_offset</span>
        <span class="s1">)</span>
        <span class="s1">self.struct.__unpack__(data)</span>

    <span class="s4">def </span><span class="s1">length_in_code_structures(self</span><span class="s4">, </span><span class="s1">unw_code</span><span class="s4">, </span><span class="s1">unw_info):</span>
        <span class="s2">&quot;&quot;&quot;Computes how many UNWIND_CODE structures UNWIND_CODE occupies. 
        May be called before initialize() and, for that reason, should not rely on 
        the values of intance attributes. 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s5">1</span>

    <span class="s4">def </span><span class="s1">is_valid(self):</span>
        <span class="s4">return True</span>

    <span class="s4">def </span><span class="s1">_get_format(self</span><span class="s4">, </span><span class="s1">unw_code):</span>
        <span class="s4">return </span><span class="s1">(</span><span class="s3">&quot;UNWIND_CODE&quot;</span><span class="s4">, </span><span class="s1">(</span><span class="s3">&quot;B,CodeOffset&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,UnwindOp&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,OpInfo&quot;</span><span class="s1">))</span>


<span class="s4">class </span><span class="s1">PrologEpilogOpPushReg(PrologEpilogOp):</span>
    <span class="s2">&quot;&quot;&quot;UWOP_PUSH_NONVOL&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">_get_format(self</span><span class="s4">, </span><span class="s1">unw_code):</span>
        <span class="s4">return </span><span class="s1">(</span><span class="s3">&quot;UNWIND_CODE_PUSH_NONVOL&quot;</span><span class="s4">, </span><span class="s1">(</span><span class="s3">&quot;B,CodeOffset&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,UnwindOp&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,Reg&quot;</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s3">&quot;.PUSHREG &quot; </span><span class="s1">+ REGISTERS[self.struct.Reg]</span>


<span class="s4">class </span><span class="s1">PrologEpilogOpAllocLarge(PrologEpilogOp):</span>
    <span class="s2">&quot;&quot;&quot;UWOP_ALLOC_LARGE&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">_get_format(self</span><span class="s4">, </span><span class="s1">unw_code):</span>
        <span class="s4">return </span><span class="s1">(</span>
            <span class="s3">&quot;UNWIND_CODE_ALLOC_LARGE&quot;</span><span class="s4">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;B,CodeOffset&quot;</span><span class="s4">,</span>
                <span class="s3">&quot;B:4,UnwindOp&quot;</span><span class="s4">,</span>
                <span class="s3">&quot;B:4,OpInfo&quot;</span><span class="s4">,</span>
                <span class="s3">&quot;H,AllocSizeInQwords&quot; </span><span class="s4">if </span><span class="s1">unw_code.OpInfo == </span><span class="s5">0 </span><span class="s4">else </span><span class="s3">&quot;I,AllocSize&quot;</span><span class="s4">,</span>
            <span class="s1">)</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">length_in_code_structures(self</span><span class="s4">, </span><span class="s1">unw_code</span><span class="s4">, </span><span class="s1">unw_info):</span>
        <span class="s4">return </span><span class="s5">2 </span><span class="s4">if </span><span class="s1">unw_code.OpInfo == </span><span class="s5">0 </span><span class="s4">else </span><span class="s5">3</span>

    <span class="s4">def </span><span class="s1">get_alloc_size(self):</span>
        <span class="s4">return </span><span class="s1">(</span>
            <span class="s1">self.struct.AllocSizeInQwords * </span><span class="s5">8</span>
            <span class="s4">if </span><span class="s1">self.struct.OpInfo == </span><span class="s5">0</span>
            <span class="s4">else </span><span class="s1">self.struct.AllocSize</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s3">&quot;.ALLOCSTACK &quot; </span><span class="s1">+ hex(self.get_alloc_size())</span>


<span class="s4">class </span><span class="s1">PrologEpilogOpAllocSmall(PrologEpilogOp):</span>
    <span class="s2">&quot;&quot;&quot;UWOP_ALLOC_SMALL&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">_get_format(self</span><span class="s4">, </span><span class="s1">unw_code):</span>
        <span class="s4">return </span><span class="s1">(</span>
            <span class="s3">&quot;UNWIND_CODE_ALLOC_SMALL&quot;</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;B,CodeOffset&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,UnwindOp&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,AllocSizeInQwordsMinus8&quot;</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">get_alloc_size(self):</span>
        <span class="s4">return </span><span class="s1">self.struct.AllocSizeInQwordsMinus8 * </span><span class="s5">8 </span><span class="s1">+ </span><span class="s5">8</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s3">&quot;.ALLOCSTACK &quot; </span><span class="s1">+ hex(self.get_alloc_size())</span>


<span class="s4">class </span><span class="s1">PrologEpilogOpSetFP(PrologEpilogOp):</span>
    <span class="s2">&quot;&quot;&quot;UWOP_SET_FPREG&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">initialize(self</span><span class="s4">, </span><span class="s1">unw_code</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">unw_info</span><span class="s4">, </span><span class="s1">file_offset):</span>
        <span class="s1">super(PrologEpilogOpSetFP</span><span class="s4">, </span><span class="s1">self).initialize(</span>
            <span class="s1">unw_code</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">unw_info</span><span class="s4">, </span><span class="s1">file_offset</span>
        <span class="s1">)</span>
        <span class="s1">self._frame_register = unw_info.FrameRegister</span>
        <span class="s1">self._frame_offset = unw_info.FrameOffset * </span><span class="s5">16</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s1">(</span>
            <span class="s3">&quot;.SETFRAME &quot;</span>
            <span class="s1">+ REGISTERS[self._frame_register]</span>
            <span class="s1">+ </span><span class="s3">&quot;, &quot;</span>
            <span class="s1">+ hex(self._frame_offset)</span>
        <span class="s1">)</span>


<span class="s4">class </span><span class="s1">PrologEpilogOpSaveReg(PrologEpilogOp):</span>
    <span class="s2">&quot;&quot;&quot;UWOP_SAVE_NONVOL&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">length_in_code_structures(self</span><span class="s4">, </span><span class="s1">unwcode</span><span class="s4">, </span><span class="s1">unw_info):</span>
        <span class="s4">return </span><span class="s5">2</span>

    <span class="s4">def </span><span class="s1">get_offset(self):</span>
        <span class="s4">return </span><span class="s1">self.struct.OffsetInQwords * </span><span class="s5">8</span>

    <span class="s4">def </span><span class="s1">_get_format(self</span><span class="s4">, </span><span class="s1">unw_code):</span>
        <span class="s4">return </span><span class="s1">(</span>
            <span class="s3">&quot;UNWIND_CODE_SAVE_NONVOL&quot;</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;B,CodeOffset&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,UnwindOp&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,Reg&quot;</span><span class="s4">, </span><span class="s3">&quot;H,OffsetInQwords&quot;</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s3">&quot;.SAVEREG &quot; </span><span class="s1">+ REGISTERS[self.struct.Reg] + </span><span class="s3">&quot;, &quot; </span><span class="s1">+ hex(self.get_offset())</span>


<span class="s4">class </span><span class="s1">PrologEpilogOpSaveRegFar(PrologEpilogOp):</span>
    <span class="s2">&quot;&quot;&quot;UWOP_SAVE_NONVOL_FAR&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">length_in_code_structures(self</span><span class="s4">, </span><span class="s1">unw_code</span><span class="s4">, </span><span class="s1">unw_info):</span>
        <span class="s4">return </span><span class="s5">3</span>

    <span class="s4">def </span><span class="s1">get_offset(self):</span>
        <span class="s4">return </span><span class="s1">self.struct.Offset</span>

    <span class="s4">def </span><span class="s1">_get_format(self</span><span class="s4">, </span><span class="s1">unw_code):</span>
        <span class="s4">return </span><span class="s1">(</span>
            <span class="s3">&quot;UNWIND_CODE_SAVE_NONVOL_FAR&quot;</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;B,CodeOffset&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,UnwindOp&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,Reg&quot;</span><span class="s4">, </span><span class="s3">&quot;I,Offset&quot;</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s3">&quot;.SAVEREG &quot; </span><span class="s1">+ REGISTERS[self.struct.Reg] + </span><span class="s3">&quot;, &quot; </span><span class="s1">+ hex(self.struct.Offset)</span>


<span class="s4">class </span><span class="s1">PrologEpilogOpSaveXMM(PrologEpilogOp):</span>
    <span class="s2">&quot;&quot;&quot;UWOP_SAVE_XMM128&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">_get_format(self</span><span class="s4">, </span><span class="s1">unw_code):</span>
        <span class="s4">return </span><span class="s1">(</span>
            <span class="s3">&quot;UNWIND_CODE_SAVE_XMM128&quot;</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;B,CodeOffset&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,UnwindOp&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,Reg&quot;</span><span class="s4">, </span><span class="s3">&quot;H,OffsetIn2Qwords&quot;</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">length_in_code_structures(self</span><span class="s4">, </span><span class="s1">unw_code</span><span class="s4">, </span><span class="s1">unw_info):</span>
        <span class="s4">return </span><span class="s5">2</span>

    <span class="s4">def </span><span class="s1">get_offset(self):</span>
        <span class="s4">return </span><span class="s1">self.struct.OffsetIn2Qwords * </span><span class="s5">16</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s3">&quot;.SAVEXMM128 XMM&quot; </span><span class="s1">+ str(self.struct.Reg) + </span><span class="s3">&quot;, &quot; </span><span class="s1">+ hex(self.get_offset())</span>


<span class="s4">class </span><span class="s1">PrologEpilogOpSaveXMMFar(PrologEpilogOp):</span>
    <span class="s2">&quot;&quot;&quot;UWOP_SAVE_XMM128_FAR&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">_get_format(self</span><span class="s4">, </span><span class="s1">unw_code):</span>
        <span class="s4">return </span><span class="s1">(</span>
            <span class="s3">&quot;UNWIND_CODE_SAVE_XMM128_FAR&quot;</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;B,CodeOffset&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,UnwindOp&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,Reg&quot;</span><span class="s4">, </span><span class="s3">&quot;I,Offset&quot;</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">length_in_code_structures(self</span><span class="s4">, </span><span class="s1">unw_code</span><span class="s4">, </span><span class="s1">unw_info):</span>
        <span class="s4">return </span><span class="s5">3</span>

    <span class="s4">def </span><span class="s1">get_offset(self):</span>
        <span class="s4">return </span><span class="s1">self.struct.Offset</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s3">&quot;.SAVEXMM128 XMM&quot; </span><span class="s1">+ str(self.struct.Reg) + </span><span class="s3">&quot;, &quot; </span><span class="s1">+ hex(self.struct.Offset)</span>


<span class="s4">class </span><span class="s1">PrologEpilogOpPushFrame(PrologEpilogOp):</span>
    <span class="s2">&quot;&quot;&quot;UWOP_PUSH_MACHFRAME&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s3">&quot;.PUSHFRAME&quot; </span><span class="s1">+ (</span><span class="s3">&quot; &lt;code&gt;&quot; </span><span class="s4">if </span><span class="s1">self.struct.OpInfo </span><span class="s4">else </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>


<span class="s4">class </span><span class="s1">PrologEpilogOpEpilogMarker(PrologEpilogOp):</span>
    <span class="s2">&quot;&quot;&quot;UWOP_EPILOG&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">initialize(self</span><span class="s4">, </span><span class="s1">unw_code</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">unw_info</span><span class="s4">, </span><span class="s1">file_offset):</span>
        <span class="s1">self._long_offst = </span><span class="s4">True</span>
        <span class="s1">self._first = </span><span class="s4">not </span><span class="s1">hasattr(unw_info</span><span class="s4">, </span><span class="s3">&quot;SizeOfEpilog&quot;</span><span class="s1">)</span>
        <span class="s1">super(PrologEpilogOpEpilogMarker</span><span class="s4">, </span><span class="s1">self).initialize(</span>
            <span class="s1">unw_code</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">unw_info</span><span class="s4">, </span><span class="s1">file_offset</span>
        <span class="s1">)</span>
        <span class="s4">if </span><span class="s1">self._first:</span>
            <span class="s1">setattr(unw_info</span><span class="s4">, </span><span class="s3">&quot;SizeOfEpilog&quot;</span><span class="s4">, </span><span class="s1">self.struct.Size)</span>
            <span class="s1">self._long_offst = unw_code.OpInfo &amp; </span><span class="s5">1 </span><span class="s1">== </span><span class="s5">0</span>
        <span class="s1">self._epilog_size = unw_info.SizeOfEpilog</span>

    <span class="s4">def </span><span class="s1">_get_format(self</span><span class="s4">, </span><span class="s1">unw_code):</span>
        <span class="s0"># check if it is the first epilog code among encountered; then its record</span>
        <span class="s0"># will contain size of the epilog</span>
        <span class="s4">if </span><span class="s1">self._first:</span>
            <span class="s4">return </span><span class="s1">(</span>
                <span class="s3">&quot;UNWIND_CODE_EPILOG&quot;</span><span class="s4">,</span>
                <span class="s1">(</span><span class="s3">&quot;B,OffsetLow,Size&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,UnwindOp&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,Flags&quot;</span><span class="s1">)</span>
                <span class="s4">if </span><span class="s1">unw_code.OpInfo &amp; </span><span class="s5">1 </span><span class="s1">== </span><span class="s5">1</span>
                <span class="s4">else </span><span class="s1">(</span>
                    <span class="s3">&quot;B,Size&quot;</span><span class="s4">,</span>
                    <span class="s3">&quot;B:4,UnwindOp&quot;</span><span class="s4">,</span>
                    <span class="s3">&quot;B:4,Flags&quot;</span><span class="s4">,</span>
                    <span class="s3">&quot;B,OffsetLow&quot;</span><span class="s4">,</span>
                    <span class="s3">&quot;B:4,Unused&quot;</span><span class="s4">,</span>
                    <span class="s3">&quot;B:4,OffsetHigh&quot;</span><span class="s4">,</span>
                <span class="s1">)</span><span class="s4">,</span>
            <span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">(</span>
                <span class="s3">&quot;UNWIND_CODE_EPILOG&quot;</span><span class="s4">,</span>
                <span class="s1">(</span><span class="s3">&quot;B,OffsetLow&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,UnwindOp&quot;</span><span class="s4">, </span><span class="s3">&quot;B:4,OffsetHigh&quot;</span><span class="s1">)</span><span class="s4">,</span>
            <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">length_in_code_structures(self</span><span class="s4">, </span><span class="s1">unw_code</span><span class="s4">, </span><span class="s1">unw_info):</span>
        <span class="s4">return </span><span class="s1">(</span>
            <span class="s5">2</span>
            <span class="s4">if not </span><span class="s1">hasattr(unw_info</span><span class="s4">, </span><span class="s3">&quot;SizeOfEpilog&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">(unw_code.OpInfo &amp; </span><span class="s5">1</span><span class="s1">) == </span><span class="s5">0</span>
            <span class="s4">else </span><span class="s5">1</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">get_offset(self):</span>
        <span class="s4">return </span><span class="s1">self.struct.OffsetLow | (</span>
            <span class="s1">self.struct.OffsetHigh &lt;&lt; </span><span class="s5">8 </span><span class="s4">if </span><span class="s1">self._long_offst </span><span class="s4">else </span><span class="s5">0</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">is_valid(self):</span>
        <span class="s4">return </span><span class="s1">self.get_offset() &gt; </span><span class="s5">0</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s0"># the EPILOG sequence may have a terminating all-zeros entry</span>
        <span class="s4">return </span><span class="s1">(</span>
            <span class="s3">&quot;EPILOG: size=&quot;</span>
            <span class="s1">+ hex(self._epilog_size)</span>
            <span class="s1">+ </span><span class="s3">&quot;, offset from the end=-&quot;</span>
            <span class="s1">+ hex(self.get_offset())</span>
            <span class="s4">if </span><span class="s1">self.get_offset() &gt; </span><span class="s5">0</span>
            <span class="s4">else </span><span class="s3">&quot;&quot;</span>
        <span class="s1">)</span>


<span class="s4">class </span><span class="s1">PrologEpilogOpsFactory:</span>
    <span class="s2">&quot;&quot;&quot;A factory for creating unwind codes based on the value of UnwindOp&quot;&quot;&quot;</span>

    <span class="s1">_class_dict = {</span>
        <span class="s1">UWOP_PUSH_NONVOL: PrologEpilogOpPushReg</span><span class="s4">,</span>
        <span class="s1">UWOP_ALLOC_LARGE: PrologEpilogOpAllocLarge</span><span class="s4">,</span>
        <span class="s1">UWOP_ALLOC_SMALL: PrologEpilogOpAllocSmall</span><span class="s4">,</span>
        <span class="s1">UWOP_SET_FPREG: PrologEpilogOpSetFP</span><span class="s4">,</span>
        <span class="s1">UWOP_SAVE_NONVOL: PrologEpilogOpSaveReg</span><span class="s4">,</span>
        <span class="s1">UWOP_SAVE_NONVOL_FAR: PrologEpilogOpSaveRegFar</span><span class="s4">,</span>
        <span class="s1">UWOP_SAVE_XMM128: PrologEpilogOpSaveXMM</span><span class="s4">,</span>
        <span class="s1">UWOP_SAVE_XMM128_FAR: PrologEpilogOpSaveXMMFar</span><span class="s4">,</span>
        <span class="s1">UWOP_PUSH_MACHFRAME: PrologEpilogOpPushFrame</span><span class="s4">,</span>
        <span class="s1">UWOP_EPILOG: PrologEpilogOpEpilogMarker</span><span class="s4">,</span>
    <span class="s1">}</span>

    <span class="s1">@staticmethod</span>
    <span class="s4">def </span><span class="s1">create(unwcode):</span>
        <span class="s1">code = unwcode.UnwindOp</span>
        <span class="s4">return </span><span class="s1">(</span>
            <span class="s1">PrologEpilogOpsFactory._class_dict[code]()</span>
            <span class="s4">if </span><span class="s1">code </span><span class="s4">in </span><span class="s1">PrologEpilogOpsFactory._class_dict</span>
            <span class="s4">else None</span>
        <span class="s1">)</span>


<span class="s0"># Valid FAT32 8.3 short filename characters according to:</span>
<span class="s0">#  http://en.wikipedia.org/wiki/8.3_filename</span>
<span class="s0"># This will help decide whether DLL ASCII names are likely</span>
<span class="s0"># to be valid or otherwise corrupt data</span>
<span class="s0">#</span>
<span class="s0"># The filename length is not checked because the DLLs filename</span>
<span class="s0"># can be longer that the 8.3</span>

<span class="s1">allowed_filename = b(</span>
    <span class="s1">string.ascii_lowercase</span>
    <span class="s1">+ string.ascii_uppercase</span>
    <span class="s1">+ string.digits</span>
    <span class="s1">+ </span><span class="s3">&quot;!#$%&amp;'()-@^_`{}~+,.;=[]&quot;</span>
<span class="s1">)</span>


<span class="s4">def </span><span class="s1">is_valid_dos_filename(s):</span>
    <span class="s4">if </span><span class="s1">s </span><span class="s4">is None or not </span><span class="s1">isinstance(s</span><span class="s4">, </span><span class="s1">(str</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">, </span><span class="s1">bytearray)):</span>
        <span class="s4">return False</span>
    <span class="s0"># Allow path separators as import names can contain directories.</span>
    <span class="s1">allowed = allowed_filename + </span><span class="s6">b&quot;</span><span class="s4">\\</span><span class="s6">/&quot;</span>
    <span class="s4">return </span><span class="s1">all(c </span><span class="s4">in </span><span class="s1">allowed </span><span class="s4">for </span><span class="s1">c </span><span class="s4">in </span><span class="s1">set(s))</span>


<span class="s0"># Check if an imported name uses the valid accepted characters expected in</span>
<span class="s0"># mangled function names. If the symbol's characters don't fall within this</span>
<span class="s0"># charset we will assume the name is invalid.</span>
<span class="s0"># The dot &quot;.&quot; character comes from: https://github.com/erocarrera/pefile/pull/346</span>
<span class="s0"># All other symbols can be inserted by adding a name with that symbol to a .def file,</span>
<span class="s0"># and passing it to link.exe (See export_test.py)</span>
<span class="s1">allowed_function_name = b(</span>
    <span class="s1">string.ascii_lowercase + string.ascii_uppercase + string.digits</span>
<span class="s1">)</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s5">2048</span><span class="s1">)</span>
<span class="s4">def </span><span class="s1">is_valid_function_name(</span>
    <span class="s1">s: Union[str</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">, </span><span class="s1">bytearray]</span><span class="s4">, </span><span class="s1">relax_allowed_characters: bool = </span><span class="s4">False</span>
<span class="s1">) -&gt; bool:</span>
    <span class="s1">allowed_extra = </span><span class="s6">b&quot;._?@$()&lt;&gt;&quot;</span>
    <span class="s4">if </span><span class="s1">relax_allowed_characters:</span>
        <span class="s1">allowed_extra = </span><span class="s6">b&quot;!</span><span class="s4">\&quot;</span><span class="s6">#$%&amp;'()*+,-./:&lt;&gt;?[</span><span class="s4">\\</span><span class="s6">]^_`{|}~@&quot;</span>
    <span class="s4">return </span><span class="s1">(</span>
        <span class="s1">s </span><span class="s4">is not None</span>
        <span class="s4">and </span><span class="s1">isinstance(s</span><span class="s4">, </span><span class="s1">(str</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">, </span><span class="s1">bytearray))</span>
        <span class="s4">and </span><span class="s1">all((c </span><span class="s4">in </span><span class="s1">allowed_function_name </span><span class="s4">or </span><span class="s1">c </span><span class="s4">in </span><span class="s1">allowed_extra) </span><span class="s4">for </span><span class="s1">c </span><span class="s4">in </span><span class="s1">set(s))</span>
    <span class="s1">)</span>


<span class="s4">class </span><span class="s1">PE:</span>
    <span class="s2">&quot;&quot;&quot;A Portable Executable representation. 
 
    This class provides access to most of the information in a PE file. 
 
    It expects to be supplied the name of the file to load or PE data 
    to process and an optional argument 'fast_load' (False by default) 
    which controls whether to load all the directories information, 
    which can be quite time consuming. 
 
    pe = pefile.PE('module.dll') 
    pe = pefile.PE(name='module.dll') 
 
    would load 'module.dll' and process it. If the data is already 
    available in a buffer the same can be achieved with: 
 
    pe = pefile.PE(data=module_dll_data) 
 
    The &quot;fast_load&quot; can be set to a default by setting its value in the 
    module itself by means, for instance, of a &quot;pefile.fast_load = True&quot;. 
    That will make all the subsequent instances not to load the 
    whole PE structure. The &quot;full_load&quot; method can be used to parse 
    the missing data at a later stage. 
 
    Basic headers information will be available in the attributes: 
 
    DOS_HEADER 
    NT_HEADERS 
    FILE_HEADER 
    OPTIONAL_HEADER 
 
    All of them will contain among their attributes the members of the 
    corresponding structures as defined in WINNT.H 
 
    The raw data corresponding to the header (from the beginning of the 
    file up to the start of the first section) will be available in the 
    instance's attribute 'header' as a string. 
 
    The sections will be available as a list in the 'sections' attribute. 
    Each entry will contain as attributes all the structure's members. 
 
    Directory entries will be available as attributes (if they exist): 
    (no other entries are processed at this point) 
 
    DIRECTORY_ENTRY_IMPORT (list of ImportDescData instances) 
    DIRECTORY_ENTRY_EXPORT (ExportDirData instance) 
    DIRECTORY_ENTRY_RESOURCE (ResourceDirData instance) 
    DIRECTORY_ENTRY_DEBUG (list of DebugData instances) 
    DIRECTORY_ENTRY_BASERELOC (list of BaseRelocationData instances) 
    DIRECTORY_ENTRY_TLS 
    DIRECTORY_ENTRY_BOUND_IMPORT (list of BoundImportData instances) 
 
    The following dictionary attributes provide ways of mapping different 
    constants. They will accept the numeric value and return the string 
    representation and the opposite, feed in the string and get the 
    numeric constant: 
 
    DIRECTORY_ENTRY 
    IMAGE_CHARACTERISTICS 
    SECTION_CHARACTERISTICS 
    DEBUG_TYPE 
    SUBSYSTEM_TYPE 
    MACHINE_TYPE 
    RELOCATION_TYPE 
    RESOURCE_TYPE 
    LANG 
    SUBLANG 
    &quot;&quot;&quot;</span>

    <span class="s0">#</span>
    <span class="s0"># Format specifications for PE structures.</span>
    <span class="s0">#</span>

    <span class="s1">__IMAGE_DOS_HEADER_format__ = (</span>
        <span class="s3">&quot;IMAGE_DOS_HEADER&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;H,e_magic&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_cblp&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_cp&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_crlc&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_cparhdr&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_minalloc&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_maxalloc&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_ss&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_sp&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_csum&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_ip&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_cs&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_lfarlc&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_ovno&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;8s,e_res&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_oemid&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,e_oeminfo&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;20s,e_res2&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,e_lfanew&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_FILE_HEADER_format__ = (</span>
        <span class="s3">&quot;IMAGE_FILE_HEADER&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;H,Machine&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,NumberOfSections&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,TimeDateStamp&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,PointerToSymbolTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,NumberOfSymbols&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,SizeOfOptionalHeader&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,Characteristics&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_DATA_DIRECTORY_format__ = (</span>
        <span class="s3">&quot;IMAGE_DATA_DIRECTORY&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I,VirtualAddress&quot;</span><span class="s4">, </span><span class="s3">&quot;I,Size&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_OPTIONAL_HEADER_format__ = (</span>
        <span class="s3">&quot;IMAGE_OPTIONAL_HEADER&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;H,Magic&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;B,MajorLinkerVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;B,MinorLinkerVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfCode&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfInitializedData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfUninitializedData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,AddressOfEntryPoint&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,BaseOfCode&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,BaseOfData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,ImageBase&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SectionAlignment&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,FileAlignment&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MajorOperatingSystemVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MinorOperatingSystemVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MajorImageVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MinorImageVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MajorSubsystemVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MinorSubsystemVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,Reserved1&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfImage&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfHeaders&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,CheckSum&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,Subsystem&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,DllCharacteristics&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfStackReserve&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfStackCommit&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfHeapReserve&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfHeapCommit&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,LoaderFlags&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,NumberOfRvaAndSizes&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_OPTIONAL_HEADER64_format__ = (</span>
        <span class="s3">&quot;IMAGE_OPTIONAL_HEADER64&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;H,Magic&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;B,MajorLinkerVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;B,MinorLinkerVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfCode&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfInitializedData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfUninitializedData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,AddressOfEntryPoint&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,BaseOfCode&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,ImageBase&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SectionAlignment&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,FileAlignment&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MajorOperatingSystemVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MinorOperatingSystemVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MajorImageVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MinorImageVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MajorSubsystemVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MinorSubsystemVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,Reserved1&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfImage&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfHeaders&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,CheckSum&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,Subsystem&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,DllCharacteristics&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,SizeOfStackReserve&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,SizeOfStackCommit&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,SizeOfHeapReserve&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,SizeOfHeapCommit&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,LoaderFlags&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,NumberOfRvaAndSizes&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_NT_HEADERS_format__ = (</span><span class="s3">&quot;IMAGE_NT_HEADERS&quot;</span><span class="s4">, </span><span class="s1">(</span><span class="s3">&quot;I,Signature&quot;</span><span class="s4">,</span><span class="s1">))</span>

    <span class="s1">__IMAGE_SECTION_HEADER_format__ = (</span>
        <span class="s3">&quot;IMAGE_SECTION_HEADER&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;8s,Name&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,Misc,Misc_PhysicalAddress,Misc_VirtualSize&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,VirtualAddress&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfRawData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,PointerToRawData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,PointerToRelocations&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,PointerToLinenumbers&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,NumberOfRelocations&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,NumberOfLinenumbers&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,Characteristics&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_DELAY_IMPORT_DESCRIPTOR_format__ = (</span>
        <span class="s3">&quot;IMAGE_DELAY_IMPORT_DESCRIPTOR&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;I,grAttrs&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,szName&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,phmod&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,pIAT&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,pINT&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,pBoundIAT&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,pUnloadIAT&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,dwTimeStamp&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_IMPORT_DESCRIPTOR_format__ = (</span>
        <span class="s3">&quot;IMAGE_IMPORT_DESCRIPTOR&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;I,OriginalFirstThunk,Characteristics&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,TimeDateStamp&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,ForwarderChain&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,Name&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,FirstThunk&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_EXPORT_DIRECTORY_format__ = (</span>
        <span class="s3">&quot;IMAGE_EXPORT_DIRECTORY&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;I,Characteristics&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,TimeDateStamp&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MajorVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MinorVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,Name&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,Base&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,NumberOfFunctions&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,NumberOfNames&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,AddressOfFunctions&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,AddressOfNames&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,AddressOfNameOrdinals&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_RESOURCE_DIRECTORY_format__ = (</span>
        <span class="s3">&quot;IMAGE_RESOURCE_DIRECTORY&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;I,Characteristics&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,TimeDateStamp&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MajorVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MinorVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,NumberOfNamedEntries&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,NumberOfIdEntries&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_RESOURCE_DIRECTORY_ENTRY_format__ = (</span>
        <span class="s3">&quot;IMAGE_RESOURCE_DIRECTORY_ENTRY&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I,Name&quot;</span><span class="s4">, </span><span class="s3">&quot;I,OffsetToData&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_RESOURCE_DATA_ENTRY_format__ = (</span>
        <span class="s3">&quot;IMAGE_RESOURCE_DATA_ENTRY&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I,OffsetToData&quot;</span><span class="s4">, </span><span class="s3">&quot;I,Size&quot;</span><span class="s4">, </span><span class="s3">&quot;I,CodePage&quot;</span><span class="s4">, </span><span class="s3">&quot;I,Reserved&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__VS_VERSIONINFO_format__ = (</span>
        <span class="s3">&quot;VS_VERSIONINFO&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;H,Length&quot;</span><span class="s4">, </span><span class="s3">&quot;H,ValueLength&quot;</span><span class="s4">, </span><span class="s3">&quot;H,Type&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__VS_FIXEDFILEINFO_format__ = (</span>
        <span class="s3">&quot;VS_FIXEDFILEINFO&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;I,Signature&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,StrucVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,FileVersionMS&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,FileVersionLS&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,ProductVersionMS&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,ProductVersionLS&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,FileFlagsMask&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,FileFlags&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,FileOS&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,FileType&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,FileSubtype&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,FileDateMS&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,FileDateLS&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__StringFileInfo_format__ = (</span>
        <span class="s3">&quot;StringFileInfo&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;H,Length&quot;</span><span class="s4">, </span><span class="s3">&quot;H,ValueLength&quot;</span><span class="s4">, </span><span class="s3">&quot;H,Type&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__StringTable_format__ = (</span><span class="s3">&quot;StringTable&quot;</span><span class="s4">, </span><span class="s1">(</span><span class="s3">&quot;H,Length&quot;</span><span class="s4">, </span><span class="s3">&quot;H,ValueLength&quot;</span><span class="s4">, </span><span class="s3">&quot;H,Type&quot;</span><span class="s1">))</span>

    <span class="s1">__String_format__ = (</span><span class="s3">&quot;String&quot;</span><span class="s4">, </span><span class="s1">(</span><span class="s3">&quot;H,Length&quot;</span><span class="s4">, </span><span class="s3">&quot;H,ValueLength&quot;</span><span class="s4">, </span><span class="s3">&quot;H,Type&quot;</span><span class="s1">))</span>

    <span class="s1">__Var_format__ = (</span><span class="s3">&quot;Var&quot;</span><span class="s4">, </span><span class="s1">(</span><span class="s3">&quot;H,Length&quot;</span><span class="s4">, </span><span class="s3">&quot;H,ValueLength&quot;</span><span class="s4">, </span><span class="s3">&quot;H,Type&quot;</span><span class="s1">))</span>

    <span class="s1">__IMAGE_THUNK_DATA_format__ = (</span>
        <span class="s3">&quot;IMAGE_THUNK_DATA&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I,ForwarderString,Function,Ordinal,AddressOfData&quot;</span><span class="s4">,</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_THUNK_DATA64_format__ = (</span>
        <span class="s3">&quot;IMAGE_THUNK_DATA&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;Q,ForwarderString,Function,Ordinal,AddressOfData&quot;</span><span class="s4">,</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_DEBUG_DIRECTORY_format__ = (</span>
        <span class="s3">&quot;IMAGE_DEBUG_DIRECTORY&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;I,Characteristics&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,TimeDateStamp&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MajorVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MinorVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,Type&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,AddressOfRawData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,PointerToRawData&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_BASE_RELOCATION_format__ = (</span>
        <span class="s3">&quot;IMAGE_BASE_RELOCATION&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I,VirtualAddress&quot;</span><span class="s4">, </span><span class="s3">&quot;I,SizeOfBlock&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_BASE_RELOCATION_ENTRY_format__ = (</span>
        <span class="s3">&quot;IMAGE_BASE_RELOCATION_ENTRY&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;H,Data&quot;</span><span class="s4">,</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION_format__ = (</span>
        <span class="s3">&quot;IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I:12,PageRelativeOffset&quot;</span><span class="s4">, </span><span class="s3">&quot;I:1,IndirectCall&quot;</span><span class="s4">, </span><span class="s3">&quot;I:19,IATIndex&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION_format__ = (</span>
        <span class="s3">&quot;IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;I:12,PageRelativeOffset&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I:1,IndirectCall&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I:1,RexWPrefix&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I:1,CfgCheck&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I:1,Reserved&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION_format__ = (</span>
        <span class="s3">&quot;IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I:12,PageRelativeOffset&quot;</span><span class="s4">, </span><span class="s3">&quot;I:4,RegisterNumber&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_TLS_DIRECTORY_format__ = (</span>
        <span class="s3">&quot;IMAGE_TLS_DIRECTORY&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;I,StartAddressOfRawData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,EndAddressOfRawData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,AddressOfIndex&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,AddressOfCallBacks&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfZeroFill&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,Characteristics&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_TLS_DIRECTORY64_format__ = (</span>
        <span class="s3">&quot;IMAGE_TLS_DIRECTORY&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;Q,StartAddressOfRawData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,EndAddressOfRawData&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,AddressOfIndex&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,AddressOfCallBacks&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SizeOfZeroFill&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,Characteristics&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_LOAD_CONFIG_DIRECTORY_format__ = (</span>
        <span class="s3">&quot;IMAGE_LOAD_CONFIG_DIRECTORY&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;I,Size&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,TimeDateStamp&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MajorVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MinorVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GlobalFlagsClear&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GlobalFlagsSet&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,CriticalSectionDefaultTimeout&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,DeCommitFreeBlockThreshold&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,DeCommitTotalFreeThreshold&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,LockPrefixTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,MaximumAllocationSize&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,VirtualMemoryThreshold&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,ProcessHeapFlags&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,ProcessAffinityMask&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,CSDVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,Reserved1&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,EditList&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SecurityCookie&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SEHandlerTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,SEHandlerCount&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardCFCheckFunctionPointer&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardCFDispatchFunctionPointer&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardCFFunctionTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardCFFunctionCount&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardFlags&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,CodeIntegrityFlags&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,CodeIntegrityCatalog&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,CodeIntegrityCatalogOffset&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,CodeIntegrityReserved&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardAddressTakenIatEntryTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardAddressTakenIatEntryCount&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardLongJumpTargetTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardLongJumpTargetCount&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,DynamicValueRelocTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,CHPEMetadataPointer&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardRFFailureRoutine&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardRFFailureRoutineFunctionPointer&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,DynamicValueRelocTableOffset&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,DynamicValueRelocTableSection&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,Reserved2&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardRFVerifyStackPointerFunctionPointer&quot; &quot;I,HotPatchTableOffset&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,Reserved3&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,EnclaveConfigurationPointer&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_LOAD_CONFIG_DIRECTORY64_format__ = (</span>
        <span class="s3">&quot;IMAGE_LOAD_CONFIG_DIRECTORY&quot;</span><span class="s4">,</span>
        <span class="s1">(</span>
            <span class="s3">&quot;I,Size&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,TimeDateStamp&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MajorVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,MinorVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GlobalFlagsClear&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GlobalFlagsSet&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,CriticalSectionDefaultTimeout&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,DeCommitFreeBlockThreshold&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,DeCommitTotalFreeThreshold&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,LockPrefixTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,MaximumAllocationSize&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,VirtualMemoryThreshold&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,ProcessAffinityMask&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,ProcessHeapFlags&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,CSDVersion&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,Reserved1&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,EditList&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,SecurityCookie&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,SEHandlerTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,SEHandlerCount&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,GuardCFCheckFunctionPointer&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,GuardCFDispatchFunctionPointer&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,GuardCFFunctionTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,GuardCFFunctionCount&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,GuardFlags&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,CodeIntegrityFlags&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,CodeIntegrityCatalog&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,CodeIntegrityCatalogOffset&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,CodeIntegrityReserved&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,GuardAddressTakenIatEntryTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,GuardAddressTakenIatEntryCount&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,GuardLongJumpTargetTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,GuardLongJumpTargetCount&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,DynamicValueRelocTable&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,CHPEMetadataPointer&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,GuardRFFailureRoutine&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,GuardRFFailureRoutineFunctionPointer&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,DynamicValueRelocTableOffset&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,DynamicValueRelocTableSection&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;H,Reserved2&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,GuardRFVerifyStackPointerFunctionPointer&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,HotPatchTableOffset&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;I,Reserved3&quot;</span><span class="s4">,</span>
            <span class="s3">&quot;Q,EnclaveConfigurationPointer&quot;</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_DYNAMIC_RELOCATION_TABLE_format__ = (</span>
        <span class="s3">&quot;IMAGE_DYNAMIC_RELOCATION_TABLE&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I,Version&quot;</span><span class="s4">, </span><span class="s3">&quot;I,Size&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_DYNAMIC_RELOCATION_format__ = (</span>
        <span class="s3">&quot;IMAGE_DYNAMIC_RELOCATION&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I,Symbol&quot;</span><span class="s4">, </span><span class="s3">&quot;I,BaseRelocSize&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_DYNAMIC_RELOCATION64_format__ = (</span>
        <span class="s3">&quot;IMAGE_DYNAMIC_RELOCATION64&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;Q,Symbol&quot;</span><span class="s4">, </span><span class="s3">&quot;I,BaseRelocSize&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_DYNAMIC_RELOCATION_V2_format__ = (</span>
        <span class="s3">&quot;IMAGE_DYNAMIC_RELOCATION_V2&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I,HeaderSize&quot;</span><span class="s4">, </span><span class="s3">&quot;I,FixupInfoSize&quot;</span><span class="s4">, </span><span class="s3">&quot;I,Symbol&quot;</span><span class="s4">, </span><span class="s3">&quot;I,SymbolGroup&quot;</span><span class="s4">, </span><span class="s3">&quot;I,Flags&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_DYNAMIC_RELOCATION64_V2_format__ = (</span>
        <span class="s3">&quot;IMAGE_DYNAMIC_RELOCATION64_V2&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I,HeaderSize&quot;</span><span class="s4">, </span><span class="s3">&quot;I,FixupInfoSize&quot;</span><span class="s4">, </span><span class="s3">&quot;Q,Symbol&quot;</span><span class="s4">, </span><span class="s3">&quot;I,SymbolGroup&quot;</span><span class="s4">, </span><span class="s3">&quot;I,Flags&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_BOUND_IMPORT_DESCRIPTOR_format__ = (</span>
        <span class="s3">&quot;IMAGE_BOUND_IMPORT_DESCRIPTOR&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I,TimeDateStamp&quot;</span><span class="s4">, </span><span class="s3">&quot;H,OffsetModuleName&quot;</span><span class="s4">, </span><span class="s3">&quot;H,NumberOfModuleForwarderRefs&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__IMAGE_BOUND_FORWARDER_REF_format__ = (</span>
        <span class="s3">&quot;IMAGE_BOUND_FORWARDER_REF&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I,TimeDateStamp&quot;</span><span class="s4">, </span><span class="s3">&quot;H,OffsetModuleName&quot;</span><span class="s4">, </span><span class="s3">&quot;H,Reserved&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">__RUNTIME_FUNCTION_format__ = (</span>
        <span class="s3">&quot;RUNTIME_FUNCTION&quot;</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;I,BeginAddress&quot;</span><span class="s4">, </span><span class="s3">&quot;I,EndAddress&quot;</span><span class="s4">, </span><span class="s3">&quot;I,UnwindData&quot;</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name=</span><span class="s4">None,</span>
        <span class="s1">data=</span><span class="s4">None,</span>
        <span class="s1">fast_load=</span><span class="s4">None,</span>
        <span class="s1">max_symbol_exports=MAX_SYMBOL_EXPORT_COUNT</span><span class="s4">,</span>
        <span class="s1">max_repeated_symbol=</span><span class="s5">120</span><span class="s4">,</span>
    <span class="s1">):</span>

        <span class="s1">self.max_symbol_exports = max_symbol_exports</span>
        <span class="s1">self.max_repeated_symbol = max_repeated_symbol</span>

        <span class="s1">self._get_section_by_rva_last_used = </span><span class="s4">None</span>

        <span class="s1">self.sections = []</span>

        <span class="s1">self.__warnings = []</span>

        <span class="s1">self.PE_TYPE = </span><span class="s4">None</span>

        <span class="s4">if </span><span class="s1">name </span><span class="s4">is None and </span><span class="s1">data </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Must supply either name or data&quot;</span><span class="s1">)</span>

        <span class="s0"># This list will keep track of all the structures created.</span>
        <span class="s0"># That will allow for an easy iteration through the list</span>
        <span class="s0"># in order to save the modifications made</span>
        <span class="s1">self.__structures__ = []</span>
        <span class="s1">self.__from_file = </span><span class="s4">None</span>

        <span class="s0"># We only want to print these warnings once</span>
        <span class="s1">self.FileAlignment_Warning = </span><span class="s4">False</span>
        <span class="s1">self.SectionAlignment_Warning = </span><span class="s4">False</span>

        <span class="s0"># Count of total resource entries across nested tables</span>
        <span class="s1">self.__total_resource_entries_count = </span><span class="s5">0</span>
        <span class="s0"># Sum of the size of all resource entries parsed, which should not</span>
        <span class="s0"># exceed the file size.</span>
        <span class="s1">self.__total_resource_bytes = </span><span class="s5">0</span>
        <span class="s0"># The number of imports parsed in this file</span>
        <span class="s1">self.__total_import_symbols = </span><span class="s5">0</span>

        <span class="s1">self.dynamic_relocation_format_by_symbol = {</span>
            <span class="s5">3</span><span class="s1">: PE.__IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION_format__</span><span class="s4">,</span>
            <span class="s5">4</span><span class="s1">: PE.__IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION_format__</span><span class="s4">,</span>
            <span class="s5">5</span><span class="s1">: PE.__IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION_format__</span><span class="s4">,</span>
        <span class="s1">}</span>

        <span class="s1">fast_load = fast_load </span><span class="s4">if </span><span class="s1">fast_load </span><span class="s4">is not None else </span><span class="s1">globals()[</span><span class="s3">&quot;fast_load&quot;</span><span class="s1">]</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">self.__parse__(name</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">fast_load)</span>
        <span class="s4">except</span><span class="s1">:</span>
            <span class="s1">self.close()</span>
            <span class="s4">raise</span>

    <span class="s4">def </span><span class="s1">__enter__(self):</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s4">def </span><span class="s1">__exit__(self</span><span class="s4">, </span><span class="s1">type</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">traceback):</span>
        <span class="s1">self.close()</span>

    <span class="s4">def </span><span class="s1">close(self):</span>
        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">self.__from_file </span><span class="s4">is True</span>
            <span class="s4">and </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;__data__&quot;</span><span class="s1">)</span>
            <span class="s4">and </span><span class="s1">(</span>
                <span class="s1">(isinstance(mmap.mmap</span><span class="s4">, </span><span class="s1">type) </span><span class="s4">and </span><span class="s1">isinstance(self.__data__</span><span class="s4">, </span><span class="s1">mmap.mmap))</span>
                <span class="s4">or </span><span class="s3">&quot;mmap.mmap&quot; </span><span class="s4">in </span><span class="s1">repr(type(self.__data__))</span>
            <span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">self.__data__.close()</span>
            <span class="s4">del </span><span class="s1">self.__data__</span>

    <span class="s4">def </span><span class="s1">__unpack_data__(self</span><span class="s4">, </span><span class="s1">format</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">file_offset):</span>
        <span class="s2">&quot;&quot;&quot;Apply structure format to raw data. 
 
        Returns an unpacked structure object if successful, None otherwise. 
        &quot;&quot;&quot;</span>

        <span class="s1">structure = Structure(format</span><span class="s4">, </span><span class="s1">file_offset=file_offset)</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">structure.__unpack__(data)</span>
        <span class="s4">except </span><span class="s1">PEFormatError </span><span class="s4">as </span><span class="s1">err:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">'Corrupt header &quot;{0}&quot; at file offset {1}. Exception: {2}'</span><span class="s1">.format(</span>
                    <span class="s1">format[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">file_offset</span><span class="s4">, </span><span class="s1">err</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s4">return None</span>

        <span class="s1">self.__structures__.append(structure)</span>

        <span class="s4">return </span><span class="s1">structure</span>

    <span class="s4">def </span><span class="s1">__unpack_data_with_bitfields__(self</span><span class="s4">, </span><span class="s1">format</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">file_offset):</span>
        <span class="s2">&quot;&quot;&quot;Apply structure format to raw data. 
 
        Returns an unpacked structure object if successful, None otherwise. 
        &quot;&quot;&quot;</span>

        <span class="s1">structure = StructureWithBitfields(format</span><span class="s4">, </span><span class="s1">file_offset=file_offset)</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">structure.__unpack__(data)</span>
        <span class="s4">except </span><span class="s1">PEFormatError </span><span class="s4">as </span><span class="s1">err:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">'Corrupt header &quot;{0}&quot; at file offset {1}. Exception: {2}'</span><span class="s1">.format(</span>
                    <span class="s1">format[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">file_offset</span><span class="s4">, </span><span class="s1">err</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s4">return None</span>

        <span class="s1">self.__structures__.append(structure)</span>

        <span class="s4">return </span><span class="s1">structure</span>

    <span class="s4">def </span><span class="s1">__parse__(self</span><span class="s4">, </span><span class="s1">fname</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">fast_load):</span>
        <span class="s2">&quot;&quot;&quot;Parse a Portable Executable file. 
 
        Loads a PE file, parsing all its structures and making them available 
        through the instance's attributes. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">fname </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">stat = os.stat(fname)</span>
            <span class="s4">if </span><span class="s1">stat.st_size == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;The file is empty&quot;</span><span class="s1">)</span>
            <span class="s1">fd = </span><span class="s4">None</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">fd = open(fname</span><span class="s4">, </span><span class="s3">&quot;rb&quot;</span><span class="s1">)</span>
                <span class="s1">self.fileno = fd.fileno()</span>
                <span class="s4">if </span><span class="s1">hasattr(mmap</span><span class="s4">, </span><span class="s3">&quot;MAP_PRIVATE&quot;</span><span class="s1">):</span>
                    <span class="s0"># Unix</span>
                    <span class="s1">self.__data__ = mmap.mmap(self.fileno</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s1">mmap.MAP_PRIVATE)</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s0"># Windows</span>
                    <span class="s1">self.__data__ = mmap.mmap(self.fileno</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s1">access=mmap.ACCESS_READ)</span>
                <span class="s1">self.__from_file = </span><span class="s4">True</span>
            <span class="s4">except </span><span class="s1">IOError </span><span class="s4">as </span><span class="s1">excp:</span>
                <span class="s1">exception_msg = </span><span class="s3">&quot;{0}&quot;</span><span class="s1">.format(excp)</span>
                <span class="s1">exception_msg = exception_msg </span><span class="s4">and </span><span class="s1">(</span><span class="s3">&quot;: %s&quot; </span><span class="s1">% exception_msg)</span>
                <span class="s4">raise </span><span class="s1">Exception(</span>
                    <span class="s3">&quot;Unable to access file '{0}'{1}&quot;</span><span class="s1">.format(fname</span><span class="s4">, </span><span class="s1">exception_msg)</span>
                <span class="s1">)</span>
            <span class="s4">finally</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">fd </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s1">fd.close()</span>
        <span class="s4">elif </span><span class="s1">data </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">self.__data__ = data</span>
            <span class="s1">self.__from_file = </span><span class="s4">False</span>

        <span class="s0"># Resources should not overlap each other, so they should not exceed the</span>
        <span class="s0"># file size.</span>
        <span class="s1">self.__resource_size_limit_upperbounds = len(self.__data__)</span>
        <span class="s1">self.__resource_size_limit_reached = </span><span class="s4">False</span>

        <span class="s4">if not </span><span class="s1">fast_load:</span>
            <span class="s4">for </span><span class="s1">byte</span><span class="s4">, </span><span class="s1">byte_count </span><span class="s4">in </span><span class="s1">Counter(bytearray(self.__data__)).items():</span>
                <span class="s0"># Only report the cases where a byte makes up for more than 50% (if</span>
                <span class="s0"># zero) or 15% (if non-zero) of the file's contents. There are</span>
                <span class="s0"># legitimate PEs where 0x00 bytes are close to 50% of the whole</span>
                <span class="s0"># file's contents.</span>
                <span class="s4">if </span><span class="s1">(byte == </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">byte_count / len(self.__data__) &gt; </span><span class="s5">0.5</span><span class="s1">) </span><span class="s4">or </span><span class="s1">(</span>
                    <span class="s1">byte != </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">byte_count / len(self.__data__) &gt; </span><span class="s5">0.15</span>
                <span class="s1">):</span>
                    <span class="s1">self.__warnings.append(</span>
                        <span class="s1">(</span>
                            <span class="s3">&quot;Byte 0x{0:02x} makes up {1:.4f}% of the file's contents.&quot;</span>
                            <span class="s3">&quot; This may indicate truncation / malformation.&quot;</span>
                        <span class="s1">).format(byte</span><span class="s4">, </span><span class="s5">100.0 </span><span class="s1">* byte_count / len(self.__data__))</span>
                    <span class="s1">)</span>

        <span class="s1">dos_header_data = self.__data__[:</span><span class="s5">64</span><span class="s1">]</span>
        <span class="s4">if </span><span class="s1">len(dos_header_data) != </span><span class="s5">64</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span>
                <span class="s3">&quot;Unable to read the DOS Header, possibly a truncated file.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self.DOS_HEADER = self.__unpack_data__(</span>
            <span class="s1">self.__IMAGE_DOS_HEADER_format__</span><span class="s4">, </span><span class="s1">dos_header_data</span><span class="s4">, </span><span class="s1">file_offset=</span><span class="s5">0</span>
        <span class="s1">)</span>

        <span class="s4">if </span><span class="s1">self.DOS_HEADER.e_magic == IMAGE_DOSZM_SIGNATURE:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;Probably a ZM Executable (not a PE file).&quot;</span><span class="s1">)</span>
        <span class="s4">if not </span><span class="s1">self.DOS_HEADER </span><span class="s4">or </span><span class="s1">self.DOS_HEADER.e_magic != IMAGE_DOS_SIGNATURE:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;DOS Header magic not found.&quot;</span><span class="s1">)</span>

        <span class="s0"># OC Patch:</span>
        <span class="s0"># Check for sane value in e_lfanew</span>
        <span class="s0">#</span>
        <span class="s4">if </span><span class="s1">self.DOS_HEADER.e_lfanew &gt; len(self.__data__):</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;Invalid e_lfanew value, probably not a PE file&quot;</span><span class="s1">)</span>

        <span class="s1">nt_headers_offset = self.DOS_HEADER.e_lfanew</span>

        <span class="s1">self.NT_HEADERS = self.__unpack_data__(</span>
            <span class="s1">self.__IMAGE_NT_HEADERS_format__</span><span class="s4">,</span>
            <span class="s1">self.__data__[nt_headers_offset : nt_headers_offset + </span><span class="s5">8</span><span class="s1">]</span><span class="s4">,</span>
            <span class="s1">file_offset=nt_headers_offset</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s0"># We better check the signature right here, before the file screws</span>
        <span class="s0"># around with sections:</span>
        <span class="s0"># OC Patch:</span>
        <span class="s0"># Some malware will cause the Signature value to not exist at all</span>
        <span class="s4">if not </span><span class="s1">self.NT_HEADERS </span><span class="s4">or not </span><span class="s1">self.NT_HEADERS.Signature:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;NT Headers not found.&quot;</span><span class="s1">)</span>

        <span class="s4">if </span><span class="s1">(</span><span class="s5">0xFFFF </span><span class="s1">&amp; self.NT_HEADERS.Signature) == IMAGE_NE_SIGNATURE:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;Invalid NT Headers signature. Probably a NE file&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s5">0xFFFF </span><span class="s1">&amp; self.NT_HEADERS.Signature) == IMAGE_LE_SIGNATURE:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;Invalid NT Headers signature. Probably a LE file&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s5">0xFFFF </span><span class="s1">&amp; self.NT_HEADERS.Signature) == IMAGE_LX_SIGNATURE:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;Invalid NT Headers signature. Probably a LX file&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s5">0xFFFF </span><span class="s1">&amp; self.NT_HEADERS.Signature) == IMAGE_TE_SIGNATURE:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;Invalid NT Headers signature. Probably a TE file&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">self.NT_HEADERS.Signature != IMAGE_NT_SIGNATURE:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;Invalid NT Headers signature.&quot;</span><span class="s1">)</span>

        <span class="s1">self.FILE_HEADER = self.__unpack_data__(</span>
            <span class="s1">self.__IMAGE_FILE_HEADER_format__</span><span class="s4">,</span>
            <span class="s1">self.__data__[nt_headers_offset + </span><span class="s5">4 </span><span class="s1">: nt_headers_offset + </span><span class="s5">4 </span><span class="s1">+ </span><span class="s5">32</span><span class="s1">]</span><span class="s4">,</span>
            <span class="s1">file_offset=nt_headers_offset + </span><span class="s5">4</span><span class="s4">,</span>
        <span class="s1">)</span>
        <span class="s1">image_flags = retrieve_flags(IMAGE_CHARACTERISTICS</span><span class="s4">, </span><span class="s3">&quot;IMAGE_FILE_&quot;</span><span class="s1">)</span>

        <span class="s4">if not </span><span class="s1">self.FILE_HEADER:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;File Header missing&quot;</span><span class="s1">)</span>

        <span class="s0"># Set the image's flags according the the Characteristics member</span>
        <span class="s1">set_flags(self.FILE_HEADER</span><span class="s4">, </span><span class="s1">self.FILE_HEADER.Characteristics</span><span class="s4">, </span><span class="s1">image_flags)</span>

        <span class="s1">optional_header_offset = nt_headers_offset + </span><span class="s5">4 </span><span class="s1">+ self.FILE_HEADER.sizeof()</span>

        <span class="s0"># Note: location of sections can be controlled from PE header:</span>
        <span class="s1">sections_offset = optional_header_offset + self.FILE_HEADER.SizeOfOptionalHeader</span>

        <span class="s1">self.OPTIONAL_HEADER = self.__unpack_data__(</span>
            <span class="s1">self.__IMAGE_OPTIONAL_HEADER_format__</span><span class="s4">,</span>
            <span class="s0"># Read up to 256 bytes to allow creating a copy of too much data</span>
            <span class="s1">self.__data__[optional_header_offset : optional_header_offset + </span><span class="s5">256</span><span class="s1">]</span><span class="s4">,</span>
            <span class="s1">file_offset=optional_header_offset</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s0"># According to solardesigner's findings for his</span>
        <span class="s0"># Tiny PE project, the optional header does not</span>
        <span class="s0"># need fields beyond &quot;Subsystem&quot; in order to be</span>
        <span class="s0"># loadable by the Windows loader (given that zeros</span>
        <span class="s0"># are acceptable values and the header is loaded</span>
        <span class="s0"># in a zeroed memory page)</span>
        <span class="s0"># If trying to parse a full Optional Header fails</span>
        <span class="s0"># we try to parse it again with some 0 padding</span>
        <span class="s0">#</span>
        <span class="s1">MINIMUM_VALID_OPTIONAL_HEADER_RAW_SIZE = </span><span class="s5">69</span>

        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">self.OPTIONAL_HEADER </span><span class="s4">is None</span>
            <span class="s4">and </span><span class="s1">len(</span>
                <span class="s1">self.__data__[optional_header_offset : optional_header_offset + </span><span class="s5">0x200</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s1">&gt;= MINIMUM_VALID_OPTIONAL_HEADER_RAW_SIZE</span>
        <span class="s1">):</span>

            <span class="s0"># Add enough zeros to make up for the unused fields</span>
            <span class="s0">#</span>
            <span class="s1">padding_length = </span><span class="s5">128</span>

            <span class="s0"># Create padding</span>
            <span class="s0">#</span>
            <span class="s1">padded_data = self.__data__[</span>
                <span class="s1">optional_header_offset : optional_header_offset + </span><span class="s5">0x200</span>
            <span class="s1">] + (</span><span class="s6">b&quot;</span><span class="s4">\0</span><span class="s6">&quot; </span><span class="s1">* padding_length)</span>

            <span class="s1">self.OPTIONAL_HEADER = self.__unpack_data__(</span>
                <span class="s1">self.__IMAGE_OPTIONAL_HEADER_format__</span><span class="s4">,</span>
                <span class="s1">padded_data</span><span class="s4">,</span>
                <span class="s1">file_offset=optional_header_offset</span><span class="s4">,</span>
            <span class="s1">)</span>

        <span class="s0"># Check the Magic in the OPTIONAL_HEADER and set the PE file</span>
        <span class="s0"># type accordingly</span>
        <span class="s0">#</span>
        <span class="s4">if </span><span class="s1">self.OPTIONAL_HEADER </span><span class="s4">is not None</span><span class="s1">:</span>

            <span class="s4">if </span><span class="s1">self.OPTIONAL_HEADER.Magic == OPTIONAL_HEADER_MAGIC_PE:</span>

                <span class="s1">self.PE_TYPE = OPTIONAL_HEADER_MAGIC_PE</span>

            <span class="s4">elif </span><span class="s1">self.OPTIONAL_HEADER.Magic == OPTIONAL_HEADER_MAGIC_PE_PLUS:</span>

                <span class="s1">self.PE_TYPE = OPTIONAL_HEADER_MAGIC_PE_PLUS</span>

                <span class="s1">self.OPTIONAL_HEADER = self.__unpack_data__(</span>
                    <span class="s1">self.__IMAGE_OPTIONAL_HEADER64_format__</span><span class="s4">,</span>
                    <span class="s1">self.__data__[</span>
                        <span class="s1">optional_header_offset : optional_header_offset + </span><span class="s5">0x200</span>
                    <span class="s1">]</span><span class="s4">,</span>
                    <span class="s1">file_offset=optional_header_offset</span><span class="s4">,</span>
                <span class="s1">)</span>

                <span class="s0"># Again, as explained above, we try to parse</span>
                <span class="s0"># a reduced form of the Optional Header which</span>
                <span class="s0"># is still valid despite not including all</span>
                <span class="s0"># structure members</span>
                <span class="s0">#</span>
                <span class="s1">MINIMUM_VALID_OPTIONAL_HEADER_RAW_SIZE = </span><span class="s5">69 </span><span class="s1">+ </span><span class="s5">4</span>

                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">self.OPTIONAL_HEADER </span><span class="s4">is None</span>
                    <span class="s4">and </span><span class="s1">len(</span>
                        <span class="s1">self.__data__[</span>
                            <span class="s1">optional_header_offset : optional_header_offset + </span><span class="s5">0x200</span>
                        <span class="s1">]</span>
                    <span class="s1">)</span>
                    <span class="s1">&gt;= MINIMUM_VALID_OPTIONAL_HEADER_RAW_SIZE</span>
                <span class="s1">):</span>

                    <span class="s1">padding_length = </span><span class="s5">128</span>
                    <span class="s1">padded_data = self.__data__[</span>
                        <span class="s1">optional_header_offset : optional_header_offset + </span><span class="s5">0x200</span>
                    <span class="s1">] + (</span><span class="s6">b&quot;</span><span class="s4">\0</span><span class="s6">&quot; </span><span class="s1">* padding_length)</span>
                    <span class="s1">self.OPTIONAL_HEADER = self.__unpack_data__(</span>
                        <span class="s1">self.__IMAGE_OPTIONAL_HEADER64_format__</span><span class="s4">,</span>
                        <span class="s1">padded_data</span><span class="s4">,</span>
                        <span class="s1">file_offset=optional_header_offset</span><span class="s4">,</span>
                    <span class="s1">)</span>

        <span class="s4">if not </span><span class="s1">self.FILE_HEADER:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;File Header missing&quot;</span><span class="s1">)</span>

        <span class="s0"># OC Patch:</span>
        <span class="s0"># Die gracefully if there is no OPTIONAL_HEADER field</span>
        <span class="s0"># 975440f5ad5e2e4a92c4d9a5f22f75c1</span>
        <span class="s4">if </span><span class="s1">self.OPTIONAL_HEADER </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;No Optional Header found, invalid PE32 or PE32+ file.&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">self.PE_TYPE </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Invalid type 0x{0:04x} in Optional Header.&quot;</span><span class="s1">.format(</span>
                    <span class="s1">self.OPTIONAL_HEADER.Magic</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">dll_characteristics_flags = retrieve_flags(</span>
            <span class="s1">DLL_CHARACTERISTICS</span><span class="s4">, </span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_&quot;</span>
        <span class="s1">)</span>

        <span class="s0"># Set the Dll Characteristics flags according the the DllCharacteristics member</span>
        <span class="s1">set_flags(</span>
            <span class="s1">self.OPTIONAL_HEADER</span><span class="s4">,</span>
            <span class="s1">self.OPTIONAL_HEADER.DllCharacteristics</span><span class="s4">,</span>
            <span class="s1">dll_characteristics_flags</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s1">self.OPTIONAL_HEADER.DATA_DIRECTORY = []</span>
        <span class="s0"># offset = (optional_header_offset + self.FILE_HEADER.SizeOfOptionalHeader)</span>
        <span class="s1">offset = optional_header_offset + self.OPTIONAL_HEADER.sizeof()</span>

        <span class="s1">self.NT_HEADERS.FILE_HEADER = self.FILE_HEADER</span>
        <span class="s1">self.NT_HEADERS.OPTIONAL_HEADER = self.OPTIONAL_HEADER</span>

        <span class="s0"># Windows 8 specific check</span>
        <span class="s0">#</span>
        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">self.OPTIONAL_HEADER.AddressOfEntryPoint</span>
            <span class="s1">&lt; self.OPTIONAL_HEADER.SizeOfHeaders</span>
        <span class="s1">):</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;SizeOfHeaders is smaller than AddressOfEntryPoint: this file &quot;</span>
                <span class="s3">&quot;cannot run under Windows 8.&quot;</span>
            <span class="s1">)</span>

        <span class="s0"># The NumberOfRvaAndSizes is sanitized to stay within</span>
        <span class="s0"># reasonable limits so can be casted to an int</span>
        <span class="s0">#</span>
        <span class="s4">if </span><span class="s1">self.OPTIONAL_HEADER.NumberOfRvaAndSizes &gt; </span><span class="s5">0x10</span><span class="s1">:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Suspicious NumberOfRvaAndSizes in the Optional Header. &quot;</span>
                <span class="s3">&quot;Normal values are never larger than 0x10, the value is: 0x%x&quot;</span>
                <span class="s1">% self.OPTIONAL_HEADER.NumberOfRvaAndSizes</span>
            <span class="s1">)</span>

        <span class="s1">MAX_ASSUMED_VALID_NUMBER_OF_RVA_AND_SIZES = </span><span class="s5">0x100</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(int(</span><span class="s5">0x7FFFFFFF </span><span class="s1">&amp; self.OPTIONAL_HEADER.NumberOfRvaAndSizes)):</span>

            <span class="s4">if </span><span class="s1">len(self.__data__) - offset == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">break</span>

            <span class="s4">if </span><span class="s1">len(self.__data__) - offset &lt; </span><span class="s5">8</span><span class="s1">:</span>
                <span class="s1">data = self.__data__[offset:] + </span><span class="s6">b&quot;</span><span class="s4">\0</span><span class="s6">&quot; </span><span class="s1">* </span><span class="s5">8</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">data = self.__data__[</span>
                    <span class="s1">offset : offset + MAX_ASSUMED_VALID_NUMBER_OF_RVA_AND_SIZES</span>
                <span class="s1">]</span>

            <span class="s1">dir_entry = self.__unpack_data__(</span>
                <span class="s1">self.__IMAGE_DATA_DIRECTORY_format__</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">file_offset=offset</span>
            <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">dir_entry </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s4">break</span>

            <span class="s0"># Would fail if missing an entry</span>
            <span class="s0"># 1d4937b2fa4d84ad1bce0309857e70ca offending sample</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">dir_entry.name = DIRECTORY_ENTRY[i]</span>
            <span class="s4">except </span><span class="s1">(KeyError</span><span class="s4">, </span><span class="s1">AttributeError):</span>
                <span class="s4">break</span>

            <span class="s1">offset += dir_entry.sizeof()</span>

            <span class="s1">self.OPTIONAL_HEADER.DATA_DIRECTORY.append(dir_entry)</span>

            <span class="s0"># If the offset goes outside the optional header,</span>
            <span class="s0"># the loop is broken, regardless of how many directories</span>
            <span class="s0"># NumberOfRvaAndSizes says there are</span>
            <span class="s0">#</span>
            <span class="s0"># We assume a normally sized optional header, hence that we do</span>
            <span class="s0"># a sizeof() instead of reading SizeOfOptionalHeader.</span>
            <span class="s0"># Then we add a default number of directories times their size,</span>
            <span class="s0"># if we go beyond that, we assume the number of directories</span>
            <span class="s0"># is wrong and stop processing</span>
            <span class="s4">if </span><span class="s1">offset &gt;= (</span>
                <span class="s1">optional_header_offset + self.OPTIONAL_HEADER.sizeof() + </span><span class="s5">8 </span><span class="s1">* </span><span class="s5">16</span>
            <span class="s1">):</span>

                <span class="s4">break</span>

        <span class="s1">offset = self.parse_sections(sections_offset)</span>

        <span class="s0"># OC Patch:</span>
        <span class="s0"># There could be a problem if there are no raw data sections</span>
        <span class="s0"># greater than 0</span>
        <span class="s0"># fc91013eb72529da005110a3403541b6 example</span>
        <span class="s0"># Should this throw an exception in the minimum header offset</span>
        <span class="s0"># can't be found?</span>
        <span class="s0">#</span>
        <span class="s1">rawDataPointers = [</span>
            <span class="s1">self.adjust_FileAlignment(</span>
                <span class="s1">s.PointerToRawData</span><span class="s4">, </span><span class="s1">self.OPTIONAL_HEADER.FileAlignment</span>
            <span class="s1">)</span>
            <span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">self.sections</span>
            <span class="s4">if </span><span class="s1">s.PointerToRawData &gt; </span><span class="s5">0</span>
        <span class="s1">]</span>

        <span class="s4">if </span><span class="s1">len(rawDataPointers) &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">lowest_section_offset = min(rawDataPointers)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">lowest_section_offset = </span><span class="s4">None</span>

        <span class="s4">if not </span><span class="s1">lowest_section_offset </span><span class="s4">or </span><span class="s1">lowest_section_offset &lt; offset:</span>
            <span class="s1">self.header = self.__data__[:offset]</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.header = self.__data__[:lowest_section_offset]</span>

        <span class="s0"># Check whether the entry point lies within a section</span>
        <span class="s0">#</span>
        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">self.get_section_by_rva(self.OPTIONAL_HEADER.AddressOfEntryPoint)</span>
            <span class="s4">is not None</span>
        <span class="s1">):</span>

            <span class="s0"># Check whether the entry point lies within the file</span>
            <span class="s0">#</span>
            <span class="s1">ep_offset = self.get_offset_from_rva(</span>
                <span class="s1">self.OPTIONAL_HEADER.AddressOfEntryPoint</span>
            <span class="s1">)</span>
            <span class="s4">if </span><span class="s1">ep_offset &gt; len(self.__data__):</span>

                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Possibly corrupt file. AddressOfEntryPoint lies outside the&quot;</span>
                    <span class="s3">&quot; file. AddressOfEntryPoint: 0x%x&quot;</span>
                    <span class="s1">% self.OPTIONAL_HEADER.AddressOfEntryPoint</span>
                <span class="s1">)</span>

        <span class="s4">else</span><span class="s1">:</span>

            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;AddressOfEntryPoint lies outside the sections' boundaries. &quot;</span>
                <span class="s3">&quot;AddressOfEntryPoint: 0x%x&quot; </span><span class="s1">% self.OPTIONAL_HEADER.AddressOfEntryPoint</span>
            <span class="s1">)</span>

        <span class="s4">if not </span><span class="s1">fast_load:</span>
            <span class="s1">self.full_load()</span>

    <span class="s4">def </span><span class="s1">parse_rich_header(self):</span>
        <span class="s2">&quot;&quot;&quot;Parses the rich header 
        see http://www.ntcore.com/files/richsign.htm for more information 
 
        Structure: 
        00 DanS ^ checksum, checksum, checksum, checksum 
        10 Symbol RVA ^ checksum, Symbol size ^ checksum... 
        ... 
        XX Rich, checksum, 0, 0,... 
        &quot;&quot;&quot;</span>

        <span class="s0"># Rich Header constants</span>
        <span class="s0">#</span>
        <span class="s1">DANS = </span><span class="s5">0x536E6144  </span><span class="s0"># 'DanS' as dword</span>
        <span class="s1">RICH = </span><span class="s5">0x68636952  </span><span class="s0"># 'Rich' as dword</span>

        <span class="s1">rich_index = self.__data__.find(</span>
            <span class="s6">b&quot;Rich&quot;</span><span class="s4">, </span><span class="s5">0x80</span><span class="s4">, </span><span class="s1">self.OPTIONAL_HEADER.get_file_offset()</span>
        <span class="s1">)</span>
        <span class="s4">if </span><span class="s1">rich_index == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">return None</span>

        <span class="s0"># Read a block of data</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s0"># The end of the structure is 8 bytes after the start of the Rich</span>
            <span class="s0"># string.</span>
            <span class="s1">rich_data = self.__data__[</span><span class="s5">0x80 </span><span class="s1">: rich_index + </span><span class="s5">8</span><span class="s1">]</span>
            <span class="s0"># Make the data have length a multiple of 4, otherwise the</span>
            <span class="s0"># subsequent parsing will fail. It's not impossible that we retrieve</span>
            <span class="s0"># truncated data that it's not a multiple.</span>
            <span class="s1">rich_data = rich_data[: </span><span class="s5">4 </span><span class="s1">* int(len(rich_data) / </span><span class="s5">4</span><span class="s1">)]</span>
            <span class="s1">data = list(</span>
                <span class="s1">struct.unpack(</span><span class="s3">&quot;&lt;{0}I&quot;</span><span class="s1">.format(int(len(rich_data) / </span><span class="s5">4</span><span class="s1">))</span><span class="s4">, </span><span class="s1">rich_data)</span>
            <span class="s1">)</span>
            <span class="s4">if </span><span class="s1">RICH </span><span class="s4">not in </span><span class="s1">data:</span>
                <span class="s4">return None</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s4">return None</span>

        <span class="s0"># get key, raw_data and clear_data</span>
        <span class="s1">key = struct.pack(</span><span class="s3">&quot;&lt;L&quot;</span><span class="s4">, </span><span class="s1">data[data.index(RICH) + </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">result = {</span><span class="s3">&quot;key&quot;</span><span class="s1">: key}</span>

        <span class="s1">raw_data = rich_data[: rich_data.find(</span><span class="s6">b&quot;Rich&quot;</span><span class="s1">)]</span>
        <span class="s1">result[</span><span class="s3">&quot;raw_data&quot;</span><span class="s1">] = raw_data</span>

        <span class="s1">ord_ = </span><span class="s4">lambda </span><span class="s1">c: ord(c) </span><span class="s4">if not </span><span class="s1">isinstance(c</span><span class="s4">, </span><span class="s1">int) </span><span class="s4">else </span><span class="s1">c</span>

        <span class="s1">clear_data = bytearray()</span>
        <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">val </span><span class="s4">in </span><span class="s1">enumerate(raw_data):</span>
            <span class="s1">clear_data.append((ord_(val) ^ ord_(key[idx % len(key)])))</span>
        <span class="s1">result[</span><span class="s3">&quot;clear_data&quot;</span><span class="s1">] = bytes(clear_data)</span>

        <span class="s0"># the checksum should be present 3 times after the DanS signature</span>
        <span class="s0">#</span>
        <span class="s1">checksum = data[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s4">if </span><span class="s1">data[</span><span class="s5">0</span><span class="s1">] ^ checksum != DANS </span><span class="s4">or </span><span class="s1">data[</span><span class="s5">2</span><span class="s1">] != checksum </span><span class="s4">or </span><span class="s1">data[</span><span class="s5">3</span><span class="s1">] != checksum:</span>
            <span class="s4">return None</span>

        <span class="s1">result[</span><span class="s3">&quot;checksum&quot;</span><span class="s1">] = checksum</span>
        <span class="s1">headervalues = []</span>
        <span class="s1">result[</span><span class="s3">&quot;values&quot;</span><span class="s1">] = headervalues</span>

        <span class="s1">data = data[</span><span class="s5">4</span><span class="s1">:]</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(int(len(data) / </span><span class="s5">2</span><span class="s1">)):</span>

            <span class="s0"># Stop until the Rich footer signature is found</span>
            <span class="s0">#</span>
            <span class="s4">if </span><span class="s1">data[</span><span class="s5">2 </span><span class="s1">* i] == RICH:</span>

                <span class="s0"># it should be followed by the checksum</span>
                <span class="s0">#</span>
                <span class="s4">if </span><span class="s1">data[</span><span class="s5">2 </span><span class="s1">* i + </span><span class="s5">1</span><span class="s1">] != checksum:</span>
                    <span class="s1">self.__warnings.append(</span><span class="s3">&quot;Rich Header is malformed&quot;</span><span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s0"># header values come by pairs</span>
            <span class="s0">#</span>
            <span class="s1">headervalues += [data[</span><span class="s5">2 </span><span class="s1">* i] ^ checksum</span><span class="s4">, </span><span class="s1">data[</span><span class="s5">2 </span><span class="s1">* i + </span><span class="s5">1</span><span class="s1">] ^ checksum]</span>
        <span class="s4">return </span><span class="s1">result</span>

    <span class="s4">def </span><span class="s1">get_warnings(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the list of warnings. 
 
        Non-critical problems found when parsing the PE file are 
        appended to a list of warnings. This method returns the 
        full list. 
        &quot;&quot;&quot;</span>

        <span class="s4">return </span><span class="s1">self.__warnings</span>

    <span class="s4">def </span><span class="s1">show_warnings(self):</span>
        <span class="s2">&quot;&quot;&quot;Print the list of warnings. 
 
        Non-critical problems found when parsing the PE file are 
        appended to a list of warnings. This method prints the 
        full list to standard output. 
        &quot;&quot;&quot;</span>

        <span class="s4">for </span><span class="s1">warning </span><span class="s4">in </span><span class="s1">self.__warnings:</span>
            <span class="s1">print(</span><span class="s3">&quot;&gt;&quot;</span><span class="s4">, </span><span class="s1">warning)</span>

    <span class="s4">def </span><span class="s1">full_load(self):</span>
        <span class="s2">&quot;&quot;&quot;Process the data directories. 
 
        This method will load the data directories which might not have 
        been loaded if the &quot;fast_load&quot; option was used. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.parse_data_directories()</span>

        <span class="s4">class </span><span class="s1">RichHeader:</span>
            <span class="s4">pass</span>

        <span class="s1">rich_header = self.parse_rich_header()</span>
        <span class="s4">if </span><span class="s1">rich_header:</span>
            <span class="s1">self.RICH_HEADER = RichHeader()</span>
            <span class="s1">self.RICH_HEADER.checksum = rich_header.get(</span><span class="s3">&quot;checksum&quot;</span><span class="s4">, None</span><span class="s1">)</span>
            <span class="s1">self.RICH_HEADER.values = rich_header.get(</span><span class="s3">&quot;values&quot;</span><span class="s4">, None</span><span class="s1">)</span>
            <span class="s1">self.RICH_HEADER.key = rich_header.get(</span><span class="s3">&quot;key&quot;</span><span class="s4">, None</span><span class="s1">)</span>
            <span class="s1">self.RICH_HEADER.raw_data = rich_header.get(</span><span class="s3">&quot;raw_data&quot;</span><span class="s4">, None</span><span class="s1">)</span>
            <span class="s1">self.RICH_HEADER.clear_data = rich_header.get(</span><span class="s3">&quot;clear_data&quot;</span><span class="s4">, None</span><span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.RICH_HEADER = </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">write(self</span><span class="s4">, </span><span class="s1">filename=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Write the PE file. 
 
        This function will process all headers and components 
        of the PE file and include all changes made (by just 
        assigning to attributes in the PE objects) and write 
        the changes back to a file whose name is provided as 
        an argument. The filename is optional, if not 
        provided the data will be returned as a 'str' object. 
        &quot;&quot;&quot;</span>

        <span class="s1">file_data = bytearray(self.__data__)</span>

        <span class="s4">for </span><span class="s1">structure </span><span class="s4">in </span><span class="s1">self.__structures__:</span>
            <span class="s1">struct_data = bytearray(structure.__pack__())</span>
            <span class="s1">offset = structure.get_file_offset()</span>
            <span class="s1">file_data[offset : offset + len(struct_data)] = struct_data</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;VS_VERSIONINFO&quot;</span><span class="s1">):</span>
            <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;FileInfo&quot;</span><span class="s1">):</span>
                <span class="s4">for </span><span class="s1">finfo </span><span class="s4">in </span><span class="s1">self.FileInfo:</span>
                    <span class="s4">for </span><span class="s1">entry </span><span class="s4">in </span><span class="s1">finfo:</span>
                        <span class="s4">if </span><span class="s1">hasattr(entry</span><span class="s4">, </span><span class="s3">&quot;StringTable&quot;</span><span class="s1">):</span>
                            <span class="s4">for </span><span class="s1">st_entry </span><span class="s4">in </span><span class="s1">entry.StringTable:</span>
                                <span class="s4">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">entry </span><span class="s4">in </span><span class="s1">list(st_entry.entries.items()):</span>

                                    <span class="s0"># Offsets and lengths of the keys and values.</span>
                                    <span class="s0"># Each value in the dictionary is a tuple:</span>
                                    <span class="s0">#  (key length, value length)</span>
                                    <span class="s0"># The lengths are in characters, not in bytes.</span>
                                    <span class="s1">offsets = st_entry.entries_offsets[key]</span>
                                    <span class="s1">lengths = st_entry.entries_lengths[key]</span>

                                    <span class="s4">if </span><span class="s1">len(entry) &gt; lengths[</span><span class="s5">1</span><span class="s1">]:</span>
                                        <span class="s1">l = entry.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">).encode(</span><span class="s3">&quot;utf-16le&quot;</span><span class="s1">)</span>
                                        <span class="s1">file_data[</span>
                                            <span class="s1">offsets[</span><span class="s5">1</span><span class="s1">] : offsets[</span><span class="s5">1</span><span class="s1">] + lengths[</span><span class="s5">1</span><span class="s1">] * </span><span class="s5">2</span>
                                        <span class="s1">] = l[: lengths[</span><span class="s5">1</span><span class="s1">] * </span><span class="s5">2</span><span class="s1">]</span>
                                    <span class="s4">else</span><span class="s1">:</span>
                                        <span class="s1">encoded_data = entry.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">).encode(</span>
                                            <span class="s3">&quot;utf-16le&quot;</span>
                                        <span class="s1">)</span>
                                        <span class="s1">file_data[</span>
                                            <span class="s1">offsets[</span><span class="s5">1</span><span class="s1">] : offsets[</span><span class="s5">1</span><span class="s1">] + len(encoded_data)</span>
                                        <span class="s1">] = encoded_data</span>

        <span class="s1">new_file_data = file_data</span>
        <span class="s4">if not </span><span class="s1">filename:</span>
            <span class="s4">return </span><span class="s1">new_file_data</span>

        <span class="s1">f = open(filename</span><span class="s4">, </span><span class="s3">&quot;wb+&quot;</span><span class="s1">)</span>
        <span class="s1">f.write(new_file_data)</span>
        <span class="s1">f.close()</span>
        <span class="s4">return</span>

    <span class="s4">def </span><span class="s1">parse_sections(self</span><span class="s4">, </span><span class="s1">offset):</span>
        <span class="s2">&quot;&quot;&quot;Fetch the PE file sections. 
 
        The sections will be readily available in the &quot;sections&quot; attribute. 
        Its attributes will contain all the section information plus &quot;data&quot; 
        a buffer containing the section's data. 
 
        The &quot;Characteristics&quot; member will be processed and attributes 
        representing the section characteristics (with the 'IMAGE_SCN_' 
        string trimmed from the constant's names) will be added to the 
        section instance. 
 
        Refer to the SectionStructure class for additional info. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.sections = []</span>
        <span class="s1">MAX_SIMULTANEOUS_ERRORS = </span><span class="s5">3</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(self.FILE_HEADER.NumberOfSections):</span>
            <span class="s4">if </span><span class="s1">i &gt;= MAX_SECTIONS:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Too many sections {0} (&gt;={1})&quot;</span><span class="s1">.format(</span>
                        <span class="s1">self.FILE_HEADER.NumberOfSections</span><span class="s4">, </span><span class="s1">MAX_SECTIONS</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s4">break</span>
            <span class="s1">simultaneous_errors = </span><span class="s5">0</span>
            <span class="s1">section = SectionStructure(self.__IMAGE_SECTION_HEADER_format__</span><span class="s4">, </span><span class="s1">pe=self)</span>
            <span class="s4">if not </span><span class="s1">section:</span>
                <span class="s4">break</span>
            <span class="s1">section_offset = offset + section.sizeof() * i</span>
            <span class="s1">section.set_file_offset(section_offset)</span>
            <span class="s1">section_data = self.__data__[</span>
                <span class="s1">section_offset : section_offset + section.sizeof()</span>
            <span class="s1">]</span>
            <span class="s0"># Check if the section is all nulls and stop if so.</span>
            <span class="s4">if </span><span class="s1">count_zeroes(section_data) == section.sizeof():</span>
                <span class="s1">self.__warnings.append(</span><span class="s3">f&quot;Invalid section </span><span class="s4">{</span><span class="s1">i</span><span class="s4">}</span><span class="s3">. Contents are null-bytes.&quot;</span><span class="s1">)</span>
                <span class="s4">break</span>
            <span class="s4">if not </span><span class="s1">section_data:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">f&quot;Invalid section </span><span class="s4">{</span><span class="s1">i</span><span class="s4">}</span><span class="s3">. No data in the file (is this corkami's &quot;</span>
                    <span class="s3">&quot;virtsectblXP?).&quot;</span>
                <span class="s1">)</span>
                <span class="s4">break</span>
            <span class="s1">section.__unpack__(section_data)</span>
            <span class="s1">self.__structures__.append(section)</span>

            <span class="s4">if </span><span class="s1">section.SizeOfRawData + section.PointerToRawData &gt; len(self.__data__):</span>
                <span class="s1">simultaneous_errors += </span><span class="s5">1</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">f&quot;Error parsing section </span><span class="s4">{</span><span class="s1">i</span><span class="s4">}</span><span class="s3">. SizeOfRawData is larger than file.&quot;</span>
                <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">self.adjust_FileAlignment(</span>
                <span class="s1">section.PointerToRawData</span><span class="s4">, </span><span class="s1">self.OPTIONAL_HEADER.FileAlignment</span>
            <span class="s1">) &gt; len(self.__data__):</span>
                <span class="s1">simultaneous_errors += </span><span class="s5">1</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">f&quot;Error parsing section </span><span class="s4">{</span><span class="s1">i</span><span class="s4">}</span><span class="s3">. PointerToRawData points beyond &quot;</span>
                    <span class="s3">&quot;the end of the file.&quot;</span>
                <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">section.Misc_VirtualSize &gt; </span><span class="s5">0x10000000</span><span class="s1">:</span>
                <span class="s1">simultaneous_errors += </span><span class="s5">1</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">f&quot;Suspicious value found parsing section </span><span class="s4">{</span><span class="s1">i</span><span class="s4">}</span><span class="s3">. VirtualSize is &quot;</span>
                    <span class="s3">&quot;extremely large &gt; 256MiB.&quot;</span>
                <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">(</span>
                <span class="s1">self.adjust_SectionAlignment(</span>
                    <span class="s1">section.VirtualAddress</span><span class="s4">,</span>
                    <span class="s1">self.OPTIONAL_HEADER.SectionAlignment</span><span class="s4">,</span>
                    <span class="s1">self.OPTIONAL_HEADER.FileAlignment</span><span class="s4">,</span>
                <span class="s1">)</span>
                <span class="s1">&gt; </span><span class="s5">0x10000000</span>
            <span class="s1">):</span>
                <span class="s1">simultaneous_errors += </span><span class="s5">1</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">f&quot;Suspicious value found parsing section </span><span class="s4">{</span><span class="s1">i</span><span class="s4">}</span><span class="s3">. VirtualAddress is &quot;</span>
                    <span class="s3">&quot;beyond 0x10000000.&quot;</span>
                <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">(</span>
                <span class="s1">self.OPTIONAL_HEADER.FileAlignment != </span><span class="s5">0</span>
                <span class="s4">and </span><span class="s1">(section.PointerToRawData % self.OPTIONAL_HEADER.FileAlignment) != </span><span class="s5">0</span>
            <span class="s1">):</span>
                <span class="s1">simultaneous_errors += </span><span class="s5">1</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s1">(</span>
                        <span class="s3">f&quot;Error parsing section </span><span class="s4">{</span><span class="s1">i</span><span class="s4">}</span><span class="s3">. &quot;</span>
                        <span class="s3">&quot;PointerToRawData should normally be &quot;</span>
                        <span class="s3">&quot;a multiple of FileAlignment, this might imply the file &quot;</span>
                        <span class="s3">&quot;is trying to confuse tools which parse this incorrectly.&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">simultaneous_errors &gt;= MAX_SIMULTANEOUS_ERRORS:</span>
                <span class="s1">self.__warnings.append(</span><span class="s3">&quot;Too many warnings parsing section. Aborting.&quot;</span><span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s1">section_flags = retrieve_flags(SECTION_CHARACTERISTICS</span><span class="s4">, </span><span class="s3">&quot;IMAGE_SCN_&quot;</span><span class="s1">)</span>

            <span class="s0"># Set the section's flags according the the Characteristics member</span>
            <span class="s1">set_flags(section</span><span class="s4">, </span><span class="s1">section.Characteristics</span><span class="s4">, </span><span class="s1">section_flags)</span>

            <span class="s4">if </span><span class="s1">section.__dict__.get(</span>
                <span class="s3">&quot;IMAGE_SCN_MEM_WRITE&quot;</span><span class="s4">, False</span>
            <span class="s1">) </span><span class="s4">and </span><span class="s1">section.__dict__.get(</span><span class="s3">&quot;IMAGE_SCN_MEM_EXECUTE&quot;</span><span class="s4">, False</span><span class="s1">):</span>

                <span class="s4">if </span><span class="s1">section.Name.rstrip(</span><span class="s6">b&quot;</span><span class="s4">\x00</span><span class="s6">&quot;</span><span class="s1">) == </span><span class="s6">b&quot;PAGE&quot; </span><span class="s4">and </span><span class="s1">self.is_driver():</span>
                    <span class="s0"># Drivers can have a PAGE section with those flags set without</span>
                    <span class="s0"># implying that it is malicious</span>
                    <span class="s4">pass</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">self.__warnings.append(</span>
                        <span class="s3">f&quot;Suspicious flags set for section </span><span class="s4">{</span><span class="s1">i</span><span class="s4">}</span><span class="s3">. &quot;</span>
                        <span class="s3">&quot;Both IMAGE_SCN_MEM_WRITE and IMAGE_SCN_MEM_EXECUTE are set. &quot;</span>
                        <span class="s3">&quot;This might indicate a packed executable.&quot;</span>
                    <span class="s1">)</span>

            <span class="s1">self.sections.append(section)</span>

        <span class="s0"># Sort the sections by their VirtualAddress and add a field to each of them</span>
        <span class="s0"># with the VirtualAddress of the next section. This will allow to check</span>
        <span class="s0"># for potentially overlapping sections in badly constructed PEs.</span>
        <span class="s1">self.sections.sort(key=</span><span class="s4">lambda </span><span class="s1">a: a.VirtualAddress)</span>
        <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">section </span><span class="s4">in </span><span class="s1">enumerate(self.sections):</span>
            <span class="s4">if </span><span class="s1">idx == len(self.sections) - </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">section.next_section_virtual_address = </span><span class="s4">None</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">section.next_section_virtual_address = self.sections[</span>
                    <span class="s1">idx + </span><span class="s5">1</span>
                <span class="s1">].VirtualAddress</span>

        <span class="s4">if </span><span class="s1">self.FILE_HEADER.NumberOfSections &gt; </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">self.sections:</span>
            <span class="s4">return </span><span class="s1">(</span>
                <span class="s1">offset + self.sections[</span><span class="s5">0</span><span class="s1">].sizeof() * self.FILE_HEADER.NumberOfSections</span>
            <span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">offset</span>

    <span class="s4">def </span><span class="s1">parse_data_directories(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">directories=</span><span class="s4">None, </span><span class="s1">forwarded_exports_only=</span><span class="s4">False, </span><span class="s1">import_dllnames_only=</span><span class="s4">False</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Parse and process the PE file's data directories. 
 
        If the optional argument 'directories' is given, only 
        the directories at the specified indexes will be parsed. 
        Such functionality allows parsing of areas of interest 
        without the burden of having to parse all others. 
        The directories can then be specified as: 
 
        For export / import only: 
 
          directories = [ 0, 1 ] 
 
        or (more verbosely): 
 
          directories = [ DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT'], 
            DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXPORT'] ] 
 
        If 'directories' is a list, the ones that are processed will be removed, 
        leaving only the ones that are not present in the image. 
 
        If `forwarded_exports_only` is True, the IMAGE_DIRECTORY_ENTRY_EXPORT 
        attribute will only contain exports that are forwarded to another DLL. 
 
        If `import_dllnames_only` is True, symbols will not be parsed from 
        the import table and the entries in the IMAGE_DIRECTORY_ENTRY_IMPORT 
        attribute will not have a `symbols` attribute. 
        &quot;&quot;&quot;</span>

        <span class="s1">directory_parsing = (</span>
            <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_IMPORT&quot;</span><span class="s4">, </span><span class="s1">self.parse_import_directory)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_EXPORT&quot;</span><span class="s4">, </span><span class="s1">self.parse_export_directory)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_RESOURCE&quot;</span><span class="s4">, </span><span class="s1">self.parse_resources_directory)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_DEBUG&quot;</span><span class="s4">, </span><span class="s1">self.parse_debug_directory)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_BASERELOC&quot;</span><span class="s4">, </span><span class="s1">self.parse_relocations_directory)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_TLS&quot;</span><span class="s4">, </span><span class="s1">self.parse_directory_tls)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG&quot;</span><span class="s4">, </span><span class="s1">self.parse_directory_load_config)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT&quot;</span><span class="s4">, </span><span class="s1">self.parse_delay_import_directory)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT&quot;</span><span class="s4">, </span><span class="s1">self.parse_directory_bound_imports)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_EXCEPTION&quot;</span><span class="s4">, </span><span class="s1">self.parse_exceptions_directory)</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s4">if </span><span class="s1">directories </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">if not </span><span class="s1">isinstance(directories</span><span class="s4">, </span><span class="s1">(tuple</span><span class="s4">, </span><span class="s1">list)):</span>
                <span class="s1">directories = [directories]</span>

        <span class="s4">for </span><span class="s1">entry </span><span class="s4">in </span><span class="s1">directory_parsing:</span>
            <span class="s0"># OC Patch:</span>
            <span class="s0">#</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">directory_index = DIRECTORY_ENTRY[entry[</span><span class="s5">0</span><span class="s1">]]</span>
                <span class="s1">dir_entry = self.OPTIONAL_HEADER.DATA_DIRECTORY[directory_index]</span>
            <span class="s4">except </span><span class="s1">IndexError:</span>
                <span class="s4">break</span>

            <span class="s0"># Only process all the directories if no individual ones have</span>
            <span class="s0"># been chosen</span>
            <span class="s0">#</span>
            <span class="s4">if </span><span class="s1">directories </span><span class="s4">is None or </span><span class="s1">directory_index </span><span class="s4">in </span><span class="s1">directories:</span>

                <span class="s1">value = </span><span class="s4">None</span>
                <span class="s4">if </span><span class="s1">dir_entry.VirtualAddress:</span>
                    <span class="s4">if </span><span class="s1">(</span>
                        <span class="s1">forwarded_exports_only</span>
                        <span class="s4">and </span><span class="s1">entry[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_EXPORT&quot;</span>
                    <span class="s1">):</span>
                        <span class="s1">value = entry[</span><span class="s5">1</span><span class="s1">](</span>
                            <span class="s1">dir_entry.VirtualAddress</span><span class="s4">,</span>
                            <span class="s1">dir_entry.Size</span><span class="s4">,</span>
                            <span class="s1">forwarded_only=</span><span class="s4">True,</span>
                        <span class="s1">)</span>
                    <span class="s4">elif </span><span class="s1">(</span>
                        <span class="s1">import_dllnames_only</span>
                        <span class="s4">and </span><span class="s1">entry[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_IMPORT&quot;</span>
                    <span class="s1">):</span>
                        <span class="s1">value = entry[</span><span class="s5">1</span><span class="s1">](</span>
                            <span class="s1">dir_entry.VirtualAddress</span><span class="s4">, </span><span class="s1">dir_entry.Size</span><span class="s4">, </span><span class="s1">dllnames_only=</span><span class="s4">True</span>
                        <span class="s1">)</span>

                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s4">try</span><span class="s1">:</span>
                            <span class="s1">value = entry[</span><span class="s5">1</span><span class="s1">](dir_entry.VirtualAddress</span><span class="s4">, </span><span class="s1">dir_entry.Size)</span>
                        <span class="s4">except </span><span class="s1">PEFormatError </span><span class="s4">as </span><span class="s1">excp:</span>
                            <span class="s1">self.__warnings.append(</span>
                                <span class="s3">f'Failed to process directoty &quot;</span><span class="s4">{</span><span class="s1">entry[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">}</span><span class="s3">&quot;: </span><span class="s4">{</span><span class="s1">excp</span><span class="s4">}</span><span class="s3">'</span>
                            <span class="s1">)</span>
                    <span class="s4">if </span><span class="s1">value:</span>
                        <span class="s1">setattr(self</span><span class="s4">, </span><span class="s1">entry[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">6</span><span class="s1">:]</span><span class="s4">, </span><span class="s1">value)</span>

            <span class="s4">if </span><span class="s1">(</span>
                <span class="s1">(directories </span><span class="s4">is not None</span><span class="s1">)</span>
                <span class="s4">and </span><span class="s1">isinstance(directories</span><span class="s4">, </span><span class="s1">list)</span>
                <span class="s4">and </span><span class="s1">(entry[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">in </span><span class="s1">directories)</span>
            <span class="s1">):</span>
                <span class="s1">directories.remove(directory_index)</span>

    <span class="s4">def </span><span class="s1">parse_exceptions_directory(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size):</span>
        <span class="s2">&quot;&quot;&quot;Parses exception directory 
 
        All the code related to handling exception directories is documented in 
        https://auscitte.github.io/systems%20blog/Exception-Directory-pefile#implementation-details 
        &quot;&quot;&quot;</span>

        <span class="s0"># &quot;For x64 and Itanium platforms; the format is different for other platforms&quot;</span>
        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">self.FILE_HEADER.Machine != MACHINE_TYPE[</span><span class="s3">&quot;IMAGE_FILE_MACHINE_AMD64&quot;</span><span class="s1">]</span>
            <span class="s4">and </span><span class="s1">self.FILE_HEADER.Machine != MACHINE_TYPE[</span><span class="s3">&quot;IMAGE_FILE_MACHINE_IA64&quot;</span><span class="s1">]</span>
        <span class="s1">):</span>
            <span class="s4">return None</span>

        <span class="s1">rf = Structure(self.__RUNTIME_FUNCTION_format__)</span>
        <span class="s1">rf_size = rf.sizeof()</span>
        <span class="s1">rva2rt = {}</span>
        <span class="s1">rt_funcs = []</span>
        <span class="s1">rva2infos = {}</span>
        <span class="s4">for </span><span class="s1">_ </span><span class="s4">in </span><span class="s1">range(size // rf_size):</span>
            <span class="s1">rf = self.__unpack_data__(</span>
                <span class="s1">self.__RUNTIME_FUNCTION_format__</span><span class="s4">,</span>
                <span class="s1">self.get_data(rva</span><span class="s4">, </span><span class="s1">rf_size)</span><span class="s4">,</span>
                <span class="s1">file_offset=self.get_offset_from_rva(rva)</span><span class="s4">,</span>
            <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">rf </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s4">break</span>

            <span class="s1">ui = </span><span class="s4">None</span>

            <span class="s4">if </span><span class="s1">(rf.UnwindData &amp; </span><span class="s5">0x1</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s0"># according to &quot;Improving Automated Analysis of Windows x64 Binaries&quot;,</span>
                <span class="s0"># if the lowest bit is set, (UnwindData &amp; ~0x1) should point to the</span>
                <span class="s0"># chained RUNTIME_FUNCTION instead of UNWIND_INFO</span>

                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">rf.UnwindData </span><span class="s4">in </span><span class="s1">rva2infos</span>
                <span class="s1">):  </span><span class="s0"># unwind info data structures can be shared among functions</span>
                    <span class="s1">ui = rva2infos[rf.UnwindData]</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">ui = UnwindInfo(file_offset=self.get_offset_from_rva(rf.UnwindData))</span>
                    <span class="s1">rva2infos[rf.UnwindData] = ui</span>

                <span class="s1">ws = ui.unpack_in_stages(self.get_data(rf.UnwindData</span><span class="s4">, </span><span class="s1">ui.sizeof()))</span>
                <span class="s4">if </span><span class="s1">ws != </span><span class="s4">None</span><span class="s1">:</span>
                    <span class="s1">self.__warnings.append(ws)</span>
                    <span class="s4">break</span>
                <span class="s1">ws = ui.unpack_in_stages(self.get_data(rf.UnwindData</span><span class="s4">, </span><span class="s1">ui.sizeof()))</span>
                <span class="s4">if </span><span class="s1">ws != </span><span class="s4">None</span><span class="s1">:</span>
                    <span class="s1">self.__warnings.append(ws)</span>
                    <span class="s4">break</span>

                <span class="s1">self.__structures__.append(ui)</span>

            <span class="s1">entry = ExceptionsDirEntryData(struct=rf</span><span class="s4">, </span><span class="s1">unwindinfo=ui)</span>
            <span class="s1">rt_funcs.append(entry)</span>

            <span class="s1">rva2rt[rf.BeginAddress] = entry</span>
            <span class="s1">rva += rf_size</span>

        <span class="s0"># each chained function entry holds a reference to the function first in chain</span>
        <span class="s4">for </span><span class="s1">rf </span><span class="s4">in </span><span class="s1">rt_funcs:</span>
            <span class="s4">if </span><span class="s1">rf.unwindinfo </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s0"># TODO: have not encountered such a binary yet;</span>
                <span class="s0"># in theory, (UnwindData &amp; ~0x1) should point to the chained</span>
                <span class="s0"># RUNTIME_FUNCTION which could be used to locate the corresponding</span>
                <span class="s0"># ExceptionsDirEntryData and set_chained_function_entry()</span>
                <span class="s4">continue</span>
            <span class="s4">if not </span><span class="s1">hasattr(rf.unwindinfo</span><span class="s4">, </span><span class="s3">&quot;FunctionEntry&quot;</span><span class="s1">):</span>
                <span class="s4">continue</span>
            <span class="s4">if not </span><span class="s1">rf.unwindinfo.FunctionEntry </span><span class="s4">in </span><span class="s1">rva2rt:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">f&quot;FunctionEntry of UNWIND_INFO at </span><span class="s4">{</span><span class="s1">rf.struct.get_file_offset()</span><span class="s4">:</span><span class="s3">x</span><span class="s4">}</span><span class="s3">&quot;</span>
                    <span class="s3">&quot; points to an entry that does not exist&quot;</span>
                <span class="s1">)</span>
                <span class="s4">continue</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">rf.unwindinfo.set_chained_function_entry(</span>
                    <span class="s1">rva2rt[rf.unwindinfo.FunctionEntry]</span>
                <span class="s1">)</span>
            <span class="s4">except </span><span class="s1">PEFormatError </span><span class="s4">as </span><span class="s1">excp:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Failed parsing FunctionEntry of UNWIND_INFO at &quot;</span>
                    <span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">rf.struct.get_file_offset()</span><span class="s4">:</span><span class="s3">x</span><span class="s4">}</span><span class="s3">: </span><span class="s4">{</span><span class="s1">excp</span><span class="s4">}</span><span class="s3">&quot;</span>
                <span class="s1">)</span>
                <span class="s4">continue</span>

        <span class="s4">return </span><span class="s1">rt_funcs</span>

    <span class="s4">def </span><span class="s1">parse_directory_bound_imports(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size):</span>
        <span class="s2">&quot;&quot;&quot;&quot;&quot;&quot;</span>

        <span class="s1">bnd_descr = Structure(self.__IMAGE_BOUND_IMPORT_DESCRIPTOR_format__)</span>
        <span class="s1">bnd_descr_size = bnd_descr.sizeof()</span>
        <span class="s1">start = rva</span>

        <span class="s1">bound_imports = []</span>
        <span class="s4">while True</span><span class="s1">:</span>
            <span class="s1">bnd_descr = self.__unpack_data__(</span>
                <span class="s1">self.__IMAGE_BOUND_IMPORT_DESCRIPTOR_format__</span><span class="s4">,</span>
                <span class="s1">self.__data__[rva : rva + bnd_descr_size]</span><span class="s4">,</span>
                <span class="s1">file_offset=rva</span><span class="s4">,</span>
            <span class="s1">)</span>
            <span class="s4">if </span><span class="s1">bnd_descr </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s0"># If can't parse directory then silently return.</span>
                <span class="s0"># This directory does not necessarily have to be valid to</span>
                <span class="s0"># still have a valid PE file</span>

                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;The Bound Imports directory exists but can't be parsed.&quot;</span>
                <span class="s1">)</span>

                <span class="s4">return</span>

            <span class="s4">if </span><span class="s1">bnd_descr.all_zeroes():</span>
                <span class="s4">break</span>

            <span class="s1">rva += bnd_descr.sizeof()</span>

            <span class="s1">section = self.get_section_by_offset(rva)</span>
            <span class="s1">file_offset = self.get_offset_from_rva(rva)</span>
            <span class="s4">if </span><span class="s1">section </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">safety_boundary = len(self.__data__) - file_offset</span>
                <span class="s1">sections_after_offset = [</span>
                    <span class="s1">s.PointerToRawData</span>
                    <span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">self.sections</span>
                    <span class="s4">if </span><span class="s1">s.PointerToRawData &gt; file_offset</span>
                <span class="s1">]</span>
                <span class="s4">if </span><span class="s1">sections_after_offset:</span>
                    <span class="s0"># Find the first section starting at a later offset than that</span>
                    <span class="s0"># specified by 'rva'</span>
                    <span class="s1">first_section_after_offset = min(sections_after_offset)</span>
                    <span class="s1">section = self.get_section_by_offset(first_section_after_offset)</span>
                    <span class="s4">if </span><span class="s1">section </span><span class="s4">is not None</span><span class="s1">:</span>
                        <span class="s1">safety_boundary = section.PointerToRawData - file_offset</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">safety_boundary = (</span>
                    <span class="s1">section.PointerToRawData + len(section.get_data()) - file_offset</span>
                <span class="s1">)</span>
            <span class="s4">if not </span><span class="s1">section:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s1">(</span>
                        <span class="s3">&quot;RVA of IMAGE_BOUND_IMPORT_DESCRIPTOR points &quot;</span>
                        <span class="s3">&quot;to an invalid address: {0:x}&quot;</span>
                    <span class="s1">).format(rva)</span>
                <span class="s1">)</span>
                <span class="s4">return</span>

            <span class="s1">forwarder_refs = []</span>
            <span class="s0"># 8 is the size of __IMAGE_BOUND_IMPORT_DESCRIPTOR_format__</span>
            <span class="s4">for </span><span class="s1">_ </span><span class="s4">in </span><span class="s1">range(</span>
                <span class="s1">min(bnd_descr.NumberOfModuleForwarderRefs</span><span class="s4">, </span><span class="s1">int(safety_boundary / </span><span class="s5">8</span><span class="s1">))</span>
            <span class="s1">):</span>
                <span class="s0"># Both structures IMAGE_BOUND_IMPORT_DESCRIPTOR and</span>
                <span class="s0"># IMAGE_BOUND_FORWARDER_REF have the same size.</span>
                <span class="s1">bnd_frwd_ref = self.__unpack_data__(</span>
                    <span class="s1">self.__IMAGE_BOUND_FORWARDER_REF_format__</span><span class="s4">,</span>
                    <span class="s1">self.__data__[rva : rva + bnd_descr_size]</span><span class="s4">,</span>
                    <span class="s1">file_offset=rva</span><span class="s4">,</span>
                <span class="s1">)</span>
                <span class="s0"># OC Patch:</span>
                <span class="s4">if not </span><span class="s1">bnd_frwd_ref:</span>
                    <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;IMAGE_BOUND_FORWARDER_REF cannot be read&quot;</span><span class="s1">)</span>
                <span class="s1">rva += bnd_frwd_ref.sizeof()</span>

                <span class="s1">offset = start + bnd_frwd_ref.OffsetModuleName</span>
                <span class="s1">name_str = self.get_string_from_data(</span>
                    <span class="s5">0</span><span class="s4">, </span><span class="s1">self.__data__[offset : offset + MAX_STRING_LENGTH]</span>
                <span class="s1">)</span>

                <span class="s0"># OffsetModuleName points to a DLL name. These shouldn't be too long.</span>
                <span class="s0"># Anything longer than a safety length of 128 will be taken to indicate</span>
                <span class="s0"># a corrupt entry and abort the processing of these entries.</span>
                <span class="s0"># Names shorter than 4 characters will be taken as invalid as well.</span>

                <span class="s4">if </span><span class="s1">name_str:</span>
                    <span class="s1">invalid_chars = [</span>
                        <span class="s1">c </span><span class="s4">for </span><span class="s1">c </span><span class="s4">in </span><span class="s1">bytearray(name_str) </span><span class="s4">if </span><span class="s1">chr(c) </span><span class="s4">not in </span><span class="s1">string.printable</span>
                    <span class="s1">]</span>
                    <span class="s4">if </span><span class="s1">len(name_str) &gt; </span><span class="s5">256 </span><span class="s4">or </span><span class="s1">invalid_chars:</span>
                        <span class="s4">break</span>

                <span class="s1">forwarder_refs.append(</span>
                    <span class="s1">BoundImportRefData(struct=bnd_frwd_ref</span><span class="s4">, </span><span class="s1">name=name_str)</span>
                <span class="s1">)</span>

            <span class="s1">offset = start + bnd_descr.OffsetModuleName</span>
            <span class="s1">name_str = self.get_string_from_data(</span>
                <span class="s5">0</span><span class="s4">, </span><span class="s1">self.__data__[offset : offset + MAX_STRING_LENGTH]</span>
            <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">name_str:</span>
                <span class="s1">invalid_chars = [</span>
                    <span class="s1">c </span><span class="s4">for </span><span class="s1">c </span><span class="s4">in </span><span class="s1">bytearray(name_str) </span><span class="s4">if </span><span class="s1">chr(c) </span><span class="s4">not in </span><span class="s1">string.printable</span>
                <span class="s1">]</span>
                <span class="s4">if </span><span class="s1">len(name_str) &gt; </span><span class="s5">256 </span><span class="s4">or </span><span class="s1">invalid_chars:</span>
                    <span class="s4">break</span>

            <span class="s4">if not </span><span class="s1">name_str:</span>
                <span class="s4">break</span>
            <span class="s1">bound_imports.append(</span>
                <span class="s1">BoundImportDescData(</span>
                    <span class="s1">struct=bnd_descr</span><span class="s4">, </span><span class="s1">name=name_str</span><span class="s4">, </span><span class="s1">entries=forwarder_refs</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s4">return </span><span class="s1">bound_imports</span>

    <span class="s4">def </span><span class="s1">parse_directory_tls(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size):</span>
        <span class="s2">&quot;&quot;&quot;&quot;&quot;&quot;</span>

        <span class="s0"># By default let's pretend the format is a 32-bit PE. It may help</span>
        <span class="s0"># produce some output for files where the Magic in the Optional Header</span>
        <span class="s0"># is incorrect.</span>
        <span class="s1">format = self.__IMAGE_TLS_DIRECTORY_format__</span>

        <span class="s4">if </span><span class="s1">self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE_PLUS:</span>
            <span class="s1">format = self.__IMAGE_TLS_DIRECTORY64_format__</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">tls_struct = self.__unpack_data__(</span>
                <span class="s1">format</span><span class="s4">,</span>
                <span class="s1">self.get_data(rva</span><span class="s4">, </span><span class="s1">Structure(format).sizeof())</span><span class="s4">,</span>
                <span class="s1">file_offset=self.get_offset_from_rva(rva)</span><span class="s4">,</span>
            <span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Invalid TLS information. Can't read &quot; &quot;data at RVA: 0x%x&quot; </span><span class="s1">% rva</span>
            <span class="s1">)</span>
            <span class="s1">tls_struct = </span><span class="s4">None</span>

        <span class="s4">if not </span><span class="s1">tls_struct:</span>
            <span class="s4">return None</span>

        <span class="s4">return </span><span class="s1">TlsData(struct=tls_struct)</span>

    <span class="s4">def </span><span class="s1">parse_directory_load_config(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size):</span>
        <span class="s2">&quot;&quot;&quot;&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE:</span>
            <span class="s1">load_config_dir_sz = self.get_dword_at_rva(rva)</span>
            <span class="s1">format = self.__IMAGE_LOAD_CONFIG_DIRECTORY_format__</span>
        <span class="s4">elif </span><span class="s1">self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE_PLUS:</span>
            <span class="s1">load_config_dir_sz = self.get_dword_at_rva(rva)</span>
            <span class="s1">format = self.__IMAGE_LOAD_CONFIG_DIRECTORY64_format__</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Don't know how to parse LOAD_CONFIG information for non-PE32/&quot;</span>
                <span class="s3">&quot;PE32+ file&quot;</span>
            <span class="s1">)</span>
            <span class="s4">return None</span>

        <span class="s0"># load config directory size can be less than represented by 'format' variable,</span>
        <span class="s0"># generate truncated format which correspond load config directory size</span>
        <span class="s1">fields_counter = </span><span class="s5">0</span>
        <span class="s1">cumulative_sz = </span><span class="s5">0</span>
        <span class="s4">for </span><span class="s1">field </span><span class="s4">in </span><span class="s1">format[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s1">fields_counter += </span><span class="s5">1</span>
            <span class="s1">cumulative_sz += STRUCT_SIZEOF_TYPES[field.split(</span><span class="s3">&quot;,&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]]</span>
            <span class="s4">if </span><span class="s1">cumulative_sz == load_config_dir_sz:</span>
                <span class="s4">break</span>
        <span class="s1">format = (format[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">format[</span><span class="s5">1</span><span class="s1">][:fields_counter])</span>

        <span class="s1">load_config_struct = </span><span class="s4">None</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">load_config_struct = self.__unpack_data__(</span>
                <span class="s1">format</span><span class="s4">,</span>
                <span class="s1">self.get_data(rva</span><span class="s4">, </span><span class="s1">Structure(format).sizeof())</span><span class="s4">,</span>
                <span class="s1">file_offset=self.get_offset_from_rva(rva)</span><span class="s4">,</span>
            <span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Invalid LOAD_CONFIG information. Can't read &quot; &quot;data at RVA: 0x%x&quot; </span><span class="s1">% rva</span>
            <span class="s1">)</span>

        <span class="s4">if not </span><span class="s1">load_config_struct:</span>
            <span class="s4">return None</span>

        <span class="s1">dynamic_relocations = </span><span class="s4">None</span>
        <span class="s4">if </span><span class="s1">fields_counter &gt; </span><span class="s5">35</span><span class="s1">:</span>
            <span class="s1">dynamic_relocations = self.parse_dynamic_relocations(</span>
                <span class="s1">load_config_struct.DynamicValueRelocTableOffset</span><span class="s4">,</span>
                <span class="s1">load_config_struct.DynamicValueRelocTableSection</span><span class="s4">,</span>
            <span class="s1">)</span>

        <span class="s4">return </span><span class="s1">LoadConfigData(</span>
            <span class="s1">struct=load_config_struct</span><span class="s4">, </span><span class="s1">dynamic_relocations=dynamic_relocations</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">parse_dynamic_relocations(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">dynamic_value_reloc_table_offset</span><span class="s4">, </span><span class="s1">dynamic_value_reloc_table_section</span>
    <span class="s1">):</span>
        <span class="s4">if not </span><span class="s1">dynamic_value_reloc_table_offset:</span>
            <span class="s4">return None</span>
        <span class="s4">if not </span><span class="s1">dynamic_value_reloc_table_section:</span>
            <span class="s4">return None</span>

        <span class="s4">if </span><span class="s1">dynamic_value_reloc_table_section &gt; len(self.sections):</span>
            <span class="s4">return None</span>

        <span class="s1">section = self.sections[dynamic_value_reloc_table_section - </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">rva = section.VirtualAddress + dynamic_value_reloc_table_offset</span>
        <span class="s1">image_dynamic_reloc_table_struct = </span><span class="s4">None</span>
        <span class="s1">reloc_table_size = Structure(</span>
            <span class="s1">self.__IMAGE_DYNAMIC_RELOCATION_TABLE_format__</span>
        <span class="s1">).sizeof()</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">image_dynamic_reloc_table_struct = self.__unpack_data__(</span>
                <span class="s1">self.__IMAGE_DYNAMIC_RELOCATION_TABLE_format__</span><span class="s4">,</span>
                <span class="s1">self.get_data(rva</span><span class="s4">, </span><span class="s1">reloc_table_size)</span><span class="s4">,</span>
                <span class="s1">file_offset=self.get_offset_from_rva(rva)</span><span class="s4">,</span>
            <span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Invalid IMAGE_DYNAMIC_RELOCATION_TABLE information. Can't read &quot;</span>
                <span class="s3">&quot;data at RVA: 0x%x&quot; </span><span class="s1">% rva</span>
            <span class="s1">)</span>

        <span class="s4">if </span><span class="s1">image_dynamic_reloc_table_struct.Version != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;No pasring available for IMAGE_DYNAMIC_RELOCATION_TABLE.Version = %d&quot;</span><span class="s4">,</span>
                <span class="s1">image_dynamic_reloc_table_struct.Version</span><span class="s4">,</span>
            <span class="s1">)</span>
            <span class="s4">return None</span>

        <span class="s1">rva += reloc_table_size</span>
        <span class="s1">end = rva + image_dynamic_reloc_table_struct.Size</span>
        <span class="s1">dynamic_relocations = []</span>

        <span class="s4">while </span><span class="s1">rva &lt; end:</span>
            <span class="s1">format = self.__IMAGE_DYNAMIC_RELOCATION_format__</span>

            <span class="s4">if </span><span class="s1">self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE_PLUS:</span>
                <span class="s1">format = self.__IMAGE_DYNAMIC_RELOCATION64_format__</span>

            <span class="s1">rlc_size = Structure(format).sizeof()</span>

            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">dynamic_rlc = self.__unpack_data__(</span>
                    <span class="s1">format</span><span class="s4">,</span>
                    <span class="s1">self.get_data(rva</span><span class="s4">, </span><span class="s1">rlc_size)</span><span class="s4">,</span>
                    <span class="s1">file_offset=self.get_offset_from_rva(rva)</span><span class="s4">,</span>
                <span class="s1">)</span>
            <span class="s4">except </span><span class="s1">PEFormatError:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Invalid relocation information. Can't read &quot;</span>
                    <span class="s3">&quot;data at RVA: 0x%x&quot; </span><span class="s1">% rva</span>
                <span class="s1">)</span>
                <span class="s1">dynamic_rlc = </span><span class="s4">None</span>

            <span class="s4">if not </span><span class="s1">dynamic_rlc:</span>
                <span class="s4">break</span>

            <span class="s1">rva += rlc_size</span>
            <span class="s1">symbol = dynamic_rlc.Symbol</span>
            <span class="s1">size = dynamic_rlc.BaseRelocSize</span>

            <span class="s4">if </span><span class="s5">3 </span><span class="s1">&lt;= symbol &lt;= </span><span class="s5">5</span><span class="s1">:</span>
                <span class="s1">relocations = self.parse_image_base_relocation_list(</span>
                    <span class="s1">rva</span><span class="s4">, </span><span class="s1">size</span><span class="s4">, </span><span class="s1">self.dynamic_relocation_format_by_symbol[symbol]</span>
                <span class="s1">)</span>
                <span class="s1">dynamic_relocations.append(</span>
                    <span class="s1">DynamicRelocationData(</span>
                        <span class="s1">struct=dynamic_rlc</span><span class="s4">, </span><span class="s1">symbol=symbol</span><span class="s4">, </span><span class="s1">relocations=relocations</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">symbol &gt; </span><span class="s5">5</span><span class="s1">:</span>
                <span class="s1">relocations = self.parse_image_base_relocation_list(rva</span><span class="s4">, </span><span class="s1">size)</span>
                <span class="s1">dynamic_relocations.append(</span>
                    <span class="s1">DynamicRelocationData(</span>
                        <span class="s1">struct=dynamic_rlc</span><span class="s4">, </span><span class="s1">symbol=symbol</span><span class="s4">, </span><span class="s1">relocations=relocations</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s1">rva += size</span>

        <span class="s4">return </span><span class="s1">dynamic_relocations</span>

    <span class="s4">def </span><span class="s1">parse_relocations_directory(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size):</span>
        <span class="s2">&quot;&quot;&quot;&quot;&quot;&quot;</span>

        <span class="s4">return </span><span class="s1">self.parse_image_base_relocation_list(rva</span><span class="s4">, </span><span class="s1">size)</span>

    <span class="s4">def </span><span class="s1">parse_image_base_relocation_list(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size</span><span class="s4">, </span><span class="s1">fmt=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s1">rlc_size = Structure(self.__IMAGE_BASE_RELOCATION_format__).sizeof()</span>
        <span class="s1">end = rva + size</span>

        <span class="s1">relocations = []</span>
        <span class="s4">while </span><span class="s1">rva &lt; end:</span>

            <span class="s0"># OC Patch:</span>
            <span class="s0"># Malware that has bad RVA entries will cause an error.</span>
            <span class="s0"># Just continue on after an exception</span>
            <span class="s0">#</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">rlc = self.__unpack_data__(</span>
                    <span class="s1">self.__IMAGE_BASE_RELOCATION_format__</span><span class="s4">,</span>
                    <span class="s1">self.get_data(rva</span><span class="s4">, </span><span class="s1">rlc_size)</span><span class="s4">,</span>
                    <span class="s1">file_offset=self.get_offset_from_rva(rva)</span><span class="s4">,</span>
                <span class="s1">)</span>
            <span class="s4">except </span><span class="s1">PEFormatError:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Invalid relocation information. Can't read &quot;</span>
                    <span class="s3">&quot;data at RVA: 0x%x&quot; </span><span class="s1">% rva</span>
                <span class="s1">)</span>
                <span class="s1">rlc = </span><span class="s4">None</span>

            <span class="s4">if not </span><span class="s1">rlc:</span>
                <span class="s4">break</span>

            <span class="s0"># rlc.VirtualAddress must lie within the Image</span>
            <span class="s4">if </span><span class="s1">rlc.VirtualAddress &gt; self.OPTIONAL_HEADER.SizeOfImage:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Invalid relocation information. VirtualAddress outside&quot;</span>
                    <span class="s3">&quot; of Image: 0x%x&quot; </span><span class="s1">% rlc.VirtualAddress</span>
                <span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s0"># rlc.SizeOfBlock must be less or equal than the size of the image</span>
            <span class="s0"># (It's a rather loose sanity test)</span>
            <span class="s4">if </span><span class="s1">rlc.SizeOfBlock &gt; self.OPTIONAL_HEADER.SizeOfImage:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Invalid relocation information. SizeOfBlock too large&quot;</span>
                    <span class="s3">&quot;: %d&quot; </span><span class="s1">% rlc.SizeOfBlock</span>
                <span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s4">if </span><span class="s1">fmt </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">reloc_entries = self.parse_relocations(</span>
                    <span class="s1">rva + rlc_size</span><span class="s4">, </span><span class="s1">rlc.VirtualAddress</span><span class="s4">, </span><span class="s1">rlc.SizeOfBlock - rlc_size</span>
                <span class="s1">)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">reloc_entries = self.parse_relocations_with_format(</span>
                    <span class="s1">rva + rlc_size</span><span class="s4">, </span><span class="s1">rlc.VirtualAddress</span><span class="s4">, </span><span class="s1">rlc.SizeOfBlock - rlc_size</span><span class="s4">, </span><span class="s1">fmt</span>
                <span class="s1">)</span>

            <span class="s1">relocations.append(BaseRelocationData(struct=rlc</span><span class="s4">, </span><span class="s1">entries=reloc_entries))</span>

            <span class="s4">if not </span><span class="s1">rlc.SizeOfBlock:</span>
                <span class="s4">break</span>
            <span class="s1">rva += rlc.SizeOfBlock</span>

        <span class="s4">return </span><span class="s1">relocations</span>

    <span class="s4">def </span><span class="s1">parse_relocations(self</span><span class="s4">, </span><span class="s1">data_rva</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size):</span>
        <span class="s2">&quot;&quot;&quot;&quot;&quot;&quot;</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">data = self.get_data(data_rva</span><span class="s4">, </span><span class="s1">size)</span>
            <span class="s1">file_offset = self.get_offset_from_rva(data_rva)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.__warnings.append(</span><span class="s3">f&quot;Bad RVA in relocation data: 0x</span><span class="s4">{</span><span class="s1">data_rva</span><span class="s4">:</span><span class="s3">x</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s4">return </span><span class="s1">[]</span>

        <span class="s1">entries = []</span>
        <span class="s1">offsets_and_type = set()</span>
        <span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">range(int(len(data) / </span><span class="s5">2</span><span class="s1">)):</span>

            <span class="s1">entry = self.__unpack_data__(</span>
                <span class="s1">self.__IMAGE_BASE_RELOCATION_ENTRY_format__</span><span class="s4">,</span>
                <span class="s1">data[idx * </span><span class="s5">2 </span><span class="s1">: (idx + </span><span class="s5">1</span><span class="s1">) * </span><span class="s5">2</span><span class="s1">]</span><span class="s4">,</span>
                <span class="s1">file_offset=file_offset</span><span class="s4">,</span>
            <span class="s1">)</span>

            <span class="s4">if not </span><span class="s1">entry:</span>
                <span class="s4">break</span>
            <span class="s1">word = entry.Data</span>

            <span class="s1">reloc_type = word &gt;&gt; </span><span class="s5">12</span>
            <span class="s1">reloc_offset = word &amp; </span><span class="s5">0x0FFF</span>
            <span class="s4">if </span><span class="s1">(reloc_offset</span><span class="s4">, </span><span class="s1">reloc_type) </span><span class="s4">in </span><span class="s1">offsets_and_type:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Overlapping offsets in relocation data &quot;</span>
                    <span class="s3">&quot;at RVA: 0x%x&quot; </span><span class="s1">% (reloc_offset + rva)</span>
                <span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s1">offsets_and_type.add((reloc_offset</span><span class="s4">, </span><span class="s1">reloc_type))</span>

            <span class="s1">entries.append(</span>
                <span class="s1">RelocationData(</span>
                    <span class="s1">struct=entry</span><span class="s4">, </span><span class="s1">type=reloc_type</span><span class="s4">, </span><span class="s1">base_rva=rva</span><span class="s4">, </span><span class="s1">rva=reloc_offset + rva</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">file_offset += entry.sizeof()</span>

        <span class="s4">return </span><span class="s1">entries</span>

    <span class="s4">def </span><span class="s1">parse_relocations_with_format(self</span><span class="s4">, </span><span class="s1">data_rva</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size</span><span class="s4">, </span><span class="s1">format):</span>
        <span class="s2">&quot;&quot;&quot;&quot;&quot;&quot;</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">data = self.get_data(data_rva</span><span class="s4">, </span><span class="s1">size)</span>
            <span class="s1">file_offset = self.get_offset_from_rva(data_rva)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.__warnings.append(</span><span class="s3">f&quot;Bad RVA in relocation data: 0x</span><span class="s4">{</span><span class="s1">data_rva</span><span class="s4">:</span><span class="s3">x</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s4">return </span><span class="s1">[]</span>

        <span class="s1">entry_size = StructureWithBitfields(format).sizeof()</span>
        <span class="s1">entries = []</span>
        <span class="s1">offsets = set()</span>
        <span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">range(int(len(data) / entry_size)):</span>

            <span class="s1">entry = self.__unpack_data_with_bitfields__(</span>
                <span class="s1">format</span><span class="s4">,</span>
                <span class="s1">data[idx * entry_size : (idx + </span><span class="s5">1</span><span class="s1">) * entry_size]</span><span class="s4">,</span>
                <span class="s1">file_offset=file_offset</span><span class="s4">,</span>
            <span class="s1">)</span>

            <span class="s4">if not </span><span class="s1">entry:</span>
                <span class="s4">break</span>

            <span class="s1">reloc_offset = entry.PageRelativeOffset</span>
            <span class="s4">if </span><span class="s1">reloc_offset </span><span class="s4">in </span><span class="s1">offsets:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Overlapping offsets in relocation data &quot;</span>
                    <span class="s3">&quot;at RVA: 0x%x&quot; </span><span class="s1">% (reloc_offset + rva)</span>
                <span class="s1">)</span>
                <span class="s4">break</span>
            <span class="s1">offsets.add(reloc_offset)</span>

            <span class="s1">entries.append(</span>
                <span class="s1">RelocationData(struct=entry</span><span class="s4">, </span><span class="s1">base_rva=rva</span><span class="s4">, </span><span class="s1">rva=reloc_offset + rva)</span>
            <span class="s1">)</span>
            <span class="s1">file_offset += entry_size</span>

        <span class="s4">return </span><span class="s1">entries</span>

    <span class="s4">def </span><span class="s1">parse_debug_directory(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size):</span>
        <span class="s2">&quot;&quot;&quot;&quot;&quot;&quot;</span>

        <span class="s1">dbg_size = Structure(self.__IMAGE_DEBUG_DIRECTORY_format__).sizeof()</span>

        <span class="s1">debug = []</span>
        <span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">range(int(size / dbg_size)):</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">data = self.get_data(rva + dbg_size * idx</span><span class="s4">, </span><span class="s1">dbg_size)</span>
            <span class="s4">except </span><span class="s1">PEFormatError:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Invalid debug information. Can't read &quot; &quot;data at RVA: 0x%x&quot; </span><span class="s1">% rva</span>
                <span class="s1">)</span>
                <span class="s4">return None</span>

            <span class="s1">dbg = self.__unpack_data__(</span>
                <span class="s1">self.__IMAGE_DEBUG_DIRECTORY_format__</span><span class="s4">,</span>
                <span class="s1">data</span><span class="s4">,</span>
                <span class="s1">file_offset=self.get_offset_from_rva(rva + dbg_size * idx)</span><span class="s4">,</span>
            <span class="s1">)</span>

            <span class="s4">if not </span><span class="s1">dbg:</span>
                <span class="s4">return None</span>

            <span class="s0"># apply structure according to DEBUG_TYPE</span>
            <span class="s0"># http://www.debuginfo.com/articles/debuginfomatch.html</span>
            <span class="s0">#</span>
            <span class="s1">dbg_type = </span><span class="s4">None</span>

            <span class="s4">if </span><span class="s1">dbg.Type == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s0"># IMAGE_DEBUG_TYPE_COFF</span>
                <span class="s4">pass</span>

            <span class="s4">elif </span><span class="s1">dbg.Type == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s0"># if IMAGE_DEBUG_TYPE_CODEVIEW</span>
                <span class="s1">dbg_type_offset = dbg.PointerToRawData</span>
                <span class="s1">dbg_type_size = dbg.SizeOfData</span>
                <span class="s1">dbg_type_data = self.__data__[</span>
                    <span class="s1">dbg_type_offset : dbg_type_offset + dbg_type_size</span>
                <span class="s1">]</span>

                <span class="s4">if </span><span class="s1">dbg_type_data[:</span><span class="s5">4</span><span class="s1">] == </span><span class="s6">b&quot;RSDS&quot;</span><span class="s1">:</span>
                    <span class="s0"># pdb7.0</span>
                    <span class="s1">__CV_INFO_PDB70_format__ = [</span>
                        <span class="s3">&quot;CV_INFO_PDB70&quot;</span><span class="s4">,</span>
                        <span class="s1">[</span>
                            <span class="s3">&quot;4s,CvSignature&quot;</span><span class="s4">,</span>
                            <span class="s3">&quot;I,Signature_Data1&quot;</span><span class="s4">,  </span><span class="s0"># Signature is of GUID type</span>
                            <span class="s3">&quot;H,Signature_Data2&quot;</span><span class="s4">,</span>
                            <span class="s3">&quot;H,Signature_Data3&quot;</span><span class="s4">,</span>
                            <span class="s3">&quot;B,Signature_Data4&quot;</span><span class="s4">,</span>
                            <span class="s3">&quot;B,Signature_Data5&quot;</span><span class="s4">,</span>
                            <span class="s3">&quot;6s,Signature_Data6&quot;</span><span class="s4">,</span>
                            <span class="s3">&quot;I,Age&quot;</span><span class="s4">,</span>
                        <span class="s1">]</span><span class="s4">,</span>
                    <span class="s1">]</span>
                    <span class="s1">pdbFileName_size = (</span>
                        <span class="s1">dbg_type_size - Structure(__CV_INFO_PDB70_format__).sizeof()</span>
                    <span class="s1">)</span>

                    <span class="s0"># pdbFileName_size can be negative here, as seen in the malware</span>
                    <span class="s0"># sample with hash</span>
                    <span class="s0"># MD5: 7c297600870d026c014d42596bb9b5fd</span>
                    <span class="s0"># SHA256:</span>
                    <span class="s0">#   83f4e63681fcba8a9d7bbb1688c71981b1837446514a1773597e0192bba9fac3</span>
                    <span class="s0"># Checking for positive size here to ensure proper parsing.</span>
                    <span class="s4">if </span><span class="s1">pdbFileName_size &gt; </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s1">__CV_INFO_PDB70_format__[</span><span class="s5">1</span><span class="s1">].append(</span>
                            <span class="s3">&quot;{0}s,PdbFileName&quot;</span><span class="s1">.format(pdbFileName_size)</span>
                        <span class="s1">)</span>
                    <span class="s1">dbg_type = self.__unpack_data__(</span>
                        <span class="s1">__CV_INFO_PDB70_format__</span><span class="s4">, </span><span class="s1">dbg_type_data</span><span class="s4">, </span><span class="s1">dbg_type_offset</span>
                    <span class="s1">)</span>
                    <span class="s4">if </span><span class="s1">dbg_type </span><span class="s4">is not None</span><span class="s1">:</span>
                        <span class="s1">dbg_type.Signature_Data6_value = struct.unpack(</span>
                            <span class="s3">&quot;&gt;Q&quot;</span><span class="s4">, </span><span class="s6">b&quot;</span><span class="s4">\0\0</span><span class="s6">&quot; </span><span class="s1">+ dbg_type.Signature_Data6</span>
                        <span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
                        <span class="s1">dbg_type.Signature_String = (</span>
                            <span class="s1">str(</span>
                                <span class="s1">uuid.UUID(</span>
                                    <span class="s1">fields=(</span>
                                        <span class="s1">dbg_type.Signature_Data1</span><span class="s4">,</span>
                                        <span class="s1">dbg_type.Signature_Data2</span><span class="s4">,</span>
                                        <span class="s1">dbg_type.Signature_Data3</span><span class="s4">,</span>
                                        <span class="s1">dbg_type.Signature_Data4</span><span class="s4">,</span>
                                        <span class="s1">dbg_type.Signature_Data5</span><span class="s4">,</span>
                                        <span class="s1">dbg_type.Signature_Data6_value</span><span class="s4">,</span>
                                    <span class="s1">)</span>
                                <span class="s1">)</span>
                            <span class="s1">)</span>
                            <span class="s1">.replace(</span><span class="s3">&quot;-&quot;</span><span class="s4">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
                            <span class="s1">.upper()</span>
                            <span class="s1">+ </span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">dbg_type.Age</span><span class="s4">:</span><span class="s3">X</span><span class="s4">}</span><span class="s3">&quot;</span>
                        <span class="s1">)</span>

                <span class="s4">elif </span><span class="s1">dbg_type_data[:</span><span class="s5">4</span><span class="s1">] == </span><span class="s6">b&quot;NB10&quot;</span><span class="s1">:</span>
                    <span class="s0"># pdb2.0</span>
                    <span class="s1">__CV_INFO_PDB20_format__ = [</span>
                        <span class="s3">&quot;CV_INFO_PDB20&quot;</span><span class="s4">,</span>
                        <span class="s1">[</span>
                            <span class="s3">&quot;I,CvHeaderSignature&quot;</span><span class="s4">,</span>
                            <span class="s3">&quot;I,CvHeaderOffset&quot;</span><span class="s4">,</span>
                            <span class="s3">&quot;I,Signature&quot;</span><span class="s4">,</span>
                            <span class="s3">&quot;I,Age&quot;</span><span class="s4">,</span>
                        <span class="s1">]</span><span class="s4">,</span>
                    <span class="s1">]</span>
                    <span class="s1">pdbFileName_size = (</span>
                        <span class="s1">dbg_type_size - Structure(__CV_INFO_PDB20_format__).sizeof()</span>
                    <span class="s1">)</span>

                    <span class="s0"># As with the PDB 7.0 case, ensuring a positive size for</span>
                    <span class="s0"># pdbFileName_size to ensure proper parsing.</span>
                    <span class="s4">if </span><span class="s1">pdbFileName_size &gt; </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s0"># Add the last variable-length string field.</span>
                        <span class="s1">__CV_INFO_PDB20_format__[</span><span class="s5">1</span><span class="s1">].append(</span>
                            <span class="s3">&quot;{0}s,PdbFileName&quot;</span><span class="s1">.format(pdbFileName_size)</span>
                        <span class="s1">)</span>
                    <span class="s1">dbg_type = self.__unpack_data__(</span>
                        <span class="s1">__CV_INFO_PDB20_format__</span><span class="s4">, </span><span class="s1">dbg_type_data</span><span class="s4">, </span><span class="s1">dbg_type_offset</span>
                    <span class="s1">)</span>

            <span class="s4">elif </span><span class="s1">dbg.Type == </span><span class="s5">4</span><span class="s1">:</span>
                <span class="s0"># IMAGE_DEBUG_TYPE_MISC</span>
                <span class="s1">dbg_type_offset = dbg.PointerToRawData</span>
                <span class="s1">dbg_type_size = dbg.SizeOfData</span>
                <span class="s1">dbg_type_data = self.__data__[</span>
                    <span class="s1">dbg_type_offset : dbg_type_offset + dbg_type_size</span>
                <span class="s1">]</span>
                <span class="s1">___IMAGE_DEBUG_MISC_format__ = [</span>
                    <span class="s3">&quot;IMAGE_DEBUG_MISC&quot;</span><span class="s4">,</span>
                    <span class="s1">[</span>
                        <span class="s3">&quot;I,DataType&quot;</span><span class="s4">,</span>
                        <span class="s3">&quot;I,Length&quot;</span><span class="s4">,</span>
                        <span class="s3">&quot;B,Unicode&quot;</span><span class="s4">,</span>
                        <span class="s3">&quot;B,Reserved1&quot;</span><span class="s4">,</span>
                        <span class="s3">&quot;H,Reserved2&quot;</span><span class="s4">,</span>
                    <span class="s1">]</span><span class="s4">,</span>
                <span class="s1">]</span>
                <span class="s1">dbg_type_partial = self.__unpack_data__(</span>
                    <span class="s1">___IMAGE_DEBUG_MISC_format__</span><span class="s4">, </span><span class="s1">dbg_type_data</span><span class="s4">, </span><span class="s1">dbg_type_offset</span>
                <span class="s1">)</span>

                <span class="s0"># Need to check that dbg_type_partial contains a correctly unpacked data</span>
                <span class="s0"># structure, as the malware sample with the following hash</span>
                <span class="s0"># MD5:    5e7d6707d693108de5a303045c17d95b</span>
                <span class="s0"># SHA256:</span>
                <span class="s0">#  5dd94a95025f3b6e3dd440d52f7c6d2964fdd1aa119e0ee92e38c7bf83829e5c</span>
                <span class="s0"># contains a value of None for dbg_type_partial after unpacking,</span>
                <span class="s0"># presumably due to a malformed DEBUG entry.</span>
                <span class="s4">if </span><span class="s1">dbg_type_partial:</span>
                    <span class="s0"># The Unicode bool should be set to 0 or 1.</span>
                    <span class="s4">if </span><span class="s1">dbg_type_partial.Unicode </span><span class="s4">in </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s1">):</span>
                        <span class="s1">data_size = (</span>
                            <span class="s1">dbg_type_size</span>
                            <span class="s1">- Structure(___IMAGE_DEBUG_MISC_format__).sizeof()</span>
                        <span class="s1">)</span>

                        <span class="s0"># As with the PDB case, ensuring a positive size for data_size</span>
                        <span class="s0"># here to ensure proper parsing.</span>
                        <span class="s4">if </span><span class="s1">data_size &gt; </span><span class="s5">0</span><span class="s1">:</span>
                            <span class="s1">___IMAGE_DEBUG_MISC_format__[</span><span class="s5">1</span><span class="s1">].append(</span>
                                <span class="s3">&quot;{0}s,Data&quot;</span><span class="s1">.format(data_size)</span>
                            <span class="s1">)</span>
                        <span class="s1">dbg_type = self.__unpack_data__(</span>
                            <span class="s1">___IMAGE_DEBUG_MISC_format__</span><span class="s4">, </span><span class="s1">dbg_type_data</span><span class="s4">, </span><span class="s1">dbg_type_offset</span>
                        <span class="s1">)</span>

            <span class="s1">debug.append(DebugData(struct=dbg</span><span class="s4">, </span><span class="s1">entry=dbg_type))</span>

        <span class="s4">return </span><span class="s1">debug</span>

    <span class="s4">def </span><span class="s1">parse_resources_directory(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size=</span><span class="s5">0</span><span class="s4">, </span><span class="s1">base_rva=</span><span class="s4">None, </span><span class="s1">level=</span><span class="s5">0</span><span class="s4">, </span><span class="s1">dirs=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Parse the resources directory. 
 
        Given the RVA of the resources directory, it will process all 
        its entries. 
 
        The root will have the corresponding member of its structure, 
        IMAGE_RESOURCE_DIRECTORY plus 'entries', a list of all the 
        entries in the directory. 
 
        Those entries will have, correspondingly, all the structure's 
        members (IMAGE_RESOURCE_DIRECTORY_ENTRY) and an additional one, 
        &quot;directory&quot;, pointing to the IMAGE_RESOURCE_DIRECTORY structure 
        representing upper layers of the tree. This one will also have 
        an 'entries' attribute, pointing to the 3rd, and last, level. 
        Another directory with more entries. Those last entries will 
        have a new attribute (both 'leaf' or 'data_entry' can be used to 
        access it). This structure finally points to the resource data. 
        All the members of this structure, IMAGE_RESOURCE_DATA_ENTRY, 
        are available as its attributes. 
        &quot;&quot;&quot;</span>

        <span class="s0"># OC Patch:</span>
        <span class="s4">if </span><span class="s1">dirs </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">dirs = [rva]</span>

        <span class="s4">if </span><span class="s1">base_rva </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">base_rva = rva</span>

        <span class="s4">if </span><span class="s1">level &gt; MAX_RESOURCE_DEPTH:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Error parsing the resources directory. &quot;</span>
                <span class="s3">&quot;Excessively nested table depth %d (&gt;%s)&quot; </span><span class="s1">% (level</span><span class="s4">, </span><span class="s1">MAX_RESOURCE_DEPTH)</span>
            <span class="s1">)</span>
            <span class="s4">return None</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s0"># If the RVA is invalid all would blow up. Some EXEs seem to be</span>
            <span class="s0"># specially nasty and have an invalid RVA.</span>
            <span class="s1">data = self.get_data(</span>
                <span class="s1">rva</span><span class="s4">, </span><span class="s1">Structure(self.__IMAGE_RESOURCE_DIRECTORY_format__).sizeof()</span>
            <span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Invalid resources directory. Can't read &quot;</span>
                <span class="s3">&quot;directory data at RVA: 0x%x&quot; </span><span class="s1">% rva</span>
            <span class="s1">)</span>
            <span class="s4">return None</span>

        <span class="s0"># Get the resource directory structure, that is, the header</span>
        <span class="s0"># of the table preceding the actual entries</span>
        <span class="s0">#</span>
        <span class="s1">resource_dir = self.__unpack_data__(</span>
            <span class="s1">self.__IMAGE_RESOURCE_DIRECTORY_format__</span><span class="s4">,</span>
            <span class="s1">data</span><span class="s4">,</span>
            <span class="s1">file_offset=self.get_offset_from_rva(rva)</span><span class="s4">,</span>
        <span class="s1">)</span>
        <span class="s4">if </span><span class="s1">resource_dir </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s0"># If we can't parse resources directory then silently return.</span>
            <span class="s0"># This directory does not necessarily have to be valid to</span>
            <span class="s0"># still have a valid PE file</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Invalid resources directory. Can't parse &quot;</span>
                <span class="s3">&quot;directory data at RVA: 0x%x&quot; </span><span class="s1">% rva</span>
            <span class="s1">)</span>
            <span class="s4">return None</span>

        <span class="s1">dir_entries = []</span>

        <span class="s0"># Advance the RVA to the position immediately following the directory</span>
        <span class="s0"># table header and pointing to the first entry in the table</span>
        <span class="s0">#</span>
        <span class="s1">rva += resource_dir.sizeof()</span>

        <span class="s1">number_of_entries = (</span>
            <span class="s1">resource_dir.NumberOfNamedEntries + resource_dir.NumberOfIdEntries</span>
        <span class="s1">)</span>

        <span class="s0"># Set a hard limit on the maximum reasonable number of entries</span>
        <span class="s1">MAX_ALLOWED_ENTRIES = </span><span class="s5">4096</span>
        <span class="s4">if </span><span class="s1">number_of_entries &gt; MAX_ALLOWED_ENTRIES:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Error parsing the resources directory. &quot;</span>
                <span class="s3">&quot;The directory contains %d entries (&gt;%s)&quot;</span>
                <span class="s1">% (number_of_entries</span><span class="s4">, </span><span class="s1">MAX_ALLOWED_ENTRIES)</span>
            <span class="s1">)</span>
            <span class="s4">return None</span>

        <span class="s1">self.__total_resource_entries_count += number_of_entries</span>
        <span class="s4">if </span><span class="s1">self.__total_resource_entries_count &gt; MAX_RESOURCE_ENTRIES:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Error parsing the resources directory. &quot;</span>
                <span class="s3">&quot;The file contains at least %d entries (&gt;%d)&quot;</span>
                <span class="s1">% (self.__total_resource_entries_count</span><span class="s4">, </span><span class="s1">MAX_RESOURCE_ENTRIES)</span>
            <span class="s1">)</span>
            <span class="s4">return None</span>

        <span class="s1">strings_to_postprocess = []</span>

        <span class="s0"># Keep track of the last name's start and end offsets in order</span>
        <span class="s0"># to be able to detect overlapping entries that might suggest</span>
        <span class="s0"># and invalid or corrupt directory.</span>
        <span class="s1">last_name_begin_end = </span><span class="s4">None</span>
        <span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">range(number_of_entries):</span>
            <span class="s4">if </span><span class="s1">(</span>
                <span class="s4">not </span><span class="s1">self.__resource_size_limit_reached</span>
                <span class="s4">and </span><span class="s1">self.__total_resource_bytes &gt; self.__resource_size_limit_upperbounds</span>
            <span class="s1">):</span>

                <span class="s1">self.__resource_size_limit_reached = </span><span class="s4">True</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Resource size 0x%x exceeds file size 0x%x, overlapping &quot;</span>
                    <span class="s3">&quot;resources found.&quot;</span>
                    <span class="s1">% (</span>
                        <span class="s1">self.__total_resource_bytes</span><span class="s4">,</span>
                        <span class="s1">self.__resource_size_limit_upperbounds</span><span class="s4">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s1">res = self.parse_resource_entry(rva)</span>
            <span class="s4">if </span><span class="s1">res </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Error parsing the resources directory, &quot;</span>
                    <span class="s3">&quot;Entry %d is invalid, RVA = 0x%x. &quot; </span><span class="s1">% (idx</span><span class="s4">, </span><span class="s1">rva)</span>
                <span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s1">entry_name = </span><span class="s4">None</span>
            <span class="s1">entry_id = </span><span class="s4">None</span>

            <span class="s1">name_is_string = (res.Name &amp; </span><span class="s5">0x80000000</span><span class="s1">) &gt;&gt; </span><span class="s5">31</span>
            <span class="s4">if not </span><span class="s1">name_is_string:</span>
                <span class="s1">entry_id = res.Name</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">ustr_offset = base_rva + res.NameOffset</span>
                <span class="s4">try</span><span class="s1">:</span>
                    <span class="s1">entry_name = UnicodeStringWrapperPostProcessor(self</span><span class="s4">, </span><span class="s1">ustr_offset)</span>
                    <span class="s1">self.__total_resource_bytes += entry_name.get_pascal_16_length()</span>
                    <span class="s0"># If the last entry's offset points before the current's but its end</span>
                    <span class="s0"># is past the current's beginning, assume the overlap indicates a</span>
                    <span class="s0"># corrupt name.</span>
                    <span class="s4">if </span><span class="s1">last_name_begin_end </span><span class="s4">and </span><span class="s1">(</span>
                        <span class="s1">last_name_begin_end[</span><span class="s5">0</span><span class="s1">] &lt; ustr_offset</span>
                        <span class="s4">and </span><span class="s1">last_name_begin_end[</span><span class="s5">1</span><span class="s1">] &gt;= ustr_offset</span>
                    <span class="s1">):</span>
                        <span class="s0"># Remove the previous overlapping entry as it's likely to be</span>
                        <span class="s0"># already corrupt data.</span>
                        <span class="s1">strings_to_postprocess.pop()</span>
                        <span class="s1">self.__warnings.append(</span>
                            <span class="s3">&quot;Error parsing the resources directory, &quot;</span>
                            <span class="s3">&quot;attempting to read entry name. &quot;</span>
                            <span class="s3">&quot;Entry names overlap 0x%x&quot; </span><span class="s1">% (ustr_offset)</span>
                        <span class="s1">)</span>
                        <span class="s4">break</span>

                    <span class="s1">last_name_begin_end = (</span>
                        <span class="s1">ustr_offset</span><span class="s4">,</span>
                        <span class="s1">ustr_offset + entry_name.get_pascal_16_length()</span><span class="s4">,</span>
                    <span class="s1">)</span>

                    <span class="s1">strings_to_postprocess.append(entry_name)</span>

                <span class="s4">except </span><span class="s1">PEFormatError:</span>
                    <span class="s1">self.__warnings.append(</span>
                        <span class="s3">&quot;Error parsing the resources directory, &quot;</span>
                        <span class="s3">&quot;attempting to read entry name. &quot;</span>
                        <span class="s3">&quot;Can't read unicode string at offset 0x%x&quot; </span><span class="s1">% (ustr_offset)</span>
                    <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">res.DataIsDirectory:</span>
                <span class="s0"># OC Patch:</span>
                <span class="s0">#</span>
                <span class="s0"># One trick malware can do is to recursively reference</span>
                <span class="s0"># the next directory. This causes hilarity to ensue when</span>
                <span class="s0"># trying to parse everything correctly.</span>
                <span class="s0"># If the original RVA given to this function is equal to</span>
                <span class="s0"># the next one to parse, we assume that it's a trick.</span>
                <span class="s0"># Instead of raising a PEFormatError this would skip some</span>
                <span class="s0"># reasonable data so we just break.</span>
                <span class="s0">#</span>
                <span class="s0"># 9ee4d0a0caf095314fd7041a3e4404dc is the offending sample</span>
                <span class="s4">if </span><span class="s1">base_rva + res.OffsetToDirectory </span><span class="s4">in </span><span class="s1">dirs:</span>
                    <span class="s4">break</span>

                <span class="s1">entry_directory = self.parse_resources_directory(</span>
                    <span class="s1">base_rva + res.OffsetToDirectory</span><span class="s4">,</span>
                    <span class="s1">size - (rva - base_rva)</span><span class="s4">,  </span><span class="s0"># size</span>
                    <span class="s1">base_rva=base_rva</span><span class="s4">,</span>
                    <span class="s1">level=level + </span><span class="s5">1</span><span class="s4">,</span>
                    <span class="s1">dirs=dirs + [base_rva + res.OffsetToDirectory]</span><span class="s4">,</span>
                <span class="s1">)</span>

                <span class="s4">if not </span><span class="s1">entry_directory:</span>
                    <span class="s4">break</span>

                <span class="s0"># Ange Albertini's code to process resources' strings</span>
                <span class="s0">#</span>
                <span class="s1">strings = </span><span class="s4">None</span>
                <span class="s4">if </span><span class="s1">entry_id == RESOURCE_TYPE[</span><span class="s3">&quot;RT_STRING&quot;</span><span class="s1">]:</span>
                    <span class="s1">strings = {}</span>
                    <span class="s4">for </span><span class="s1">resource_id </span><span class="s4">in </span><span class="s1">entry_directory.entries:</span>
                        <span class="s4">if </span><span class="s1">hasattr(resource_id</span><span class="s4">, </span><span class="s3">&quot;directory&quot;</span><span class="s1">):</span>

                            <span class="s1">resource_strings = {}</span>

                            <span class="s4">for </span><span class="s1">resource_lang </span><span class="s4">in </span><span class="s1">resource_id.directory.entries:</span>

                                <span class="s4">if </span><span class="s1">(</span>
                                    <span class="s1">resource_lang </span><span class="s4">is None</span>
                                    <span class="s4">or not </span><span class="s1">hasattr(resource_lang</span><span class="s4">, </span><span class="s3">&quot;data&quot;</span><span class="s1">)</span>
                                    <span class="s4">or </span><span class="s1">resource_lang.data.struct.Size </span><span class="s4">is None</span>
                                    <span class="s4">or </span><span class="s1">resource_id.id </span><span class="s4">is None</span>
                                <span class="s1">):</span>
                                    <span class="s4">continue</span>

                                <span class="s1">string_entry_rva = (</span>
                                    <span class="s1">resource_lang.data.struct.OffsetToData</span>
                                <span class="s1">)</span>
                                <span class="s1">string_entry_size = resource_lang.data.struct.Size</span>
                                <span class="s1">string_entry_id = resource_id.id</span>

                                <span class="s0"># XXX: has been raising exceptions preventing parsing</span>
                                <span class="s4">try</span><span class="s1">:</span>
                                    <span class="s1">string_entry_data = self.get_data(</span>
                                        <span class="s1">string_entry_rva</span><span class="s4">, </span><span class="s1">string_entry_size</span>
                                    <span class="s1">)</span>
                                <span class="s4">except </span><span class="s1">PEFormatError:</span>
                                    <span class="s1">self.__warnings.append(</span>
                                        <span class="s3">f&quot;Error parsing resource of type RT_STRING at &quot;</span>
                                        <span class="s3">f&quot;RVA 0x</span><span class="s4">{</span><span class="s1">string_entry_rva</span><span class="s4">:</span><span class="s3">x</span><span class="s4">} </span><span class="s3">with &quot;</span>
                                        <span class="s3">f&quot;size </span><span class="s4">{</span><span class="s1">string_entry_size</span><span class="s4">}</span><span class="s3">&quot;</span>
                                    <span class="s1">)</span>
                                    <span class="s4">continue</span>

                                <span class="s1">parse_strings(</span>
                                    <span class="s1">string_entry_data</span><span class="s4">,</span>
                                    <span class="s1">(int(string_entry_id) - </span><span class="s5">1</span><span class="s1">) * </span><span class="s5">16</span><span class="s4">,</span>
                                    <span class="s1">resource_strings</span><span class="s4">,</span>
                                <span class="s1">)</span>
                                <span class="s1">strings.update(resource_strings)</span>

                            <span class="s1">resource_id.directory.strings = resource_strings</span>

                <span class="s1">dir_entries.append(</span>
                    <span class="s1">ResourceDirEntryData(</span>
                        <span class="s1">struct=res</span><span class="s4">,</span>
                        <span class="s1">name=entry_name</span><span class="s4">,</span>
                        <span class="s1">id=entry_id</span><span class="s4">,</span>
                        <span class="s1">directory=entry_directory</span><span class="s4">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">struct = self.parse_resource_data_entry(</span>
                    <span class="s1">base_rva + res.OffsetToDirectory</span>
                <span class="s1">)</span>

                <span class="s4">if </span><span class="s1">struct:</span>
                    <span class="s1">self.__total_resource_bytes += struct.Size</span>
                    <span class="s1">entry_data = ResourceDataEntryData(</span>
                        <span class="s1">struct=struct</span><span class="s4">, </span><span class="s1">lang=res.Name &amp; </span><span class="s5">0x3FF</span><span class="s4">, </span><span class="s1">sublang=res.Name &gt;&gt; </span><span class="s5">10</span>
                    <span class="s1">)</span>

                    <span class="s1">dir_entries.append(</span>
                        <span class="s1">ResourceDirEntryData(</span>
                            <span class="s1">struct=res</span><span class="s4">, </span><span class="s1">name=entry_name</span><span class="s4">, </span><span class="s1">id=entry_id</span><span class="s4">, </span><span class="s1">data=entry_data</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s4">break</span>

            <span class="s0"># Check if this entry contains version information</span>
            <span class="s0">#</span>
            <span class="s4">if </span><span class="s1">level == </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">res.Id == RESOURCE_TYPE[</span><span class="s3">&quot;RT_VERSION&quot;</span><span class="s1">]:</span>
                <span class="s4">if </span><span class="s1">dir_entries:</span>
                    <span class="s1">last_entry = dir_entries[-</span><span class="s5">1</span><span class="s1">]</span>

                <span class="s4">try</span><span class="s1">:</span>
                    <span class="s1">version_entries = last_entry.directory.entries[</span><span class="s5">0</span><span class="s1">].directory.entries</span>
                <span class="s4">except</span><span class="s1">:</span>
                    <span class="s0"># Maybe a malformed directory structure...?</span>
                    <span class="s0"># Let's ignore it</span>
                    <span class="s4">pass</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s4">for </span><span class="s1">version_entry </span><span class="s4">in </span><span class="s1">version_entries:</span>
                        <span class="s1">rt_version_struct = </span><span class="s4">None</span>
                        <span class="s4">try</span><span class="s1">:</span>
                            <span class="s1">rt_version_struct = version_entry.data.struct</span>
                        <span class="s4">except</span><span class="s1">:</span>
                            <span class="s0"># Maybe a malformed directory structure...?</span>
                            <span class="s0"># Let's ignore it</span>
                            <span class="s4">pass</span>

                        <span class="s4">if </span><span class="s1">rt_version_struct </span><span class="s4">is not None</span><span class="s1">:</span>
                            <span class="s1">self.parse_version_information(rt_version_struct)</span>

            <span class="s1">rva += res.sizeof()</span>

        <span class="s1">string_rvas = [s.get_rva() </span><span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">strings_to_postprocess]</span>
        <span class="s1">string_rvas.sort()</span>

        <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">s </span><span class="s4">in </span><span class="s1">enumerate(strings_to_postprocess):</span>
            <span class="s1">s.render_pascal_16()</span>

        <span class="s1">resource_directory_data = ResourceDirData(</span>
            <span class="s1">struct=resource_dir</span><span class="s4">, </span><span class="s1">entries=dir_entries</span>
        <span class="s1">)</span>

        <span class="s4">return </span><span class="s1">resource_directory_data</span>

    <span class="s4">def </span><span class="s1">parse_resource_data_entry(self</span><span class="s4">, </span><span class="s1">rva):</span>
        <span class="s2">&quot;&quot;&quot;Parse a data entry from the resources directory.&quot;&quot;&quot;</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s0"># If the RVA is invalid all would blow up. Some EXEs seem to be</span>
            <span class="s0"># specially nasty and have an invalid RVA.</span>
            <span class="s1">data = self.get_data(</span>
                <span class="s1">rva</span><span class="s4">, </span><span class="s1">Structure(self.__IMAGE_RESOURCE_DATA_ENTRY_format__).sizeof()</span>
            <span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Error parsing a resource directory data entry, &quot;</span>
                <span class="s3">&quot;the RVA is invalid: 0x%x&quot; </span><span class="s1">% (rva)</span>
            <span class="s1">)</span>
            <span class="s4">return None</span>

        <span class="s1">data_entry = self.__unpack_data__(</span>
            <span class="s1">self.__IMAGE_RESOURCE_DATA_ENTRY_format__</span><span class="s4">,</span>
            <span class="s1">data</span><span class="s4">,</span>
            <span class="s1">file_offset=self.get_offset_from_rva(rva)</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s4">return </span><span class="s1">data_entry</span>

    <span class="s4">def </span><span class="s1">parse_resource_entry(self</span><span class="s4">, </span><span class="s1">rva):</span>
        <span class="s2">&quot;&quot;&quot;Parse a directory entry from the resources directory.&quot;&quot;&quot;</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">data = self.get_data(</span>
                <span class="s1">rva</span><span class="s4">, </span><span class="s1">Structure(self.__IMAGE_RESOURCE_DIRECTORY_ENTRY_format__).sizeof()</span>
            <span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s0"># A warning will be added by the caller if this method returns None</span>
            <span class="s4">return None</span>

        <span class="s1">resource = self.__unpack_data__(</span>
            <span class="s1">self.__IMAGE_RESOURCE_DIRECTORY_ENTRY_format__</span><span class="s4">,</span>
            <span class="s1">data</span><span class="s4">,</span>
            <span class="s1">file_offset=self.get_offset_from_rva(rva)</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s4">if </span><span class="s1">resource </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s4">return None</span>

        <span class="s0"># resource.NameIsString = (resource.Name &amp; 0x80000000L) &gt;&gt; 31</span>
        <span class="s1">resource.NameOffset = resource.Name &amp; </span><span class="s5">0x7FFFFFFF</span>

        <span class="s1">resource.__pad = resource.Name &amp; </span><span class="s5">0xFFFF0000</span>
        <span class="s1">resource.Id = resource.Name &amp; </span><span class="s5">0x0000FFFF</span>

        <span class="s1">resource.DataIsDirectory = (resource.OffsetToData &amp; </span><span class="s5">0x80000000</span><span class="s1">) &gt;&gt; </span><span class="s5">31</span>
        <span class="s1">resource.OffsetToDirectory = resource.OffsetToData &amp; </span><span class="s5">0x7FFFFFFF</span>

        <span class="s4">return </span><span class="s1">resource</span>

    <span class="s4">def </span><span class="s1">parse_version_information(self</span><span class="s4">, </span><span class="s1">version_struct):</span>
        <span class="s2">&quot;&quot;&quot;Parse version information structure. 
 
        The date will be made available in three attributes of the PE object. 
 
        VS_VERSIONINFO   will contain the first three fields of the main structure: 
            'Length', 'ValueLength', and 'Type' 
 
        VS_FIXEDFILEINFO will hold the rest of the fields, accessible as sub-attributes: 
            'Signature', 'StrucVersion', 'FileVersionMS', 'FileVersionLS', 
            'ProductVersionMS', 'ProductVersionLS', 'FileFlagsMask', 'FileFlags', 
            'FileOS', 'FileType', 'FileSubtype', 'FileDateMS', 'FileDateLS' 
 
        FileInfo    is a list of all StringFileInfo and VarFileInfo structures. 
 
        StringFileInfo structures will have a list as an attribute named 'StringTable' 
        containing all the StringTable structures. Each of those structures contains a 
        dictionary 'entries' with all the key / value version information string pairs. 
 
        VarFileInfo structures will have a list as an attribute named 'Var' containing 
        all Var structures. Each Var structure will have a dictionary as an attribute 
        named 'entry' which will contain the name and value of the Var. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Retrieve the data for the version info resource</span>
        <span class="s0">#</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">start_offset = self.get_offset_from_rva(version_struct.OffsetToData)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Error parsing the version information, &quot;</span>
                <span class="s3">&quot;attempting to read OffsetToData with RVA: 0x{:x}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">version_struct.OffsetToData</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s4">return</span>
        <span class="s1">raw_data = self.__data__[start_offset : start_offset + version_struct.Size]</span>

        <span class="s0"># Map the main structure and the subsequent string</span>
        <span class="s0">#</span>
        <span class="s1">versioninfo_struct = self.__unpack_data__(</span>
            <span class="s1">self.__VS_VERSIONINFO_format__</span><span class="s4">, </span><span class="s1">raw_data</span><span class="s4">, </span><span class="s1">file_offset=start_offset</span>
        <span class="s1">)</span>

        <span class="s4">if </span><span class="s1">versioninfo_struct </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s4">return</span>

        <span class="s1">ustr_offset = version_struct.OffsetToData + versioninfo_struct.sizeof()</span>
        <span class="s1">section = self.get_section_by_rva(ustr_offset)</span>
        <span class="s1">section_end = </span><span class="s4">None</span>
        <span class="s4">if </span><span class="s1">section:</span>
            <span class="s1">section_end = section.VirtualAddress + max(</span>
                <span class="s1">section.SizeOfRawData</span><span class="s4">, </span><span class="s1">section.Misc_VirtualSize</span>
            <span class="s1">)</span>

        <span class="s1">versioninfo_string = </span><span class="s4">None</span>
        <span class="s0"># These should return 'ascii' decoded data. For the case when it's</span>
        <span class="s0"># garbled data the ascii string will retain the byte values while</span>
        <span class="s0"># encoding it to something else may yield values that don't match the</span>
        <span class="s0"># file's contents.</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">section_end </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">versioninfo_string = self.get_string_u_at_rva(</span>
                    <span class="s1">ustr_offset</span><span class="s4">, </span><span class="s1">encoding=</span><span class="s3">&quot;ascii&quot;</span>
                <span class="s1">)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">versioninfo_string = self.get_string_u_at_rva(</span>
                    <span class="s1">ustr_offset</span><span class="s4">, </span><span class="s1">(section_end - ustr_offset) &gt;&gt; </span><span class="s5">1</span><span class="s4">, </span><span class="s1">encoding=</span><span class="s3">&quot;ascii&quot;</span>
                <span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Error parsing the version information, &quot;</span>
                <span class="s3">&quot;attempting to read VS_VERSION_INFO string. Can't &quot;</span>
                <span class="s3">&quot;read unicode string at offset 0x%x&quot; </span><span class="s1">% (ustr_offset)</span>
            <span class="s1">)</span>

        <span class="s4">if </span><span class="s1">versioninfo_string </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Invalid VS_VERSION_INFO block: {0}&quot;</span><span class="s1">.format(versioninfo_string)</span>
            <span class="s1">)</span>
            <span class="s4">return</span>

        <span class="s0"># If the structure does not contain the expected name, it's assumed to</span>
        <span class="s0"># be invalid</span>
        <span class="s4">if </span><span class="s1">versioninfo_string </span><span class="s4">is not None and </span><span class="s1">versioninfo_string != </span><span class="s6">b&quot;VS_VERSION_INFO&quot;</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">len(versioninfo_string) &gt; </span><span class="s5">128</span><span class="s1">:</span>
                <span class="s1">excerpt = versioninfo_string[:</span><span class="s5">128</span><span class="s1">].decode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>
                <span class="s0"># Don't leave any half-escaped characters</span>
                <span class="s1">excerpt = excerpt[: excerpt.rfind(</span><span class="s3">&quot;</span><span class="s4">\\</span><span class="s3">u&quot;</span><span class="s1">)]</span>
                <span class="s1">versioninfo_string = b(</span>
                    <span class="s3">&quot;{0} ... ({1} bytes, too long to display)&quot;</span><span class="s1">.format(</span>
                        <span class="s1">excerpt</span><span class="s4">, </span><span class="s1">len(versioninfo_string)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Invalid VS_VERSION_INFO block: {0}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">versioninfo_string.decode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">).replace(</span><span class="s3">&quot;</span><span class="s4">\00</span><span class="s3">&quot;</span><span class="s4">, </span><span class="s3">&quot;</span><span class="s4">\\</span><span class="s3">00&quot;</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s4">return</span>

        <span class="s4">if not </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;VS_VERSIONINFO&quot;</span><span class="s1">):</span>
            <span class="s1">self.VS_VERSIONINFO = []</span>

        <span class="s0"># Set the PE object's VS_VERSIONINFO to this one</span>
        <span class="s1">vinfo = versioninfo_struct</span>

        <span class="s0"># Set the Key attribute to point to the unicode string identifying the structure</span>
        <span class="s1">vinfo.Key = versioninfo_string</span>

        <span class="s1">self.VS_VERSIONINFO.append(vinfo)</span>

        <span class="s4">if </span><span class="s1">versioninfo_string </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">versioninfo_string = </span><span class="s3">&quot;&quot;</span>
        <span class="s0"># Process the fixed version information, get the offset and structure</span>
        <span class="s1">fixedfileinfo_offset = self.dword_align(</span>
            <span class="s1">versioninfo_struct.sizeof() + </span><span class="s5">2 </span><span class="s1">* (len(versioninfo_string) + </span><span class="s5">1</span><span class="s1">)</span><span class="s4">,</span>
            <span class="s1">version_struct.OffsetToData</span><span class="s4">,</span>
        <span class="s1">)</span>
        <span class="s1">fixedfileinfo_struct = self.__unpack_data__(</span>
            <span class="s1">self.__VS_FIXEDFILEINFO_format__</span><span class="s4">,</span>
            <span class="s1">raw_data[fixedfileinfo_offset:]</span><span class="s4">,</span>
            <span class="s1">file_offset=start_offset + fixedfileinfo_offset</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s4">if not </span><span class="s1">fixedfileinfo_struct:</span>
            <span class="s4">return</span>

        <span class="s4">if not </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;VS_FIXEDFILEINFO&quot;</span><span class="s1">):</span>
            <span class="s1">self.VS_FIXEDFILEINFO = []</span>

        <span class="s0"># Set the PE object's VS_FIXEDFILEINFO to this one</span>
        <span class="s1">self.VS_FIXEDFILEINFO.append(fixedfileinfo_struct)</span>

        <span class="s0"># Start parsing all the StringFileInfo and VarFileInfo structures</span>

        <span class="s0"># Get the first one</span>
        <span class="s1">stringfileinfo_offset = self.dword_align(</span>
            <span class="s1">fixedfileinfo_offset + fixedfileinfo_struct.sizeof()</span><span class="s4">,</span>
            <span class="s1">version_struct.OffsetToData</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s0"># Set the PE object's attribute that will contain them all.</span>
        <span class="s4">if not </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;FileInfo&quot;</span><span class="s1">):</span>
            <span class="s1">self.FileInfo = []</span>

        <span class="s1">finfo = []</span>
        <span class="s4">while True</span><span class="s1">:</span>

            <span class="s0"># Process the StringFileInfo/VarFileInfo structure</span>
            <span class="s1">stringfileinfo_struct = self.__unpack_data__(</span>
                <span class="s1">self.__StringFileInfo_format__</span><span class="s4">,</span>
                <span class="s1">raw_data[stringfileinfo_offset:]</span><span class="s4">,</span>
                <span class="s1">file_offset=start_offset + stringfileinfo_offset</span><span class="s4">,</span>
            <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">stringfileinfo_struct </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Error parsing StringFileInfo/VarFileInfo struct&quot;</span>
                <span class="s1">)</span>
                <span class="s4">return None</span>

            <span class="s0"># Get the subsequent string defining the structure.</span>
            <span class="s1">ustr_offset = (</span>
                <span class="s1">version_struct.OffsetToData</span>
                <span class="s1">+ stringfileinfo_offset</span>
                <span class="s1">+ versioninfo_struct.sizeof()</span>
            <span class="s1">)</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">stringfileinfo_string = self.get_string_u_at_rva(ustr_offset)</span>
            <span class="s4">except </span><span class="s1">PEFormatError:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Error parsing the version information, &quot;</span>
                    <span class="s3">&quot;attempting to read StringFileInfo string. Can't &quot;</span>
                    <span class="s3">&quot;read unicode string at offset 0x{0:x}&quot;</span><span class="s1">.format(ustr_offset)</span>
                <span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s0"># Set such string as the Key attribute</span>
            <span class="s1">stringfileinfo_struct.Key = stringfileinfo_string</span>

            <span class="s0"># Append the structure to the PE object's list</span>
            <span class="s1">finfo.append(stringfileinfo_struct)</span>

            <span class="s0"># Parse a StringFileInfo entry</span>
            <span class="s4">if </span><span class="s1">stringfileinfo_string </span><span class="s4">and </span><span class="s1">stringfileinfo_string.startswith(</span>
                <span class="s6">b&quot;StringFileInfo&quot;</span>
            <span class="s1">):</span>

                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">stringfileinfo_struct.Type </span><span class="s4">in </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">stringfileinfo_struct.ValueLength == </span><span class="s5">0</span>
                <span class="s1">):</span>

                    <span class="s1">stringtable_offset = self.dword_align(</span>
                        <span class="s1">stringfileinfo_offset</span>
                        <span class="s1">+ stringfileinfo_struct.sizeof()</span>
                        <span class="s1">+ </span><span class="s5">2 </span><span class="s1">* (len(stringfileinfo_string) + </span><span class="s5">1</span><span class="s1">)</span><span class="s4">,</span>
                        <span class="s1">version_struct.OffsetToData</span><span class="s4">,</span>
                    <span class="s1">)</span>

                    <span class="s1">stringfileinfo_struct.StringTable = []</span>

                    <span class="s0"># Process the String Table entries</span>
                    <span class="s4">while True</span><span class="s1">:</span>

                        <span class="s1">stringtable_struct = self.__unpack_data__(</span>
                            <span class="s1">self.__StringTable_format__</span><span class="s4">,</span>
                            <span class="s1">raw_data[stringtable_offset:]</span><span class="s4">,</span>
                            <span class="s1">file_offset=start_offset + stringtable_offset</span><span class="s4">,</span>
                        <span class="s1">)</span>

                        <span class="s4">if not </span><span class="s1">stringtable_struct:</span>
                            <span class="s4">break</span>

                        <span class="s1">ustr_offset = (</span>
                            <span class="s1">version_struct.OffsetToData</span>
                            <span class="s1">+ stringtable_offset</span>
                            <span class="s1">+ stringtable_struct.sizeof()</span>
                        <span class="s1">)</span>
                        <span class="s4">try</span><span class="s1">:</span>
                            <span class="s1">stringtable_string = self.get_string_u_at_rva(ustr_offset)</span>
                        <span class="s4">except </span><span class="s1">PEFormatError:</span>
                            <span class="s1">self.__warnings.append(</span>
                                <span class="s3">&quot;Error parsing the version information, &quot;</span>
                                <span class="s3">&quot;attempting to read StringTable string. Can't &quot;</span>
                                <span class="s3">&quot;read unicode string at offset 0x{0:x}&quot;</span><span class="s1">.format(</span>
                                    <span class="s1">ustr_offset</span>
                                <span class="s1">)</span>
                            <span class="s1">)</span>
                            <span class="s4">break</span>

                        <span class="s1">stringtable_struct.LangID = stringtable_string</span>
                        <span class="s1">stringtable_struct.entries = {}</span>
                        <span class="s1">stringtable_struct.entries_offsets = {}</span>
                        <span class="s1">stringtable_struct.entries_lengths = {}</span>
                        <span class="s1">stringfileinfo_struct.StringTable.append(stringtable_struct)</span>

                        <span class="s1">entry_offset = self.dword_align(</span>
                            <span class="s1">stringtable_offset</span>
                            <span class="s1">+ stringtable_struct.sizeof()</span>
                            <span class="s1">+ </span><span class="s5">2 </span><span class="s1">* (len(stringtable_string) + </span><span class="s5">1</span><span class="s1">)</span><span class="s4">,</span>
                            <span class="s1">version_struct.OffsetToData</span><span class="s4">,</span>
                        <span class="s1">)</span>

                        <span class="s0"># Process all entries in the string table</span>

                        <span class="s4">while </span><span class="s1">(</span>
                            <span class="s1">entry_offset</span>
                            <span class="s1">&lt; stringtable_offset + stringtable_struct.Length</span>
                        <span class="s1">):</span>

                            <span class="s1">string_struct = self.__unpack_data__(</span>
                                <span class="s1">self.__String_format__</span><span class="s4">,</span>
                                <span class="s1">raw_data[entry_offset:]</span><span class="s4">,</span>
                                <span class="s1">file_offset=start_offset + entry_offset</span><span class="s4">,</span>
                            <span class="s1">)</span>

                            <span class="s4">if not </span><span class="s1">string_struct:</span>
                                <span class="s4">break</span>

                            <span class="s1">ustr_offset = (</span>
                                <span class="s1">version_struct.OffsetToData</span>
                                <span class="s1">+ entry_offset</span>
                                <span class="s1">+ string_struct.sizeof()</span>
                            <span class="s1">)</span>
                            <span class="s4">try</span><span class="s1">:</span>
                                <span class="s1">key = self.get_string_u_at_rva(ustr_offset)</span>
                                <span class="s1">key_offset = self.get_offset_from_rva(ustr_offset)</span>
                            <span class="s4">except </span><span class="s1">PEFormatError:</span>
                                <span class="s1">self.__warnings.append(</span>
                                    <span class="s3">&quot;Error parsing the version information, &quot;</span>
                                    <span class="s3">&quot;attempting to read StringTable Key string. Can't &quot;</span>
                                    <span class="s3">&quot;read unicode string at offset 0x{0:x}&quot;</span><span class="s1">.format(</span>
                                        <span class="s1">ustr_offset</span>
                                    <span class="s1">)</span>
                                <span class="s1">)</span>
                                <span class="s4">break</span>

                            <span class="s1">value_offset = self.dword_align(</span>
                                <span class="s5">2 </span><span class="s1">* (len(key) + </span><span class="s5">1</span><span class="s1">)</span>
                                <span class="s1">+ entry_offset</span>
                                <span class="s1">+ string_struct.sizeof()</span><span class="s4">,</span>
                                <span class="s1">version_struct.OffsetToData</span><span class="s4">,</span>
                            <span class="s1">)</span>

                            <span class="s1">ustr_offset = version_struct.OffsetToData + value_offset</span>
                            <span class="s4">try</span><span class="s1">:</span>
                                <span class="s1">value = self.get_string_u_at_rva(</span>
                                    <span class="s1">ustr_offset</span><span class="s4">, </span><span class="s1">max_length=string_struct.ValueLength</span>
                                <span class="s1">)</span>
                                <span class="s1">value_offset = self.get_offset_from_rva(ustr_offset)</span>
                            <span class="s4">except </span><span class="s1">PEFormatError:</span>
                                <span class="s1">self.__warnings.append(</span>
                                    <span class="s3">&quot;Error parsing the version information, attempting &quot;</span>
                                    <span class="s3">&quot;to read StringTable Value string. Can't read &quot;</span>
                                    <span class="s3">f&quot;unicode string at offset 0x</span><span class="s4">{</span><span class="s1">ustr_offset</span><span class="s4">:</span><span class="s3">x</span><span class="s4">}</span><span class="s3">&quot;</span>
                                <span class="s1">)</span>
                                <span class="s4">break</span>

                            <span class="s4">if </span><span class="s1">string_struct.Length == </span><span class="s5">0</span><span class="s1">:</span>
                                <span class="s1">entry_offset = (</span>
                                    <span class="s1">stringtable_offset + stringtable_struct.Length</span>
                                <span class="s1">)</span>
                            <span class="s4">else</span><span class="s1">:</span>
                                <span class="s1">entry_offset = self.dword_align(</span>
                                    <span class="s1">string_struct.Length + entry_offset</span><span class="s4">,</span>
                                    <span class="s1">version_struct.OffsetToData</span><span class="s4">,</span>
                                <span class="s1">)</span>

                            <span class="s1">stringtable_struct.entries[key] = value</span>
                            <span class="s1">stringtable_struct.entries_offsets[key] = (</span>
                                <span class="s1">key_offset</span><span class="s4">,</span>
                                <span class="s1">value_offset</span><span class="s4">,</span>
                            <span class="s1">)</span>
                            <span class="s1">stringtable_struct.entries_lengths[key] = (</span>
                                <span class="s1">len(key)</span><span class="s4">,</span>
                                <span class="s1">len(value)</span><span class="s4">,</span>
                            <span class="s1">)</span>

                        <span class="s1">new_stringtable_offset = self.dword_align(</span>
                            <span class="s1">stringtable_struct.Length + stringtable_offset</span><span class="s4">,</span>
                            <span class="s1">version_struct.OffsetToData</span><span class="s4">,</span>
                        <span class="s1">)</span>

                        <span class="s0"># Check if the entry is crafted in a way that would lead</span>
                        <span class="s0"># to an infinite loop and break if so.</span>
                        <span class="s4">if </span><span class="s1">new_stringtable_offset == stringtable_offset:</span>
                            <span class="s4">break</span>
                        <span class="s1">stringtable_offset = new_stringtable_offset</span>

                        <span class="s4">if </span><span class="s1">stringtable_offset &gt;= stringfileinfo_struct.Length:</span>
                            <span class="s4">break</span>

            <span class="s0"># Parse a VarFileInfo entry</span>
            <span class="s4">elif </span><span class="s1">stringfileinfo_string </span><span class="s4">and </span><span class="s1">stringfileinfo_string.startswith(</span>
                <span class="s6">b&quot;VarFileInfo&quot;</span>
            <span class="s1">):</span>

                <span class="s1">varfileinfo_struct = stringfileinfo_struct</span>
                <span class="s1">varfileinfo_struct.name = </span><span class="s3">&quot;VarFileInfo&quot;</span>

                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">varfileinfo_struct.Type </span><span class="s4">in </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">varfileinfo_struct.ValueLength == </span><span class="s5">0</span>
                <span class="s1">):</span>

                    <span class="s1">var_offset = self.dword_align(</span>
                        <span class="s1">stringfileinfo_offset</span>
                        <span class="s1">+ varfileinfo_struct.sizeof()</span>
                        <span class="s1">+ </span><span class="s5">2 </span><span class="s1">* (len(stringfileinfo_string) + </span><span class="s5">1</span><span class="s1">)</span><span class="s4">,</span>
                        <span class="s1">version_struct.OffsetToData</span><span class="s4">,</span>
                    <span class="s1">)</span>

                    <span class="s1">varfileinfo_struct.Var = []</span>

                    <span class="s0"># Process all entries</span>

                    <span class="s4">while True</span><span class="s1">:</span>
                        <span class="s1">var_struct = self.__unpack_data__(</span>
                            <span class="s1">self.__Var_format__</span><span class="s4">,</span>
                            <span class="s1">raw_data[var_offset:]</span><span class="s4">,</span>
                            <span class="s1">file_offset=start_offset + var_offset</span><span class="s4">,</span>
                        <span class="s1">)</span>

                        <span class="s4">if not </span><span class="s1">var_struct:</span>
                            <span class="s4">break</span>

                        <span class="s1">ustr_offset = (</span>
                            <span class="s1">version_struct.OffsetToData</span>
                            <span class="s1">+ var_offset</span>
                            <span class="s1">+ var_struct.sizeof()</span>
                        <span class="s1">)</span>
                        <span class="s4">try</span><span class="s1">:</span>
                            <span class="s1">var_string = self.get_string_u_at_rva(ustr_offset)</span>
                        <span class="s4">except </span><span class="s1">PEFormatError:</span>
                            <span class="s1">self.__warnings.append(</span>
                                <span class="s3">&quot;Error parsing the version information, &quot;</span>
                                <span class="s3">&quot;attempting to read VarFileInfo Var string. &quot;</span>
                                <span class="s3">&quot;Can't read unicode string at offset 0x{0:x}&quot;</span><span class="s1">.format(</span>
                                    <span class="s1">ustr_offset</span>
                                <span class="s1">)</span>
                            <span class="s1">)</span>
                            <span class="s4">break</span>

                        <span class="s4">if </span><span class="s1">var_string </span><span class="s4">is None</span><span class="s1">:</span>
                            <span class="s4">break</span>

                        <span class="s1">varfileinfo_struct.Var.append(var_struct)</span>

                        <span class="s1">varword_offset = self.dword_align(</span>
                            <span class="s5">2 </span><span class="s1">* (len(var_string) + </span><span class="s5">1</span><span class="s1">)</span>
                            <span class="s1">+ var_offset</span>
                            <span class="s1">+ var_struct.sizeof()</span><span class="s4">,</span>
                            <span class="s1">version_struct.OffsetToData</span><span class="s4">,</span>
                        <span class="s1">)</span>
                        <span class="s1">orig_varword_offset = varword_offset</span>

                        <span class="s4">while </span><span class="s1">(</span>
                            <span class="s1">varword_offset</span>
                            <span class="s1">&lt; orig_varword_offset + var_struct.ValueLength</span>
                        <span class="s1">):</span>
                            <span class="s1">word1 = self.get_word_from_data(</span>
                                <span class="s1">raw_data[varword_offset : varword_offset + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">, </span><span class="s5">0</span>
                            <span class="s1">)</span>
                            <span class="s1">word2 = self.get_word_from_data(</span>
                                <span class="s1">raw_data[varword_offset + </span><span class="s5">2 </span><span class="s1">: varword_offset + </span><span class="s5">4</span><span class="s1">]</span><span class="s4">, </span><span class="s5">0</span>
                            <span class="s1">)</span>
                            <span class="s1">varword_offset += </span><span class="s5">4</span>

                            <span class="s4">if </span><span class="s1">isinstance(word1</span><span class="s4">, </span><span class="s1">int) </span><span class="s4">and </span><span class="s1">isinstance(word2</span><span class="s4">, </span><span class="s1">int):</span>
                                <span class="s1">var_struct.entry = {</span>
                                    <span class="s1">var_string: </span><span class="s3">&quot;0x%04x 0x%04x&quot; </span><span class="s1">% (word1</span><span class="s4">, </span><span class="s1">word2)</span>
                                <span class="s1">}</span>

                        <span class="s1">var_offset = self.dword_align(</span>
                            <span class="s1">var_offset + var_struct.Length</span><span class="s4">, </span><span class="s1">version_struct.OffsetToData</span>
                        <span class="s1">)</span>

                        <span class="s4">if </span><span class="s1">var_offset &lt;= var_offset + var_struct.Length:</span>
                            <span class="s4">break</span>

            <span class="s0"># Increment and align the offset</span>
            <span class="s1">stringfileinfo_offset = self.dword_align(</span>
                <span class="s1">stringfileinfo_struct.Length + stringfileinfo_offset</span><span class="s4">,</span>
                <span class="s1">version_struct.OffsetToData</span><span class="s4">,</span>
            <span class="s1">)</span>

            <span class="s0"># Check if all the StringFileInfo and VarFileInfo items have been processed</span>
            <span class="s4">if </span><span class="s1">(</span>
                <span class="s1">stringfileinfo_struct.Length == </span><span class="s5">0</span>
                <span class="s4">or </span><span class="s1">stringfileinfo_offset &gt;= versioninfo_struct.Length</span>
            <span class="s1">):</span>
                <span class="s4">break</span>

        <span class="s1">self.FileInfo.append(finfo)</span>

    <span class="s4">def </span><span class="s1">parse_export_directory(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size</span><span class="s4">, </span><span class="s1">forwarded_only=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Parse the export directory. 
 
        Given the RVA of the export directory, it will process all 
        its entries. 
 
        The exports will be made available as a list of ExportData 
        instances in the 'IMAGE_DIRECTORY_ENTRY_EXPORT' PE attribute. 
        &quot;&quot;&quot;</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">export_dir = self.__unpack_data__(</span>
                <span class="s1">self.__IMAGE_EXPORT_DIRECTORY_format__</span><span class="s4">,</span>
                <span class="s1">self.get_data(</span>
                    <span class="s1">rva</span><span class="s4">, </span><span class="s1">Structure(self.__IMAGE_EXPORT_DIRECTORY_format__).sizeof()</span>
                <span class="s1">)</span><span class="s4">,</span>
                <span class="s1">file_offset=self.get_offset_from_rva(rva)</span><span class="s4">,</span>
            <span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Error parsing export directory at RVA: 0x%x&quot; </span><span class="s1">% (rva)</span>
            <span class="s1">)</span>
            <span class="s4">return</span>

        <span class="s4">if not </span><span class="s1">export_dir:</span>
            <span class="s4">return</span>

        <span class="s0"># We keep track of the bytes left in the file and use it to set a upper</span>
        <span class="s0"># bound in the number of items that can be read from the different</span>
        <span class="s0"># arrays.</span>
        <span class="s4">def </span><span class="s1">length_until_eof(rva):</span>
            <span class="s4">return </span><span class="s1">len(self.__data__) - self.get_offset_from_rva(rva)</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">address_of_names = self.get_data(</span>
                <span class="s1">export_dir.AddressOfNames</span><span class="s4">,</span>
                <span class="s1">min(</span>
                    <span class="s1">length_until_eof(export_dir.AddressOfNames)</span><span class="s4">,</span>
                    <span class="s1">export_dir.NumberOfNames * </span><span class="s5">4</span><span class="s4">,</span>
                <span class="s1">)</span><span class="s4">,</span>
            <span class="s1">)</span>
            <span class="s1">address_of_name_ordinals = self.get_data(</span>
                <span class="s1">export_dir.AddressOfNameOrdinals</span><span class="s4">,</span>
                <span class="s1">min(</span>
                    <span class="s1">length_until_eof(export_dir.AddressOfNameOrdinals)</span><span class="s4">,</span>
                    <span class="s1">export_dir.NumberOfNames * </span><span class="s5">4</span><span class="s4">,</span>
                <span class="s1">)</span><span class="s4">,</span>
            <span class="s1">)</span>
            <span class="s1">address_of_functions = self.get_data(</span>
                <span class="s1">export_dir.AddressOfFunctions</span><span class="s4">,</span>
                <span class="s1">min(</span>
                    <span class="s1">length_until_eof(export_dir.AddressOfFunctions)</span><span class="s4">,</span>
                    <span class="s1">export_dir.NumberOfFunctions * </span><span class="s5">4</span><span class="s4">,</span>
                <span class="s1">)</span><span class="s4">,</span>
            <span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Error parsing export directory at RVA: 0x%x&quot; </span><span class="s1">% (rva)</span>
            <span class="s1">)</span>
            <span class="s4">return</span>

        <span class="s1">exports = []</span>

        <span class="s1">max_failed_entries_before_giving_up = </span><span class="s5">10</span>

        <span class="s1">section = self.get_section_by_rva(export_dir.AddressOfNames)</span>
        <span class="s0"># Overly generous upper bound</span>
        <span class="s1">safety_boundary = len(self.__data__)</span>
        <span class="s4">if </span><span class="s1">section:</span>
            <span class="s1">safety_boundary = (</span>
                <span class="s1">section.VirtualAddress</span>
                <span class="s1">+ len(section.get_data())</span>
                <span class="s1">- export_dir.AddressOfNames</span>
            <span class="s1">)</span>

        <span class="s1">symbol_counts = collections.defaultdict(int)</span>
        <span class="s1">export_parsing_loop_completed_normally = </span><span class="s4">True</span>
        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(min(export_dir.NumberOfNames</span><span class="s4">, </span><span class="s1">int(safety_boundary / </span><span class="s5">4</span><span class="s1">))):</span>
            <span class="s1">symbol_ordinal = self.get_word_from_data(address_of_name_ordinals</span><span class="s4">, </span><span class="s1">i)</span>

            <span class="s4">if </span><span class="s1">symbol_ordinal </span><span class="s4">is not None and </span><span class="s1">symbol_ordinal * </span><span class="s5">4 </span><span class="s1">&lt; len(</span>
                <span class="s1">address_of_functions</span>
            <span class="s1">):</span>
                <span class="s1">symbol_address = self.get_dword_from_data(</span>
                    <span class="s1">address_of_functions</span><span class="s4">, </span><span class="s1">symbol_ordinal</span>
                <span class="s1">)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s0"># Corrupt? a bad pointer... we assume it's all</span>
                <span class="s0"># useless, no exports</span>
                <span class="s4">return None</span>
            <span class="s4">if </span><span class="s1">symbol_address </span><span class="s4">is None or </span><span class="s1">symbol_address == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">continue</span>

            <span class="s0"># If the function's RVA points within the export directory</span>
            <span class="s0"># it will point to a string with the forwarded symbol's string</span>
            <span class="s0"># instead of pointing the the function start address.</span>
            <span class="s4">if </span><span class="s1">symbol_address &gt;= rva </span><span class="s4">and </span><span class="s1">symbol_address &lt; rva + size:</span>
                <span class="s1">forwarder_str = self.get_string_at_rva(symbol_address)</span>
                <span class="s4">try</span><span class="s1">:</span>
                    <span class="s1">forwarder_offset = self.get_offset_from_rva(symbol_address)</span>
                <span class="s4">except </span><span class="s1">PEFormatError:</span>
                    <span class="s4">continue</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">forwarded_only:</span>
                    <span class="s4">continue</span>
                <span class="s1">forwarder_str = </span><span class="s4">None</span>
                <span class="s1">forwarder_offset = </span><span class="s4">None</span>

            <span class="s1">symbol_name_address = self.get_dword_from_data(address_of_names</span><span class="s4">, </span><span class="s1">i)</span>
            <span class="s4">if </span><span class="s1">symbol_name_address </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s1">max_failed_entries_before_giving_up -= </span><span class="s5">1</span>
                <span class="s4">if </span><span class="s1">max_failed_entries_before_giving_up &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">export_parsing_loop_completed_normally = </span><span class="s4">False</span>
                    <span class="s4">break</span>

            <span class="s1">symbol_name = self.get_string_at_rva(</span>
                <span class="s1">symbol_name_address</span><span class="s4">, </span><span class="s1">MAX_SYMBOL_NAME_LENGTH</span>
            <span class="s1">)</span>
            <span class="s4">if not </span><span class="s1">is_valid_function_name(symbol_name</span><span class="s4">, </span><span class="s1">relax_allowed_characters=</span><span class="s4">True</span><span class="s1">):</span>
                <span class="s1">export_parsing_loop_completed_normally = </span><span class="s4">False</span>
                <span class="s4">break</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">symbol_name_offset = self.get_offset_from_rva(symbol_name_address)</span>
            <span class="s4">except </span><span class="s1">PEFormatError:</span>
                <span class="s1">max_failed_entries_before_giving_up -= </span><span class="s5">1</span>
                <span class="s4">if </span><span class="s1">max_failed_entries_before_giving_up &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">export_parsing_loop_completed_normally = </span><span class="s4">False</span>
                    <span class="s4">break</span>
                <span class="s4">try</span><span class="s1">:</span>
                    <span class="s1">symbol_name_offset = self.get_offset_from_rva(symbol_name_address)</span>
                <span class="s4">except </span><span class="s1">PEFormatError:</span>
                    <span class="s1">max_failed_entries_before_giving_up -= </span><span class="s5">1</span>
                    <span class="s4">if </span><span class="s1">max_failed_entries_before_giving_up &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s1">export_parsing_loop_completed_normally = </span><span class="s4">False</span>
                        <span class="s4">break</span>
                    <span class="s4">continue</span>

            <span class="s0"># File 0b1d3d3664915577ab9a32188d29bbf3542b86c7b9ce333e245496c3018819f1</span>
            <span class="s0"># was being parsed as potentially containing millions of exports.</span>
            <span class="s0"># Checking for duplicates addresses the issue.</span>
            <span class="s1">symbol_counts[(symbol_name</span><span class="s4">, </span><span class="s1">symbol_address)] += </span><span class="s5">1</span>
            <span class="s4">if </span><span class="s1">symbol_counts[(symbol_name</span><span class="s4">, </span><span class="s1">symbol_address)] &gt; </span><span class="s5">10</span><span class="s1">:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">f&quot;Export directory contains more than 10 repeated entries &quot;</span>
                    <span class="s3">f&quot;(</span><span class="s4">{</span><span class="s1">symbol_name</span><span class="s4">}</span><span class="s3">, </span><span class="s4">{</span><span class="s1">symbol_address</span><span class="s4">:</span><span class="s3">#02x</span><span class="s4">}</span><span class="s3">). Assuming corrupt.&quot;</span>
                <span class="s1">)</span>
                <span class="s4">break</span>
            <span class="s4">elif </span><span class="s1">len(symbol_counts) &gt; self.max_symbol_exports:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Export directory contains more than {} symbol entries. &quot;</span>
                    <span class="s3">&quot;Assuming corrupt.&quot;</span><span class="s1">.format(self.max_symbol_exports)</span>
                <span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s1">exports.append(</span>
                <span class="s1">ExportData(</span>
                    <span class="s1">pe=self</span><span class="s4">,</span>
                    <span class="s1">ordinal=export_dir.Base + symbol_ordinal</span><span class="s4">,</span>
                    <span class="s1">ordinal_offset=self.get_offset_from_rva(</span>
                        <span class="s1">export_dir.AddressOfNameOrdinals + </span><span class="s5">2 </span><span class="s1">* i</span>
                    <span class="s1">)</span><span class="s4">,</span>
                    <span class="s1">address=symbol_address</span><span class="s4">,</span>
                    <span class="s1">address_offset=self.get_offset_from_rva(</span>
                        <span class="s1">export_dir.AddressOfFunctions + </span><span class="s5">4 </span><span class="s1">* symbol_ordinal</span>
                    <span class="s1">)</span><span class="s4">,</span>
                    <span class="s1">name=symbol_name</span><span class="s4">,</span>
                    <span class="s1">name_offset=symbol_name_offset</span><span class="s4">,</span>
                    <span class="s1">forwarder=forwarder_str</span><span class="s4">,</span>
                    <span class="s1">forwarder_offset=forwarder_offset</span><span class="s4">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s4">if not </span><span class="s1">export_parsing_loop_completed_normally:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">f&quot;RVA AddressOfNames in the export directory points to an invalid &quot;</span>
                <span class="s3">f&quot;address: </span><span class="s4">{</span><span class="s1">export_dir.AddressOfNames</span><span class="s4">:</span><span class="s3">x</span><span class="s4">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>

        <span class="s1">ordinals = {exp.ordinal </span><span class="s4">for </span><span class="s1">exp </span><span class="s4">in </span><span class="s1">exports}</span>

        <span class="s1">max_failed_entries_before_giving_up = </span><span class="s5">10</span>

        <span class="s1">section = self.get_section_by_rva(export_dir.AddressOfFunctions)</span>
        <span class="s0"># Overly generous upper bound</span>
        <span class="s1">safety_boundary = len(self.__data__)</span>
        <span class="s4">if </span><span class="s1">section:</span>
            <span class="s1">safety_boundary = (</span>
                <span class="s1">section.VirtualAddress</span>
                <span class="s1">+ len(section.get_data())</span>
                <span class="s1">- export_dir.AddressOfFunctions</span>
            <span class="s1">)</span>

        <span class="s1">symbol_counts = collections.defaultdict(int)</span>
        <span class="s1">export_parsing_loop_completed_normally = </span><span class="s4">True</span>
        <span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">range(min(export_dir.NumberOfFunctions</span><span class="s4">, </span><span class="s1">int(safety_boundary / </span><span class="s5">4</span><span class="s1">))):</span>

            <span class="s4">if not </span><span class="s1">idx + export_dir.Base </span><span class="s4">in </span><span class="s1">ordinals:</span>
                <span class="s4">try</span><span class="s1">:</span>
                    <span class="s1">symbol_address = self.get_dword_from_data(address_of_functions</span><span class="s4">, </span><span class="s1">idx)</span>
                <span class="s4">except </span><span class="s1">PEFormatError:</span>
                    <span class="s1">symbol_address = </span><span class="s4">None</span>

                <span class="s4">if </span><span class="s1">symbol_address </span><span class="s4">is None</span><span class="s1">:</span>
                    <span class="s1">max_failed_entries_before_giving_up -= </span><span class="s5">1</span>
                    <span class="s4">if </span><span class="s1">max_failed_entries_before_giving_up &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s1">export_parsing_loop_completed_normally = </span><span class="s4">False</span>
                        <span class="s4">break</span>

                <span class="s4">if </span><span class="s1">symbol_address == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s4">continue</span>

                <span class="s0"># Checking for forwarder again.</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">symbol_address </span><span class="s4">is not None</span>
                    <span class="s4">and </span><span class="s1">symbol_address &gt;= rva</span>
                    <span class="s4">and </span><span class="s1">symbol_address &lt; rva + size</span>
                <span class="s1">):</span>
                    <span class="s1">forwarder_str = self.get_string_at_rva(symbol_address)</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">forwarder_str = </span><span class="s4">None</span>

                <span class="s0"># File 0b1d3d3664915577ab9a32188d29bbf3542b86c7b9ce333e245496c3018819f1</span>
                <span class="s0"># was being parsed as potentially containing millions of exports.</span>
                <span class="s0"># Checking for duplicates addresses the issue.</span>
                <span class="s1">symbol_counts[symbol_address] += </span><span class="s5">1</span>
                <span class="s4">if </span><span class="s1">symbol_counts[symbol_address] &gt; self.max_repeated_symbol:</span>
                    <span class="s0"># if most_common and most_common[0][1] &gt; 10:</span>
                    <span class="s1">self.__warnings.append(</span>
                        <span class="s3">&quot;Export directory contains more than {} repeated &quot;</span>
                        <span class="s3">&quot;ordinal entries (0x{:x}). Assuming corrupt.&quot;</span><span class="s1">.format(</span>
                            <span class="s1">self.max_repeated_symbol</span><span class="s4">, </span><span class="s1">symbol_address</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                    <span class="s4">break</span>
                <span class="s4">elif </span><span class="s1">len(symbol_counts) &gt; self.max_symbol_exports:</span>
                    <span class="s1">self.__warnings.append(</span>
                        <span class="s3">&quot;Export directory contains more than &quot;</span>
                        <span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">self.max_symbol_exports</span><span class="s4">} </span><span class="s3">ordinal entries. Assuming corrupt.&quot;</span>
                    <span class="s1">)</span>
                    <span class="s4">break</span>

                <span class="s1">exports.append(</span>
                    <span class="s1">ExportData(</span>
                        <span class="s1">ordinal=export_dir.Base + idx</span><span class="s4">,</span>
                        <span class="s1">address=symbol_address</span><span class="s4">,</span>
                        <span class="s1">name=</span><span class="s4">None,</span>
                        <span class="s1">forwarder=forwarder_str</span><span class="s4">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s4">if not </span><span class="s1">export_parsing_loop_completed_normally:</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;RVA AddressOfFunctions in the export directory points to an invalid &quot;</span>
                <span class="s3">f&quot;address: </span><span class="s4">{</span><span class="s1">export_dir.AddressOfFunctions</span><span class="s4">:</span><span class="s3">x</span><span class="s4">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>
            <span class="s4">return</span>

        <span class="s4">if not </span><span class="s1">exports </span><span class="s4">and </span><span class="s1">export_dir.all_zeroes():</span>
            <span class="s4">return None</span>
        <span class="s4">return </span><span class="s1">ExportDirData(</span>
            <span class="s1">struct=export_dir</span><span class="s4">,</span>
            <span class="s1">symbols=exports</span><span class="s4">,</span>
            <span class="s1">name=self.get_string_at_rva(export_dir.Name)</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">dword_align(self</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">, </span><span class="s1">base):</span>
        <span class="s4">return </span><span class="s1">((offset + base + </span><span class="s5">3</span><span class="s1">) &amp; </span><span class="s5">0xFFFFFFFC</span><span class="s1">) - (base &amp; </span><span class="s5">0xFFFFFFFC</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">normalize_import_va(self</span><span class="s4">, </span><span class="s1">va):</span>

        <span class="s0"># Setup image range</span>
        <span class="s1">begin_of_image = self.OPTIONAL_HEADER.ImageBase</span>
        <span class="s1">end_of_image = self.OPTIONAL_HEADER.ImageBase + self.OPTIONAL_HEADER.SizeOfImage</span>

        <span class="s0"># Try to avoid bogus VAs, which are out of the image.</span>
        <span class="s0"># This also filters out entries that are zero</span>
        <span class="s4">if </span><span class="s1">begin_of_image &lt;= va </span><span class="s4">and </span><span class="s1">va &lt; end_of_image:</span>
            <span class="s1">va -= begin_of_image</span>
        <span class="s4">return </span><span class="s1">va</span>

    <span class="s4">def </span><span class="s1">parse_delay_import_directory(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size):</span>
        <span class="s2">&quot;&quot;&quot;Walk and parse the delay import directory.&quot;&quot;&quot;</span>

        <span class="s1">import_descs = []</span>
        <span class="s1">error_count = </span><span class="s5">0</span>
        <span class="s4">while True</span><span class="s1">:</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s0"># If the RVA is invalid all would blow up. Some PEs seem to be</span>
                <span class="s0"># specially nasty and have an invalid RVA.</span>
                <span class="s1">data = self.get_data(</span>
                    <span class="s1">rva</span><span class="s4">,</span>
                    <span class="s1">Structure(self.__IMAGE_DELAY_IMPORT_DESCRIPTOR_format__).sizeof()</span><span class="s4">,</span>
                <span class="s1">)</span>
            <span class="s4">except </span><span class="s1">PEFormatError:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Error parsing the Delay import directory at RVA: 0x%x&quot; </span><span class="s1">% (rva)</span>
                <span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s1">file_offset = self.get_offset_from_rva(rva)</span>
            <span class="s1">import_desc = self.__unpack_data__(</span>
                <span class="s1">self.__IMAGE_DELAY_IMPORT_DESCRIPTOR_format__</span><span class="s4">,</span>
                <span class="s1">data</span><span class="s4">,</span>
                <span class="s1">file_offset=file_offset</span><span class="s4">,</span>
            <span class="s1">)</span>

            <span class="s0"># If the structure is all zeros, we reached the end of the list</span>
            <span class="s4">if not </span><span class="s1">import_desc </span><span class="s4">or </span><span class="s1">import_desc.all_zeroes():</span>
                <span class="s4">break</span>
            <span class="s1">contains_addresses = </span><span class="s4">False</span>

            <span class="s0"># Handle old import descriptor that has Virtual Addresses instead of RVAs</span>
            <span class="s0"># This version of import descriptor is created by old Visual Studio versions</span>
            <span class="s0"># (pre 6.0)</span>
            <span class="s0"># Can only be present in 32-bit binaries (no 64-bit compiler existed at the</span>
            <span class="s0"># time)</span>
            <span class="s0"># Sample: e8d3bff0c1a9a6955993f7a441121a2692261421e82fdfadaaded45d3bea9980</span>
            <span class="s4">if </span><span class="s1">(</span>
                <span class="s1">import_desc.grAttrs == </span><span class="s5">0</span>
                <span class="s4">and </span><span class="s1">self.FILE_HEADER.Machine == MACHINE_TYPE[</span><span class="s3">&quot;IMAGE_FILE_MACHINE_I386&quot;</span><span class="s1">]</span>
            <span class="s1">):</span>
                <span class="s1">import_desc.pBoundIAT = self.normalize_import_va(import_desc.pBoundIAT)</span>
                <span class="s1">import_desc.pIAT = self.normalize_import_va(import_desc.pIAT)</span>
                <span class="s1">import_desc.pINT = self.normalize_import_va(import_desc.pINT)</span>
                <span class="s1">import_desc.pUnloadIAT = self.normalize_import_va(</span>
                    <span class="s1">import_desc.pUnloadIAT</span>
                <span class="s1">)</span>
                <span class="s1">import_desc.phmod = self.normalize_import_va(import_desc.pUnloadIAT)</span>
                <span class="s1">import_desc.szName = self.normalize_import_va(import_desc.szName)</span>
                <span class="s1">contains_addresses = </span><span class="s4">True</span>

            <span class="s1">rva += import_desc.sizeof()</span>

            <span class="s0"># If the array of thunks is somewhere earlier than the import</span>
            <span class="s0"># descriptor we can set a maximum length for the array. Otherwise</span>
            <span class="s0"># just set a maximum length of the size of the file</span>
            <span class="s1">max_len = len(self.__data__) - file_offset</span>
            <span class="s4">if </span><span class="s1">rva &gt; import_desc.pINT </span><span class="s4">or </span><span class="s1">rva &gt; import_desc.pIAT:</span>
                <span class="s1">max_len = max(rva - import_desc.pINT</span><span class="s4">, </span><span class="s1">rva - import_desc.pIAT)</span>

            <span class="s1">import_data = []</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">import_data = self.parse_imports(</span>
                    <span class="s1">import_desc.pINT</span><span class="s4">,</span>
                    <span class="s1">import_desc.pIAT</span><span class="s4">,</span>
                    <span class="s4">None,</span>
                    <span class="s1">max_len</span><span class="s4">,</span>
                    <span class="s1">contains_addresses</span><span class="s4">,</span>
                <span class="s1">)</span>
            <span class="s4">except </span><span class="s1">PEFormatError </span><span class="s4">as </span><span class="s1">excp:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Error parsing the Delay import directory. &quot;</span>
                    <span class="s3">&quot;Invalid import data at RVA: 0x{0:x} ({1})&quot;</span><span class="s1">.format(rva</span><span class="s4">, </span><span class="s1">excp.value)</span>
                <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">error_count &gt; </span><span class="s5">5</span><span class="s1">:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Too many errors parsing the Delay import directory. &quot;</span>
                    <span class="s3">&quot;Invalid import data at RVA: 0x{0:x}&quot;</span><span class="s1">.format(rva)</span>
                <span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s4">if not </span><span class="s1">import_data:</span>
                <span class="s1">error_count += </span><span class="s5">1</span>
                <span class="s4">continue</span>

            <span class="s4">if </span><span class="s1">self.__total_import_symbols &gt; MAX_IMPORT_SYMBOLS:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Error, too many imported symbols %d (&gt;%s)&quot;</span>
                    <span class="s1">% (self.__total_import_symbols</span><span class="s4">, </span><span class="s1">MAX_IMPORT_SYMBOLS)</span>
                <span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s1">dll = self.get_string_at_rva(import_desc.szName</span><span class="s4">, </span><span class="s1">MAX_DLL_LENGTH)</span>
            <span class="s4">if not </span><span class="s1">is_valid_dos_filename(dll):</span>
                <span class="s1">dll = b(</span><span class="s3">&quot;*invalid*&quot;</span><span class="s1">)</span>

            <span class="s4">if </span><span class="s1">dll:</span>
                <span class="s4">for </span><span class="s1">symbol </span><span class="s4">in </span><span class="s1">import_data:</span>
                    <span class="s4">if </span><span class="s1">symbol.name </span><span class="s4">is None</span><span class="s1">:</span>
                        <span class="s1">funcname = ordlookup.ordLookup(dll.lower()</span><span class="s4">, </span><span class="s1">symbol.ordinal)</span>
                        <span class="s4">if </span><span class="s1">funcname:</span>
                            <span class="s1">symbol.name = funcname</span>
                <span class="s1">import_descs.append(</span>
                    <span class="s1">ImportDescData(struct=import_desc</span><span class="s4">, </span><span class="s1">imports=import_data</span><span class="s4">, </span><span class="s1">dll=dll)</span>
                <span class="s1">)</span>

        <span class="s4">return </span><span class="s1">import_descs</span>

    <span class="s4">def </span><span class="s1">get_rich_header_hash(self</span><span class="s4">, </span><span class="s1">algorithm=</span><span class="s3">&quot;md5&quot;</span><span class="s1">):</span>
        <span class="s4">if not </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;RICH_HEADER&quot;</span><span class="s1">) </span><span class="s4">or </span><span class="s1">self.RICH_HEADER </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s3">&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">algorithm == </span><span class="s3">&quot;md5&quot;</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">md5(self.RICH_HEADER.clear_data).hexdigest()</span>
        <span class="s4">elif </span><span class="s1">algorithm == </span><span class="s3">&quot;sha1&quot;</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">sha1(self.RICH_HEADER.clear_data).hexdigest()</span>
        <span class="s4">elif </span><span class="s1">algorithm == </span><span class="s3">&quot;sha256&quot;</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">sha256(self.RICH_HEADER.clear_data).hexdigest()</span>
        <span class="s4">elif </span><span class="s1">algorithm == </span><span class="s3">&quot;sha512&quot;</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">sha512(self.RICH_HEADER.clear_data).hexdigest()</span>

        <span class="s4">raise </span><span class="s1">Exception(</span><span class="s3">&quot;Invalid hashing algorithm specified&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">get_imphash(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the imphash of the PE file. 
 
        Creates a hash based on imported symbol names and their specific order within 
        the executable: 
        https://www.mandiant.com/resources/blog/tracking-malware-import-hashing 
 
        Returns: 
            the hexdigest of the MD5 hash of the exported symbols. 
        &quot;&quot;&quot;</span>

        <span class="s1">impstrs = []</span>
        <span class="s1">exts = [</span><span class="s3">&quot;ocx&quot;</span><span class="s4">, </span><span class="s3">&quot;sys&quot;</span><span class="s4">, </span><span class="s3">&quot;dll&quot;</span><span class="s1">]</span>
        <span class="s4">if not </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_IMPORT&quot;</span><span class="s1">):</span>
            <span class="s4">return </span><span class="s3">&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">entry </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_IMPORT:</span>
            <span class="s4">if </span><span class="s1">isinstance(entry.dll</span><span class="s4">, </span><span class="s1">bytes):</span>
                <span class="s1">libname = entry.dll.decode().lower()</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">libname = entry.dll.lower()</span>
            <span class="s1">parts = libname.rsplit(</span><span class="s3">&quot;.&quot;</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>

            <span class="s4">if </span><span class="s1">len(parts) &gt; </span><span class="s5">1 </span><span class="s4">and </span><span class="s1">parts[</span><span class="s5">1</span><span class="s1">] </span><span class="s4">in </span><span class="s1">exts:</span>
                <span class="s1">libname = parts[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s1">entry_dll_lower = entry.dll.lower()</span>
            <span class="s4">for </span><span class="s1">imp </span><span class="s4">in </span><span class="s1">entry.imports:</span>
                <span class="s1">funcname = </span><span class="s4">None</span>
                <span class="s4">if not </span><span class="s1">imp.name:</span>
                    <span class="s1">funcname = ordlookup.ordLookup(</span>
                        <span class="s1">entry_dll_lower</span><span class="s4">, </span><span class="s1">imp.ordinal</span><span class="s4">, </span><span class="s1">make_name=</span><span class="s4">True</span>
                    <span class="s1">)</span>
                    <span class="s4">if not </span><span class="s1">funcname:</span>
                        <span class="s4">raise </span><span class="s1">PEFormatError(</span>
                            <span class="s3">f&quot;Unable to look up ordinal </span><span class="s4">{</span><span class="s1">entry.dll</span><span class="s4">}</span><span class="s3">:</span><span class="s4">{</span><span class="s1">imp.ordinal</span><span class="s4">:</span><span class="s3">04x</span><span class="s4">}</span><span class="s3">&quot;</span>
                        <span class="s1">)</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">funcname = imp.name</span>

                <span class="s4">if not </span><span class="s1">funcname:</span>
                    <span class="s4">continue</span>

                <span class="s4">if </span><span class="s1">isinstance(funcname</span><span class="s4">, </span><span class="s1">bytes):</span>
                    <span class="s1">funcname = funcname.decode()</span>
                <span class="s1">impstrs.append(</span><span class="s3">&quot;%s.%s&quot; </span><span class="s1">% (libname.lower()</span><span class="s4">, </span><span class="s1">funcname.lower()))</span>

        <span class="s4">return </span><span class="s1">md5(</span><span class="s3">&quot;,&quot;</span><span class="s1">.join(impstrs).encode()).hexdigest()</span>

    <span class="s4">def </span><span class="s1">get_exphash(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the exphash of the PE file. 
 
        Similar to imphash, but based on exported symbol names and their specific order. 
 
        Returns: 
            the hexdigest of the SHA256 hash of the exported symbols. 
        &quot;&quot;&quot;</span>

        <span class="s4">if not </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_EXPORT&quot;</span><span class="s1">):</span>
            <span class="s4">return </span><span class="s3">&quot;&quot;</span>

        <span class="s4">if not </span><span class="s1">hasattr(self.DIRECTORY_ENTRY_EXPORT</span><span class="s4">, </span><span class="s3">&quot;symbols&quot;</span><span class="s1">):</span>
            <span class="s4">return </span><span class="s3">&quot;&quot;</span>

        <span class="s1">export_list = [</span>
            <span class="s1">e.name.decode().lower()</span>
            <span class="s4">for </span><span class="s1">e </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_EXPORT.symbols</span>
            <span class="s4">if </span><span class="s1">e </span><span class="s4">and </span><span class="s1">e.name </span><span class="s4">is not None</span>
        <span class="s1">]</span>
        <span class="s4">if </span><span class="s1">len(export_list) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s3">&quot;&quot;</span>

        <span class="s4">return </span><span class="s1">sha256(</span><span class="s3">&quot;,&quot;</span><span class="s1">.join(export_list).encode()).hexdigest()</span>

    <span class="s4">def </span><span class="s1">parse_import_directory(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">size</span><span class="s4">, </span><span class="s1">dllnames_only=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Walk and parse the import directory.&quot;&quot;&quot;</span>

        <span class="s1">import_descs = []</span>
        <span class="s1">error_count = </span><span class="s5">0</span>
        <span class="s1">image_import_descriptor_size = Structure(</span>
            <span class="s1">self.__IMAGE_IMPORT_DESCRIPTOR_format__</span>
        <span class="s1">).sizeof()</span>
        <span class="s4">while True</span><span class="s1">:</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s0"># If the RVA is invalid all would blow up. Some EXEs seem to be</span>
                <span class="s0"># specially nasty and have an invalid RVA.</span>
                <span class="s1">data = self.get_data(rva</span><span class="s4">, </span><span class="s1">image_import_descriptor_size)</span>
            <span class="s4">except </span><span class="s1">PEFormatError:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">f&quot;Error parsing the import directory at RVA: 0x</span><span class="s4">{</span><span class="s1">rva</span><span class="s4">:</span><span class="s3">x</span><span class="s4">}</span><span class="s3">&quot;</span>
                <span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s1">file_offset = self.get_offset_from_rva(rva)</span>
            <span class="s1">import_desc = self.__unpack_data__(</span>
                <span class="s1">self.__IMAGE_IMPORT_DESCRIPTOR_format__</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">file_offset=file_offset</span>
            <span class="s1">)</span>

            <span class="s0"># If the structure is all zeros, we reached the end of the list</span>
            <span class="s4">if not </span><span class="s1">import_desc </span><span class="s4">or </span><span class="s1">import_desc.all_zeroes():</span>
                <span class="s4">break</span>

            <span class="s1">rva += import_desc.sizeof()</span>

            <span class="s0"># If the array of thunks is somewhere earlier than the import</span>
            <span class="s0"># descriptor we can set a maximum length for the array. Otherwise</span>
            <span class="s0"># just set a maximum length of the size of the file</span>
            <span class="s1">max_len = len(self.__data__) - file_offset</span>
            <span class="s4">if </span><span class="s1">rva &gt; import_desc.OriginalFirstThunk </span><span class="s4">or </span><span class="s1">rva &gt; import_desc.FirstThunk:</span>
                <span class="s1">max_len = max(</span>
                    <span class="s1">rva - import_desc.OriginalFirstThunk</span><span class="s4">, </span><span class="s1">rva - import_desc.FirstThunk</span>
                <span class="s1">)</span>

            <span class="s1">import_data = []</span>
            <span class="s4">if not </span><span class="s1">dllnames_only:</span>
                <span class="s4">try</span><span class="s1">:</span>
                    <span class="s1">import_data = self.parse_imports(</span>
                        <span class="s1">import_desc.OriginalFirstThunk</span><span class="s4">,</span>
                        <span class="s1">import_desc.FirstThunk</span><span class="s4">,</span>
                        <span class="s1">import_desc.ForwarderChain</span><span class="s4">,</span>
                        <span class="s1">max_length=max_len</span><span class="s4">,</span>
                    <span class="s1">)</span>
                <span class="s4">except </span><span class="s1">PEFormatError </span><span class="s4">as </span><span class="s1">e:</span>
                    <span class="s1">self.__warnings.append(</span>
                        <span class="s3">&quot;Error parsing the import directory. &quot;</span>
                        <span class="s3">f&quot;Invalid Import data at RVA: 0x</span><span class="s4">{</span><span class="s1">rva</span><span class="s4">:</span><span class="s3">x</span><span class="s4">} </span><span class="s3">(</span><span class="s4">{</span><span class="s1">e.value</span><span class="s4">}</span><span class="s3">)&quot;</span>
                    <span class="s1">)</span>

                <span class="s4">if </span><span class="s1">error_count &gt; </span><span class="s5">5</span><span class="s1">:</span>
                    <span class="s1">self.__warnings.append(</span>
                        <span class="s3">&quot;Too many errors parsing the import directory. &quot;</span>
                        <span class="s3">f&quot;Invalid import data at RVA: 0x</span><span class="s4">{</span><span class="s1">rva</span><span class="s4">:</span><span class="s3">x</span><span class="s4">}</span><span class="s3">&quot;</span>
                    <span class="s1">)</span>
                    <span class="s4">break</span>

                <span class="s4">if not </span><span class="s1">import_data:</span>
                    <span class="s1">error_count += </span><span class="s5">1</span>
                    <span class="s0"># TODO: do not continue here</span>
                    <span class="s4">continue</span>

            <span class="s1">dll = self.get_string_at_rva(import_desc.Name</span><span class="s4">, </span><span class="s1">MAX_DLL_LENGTH)</span>
            <span class="s4">if not </span><span class="s1">is_valid_dos_filename(dll):</span>
                <span class="s1">dll = b(</span><span class="s3">&quot;*invalid*&quot;</span><span class="s1">)</span>

            <span class="s4">if </span><span class="s1">dll:</span>
                <span class="s4">for </span><span class="s1">symbol </span><span class="s4">in </span><span class="s1">import_data:</span>
                    <span class="s4">if </span><span class="s1">symbol.name </span><span class="s4">is None</span><span class="s1">:</span>
                        <span class="s1">funcname = ordlookup.ordLookup(dll.lower()</span><span class="s4">, </span><span class="s1">symbol.ordinal)</span>
                        <span class="s4">if </span><span class="s1">funcname:</span>
                            <span class="s1">symbol.name = funcname</span>
                <span class="s1">import_descs.append(</span>
                    <span class="s1">ImportDescData(struct=import_desc</span><span class="s4">, </span><span class="s1">imports=import_data</span><span class="s4">, </span><span class="s1">dll=dll)</span>
                <span class="s1">)</span>

        <span class="s4">if not </span><span class="s1">dllnames_only:</span>
            <span class="s1">suspicious_imports = set([</span><span class="s3">&quot;LoadLibrary&quot;</span><span class="s4">, </span><span class="s3">&quot;GetProcAddress&quot;</span><span class="s1">])</span>
            <span class="s1">suspicious_imports_count = </span><span class="s5">0</span>
            <span class="s1">total_symbols = </span><span class="s5">0</span>
            <span class="s4">for </span><span class="s1">imp_dll </span><span class="s4">in </span><span class="s1">import_descs:</span>
                <span class="s4">for </span><span class="s1">symbol </span><span class="s4">in </span><span class="s1">imp_dll.imports:</span>
                    <span class="s4">for </span><span class="s1">suspicious_symbol </span><span class="s4">in </span><span class="s1">suspicious_imports:</span>
                        <span class="s4">if not </span><span class="s1">symbol </span><span class="s4">or not </span><span class="s1">symbol.name:</span>
                            <span class="s4">continue</span>
                        <span class="s1">name = symbol.name</span>
                        <span class="s4">if </span><span class="s1">type(symbol.name) == bytes:</span>
                            <span class="s1">name = symbol.name.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
                        <span class="s4">if </span><span class="s1">name.startswith(suspicious_symbol):</span>
                            <span class="s1">suspicious_imports_count += </span><span class="s5">1</span>
                            <span class="s4">break</span>
                    <span class="s1">total_symbols += </span><span class="s5">1</span>
            <span class="s4">if </span><span class="s1">(</span>
                <span class="s1">suspicious_imports_count == len(suspicious_imports)</span>
                <span class="s4">and </span><span class="s1">total_symbols &lt; </span><span class="s5">20</span>
            <span class="s1">):</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Imported symbols contain entries typical of packed executables.&quot;</span>
                <span class="s1">)</span>

        <span class="s4">return </span><span class="s1">import_descs</span>

    <span class="s4">def </span><span class="s1">parse_imports(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">original_first_thunk</span><span class="s4">,</span>
        <span class="s1">first_thunk</span><span class="s4">,</span>
        <span class="s1">forwarder_chain</span><span class="s4">,</span>
        <span class="s1">max_length=</span><span class="s4">None,</span>
        <span class="s1">contains_addresses=</span><span class="s4">False,</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Parse the imported symbols. 
 
        It will fill a list, which will be available as the dictionary 
        attribute &quot;imports&quot;. Its keys will be the DLL names and the values 
        of all the symbols imported from that object. 
        &quot;&quot;&quot;</span>

        <span class="s1">imported_symbols = []</span>

        <span class="s0"># Import Lookup Table. Contains ordinals or pointers to strings.</span>
        <span class="s1">ilt = self.get_import_table(</span>
            <span class="s1">original_first_thunk</span><span class="s4">, </span><span class="s1">max_length</span><span class="s4">, </span><span class="s1">contains_addresses</span>
        <span class="s1">)</span>
        <span class="s0"># Import Address Table. May have identical content to ILT if</span>
        <span class="s0"># PE file is not bound. It will contain the address of the</span>
        <span class="s0"># imported symbols once the binary is loaded or if it is already</span>
        <span class="s0"># bound.</span>
        <span class="s1">iat = self.get_import_table(first_thunk</span><span class="s4">, </span><span class="s1">max_length</span><span class="s4">, </span><span class="s1">contains_addresses)</span>

        <span class="s0"># OC Patch:</span>
        <span class="s0"># Would crash if IAT or ILT had None type</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">not </span><span class="s1">iat </span><span class="s4">or </span><span class="s1">len(iat) == </span><span class="s5">0</span><span class="s1">) </span><span class="s4">and </span><span class="s1">(</span><span class="s4">not </span><span class="s1">ilt </span><span class="s4">or </span><span class="s1">len(ilt) == </span><span class="s5">0</span><span class="s1">):</span>
            <span class="s1">self.__warnings.append(</span>
                <span class="s3">&quot;Damaged Import Table information. &quot;</span>
                <span class="s3">&quot;ILT and/or IAT appear to be broken. &quot;</span>
                <span class="s3">f&quot;OriginalFirstThunk: 0x</span><span class="s4">{</span><span class="s1">original_first_thunk</span><span class="s4">:</span><span class="s3">x</span><span class="s4">} </span><span class="s3">&quot;</span>
                <span class="s3">f&quot;FirstThunk: 0x</span><span class="s4">{</span><span class="s1">first_thunk</span><span class="s4">:</span><span class="s3">x</span><span class="s4">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>
            <span class="s4">return </span><span class="s1">[]</span>

        <span class="s1">table = </span><span class="s4">None</span>
        <span class="s4">if </span><span class="s1">ilt:</span>
            <span class="s1">table = ilt</span>
        <span class="s4">elif </span><span class="s1">iat:</span>
            <span class="s1">table = iat</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">return None</span>

        <span class="s1">imp_offset = </span><span class="s5">4</span>
        <span class="s1">address_mask = </span><span class="s5">0x7FFFFFFF</span>
        <span class="s4">if </span><span class="s1">self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE:</span>
            <span class="s1">ordinal_flag = IMAGE_ORDINAL_FLAG</span>
        <span class="s4">elif </span><span class="s1">self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE_PLUS:</span>
            <span class="s1">ordinal_flag = IMAGE_ORDINAL_FLAG64</span>
            <span class="s1">imp_offset = </span><span class="s5">8</span>
            <span class="s1">address_mask = </span><span class="s5">0x7FFFFFFFFFFFFFFF</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s0"># Some PEs may have an invalid value in the Magic field of the</span>
            <span class="s0"># Optional Header. Just in case the remaining file is parseable</span>
            <span class="s0"># let's pretend it's a 32bit PE32 by default.</span>
            <span class="s1">ordinal_flag = IMAGE_ORDINAL_FLAG</span>

        <span class="s1">num_invalid = </span><span class="s5">0</span>
        <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">tbl_entry </span><span class="s4">in </span><span class="s1">enumerate(table):</span>
            <span class="s1">imp_ord = </span><span class="s4">None</span>
            <span class="s1">imp_hint = </span><span class="s4">None</span>
            <span class="s1">imp_name = </span><span class="s4">None</span>
            <span class="s1">name_offset = </span><span class="s4">None</span>
            <span class="s1">hint_name_table_rva = </span><span class="s4">None</span>
            <span class="s1">import_by_ordinal = </span><span class="s4">False  </span><span class="s0"># declare it here first</span>

            <span class="s4">if </span><span class="s1">tbl_entry.AddressOfData:</span>
                <span class="s0"># If imported by ordinal, we will append the ordinal number</span>
                <span class="s0">#</span>
                <span class="s4">if </span><span class="s1">tbl_entry.AddressOfData &amp; ordinal_flag:</span>
                    <span class="s1">import_by_ordinal = </span><span class="s4">True</span>
                    <span class="s1">imp_ord = tbl_entry.AddressOfData &amp; </span><span class="s5">0xFFFF</span>
                    <span class="s1">imp_name = </span><span class="s4">None</span>
                    <span class="s1">name_offset = </span><span class="s4">None</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">import_by_ordinal = </span><span class="s4">False</span>
                    <span class="s4">try</span><span class="s1">:</span>
                        <span class="s1">hint_name_table_rva = tbl_entry.AddressOfData &amp; address_mask</span>
                        <span class="s1">data = self.get_data(hint_name_table_rva</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>
                        <span class="s0"># Get the Hint</span>
                        <span class="s1">imp_hint = self.get_word_from_data(data</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span>
                        <span class="s1">imp_name = self.get_string_at_rva(</span>
                            <span class="s1">tbl_entry.AddressOfData + </span><span class="s5">2</span><span class="s4">, </span><span class="s1">MAX_IMPORT_NAME_LENGTH</span>
                        <span class="s1">)</span>
                        <span class="s4">if not </span><span class="s1">is_valid_function_name(imp_name):</span>
                            <span class="s1">imp_name = b(</span><span class="s3">&quot;*invalid*&quot;</span><span class="s1">)</span>

                        <span class="s1">name_offset = self.get_offset_from_rva(</span>
                            <span class="s1">tbl_entry.AddressOfData + </span><span class="s5">2</span>
                        <span class="s1">)</span>
                    <span class="s4">except </span><span class="s1">PEFormatError:</span>
                        <span class="s4">pass</span>

                <span class="s0"># by nriva: we want the ThunkRVA and ThunkOffset</span>
                <span class="s1">thunk_offset = tbl_entry.get_file_offset()</span>
                <span class="s1">thunk_rva = self.get_rva_from_offset(thunk_offset)</span>

            <span class="s1">imp_address = (</span>
                <span class="s1">first_thunk + self.OPTIONAL_HEADER.ImageBase + idx * imp_offset</span>
            <span class="s1">)</span>

            <span class="s1">struct_iat = </span><span class="s4">None</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">iat </span><span class="s4">and </span><span class="s1">ilt </span><span class="s4">and </span><span class="s1">ilt[idx].AddressOfData != iat[idx].AddressOfData:</span>
                    <span class="s1">imp_bound = iat[idx].AddressOfData</span>
                    <span class="s1">struct_iat = iat[idx]</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">imp_bound = </span><span class="s4">None</span>
            <span class="s4">except </span><span class="s1">IndexError:</span>
                <span class="s1">imp_bound = </span><span class="s4">None</span>

            <span class="s0"># The file with hashes:</span>
            <span class="s0">#</span>
            <span class="s0"># MD5: bfe97192e8107d52dd7b4010d12b2924</span>
            <span class="s0"># SHA256: 3d22f8b001423cb460811ab4f4789f277b35838d45c62ec0454c877e7c82c7f5</span>
            <span class="s0">#</span>
            <span class="s0"># has an invalid table built in a way that it's parseable but contains</span>
            <span class="s0"># invalid entries that lead pefile to take extremely long amounts of time to</span>
            <span class="s0"># parse. It also leads to extreme memory consumption.</span>
            <span class="s0"># To prevent similar cases, if invalid entries are found in the middle of a</span>
            <span class="s0"># table the parsing will be aborted</span>
            <span class="s0">#</span>
            <span class="s4">if </span><span class="s1">imp_ord </span><span class="s4">is None and </span><span class="s1">imp_name </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;Invalid entries, aborting parsing.&quot;</span><span class="s1">)</span>

            <span class="s0"># Some PEs appear to interleave valid and invalid imports. Instead of</span>
            <span class="s0"># aborting the parsing altogether we will simply skip the invalid entries.</span>
            <span class="s0"># Although if we see 1000 invalid entries and no legit ones, we abort.</span>
            <span class="s4">if </span><span class="s1">imp_name == b(</span><span class="s3">&quot;*invalid*&quot;</span><span class="s1">):</span>
                <span class="s4">if </span><span class="s1">num_invalid &gt; </span><span class="s5">1000 </span><span class="s4">and </span><span class="s1">num_invalid == idx:</span>
                    <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;Too many invalid names, aborting parsing.&quot;</span><span class="s1">)</span>
                <span class="s1">num_invalid += </span><span class="s5">1</span>
                <span class="s4">continue</span>

            <span class="s4">if </span><span class="s1">imp_ord </span><span class="s4">or </span><span class="s1">imp_name:</span>
                <span class="s1">imported_symbols.append(</span>
                    <span class="s1">ImportData(</span>
                        <span class="s1">pe=self</span><span class="s4">,</span>
                        <span class="s1">struct_table=tbl_entry</span><span class="s4">,</span>
                        <span class="s1">struct_iat=struct_iat</span><span class="s4">,  </span><span class="s0"># for bound imports if any</span>
                        <span class="s1">import_by_ordinal=import_by_ordinal</span><span class="s4">,</span>
                        <span class="s1">ordinal=imp_ord</span><span class="s4">,</span>
                        <span class="s1">ordinal_offset=tbl_entry.get_file_offset()</span><span class="s4">,</span>
                        <span class="s1">hint=imp_hint</span><span class="s4">,</span>
                        <span class="s1">name=imp_name</span><span class="s4">,</span>
                        <span class="s1">name_offset=name_offset</span><span class="s4">,</span>
                        <span class="s1">bound=imp_bound</span><span class="s4">,</span>
                        <span class="s1">address=imp_address</span><span class="s4">,</span>
                        <span class="s1">hint_name_table_rva=hint_name_table_rva</span><span class="s4">,</span>
                        <span class="s1">thunk_offset=thunk_offset</span><span class="s4">,</span>
                        <span class="s1">thunk_rva=thunk_rva</span><span class="s4">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s4">return </span><span class="s1">imported_symbols</span>

    <span class="s4">def </span><span class="s1">get_import_table(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">max_length=</span><span class="s4">None, </span><span class="s1">contains_addresses=</span><span class="s4">False</span><span class="s1">):</span>

        <span class="s1">table = []</span>

        <span class="s0"># We need the ordinal flag for a simple heuristic</span>
        <span class="s0"># we're implementing within the loop</span>
        <span class="s0">#</span>
        <span class="s4">if </span><span class="s1">self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE:</span>
            <span class="s1">ordinal_flag = IMAGE_ORDINAL_FLAG</span>
            <span class="s1">format = self.__IMAGE_THUNK_DATA_format__</span>
        <span class="s4">elif </span><span class="s1">self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE_PLUS:</span>
            <span class="s1">ordinal_flag = IMAGE_ORDINAL_FLAG64</span>
            <span class="s1">format = self.__IMAGE_THUNK_DATA64_format__</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s0"># Some PEs may have an invalid value in the Magic field of the</span>
            <span class="s0"># Optional Header. Just in case the remaining file is parseable</span>
            <span class="s0"># let's pretend it's a 32bit PE32 by default.</span>
            <span class="s1">ordinal_flag = IMAGE_ORDINAL_FLAG</span>
            <span class="s1">format = self.__IMAGE_THUNK_DATA_format__</span>

        <span class="s1">expected_size = Structure(format).sizeof()</span>
        <span class="s1">MAX_ADDRESS_SPREAD = </span><span class="s5">128 </span><span class="s1">* </span><span class="s5">2</span><span class="s1">**</span><span class="s5">20  </span><span class="s0"># 128 MB</span>
        <span class="s1">ADDR_4GB = </span><span class="s5">2</span><span class="s1">**</span><span class="s5">32</span>
        <span class="s1">MAX_REPEATED_ADDRESSES = </span><span class="s5">15</span>
        <span class="s1">repeated_address = </span><span class="s5">0</span>
        <span class="s1">addresses_of_data_set_64 = AddressSet()</span>
        <span class="s1">addresses_of_data_set_32 = AddressSet()</span>
        <span class="s1">start_rva = rva</span>
        <span class="s4">while </span><span class="s1">rva:</span>
            <span class="s4">if </span><span class="s1">max_length </span><span class="s4">is not None and </span><span class="s1">rva &gt;= start_rva + max_length:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Error parsing the import table. Entries go beyond bounds.&quot;</span>
                <span class="s1">)</span>
                <span class="s4">break</span>
            <span class="s0"># Enforce an upper bounds on import symbols.</span>
            <span class="s4">if </span><span class="s1">self.__total_import_symbols &gt; MAX_IMPORT_SYMBOLS:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Excessive number of imports %d (&gt;%s)&quot;</span>
                    <span class="s1">% (self.__total_import_symbols</span><span class="s4">, </span><span class="s1">MAX_IMPORT_SYMBOLS)</span>
                <span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s1">self.__total_import_symbols += </span><span class="s5">1</span>

            <span class="s0"># if we see too many times the same entry we assume it could be</span>
            <span class="s0"># a table containing bogus data (with malicious intent or otherwise)</span>
            <span class="s4">if </span><span class="s1">repeated_address &gt;= MAX_REPEATED_ADDRESSES:</span>
                <span class="s4">return </span><span class="s1">[]</span>

            <span class="s0"># if the addresses point somewhere but the difference between the highest</span>
            <span class="s0"># and lowest address is larger than MAX_ADDRESS_SPREAD we assume a bogus</span>
            <span class="s0"># table as the addresses should be contained within a module</span>
            <span class="s4">if </span><span class="s1">addresses_of_data_set_32.diff() &gt; MAX_ADDRESS_SPREAD:</span>
                <span class="s4">return </span><span class="s1">[]</span>
            <span class="s4">if </span><span class="s1">addresses_of_data_set_64.diff() &gt; MAX_ADDRESS_SPREAD:</span>
                <span class="s4">return </span><span class="s1">[]</span>

            <span class="s1">failed = </span><span class="s4">False</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">data = self.get_data(rva</span><span class="s4">, </span><span class="s1">expected_size)</span>
            <span class="s4">except </span><span class="s1">PEFormatError:</span>
                <span class="s1">failed = </span><span class="s4">True</span>

            <span class="s4">if </span><span class="s1">failed </span><span class="s4">or </span><span class="s1">len(data) != expected_size:</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Error parsing the import table. &quot; &quot;Invalid data at RVA: 0x%x&quot; </span><span class="s1">% rva</span>
                <span class="s1">)</span>
                <span class="s4">return None</span>

            <span class="s1">thunk_data = self.__unpack_data__(</span>
                <span class="s1">format</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">file_offset=self.get_offset_from_rva(rva)</span>
            <span class="s1">)</span>

            <span class="s0"># If the thunk data contains VAs instead of RVAs, we need to normalize them</span>
            <span class="s4">if </span><span class="s1">contains_addresses:</span>
                <span class="s1">thunk_data.AddressOfData = self.normalize_import_va(</span>
                    <span class="s1">thunk_data.AddressOfData</span>
                <span class="s1">)</span>
                <span class="s1">thunk_data.ForwarderString = self.normalize_import_va(</span>
                    <span class="s1">thunk_data.ForwarderString</span>
                <span class="s1">)</span>
                <span class="s1">thunk_data.Function = self.normalize_import_va(thunk_data.Function)</span>
                <span class="s1">thunk_data.Ordinal = self.normalize_import_va(thunk_data.Ordinal)</span>

            <span class="s0"># Check if the AddressOfData lies within the range of RVAs that it's</span>
            <span class="s0"># being scanned, abort if that is the case, as it is very unlikely</span>
            <span class="s0"># to be legitimate data.</span>
            <span class="s0"># Seen in PE with SHA256:</span>
            <span class="s0"># 5945bb6f0ac879ddf61b1c284f3b8d20c06b228e75ae4f571fa87f5b9512902c</span>
            <span class="s4">if </span><span class="s1">(</span>
                <span class="s1">thunk_data</span>
                <span class="s4">and </span><span class="s1">thunk_data.AddressOfData &gt;= start_rva</span>
                <span class="s4">and </span><span class="s1">thunk_data.AddressOfData &lt;= rva</span>
            <span class="s1">):</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Error parsing the import table. &quot;</span>
                    <span class="s3">&quot;AddressOfData overlaps with THUNK_DATA for &quot;</span>
                    <span class="s3">&quot;THUNK at RVA 0x%x&quot; </span><span class="s1">% (rva)</span>
                <span class="s1">)</span>
                <span class="s4">break</span>

            <span class="s4">if </span><span class="s1">thunk_data </span><span class="s4">and </span><span class="s1">thunk_data.AddressOfData:</span>
                <span class="s1">addr_of_data = thunk_data.AddressOfData</span>
                <span class="s0"># If the entry looks like could be an ordinal...</span>
                <span class="s4">if </span><span class="s1">addr_of_data &amp; ordinal_flag:</span>
                    <span class="s0"># but its value is beyond 2^16, we will assume it's a</span>
                    <span class="s0"># corrupted and ignore it altogether</span>
                    <span class="s4">if </span><span class="s1">addr_of_data &amp; </span><span class="s5">0x7FFFFFFF </span><span class="s1">&gt; </span><span class="s5">0xFFFF</span><span class="s1">:</span>
                        <span class="s4">return </span><span class="s1">[]</span>
                <span class="s0"># and if it looks like it should be an RVA</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s0"># keep track of the RVAs seen and store them to study their</span>
                    <span class="s0"># properties. When certain non-standard features are detected</span>
                    <span class="s0"># the parsing will be aborted</span>
                    <span class="s4">if </span><span class="s1">addr_of_data &gt;= ADDR_4GB:</span>
                        <span class="s1">the_set = addresses_of_data_set_64</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">the_set = addresses_of_data_set_32</span>

                    <span class="s4">if </span><span class="s1">addr_of_data </span><span class="s4">in </span><span class="s1">the_set:</span>
                        <span class="s1">repeated_address += </span><span class="s5">1</span>
                    <span class="s1">the_set.add(addr_of_data)</span>

            <span class="s4">if not </span><span class="s1">thunk_data </span><span class="s4">or </span><span class="s1">thunk_data.all_zeroes():</span>
                <span class="s4">break</span>

            <span class="s1">rva += thunk_data.sizeof()</span>

            <span class="s1">table.append(thunk_data)</span>

        <span class="s4">return </span><span class="s1">table</span>

    <span class="s4">def </span><span class="s1">get_memory_mapped_image(self</span><span class="s4">, </span><span class="s1">max_virtual_address=</span><span class="s5">0x10000000</span><span class="s4">, </span><span class="s1">ImageBase=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Returns the data corresponding to the memory layout of the PE file. 
 
        The data includes the PE header and the sections loaded at offsets 
        corresponding to their relative virtual addresses. (the VirtualAddress 
        section header member). 
        Any offset in this data corresponds to the absolute memory address 
        ImageBase+offset. 
 
        The optional argument 'max_virtual_address' provides with means of limiting 
        which sections are processed. 
        Any section with their VirtualAddress beyond this value will be skipped. 
        Normally, sections with values beyond this range are just there to confuse 
        tools. It's a common trick to see in packed executables. 
 
        If the 'ImageBase' optional argument is supplied, the file's relocations 
        will be applied to the image by calling the 'relocate_image()' method. Beware 
        that the relocation information is applied permanently. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Rebase if requested</span>
        <span class="s0">#</span>
        <span class="s4">if </span><span class="s1">ImageBase </span><span class="s4">is not None</span><span class="s1">:</span>

            <span class="s0"># Keep a copy of the image's data before modifying it by rebasing it</span>
            <span class="s0">#</span>
            <span class="s1">original_data = self.__data__</span>

            <span class="s1">self.relocate_image(ImageBase)</span>

        <span class="s0"># Collect all sections in one code block</span>
        <span class="s1">mapped_data = self.__data__[:]</span>
        <span class="s4">for </span><span class="s1">section </span><span class="s4">in </span><span class="s1">self.sections:</span>

            <span class="s0"># Miscellaneous integrity tests.</span>
            <span class="s0"># Some packer will set these to bogus values to make tools go nuts.</span>
            <span class="s4">if </span><span class="s1">section.Misc_VirtualSize == </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">section.SizeOfRawData == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">continue</span>

            <span class="s1">srd = section.SizeOfRawData</span>
            <span class="s1">prd = self.adjust_FileAlignment(</span>
                <span class="s1">section.PointerToRawData</span><span class="s4">, </span><span class="s1">self.OPTIONAL_HEADER.FileAlignment</span>
            <span class="s1">)</span>
            <span class="s1">VirtualAddress_adj = self.adjust_SectionAlignment(</span>
                <span class="s1">section.VirtualAddress</span><span class="s4">,</span>
                <span class="s1">self.OPTIONAL_HEADER.SectionAlignment</span><span class="s4">,</span>
                <span class="s1">self.OPTIONAL_HEADER.FileAlignment</span><span class="s4">,</span>
            <span class="s1">)</span>

            <span class="s4">if </span><span class="s1">(</span>
                <span class="s1">srd &gt; len(self.__data__)</span>
                <span class="s4">or </span><span class="s1">prd &gt; len(self.__data__)</span>
                <span class="s4">or </span><span class="s1">srd + prd &gt; len(self.__data__)</span>
                <span class="s4">or </span><span class="s1">VirtualAddress_adj &gt;= max_virtual_address</span>
            <span class="s1">):</span>
                <span class="s4">continue</span>

            <span class="s1">padding_length = VirtualAddress_adj - len(mapped_data)</span>

            <span class="s4">if </span><span class="s1">padding_length &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">mapped_data += </span><span class="s6">b&quot;</span><span class="s4">\0</span><span class="s6">&quot; </span><span class="s1">* padding_length</span>
            <span class="s4">elif </span><span class="s1">padding_length &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">mapped_data = mapped_data[:padding_length]</span>

            <span class="s1">mapped_data += section.get_data()</span>

        <span class="s0"># If the image was rebased, restore it to its original form</span>
        <span class="s0">#</span>
        <span class="s4">if </span><span class="s1">ImageBase </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">self.__data__ = original_data</span>

        <span class="s4">return </span><span class="s1">mapped_data</span>

    <span class="s4">def </span><span class="s1">get_resources_strings(self):</span>
        <span class="s2">&quot;&quot;&quot;Returns a list of all the strings found withing the resources (if any). 
 
        This method will scan all entries in the resources directory of the PE, if 
        there is one, and will return a [] with the strings. 
 
        An empty list will be returned otherwise. 
        &quot;&quot;&quot;</span>

        <span class="s1">resources_strings = []</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_RESOURCE&quot;</span><span class="s1">):</span>

            <span class="s4">for </span><span class="s1">res_type </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_RESOURCE.entries:</span>
                <span class="s4">if </span><span class="s1">hasattr(res_type</span><span class="s4">, </span><span class="s3">&quot;directory&quot;</span><span class="s1">):</span>
                    <span class="s4">for </span><span class="s1">resource_id </span><span class="s4">in </span><span class="s1">res_type.directory.entries:</span>
                        <span class="s4">if </span><span class="s1">hasattr(resource_id</span><span class="s4">, </span><span class="s3">&quot;directory&quot;</span><span class="s1">):</span>
                            <span class="s4">if </span><span class="s1">(</span>
                                <span class="s1">hasattr(resource_id.directory</span><span class="s4">, </span><span class="s3">&quot;strings&quot;</span><span class="s1">)</span>
                                <span class="s4">and </span><span class="s1">resource_id.directory.strings</span>
                            <span class="s1">):</span>
                                <span class="s4">for </span><span class="s1">res_string </span><span class="s4">in </span><span class="s1">list(</span>
                                    <span class="s1">resource_id.directory.strings.values()</span>
                                <span class="s1">):</span>
                                    <span class="s1">resources_strings.append(res_string)</span>

        <span class="s4">return </span><span class="s1">resources_strings</span>

    <span class="s4">def </span><span class="s1">get_data(self</span><span class="s4">, </span><span class="s1">rva=</span><span class="s5">0</span><span class="s4">, </span><span class="s1">length=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Get data regardless of the section where it lies on. 
 
        Given a RVA and the size of the chunk to retrieve, this method 
        will find the section where the data lies and return the data. 
        &quot;&quot;&quot;</span>

        <span class="s1">s = self.get_section_by_rva(rva)</span>

        <span class="s4">if </span><span class="s1">length:</span>
            <span class="s1">end = rva + length</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">end = </span><span class="s4">None</span>

        <span class="s4">if not </span><span class="s1">s:</span>
            <span class="s4">if </span><span class="s1">rva &lt; len(self.header):</span>
                <span class="s4">return </span><span class="s1">self.header[rva:end]</span>

            <span class="s0"># Before we give up we check whether the file might</span>
            <span class="s0"># contain the data anyway. There are cases of PE files</span>
            <span class="s0"># without sections that rely on windows loading the first</span>
            <span class="s0"># 8291 bytes into memory and assume the data will be</span>
            <span class="s0"># there</span>
            <span class="s0"># A functional file with these characteristics is:</span>
            <span class="s0"># MD5: 0008892cdfbc3bda5ce047c565e52295</span>
            <span class="s0"># SHA-1: c7116b9ff950f86af256defb95b5d4859d4752a9</span>
            <span class="s0">#</span>
            <span class="s4">if </span><span class="s1">rva &lt; len(self.__data__):</span>
                <span class="s4">return </span><span class="s1">self.__data__[rva:end]</span>

            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">&quot;data at RVA can't be fetched. Corrupt header?&quot;</span><span class="s1">)</span>

        <span class="s4">return </span><span class="s1">s.get_data(rva</span><span class="s4">, </span><span class="s1">length)</span>

    <span class="s4">def </span><span class="s1">get_rva_from_offset(self</span><span class="s4">, </span><span class="s1">offset):</span>
        <span class="s2">&quot;&quot;&quot;Get the RVA corresponding to this file offset.&quot;&quot;&quot;</span>

        <span class="s1">s = self.get_section_by_offset(offset)</span>
        <span class="s4">if not </span><span class="s1">s:</span>
            <span class="s4">if </span><span class="s1">self.sections:</span>
                <span class="s1">lowest_rva = min(</span>
                    <span class="s1">[</span>
                        <span class="s1">self.adjust_SectionAlignment(</span>
                            <span class="s1">s.VirtualAddress</span><span class="s4">,</span>
                            <span class="s1">self.OPTIONAL_HEADER.SectionAlignment</span><span class="s4">,</span>
                            <span class="s1">self.OPTIONAL_HEADER.FileAlignment</span><span class="s4">,</span>
                        <span class="s1">)</span>
                        <span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">self.sections</span>
                    <span class="s1">]</span>
                <span class="s1">)</span>
                <span class="s4">if </span><span class="s1">offset &lt; lowest_rva:</span>
                    <span class="s0"># We will assume that the offset lies within the headers, or</span>
                    <span class="s0"># at least points before where the earliest section starts</span>
                    <span class="s0"># and we will simply return the offset as the RVA</span>
                    <span class="s0">#</span>
                    <span class="s0"># The case illustrating this behavior can be found at:</span>
                    <span class="s0"># http://corkami.blogspot.com/2010/01/hey-hey-hey-whats-in-your-head.html</span>
                    <span class="s0"># where the import table is not contained by any section</span>
                    <span class="s0"># hence the RVA needs to be resolved to a raw offset</span>
                    <span class="s4">return </span><span class="s1">offset</span>
                <span class="s4">return None</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">return </span><span class="s1">offset</span>
        <span class="s4">return </span><span class="s1">s.get_rva_from_offset(offset)</span>

    <span class="s4">def </span><span class="s1">get_offset_from_rva(self</span><span class="s4">, </span><span class="s1">rva):</span>
        <span class="s2">&quot;&quot;&quot;Get the file offset corresponding to this RVA. 
 
        Given a RVA , this method will find the section where the 
        data lies and return the offset within the file. 
        &quot;&quot;&quot;</span>

        <span class="s1">s = self.get_section_by_rva(rva)</span>
        <span class="s4">if not </span><span class="s1">s:</span>

            <span class="s0"># If not found within a section assume it might</span>
            <span class="s0"># point to overlay data or otherwise data present</span>
            <span class="s0"># but not contained in any section. In those</span>
            <span class="s0"># cases the RVA should equal the offset</span>
            <span class="s4">if </span><span class="s1">rva &lt; len(self.__data__):</span>
                <span class="s4">return </span><span class="s1">rva</span>

            <span class="s4">raise </span><span class="s1">PEFormatError(</span><span class="s3">f&quot;data at RVA 0x</span><span class="s4">{</span><span class="s1">rva</span><span class="s4">:</span><span class="s3">x</span><span class="s4">} </span><span class="s3">can't be fetched&quot;</span><span class="s1">)</span>

        <span class="s4">return </span><span class="s1">s.get_offset_from_rva(rva)</span>

    <span class="s4">def </span><span class="s1">get_string_at_rva(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">max_length=MAX_STRING_LENGTH):</span>
        <span class="s2">&quot;&quot;&quot;Get an ASCII string located at the given address.&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">rva </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s4">return None</span>

        <span class="s1">s = self.get_section_by_rva(rva)</span>
        <span class="s4">if not </span><span class="s1">s:</span>
            <span class="s4">return </span><span class="s1">self.get_string_from_data(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">self.__data__[rva : rva + max_length])</span>
        <span class="s4">return </span><span class="s1">self.get_string_from_data(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">s.get_data(rva</span><span class="s4">, </span><span class="s1">length=max_length))</span>

    <span class="s4">def </span><span class="s1">get_bytes_from_data(self</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s2">&quot;&quot;&quot;.&quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">offset &gt; len(data):</span>
            <span class="s4">return </span><span class="s6">b&quot;&quot;</span>
        <span class="s1">d = data[offset:]</span>
        <span class="s4">if </span><span class="s1">isinstance(d</span><span class="s4">, </span><span class="s1">bytearray):</span>
            <span class="s4">return </span><span class="s1">bytes(d)</span>
        <span class="s4">return </span><span class="s1">d</span>

    <span class="s4">def </span><span class="s1">get_string_from_data(self</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s2">&quot;&quot;&quot;Get an ASCII string from data.&quot;&quot;&quot;</span>
        <span class="s1">s = self.get_bytes_from_data(offset</span><span class="s4">, </span><span class="s1">data)</span>
        <span class="s1">end = s.find(</span><span class="s6">b&quot;</span><span class="s4">\0</span><span class="s6">&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">end &gt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">s = s[:end]</span>
        <span class="s4">return </span><span class="s1">s</span>

    <span class="s4">def </span><span class="s1">get_string_u_at_rva(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">max_length=</span><span class="s5">2</span><span class="s1">**</span><span class="s5">16</span><span class="s4">, </span><span class="s1">encoding=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Get an Unicode string located at the given address.&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">max_length == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s6">b&quot;&quot;</span>

        <span class="s0"># If the RVA is invalid let the exception reach the callers. All</span>
        <span class="s0"># call-sites of get_string_u_at_rva() will handle it.</span>
        <span class="s1">data = self.get_data(rva</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s0"># max_length is the maximum count of 16bit characters needs to be</span>
        <span class="s0"># doubled to get size in bytes</span>
        <span class="s1">max_length &lt;&lt;= </span><span class="s5">1</span>

        <span class="s1">requested = min(max_length</span><span class="s4">, </span><span class="s5">256</span><span class="s1">)</span>
        <span class="s1">data = self.get_data(rva</span><span class="s4">, </span><span class="s1">requested)</span>
        <span class="s0"># try to find null-termination</span>
        <span class="s1">null_index = -</span><span class="s5">1</span>
        <span class="s4">while True</span><span class="s1">:</span>
            <span class="s1">null_index = data.find(</span><span class="s6">b&quot;</span><span class="s4">\x00\x00</span><span class="s6">&quot;</span><span class="s4">, </span><span class="s1">null_index + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">null_index == -</span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">data_length = len(data)</span>
                <span class="s4">if </span><span class="s1">data_length &lt; requested </span><span class="s4">or </span><span class="s1">data_length == max_length:</span>
                    <span class="s1">null_index = len(data) &gt;&gt; </span><span class="s5">1</span>
                    <span class="s4">break</span>

                <span class="s0"># Request remaining part of data limited by max_length</span>
                <span class="s1">data += self.get_data(rva + data_length</span><span class="s4">, </span><span class="s1">max_length - data_length)</span>
                <span class="s1">null_index = requested - </span><span class="s5">1</span>
                <span class="s1">requested = max_length</span>

            <span class="s4">elif </span><span class="s1">null_index % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">null_index &gt;&gt;= </span><span class="s5">1</span>
                <span class="s4">break</span>

        <span class="s0"># convert selected part of the string to unicode</span>
        <span class="s1">uchrs = struct.unpack(</span><span class="s3">&quot;&lt;{:d}H&quot;</span><span class="s1">.format(null_index)</span><span class="s4">, </span><span class="s1">data[: null_index * </span><span class="s5">2</span><span class="s1">])</span>
        <span class="s1">s = </span><span class="s3">&quot;&quot;</span><span class="s1">.join(map(chr</span><span class="s4">, </span><span class="s1">uchrs))</span>

        <span class="s4">if </span><span class="s1">encoding:</span>
            <span class="s4">return </span><span class="s1">b(s.encode(encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">))</span>

        <span class="s4">return </span><span class="s1">b(s.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">get_section_by_offset(self</span><span class="s4">, </span><span class="s1">offset):</span>
        <span class="s2">&quot;&quot;&quot;Get the section containing the given file offset.&quot;&quot;&quot;</span>

        <span class="s4">for </span><span class="s1">section </span><span class="s4">in </span><span class="s1">self.sections:</span>
            <span class="s4">if </span><span class="s1">section.contains_offset(offset):</span>
                <span class="s4">return </span><span class="s1">section</span>

        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">get_section_by_rva(self</span><span class="s4">, </span><span class="s1">rva):</span>
        <span class="s2">&quot;&quot;&quot;Get the section containing the given address.&quot;&quot;&quot;</span>

        <span class="s0"># if we look a lot of times at RVA in the same section, &quot;cache&quot; the last used section</span>
        <span class="s0"># to speedup lookups (very useful when parsing import table)</span>
        <span class="s4">if </span><span class="s1">self._get_section_by_rva_last_used </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self._get_section_by_rva_last_used.contains_rva(rva):</span>
                <span class="s4">return </span><span class="s1">self._get_section_by_rva_last_used</span>

        <span class="s4">for </span><span class="s1">section </span><span class="s4">in </span><span class="s1">self.sections:</span>
            <span class="s4">if </span><span class="s1">section.contains_rva(rva):</span>
                <span class="s1">self._get_section_by_rva_last_used = section</span>
                <span class="s4">return </span><span class="s1">section</span>

        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s1">self.dump_info()</span>

    <span class="s4">def </span><span class="s1">has_relocs(self):</span>
        <span class="s2">&quot;&quot;&quot;Checks if the PE file has relocation directory&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_BASERELOC&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">has_dynamic_relocs(self):</span>
        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_LOAD_CONFIG&quot;</span><span class="s1">):</span>
            <span class="s4">if </span><span class="s1">self.DIRECTORY_ENTRY_LOAD_CONFIG.dynamic_relocations:</span>
                <span class="s4">return True</span>

        <span class="s4">return False</span>

    <span class="s4">def </span><span class="s1">print_info(self</span><span class="s4">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Print all the PE header information in a human readable from.&quot;&quot;&quot;</span>
        <span class="s1">print(self.dump_info(encoding=encoding))</span>

    <span class="s4">def </span><span class="s1">dump_info(self</span><span class="s4">, </span><span class="s1">dump=</span><span class="s4">None, </span><span class="s1">encoding=</span><span class="s3">&quot;ascii&quot;</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Dump all the PE header information into human readable string.&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">dump </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">dump = Dump()</span>

        <span class="s1">warnings = self.get_warnings()</span>
        <span class="s4">if </span><span class="s1">warnings:</span>
            <span class="s1">dump.add_header(</span><span class="s3">&quot;Parsing Warnings&quot;</span><span class="s1">)</span>
            <span class="s4">for </span><span class="s1">warning </span><span class="s4">in </span><span class="s1">warnings:</span>
                <span class="s1">dump.add_line(warning)</span>
                <span class="s1">dump.add_newline()</span>

        <span class="s1">dump.add_header(</span><span class="s3">&quot;DOS_HEADER&quot;</span><span class="s1">)</span>
        <span class="s1">dump.add_lines(self.DOS_HEADER.dump())</span>
        <span class="s1">dump.add_newline()</span>

        <span class="s1">dump.add_header(</span><span class="s3">&quot;NT_HEADERS&quot;</span><span class="s1">)</span>
        <span class="s1">dump.add_lines(self.NT_HEADERS.dump())</span>
        <span class="s1">dump.add_newline()</span>

        <span class="s1">dump.add_header(</span><span class="s3">&quot;FILE_HEADER&quot;</span><span class="s1">)</span>
        <span class="s1">dump.add_lines(self.FILE_HEADER.dump())</span>

        <span class="s1">image_flags = retrieve_flags(IMAGE_CHARACTERISTICS</span><span class="s4">, </span><span class="s3">&quot;IMAGE_FILE_&quot;</span><span class="s1">)</span>

        <span class="s1">dump.add(</span><span class="s3">&quot;Flags: &quot;</span><span class="s1">)</span>
        <span class="s1">flags = []</span>
        <span class="s4">for </span><span class="s1">flag </span><span class="s4">in </span><span class="s1">sorted(image_flags):</span>
            <span class="s4">if </span><span class="s1">getattr(self.FILE_HEADER</span><span class="s4">, </span><span class="s1">flag[</span><span class="s5">0</span><span class="s1">]):</span>
                <span class="s1">flags.append(flag[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">dump.add_line(</span><span class="s3">&quot;, &quot;</span><span class="s1">.join(flags))</span>
        <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;OPTIONAL_HEADER&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">self.OPTIONAL_HEADER </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">dump.add_header(</span><span class="s3">&quot;OPTIONAL_HEADER&quot;</span><span class="s1">)</span>
            <span class="s1">dump.add_lines(self.OPTIONAL_HEADER.dump())</span>

        <span class="s1">dll_characteristics_flags = retrieve_flags(</span>
            <span class="s1">DLL_CHARACTERISTICS</span><span class="s4">, </span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_&quot;</span>
        <span class="s1">)</span>

        <span class="s1">dump.add(</span><span class="s3">&quot;DllCharacteristics: &quot;</span><span class="s1">)</span>
        <span class="s1">flags = []</span>
        <span class="s4">for </span><span class="s1">flag </span><span class="s4">in </span><span class="s1">sorted(dll_characteristics_flags):</span>
            <span class="s4">if </span><span class="s1">getattr(self.OPTIONAL_HEADER</span><span class="s4">, </span><span class="s1">flag[</span><span class="s5">0</span><span class="s1">]):</span>
                <span class="s1">flags.append(flag[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">dump.add_line(</span><span class="s3">&quot;, &quot;</span><span class="s1">.join(flags))</span>
        <span class="s1">dump.add_newline()</span>

        <span class="s1">dump.add_header(</span><span class="s3">&quot;PE Sections&quot;</span><span class="s1">)</span>

        <span class="s1">section_flags = retrieve_flags(SECTION_CHARACTERISTICS</span><span class="s4">, </span><span class="s3">&quot;IMAGE_SCN_&quot;</span><span class="s1">)</span>

        <span class="s4">for </span><span class="s1">section </span><span class="s4">in </span><span class="s1">self.sections:</span>
            <span class="s1">dump.add_lines(section.dump())</span>
            <span class="s1">dump.add(</span><span class="s3">&quot;Flags: &quot;</span><span class="s1">)</span>
            <span class="s1">flags = []</span>
            <span class="s4">for </span><span class="s1">flag </span><span class="s4">in </span><span class="s1">sorted(section_flags):</span>
                <span class="s4">if </span><span class="s1">getattr(section</span><span class="s4">, </span><span class="s1">flag[</span><span class="s5">0</span><span class="s1">]):</span>
                    <span class="s1">flags.append(flag[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">dump.add_line(</span><span class="s3">&quot;, &quot;</span><span class="s1">.join(flags))</span>
            <span class="s1">dump.add_line(</span>
                <span class="s3">&quot;Entropy: {0:f} (Min=0.0, Max=8.0)&quot;</span><span class="s1">.format(section.get_entropy())</span>
            <span class="s1">)</span>
            <span class="s4">if </span><span class="s1">md5 </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">dump.add_line(</span><span class="s3">&quot;MD5     hash: {0}&quot;</span><span class="s1">.format(section.get_hash_md5()))</span>
            <span class="s4">if </span><span class="s1">sha1 </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">dump.add_line(</span><span class="s3">&quot;SHA-1   hash: %s&quot; </span><span class="s1">% section.get_hash_sha1())</span>
            <span class="s4">if </span><span class="s1">sha256 </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">dump.add_line(</span><span class="s3">&quot;SHA-256 hash: %s&quot; </span><span class="s1">% section.get_hash_sha256())</span>
            <span class="s4">if </span><span class="s1">sha512 </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">dump.add_line(</span><span class="s3">&quot;SHA-512 hash: %s&quot; </span><span class="s1">% section.get_hash_sha512())</span>
            <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;OPTIONAL_HEADER&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">hasattr(</span>
            <span class="s1">self.OPTIONAL_HEADER</span><span class="s4">, </span><span class="s3">&quot;DATA_DIRECTORY&quot;</span>
        <span class="s1">):</span>

            <span class="s1">dump.add_header(</span><span class="s3">&quot;Directories&quot;</span><span class="s1">)</span>
            <span class="s4">for </span><span class="s1">directory </span><span class="s4">in </span><span class="s1">self.OPTIONAL_HEADER.DATA_DIRECTORY:</span>
                <span class="s4">if </span><span class="s1">directory </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s1">dump.add_lines(directory.dump())</span>
            <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;VS_VERSIONINFO&quot;</span><span class="s1">):</span>
            <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">vinfo_entry </span><span class="s4">in </span><span class="s1">enumerate(self.VS_VERSIONINFO):</span>
                <span class="s4">if </span><span class="s1">len(self.VS_VERSIONINFO) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">dump.add_header(</span><span class="s3">f&quot;Version Information </span><span class="s4">{</span><span class="s1">idx + </span><span class="s5">1</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">dump.add_header(</span><span class="s3">&quot;Version Information&quot;</span><span class="s1">)</span>
                <span class="s4">if </span><span class="s1">vinfo_entry </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s1">dump.add_lines(vinfo_entry.dump())</span>
                <span class="s1">dump.add_newline()</span>

                <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;VS_FIXEDFILEINFO&quot;</span><span class="s1">):</span>
                    <span class="s1">dump.add_lines(self.VS_FIXEDFILEINFO[idx].dump())</span>
                    <span class="s1">dump.add_newline()</span>

                <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;FileInfo&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">len(self.FileInfo) &gt; idx:</span>
                    <span class="s4">for </span><span class="s1">entry </span><span class="s4">in </span><span class="s1">self.FileInfo[idx]:</span>
                        <span class="s1">dump.add_lines(entry.dump())</span>
                        <span class="s1">dump.add_newline()</span>

                        <span class="s4">if </span><span class="s1">hasattr(entry</span><span class="s4">, </span><span class="s3">&quot;StringTable&quot;</span><span class="s1">):</span>
                            <span class="s4">for </span><span class="s1">st_entry </span><span class="s4">in </span><span class="s1">entry.StringTable:</span>
                                <span class="s1">[dump.add_line(</span><span class="s3">&quot;  &quot; </span><span class="s1">+ line) </span><span class="s4">for </span><span class="s1">line </span><span class="s4">in </span><span class="s1">st_entry.dump()]</span>
                                <span class="s1">dump.add_line(</span>
                                    <span class="s3">&quot;  LangID: {0}&quot;</span><span class="s1">.format(</span>
                                        <span class="s1">st_entry.LangID.decode(</span>
                                            <span class="s1">encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span>
                                        <span class="s1">)</span>
                                    <span class="s1">)</span>
                                <span class="s1">)</span>
                                <span class="s1">dump.add_newline()</span>
                                <span class="s4">for </span><span class="s1">str_entry </span><span class="s4">in </span><span class="s1">sorted(list(st_entry.entries.items())):</span>
                                    <span class="s0"># try:</span>
                                    <span class="s1">dump.add_line(</span>
                                        <span class="s3">&quot;    {0}: {1}&quot;</span><span class="s1">.format(</span>
                                            <span class="s1">str_entry[</span><span class="s5">0</span><span class="s1">].decode(</span>
                                                <span class="s1">encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span>
                                            <span class="s1">)</span><span class="s4">,</span>
                                            <span class="s1">str_entry[</span><span class="s5">1</span><span class="s1">].decode(</span>
                                                <span class="s1">encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span>
                                            <span class="s1">)</span><span class="s4">,</span>
                                        <span class="s1">)</span>
                                    <span class="s1">)</span>

                            <span class="s1">dump.add_newline()</span>

                        <span class="s4">elif </span><span class="s1">hasattr(entry</span><span class="s4">, </span><span class="s3">&quot;Var&quot;</span><span class="s1">):</span>
                            <span class="s4">for </span><span class="s1">var_entry </span><span class="s4">in </span><span class="s1">entry.Var:</span>
                                <span class="s4">if </span><span class="s1">hasattr(var_entry</span><span class="s4">, </span><span class="s3">&quot;entry&quot;</span><span class="s1">):</span>
                                    <span class="s1">[</span>
                                        <span class="s1">dump.add_line(</span><span class="s3">&quot;  &quot; </span><span class="s1">+ line)</span>
                                        <span class="s4">for </span><span class="s1">line </span><span class="s4">in </span><span class="s1">var_entry.dump()</span>
                                    <span class="s1">]</span>
                                    <span class="s1">dump.add_line(</span>
                                        <span class="s3">&quot;    {0}: {1}&quot;</span><span class="s1">.format(</span>
                                            <span class="s1">list(var_entry.entry.keys())[</span><span class="s5">0</span><span class="s1">].decode(</span>
                                                <span class="s3">&quot;utf-8&quot;</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span>
                                            <span class="s1">)</span><span class="s4">,</span>
                                            <span class="s1">list(var_entry.entry.values())[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">,</span>
                                        <span class="s1">)</span>
                                    <span class="s1">)</span>

                            <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_EXPORT&quot;</span><span class="s1">):</span>
            <span class="s1">dump.add_header(</span><span class="s3">&quot;Exported symbols&quot;</span><span class="s1">)</span>
            <span class="s1">dump.add_lines(self.DIRECTORY_ENTRY_EXPORT.struct.dump())</span>
            <span class="s1">dump.add_newline()</span>
            <span class="s1">dump.add_line(</span><span class="s3">&quot;%-10s   %-10s  %s&quot; </span><span class="s1">% (</span><span class="s3">&quot;Ordinal&quot;</span><span class="s4">, </span><span class="s3">&quot;RVA&quot;</span><span class="s4">, </span><span class="s3">&quot;Name&quot;</span><span class="s1">))</span>
            <span class="s4">for </span><span class="s1">export </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_EXPORT.symbols:</span>
                <span class="s4">if </span><span class="s1">export.address </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s1">name = b(</span><span class="s3">&quot;None&quot;</span><span class="s1">)</span>
                    <span class="s4">if </span><span class="s1">export.name:</span>
                        <span class="s1">name = export.name</span>
                    <span class="s1">dump.add(</span>
                        <span class="s3">&quot;%-10d 0x%08X    %s&quot;</span>
                        <span class="s1">% (export.ordinal</span><span class="s4">, </span><span class="s1">export.address</span><span class="s4">, </span><span class="s1">name.decode(encoding))</span>
                    <span class="s1">)</span>
                    <span class="s4">if </span><span class="s1">export.forwarder:</span>
                        <span class="s1">dump.add_line(</span>
                            <span class="s3">&quot; forwarder: {0}&quot;</span><span class="s1">.format(</span>
                                <span class="s1">export.forwarder.decode(encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">)</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">dump.add_newline()</span>

            <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_IMPORT&quot;</span><span class="s1">):</span>
            <span class="s1">dump.add_header(</span><span class="s3">&quot;Imported symbols&quot;</span><span class="s1">)</span>
            <span class="s4">for </span><span class="s1">module </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_IMPORT:</span>
                <span class="s1">dump.add_lines(module.struct.dump())</span>
                <span class="s0"># Print the name of the DLL if there are no imports.</span>
                <span class="s4">if not </span><span class="s1">module.imports:</span>
                    <span class="s1">dump.add(</span>
                        <span class="s3">&quot;  Name -&gt; {0}&quot;</span><span class="s1">.format(</span>
                            <span class="s1">self.get_string_at_rva(module.struct.Name).decode(</span>
                                <span class="s1">encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                    <span class="s1">dump.add_newline()</span>
                <span class="s1">dump.add_newline()</span>
                <span class="s4">for </span><span class="s1">symbol </span><span class="s4">in </span><span class="s1">module.imports:</span>
                    <span class="s4">if </span><span class="s1">symbol.import_by_ordinal </span><span class="s4">is True</span><span class="s1">:</span>
                        <span class="s4">if </span><span class="s1">symbol.name </span><span class="s4">is not None</span><span class="s1">:</span>
                            <span class="s1">dump.add(</span>
                                <span class="s3">&quot;{0}.{1} Ordinal[{2}] (Imported by Ordinal)&quot;</span><span class="s1">.format(</span>
                                    <span class="s1">module.dll.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s4">,</span>
                                    <span class="s1">symbol.name.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s4">,</span>
                                    <span class="s1">symbol.ordinal</span><span class="s4">,</span>
                                <span class="s1">)</span>
                            <span class="s1">)</span>
                        <span class="s4">else</span><span class="s1">:</span>
                            <span class="s1">dump.add(</span>
                                <span class="s3">&quot;{0} Ordinal[{1}] (Imported by Ordinal)&quot;</span><span class="s1">.format(</span>
                                    <span class="s1">module.dll.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s4">, </span><span class="s1">symbol.ordinal</span>
                                <span class="s1">)</span>
                            <span class="s1">)</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">dump.add(</span>
                            <span class="s3">&quot;{0}.{1} Hint[{2:d}]&quot;</span><span class="s1">.format(</span>
                                <span class="s1">module.dll.decode(encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">)</span><span class="s4">,</span>
                                <span class="s1">symbol.name.decode(encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">)</span><span class="s4">,</span>
                                <span class="s1">symbol.hint</span><span class="s4">,</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>

                    <span class="s4">if </span><span class="s1">symbol.bound:</span>
                        <span class="s1">dump.add_line(</span><span class="s3">&quot; Bound: 0x{0:08X}&quot;</span><span class="s1">.format(symbol.bound))</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">dump.add_newline()</span>
                <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_BOUND_IMPORT&quot;</span><span class="s1">):</span>
            <span class="s1">dump.add_header(</span><span class="s3">&quot;Bound imports&quot;</span><span class="s1">)</span>
            <span class="s4">for </span><span class="s1">bound_imp_desc </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_BOUND_IMPORT:</span>

                <span class="s1">dump.add_lines(bound_imp_desc.struct.dump())</span>
                <span class="s1">dump.add_line(</span>
                    <span class="s3">&quot;DLL: {0}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">bound_imp_desc.name.decode(encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">dump.add_newline()</span>

                <span class="s4">for </span><span class="s1">bound_imp_ref </span><span class="s4">in </span><span class="s1">bound_imp_desc.entries:</span>
                    <span class="s1">dump.add_lines(bound_imp_ref.struct.dump()</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span>
                    <span class="s1">dump.add_line(</span>
                        <span class="s3">&quot;DLL: {0}&quot;</span><span class="s1">.format(</span>
                            <span class="s1">bound_imp_ref.name.decode(encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">)</span>
                        <span class="s1">)</span><span class="s4">,</span>
                        <span class="s5">4</span><span class="s4">,</span>
                    <span class="s1">)</span>
                    <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_DELAY_IMPORT&quot;</span><span class="s1">):</span>
            <span class="s1">dump.add_header(</span><span class="s3">&quot;Delay Imported symbols&quot;</span><span class="s1">)</span>
            <span class="s4">for </span><span class="s1">module </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_DELAY_IMPORT:</span>

                <span class="s1">dump.add_lines(module.struct.dump())</span>
                <span class="s1">dump.add_newline()</span>

                <span class="s4">for </span><span class="s1">symbol </span><span class="s4">in </span><span class="s1">module.imports:</span>
                    <span class="s4">if </span><span class="s1">symbol.import_by_ordinal </span><span class="s4">is True</span><span class="s1">:</span>
                        <span class="s1">dump.add(</span>
                            <span class="s3">&quot;{0} Ordinal[{1:d}] (Imported by Ordinal)&quot;</span><span class="s1">.format(</span>
                                <span class="s1">module.dll.decode(encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">)</span><span class="s4">,</span>
                                <span class="s1">symbol.ordinal</span><span class="s4">,</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">dump.add(</span>
                            <span class="s3">&quot;{0}.{1} Hint[{2}]&quot;</span><span class="s1">.format(</span>
                                <span class="s1">module.dll.decode(encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">)</span><span class="s4">,</span>
                                <span class="s1">symbol.name.decode(encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">)</span><span class="s4">,</span>
                                <span class="s1">symbol.hint</span><span class="s4">,</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>

                    <span class="s4">if </span><span class="s1">symbol.bound:</span>
                        <span class="s1">dump.add_line(</span><span class="s3">&quot; Bound: 0x{0:08X}&quot;</span><span class="s1">.format(symbol.bound))</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">dump.add_newline()</span>
                <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_RESOURCE&quot;</span><span class="s1">):</span>
            <span class="s1">dump.add_header(</span><span class="s3">&quot;Resource directory&quot;</span><span class="s1">)</span>

            <span class="s1">dump.add_lines(self.DIRECTORY_ENTRY_RESOURCE.struct.dump())</span>

            <span class="s4">for </span><span class="s1">res_type </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_RESOURCE.entries:</span>

                <span class="s4">if </span><span class="s1">res_type.name </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s1">name = res_type.name.decode(encoding</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">)</span>
                    <span class="s1">dump.add_line(</span>
                        <span class="s3">f&quot;Name: [</span><span class="s4">{</span><span class="s1">name</span><span class="s4">}</span><span class="s3">]&quot;</span><span class="s4">,</span>
                        <span class="s5">2</span><span class="s4">,</span>
                    <span class="s1">)</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">res_type_id = RESOURCE_TYPE.get(res_type.struct.Id</span><span class="s4">, </span><span class="s3">&quot;-&quot;</span><span class="s1">)</span>
                    <span class="s1">dump.add_line(</span>
                        <span class="s3">f&quot;Id: [0x</span><span class="s4">{</span><span class="s1">res_type.struct.Id</span><span class="s4">:</span><span class="s3">X</span><span class="s4">}</span><span class="s3">] (</span><span class="s4">{</span><span class="s1">res_type_id</span><span class="s4">}</span><span class="s3">)&quot;</span><span class="s4">,</span>
                        <span class="s5">2</span><span class="s4">,</span>
                    <span class="s1">)</span>

                <span class="s1">dump.add_lines(res_type.struct.dump()</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>

                <span class="s4">if </span><span class="s1">hasattr(res_type</span><span class="s4">, </span><span class="s3">&quot;directory&quot;</span><span class="s1">):</span>

                    <span class="s1">dump.add_lines(res_type.directory.struct.dump()</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span>

                    <span class="s4">for </span><span class="s1">resource_id </span><span class="s4">in </span><span class="s1">res_type.directory.entries:</span>

                        <span class="s4">if </span><span class="s1">resource_id.name </span><span class="s4">is not None</span><span class="s1">:</span>
                            <span class="s1">name = resource_id.name.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s4">, </span><span class="s3">&quot;backslashreplace_&quot;</span><span class="s1">)</span>
                            <span class="s1">dump.add_line(</span>
                                <span class="s3">f&quot;Name: [</span><span class="s4">{</span><span class="s1">name</span><span class="s4">}</span><span class="s3">]&quot;</span><span class="s4">,</span>
                                <span class="s5">6</span><span class="s4">,</span>
                            <span class="s1">)</span>
                        <span class="s4">else</span><span class="s1">:</span>
                            <span class="s1">dump.add_line(</span><span class="s3">f&quot;Id: [0x</span><span class="s4">{</span><span class="s1">resource_id.struct.Id</span><span class="s4">:</span><span class="s3">X</span><span class="s4">}</span><span class="s3">]&quot;</span><span class="s4">, </span><span class="s5">6</span><span class="s1">)</span>

                        <span class="s1">dump.add_lines(resource_id.struct.dump()</span><span class="s4">, </span><span class="s5">6</span><span class="s1">)</span>

                        <span class="s4">if </span><span class="s1">hasattr(resource_id</span><span class="s4">, </span><span class="s3">&quot;directory&quot;</span><span class="s1">):</span>
                            <span class="s1">dump.add_lines(resource_id.directory.struct.dump()</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span>

                            <span class="s4">for </span><span class="s1">resource_lang </span><span class="s4">in </span><span class="s1">resource_id.directory.entries:</span>
                                <span class="s4">if </span><span class="s1">hasattr(resource_lang</span><span class="s4">, </span><span class="s3">&quot;data&quot;</span><span class="s1">):</span>
                                    <span class="s1">dump.add_line(</span>
                                        <span class="s3">&quot;</span><span class="s4">\\</span><span class="s3">--- LANG [%d,%d][%s,%s]&quot;</span>
                                        <span class="s1">% (</span>
                                            <span class="s1">resource_lang.data.lang</span><span class="s4">,</span>
                                            <span class="s1">resource_lang.data.sublang</span><span class="s4">,</span>
                                            <span class="s1">LANG.get(</span>
                                                <span class="s1">resource_lang.data.lang</span><span class="s4">, </span><span class="s3">&quot;*unknown*&quot;</span>
                                            <span class="s1">)</span><span class="s4">,</span>
                                            <span class="s1">get_sublang_name_for_lang(</span>
                                                <span class="s1">resource_lang.data.lang</span><span class="s4">,</span>
                                                <span class="s1">resource_lang.data.sublang</span><span class="s4">,</span>
                                            <span class="s1">)</span><span class="s4">,</span>
                                        <span class="s1">)</span><span class="s4">,</span>
                                        <span class="s5">8</span><span class="s4">,</span>
                                    <span class="s1">)</span>
                                    <span class="s1">dump.add_lines(resource_lang.struct.dump()</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span>
                                    <span class="s1">dump.add_lines(resource_lang.data.struct.dump()</span><span class="s4">, </span><span class="s5">12</span><span class="s1">)</span>
                            <span class="s4">if </span><span class="s1">(</span>
                                <span class="s1">hasattr(resource_id.directory</span><span class="s4">, </span><span class="s3">&quot;strings&quot;</span><span class="s1">)</span>
                                <span class="s4">and </span><span class="s1">resource_id.directory.strings</span>
                            <span class="s1">):</span>
                                <span class="s1">dump.add_line(</span><span class="s3">&quot;[STRINGS]&quot;</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span>
                                <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">res_string </span><span class="s4">in </span><span class="s1">list(</span>
                                    <span class="s1">sorted(resource_id.directory.strings.items())</span>
                                <span class="s1">):</span>
                                    <span class="s1">dump.add_line(</span>
                                        <span class="s3">&quot;{0:6d}: {1}&quot;</span><span class="s1">.format(</span>
                                            <span class="s1">idx</span><span class="s4">,</span>
                                            <span class="s1">res_string.encode(</span>
                                                <span class="s3">&quot;unicode-escape&quot;</span><span class="s4">, </span><span class="s3">&quot;backslashreplace&quot;</span>
                                            <span class="s1">).decode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span><span class="s4">,</span>
                                        <span class="s1">)</span><span class="s4">,</span>
                                        <span class="s5">12</span><span class="s4">,</span>
                                    <span class="s1">)</span>

                <span class="s1">dump.add_newline()</span>

            <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_TLS&quot;</span><span class="s1">)</span>
            <span class="s4">and </span><span class="s1">self.DIRECTORY_ENTRY_TLS</span>
            <span class="s4">and </span><span class="s1">self.DIRECTORY_ENTRY_TLS.struct</span>
        <span class="s1">):</span>

            <span class="s1">dump.add_header(</span><span class="s3">&quot;TLS&quot;</span><span class="s1">)</span>
            <span class="s1">dump.add_lines(self.DIRECTORY_ENTRY_TLS.struct.dump())</span>
            <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_LOAD_CONFIG&quot;</span><span class="s1">)</span>
            <span class="s4">and </span><span class="s1">self.DIRECTORY_ENTRY_LOAD_CONFIG</span>
            <span class="s4">and </span><span class="s1">self.DIRECTORY_ENTRY_LOAD_CONFIG.struct</span>
        <span class="s1">):</span>

            <span class="s1">dump.add_header(</span><span class="s3">&quot;LOAD_CONFIG&quot;</span><span class="s1">)</span>
            <span class="s1">dump.add_lines(self.DIRECTORY_ENTRY_LOAD_CONFIG.struct.dump())</span>
            <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_DEBUG&quot;</span><span class="s1">):</span>
            <span class="s1">dump.add_header(</span><span class="s3">&quot;Debug information&quot;</span><span class="s1">)</span>
            <span class="s4">for </span><span class="s1">dbg </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_DEBUG:</span>
                <span class="s1">dump.add_lines(dbg.struct.dump())</span>
                <span class="s4">try</span><span class="s1">:</span>
                    <span class="s1">dump.add_line(</span><span class="s3">&quot;Type: &quot; </span><span class="s1">+ DEBUG_TYPE[dbg.struct.Type])</span>
                <span class="s4">except </span><span class="s1">KeyError:</span>
                    <span class="s1">dump.add_line(</span><span class="s3">&quot;Type: 0x{0:x}(Unknown)&quot;</span><span class="s1">.format(dbg.struct.Type))</span>
                <span class="s1">dump.add_newline()</span>
                <span class="s4">if </span><span class="s1">dbg.entry:</span>
                    <span class="s1">dump.add_lines(dbg.entry.dump()</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span>
                    <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">self.has_relocs():</span>
            <span class="s1">dump.add_header(</span><span class="s3">&quot;Base relocations&quot;</span><span class="s1">)</span>
            <span class="s4">for </span><span class="s1">base_reloc </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_BASERELOC:</span>
                <span class="s1">dump.add_lines(base_reloc.struct.dump())</span>
                <span class="s4">for </span><span class="s1">reloc </span><span class="s4">in </span><span class="s1">base_reloc.entries:</span>
                    <span class="s4">try</span><span class="s1">:</span>
                        <span class="s1">dump.add_line(</span>
                            <span class="s3">&quot;%08Xh %s&quot; </span><span class="s1">% (reloc.rva</span><span class="s4">, </span><span class="s1">RELOCATION_TYPE[reloc.type][</span><span class="s5">16</span><span class="s1">:])</span><span class="s4">,</span>
                            <span class="s5">4</span><span class="s4">,</span>
                        <span class="s1">)</span>
                    <span class="s4">except </span><span class="s1">KeyError:</span>
                        <span class="s1">dump.add_line(</span>
                            <span class="s3">&quot;0x%08X 0x%x(Unknown)&quot; </span><span class="s1">% (reloc.rva</span><span class="s4">, </span><span class="s1">reloc.type)</span><span class="s4">, </span><span class="s5">4</span>
                        <span class="s1">)</span>
                <span class="s1">dump.add_newline()</span>

        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_EXCEPTION&quot;</span><span class="s1">)</span>
            <span class="s4">and </span><span class="s1">len(self.DIRECTORY_ENTRY_EXCEPTION) &gt; </span><span class="s5">0</span>
        <span class="s1">):</span>
            <span class="s1">dump.add_header(</span><span class="s3">&quot;Unwind data for exception handling&quot;</span><span class="s1">)</span>
            <span class="s4">for </span><span class="s1">rf </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_EXCEPTION:</span>
                <span class="s1">dump.add_lines(rf.struct.dump())</span>
                <span class="s4">if </span><span class="s1">hasattr(rf</span><span class="s4">, </span><span class="s3">&quot;unwindinfo&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">rf.unwindinfo </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s1">dump.add_lines(rf.unwindinfo.dump()</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span>

        <span class="s4">return </span><span class="s1">dump.get_text()</span>

    <span class="s4">def </span><span class="s1">dump_dict(self):</span>
        <span class="s2">&quot;&quot;&quot;Dump all the PE header information into a dictionary.&quot;&quot;&quot;</span>

        <span class="s1">dump_dict = {}</span>

        <span class="s1">warnings = self.get_warnings()</span>
        <span class="s4">if </span><span class="s1">warnings:</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;Parsing Warnings&quot;</span><span class="s1">] = warnings</span>

        <span class="s1">dump_dict[</span><span class="s3">&quot;DOS_HEADER&quot;</span><span class="s1">] = self.DOS_HEADER.dump_dict()</span>
        <span class="s1">dump_dict[</span><span class="s3">&quot;NT_HEADERS&quot;</span><span class="s1">] = self.NT_HEADERS.dump_dict()</span>
        <span class="s1">dump_dict[</span><span class="s3">&quot;FILE_HEADER&quot;</span><span class="s1">] = self.FILE_HEADER.dump_dict()</span>

        <span class="s1">image_flags = retrieve_flags(IMAGE_CHARACTERISTICS</span><span class="s4">, </span><span class="s3">&quot;IMAGE_FILE_&quot;</span><span class="s1">)</span>

        <span class="s1">dump_dict[</span><span class="s3">&quot;Flags&quot;</span><span class="s1">] = []</span>
        <span class="s4">for </span><span class="s1">flag </span><span class="s4">in </span><span class="s1">image_flags:</span>
            <span class="s4">if </span><span class="s1">getattr(self.FILE_HEADER</span><span class="s4">, </span><span class="s1">flag[</span><span class="s5">0</span><span class="s1">]):</span>
                <span class="s1">dump_dict[</span><span class="s3">&quot;Flags&quot;</span><span class="s1">].append(flag[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;OPTIONAL_HEADER&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">self.OPTIONAL_HEADER </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;OPTIONAL_HEADER&quot;</span><span class="s1">] = self.OPTIONAL_HEADER.dump_dict()</span>

        <span class="s1">dll_characteristics_flags = retrieve_flags(</span>
            <span class="s1">DLL_CHARACTERISTICS</span><span class="s4">, </span><span class="s3">&quot;IMAGE_DLLCHARACTERISTICS_&quot;</span>
        <span class="s1">)</span>

        <span class="s1">dump_dict[</span><span class="s3">&quot;DllCharacteristics&quot;</span><span class="s1">] = []</span>
        <span class="s4">for </span><span class="s1">flag </span><span class="s4">in </span><span class="s1">dll_characteristics_flags:</span>
            <span class="s4">if </span><span class="s1">getattr(self.OPTIONAL_HEADER</span><span class="s4">, </span><span class="s1">flag[</span><span class="s5">0</span><span class="s1">]):</span>
                <span class="s1">dump_dict[</span><span class="s3">&quot;DllCharacteristics&quot;</span><span class="s1">].append(flag[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s1">dump_dict[</span><span class="s3">&quot;PE Sections&quot;</span><span class="s1">] = []</span>

        <span class="s1">section_flags = retrieve_flags(SECTION_CHARACTERISTICS</span><span class="s4">, </span><span class="s3">&quot;IMAGE_SCN_&quot;</span><span class="s1">)</span>
        <span class="s4">for </span><span class="s1">section </span><span class="s4">in </span><span class="s1">self.sections:</span>
            <span class="s1">section_dict = section.dump_dict()</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;PE Sections&quot;</span><span class="s1">].append(section_dict)</span>
            <span class="s1">section_dict[</span><span class="s3">&quot;Flags&quot;</span><span class="s1">] = []</span>
            <span class="s4">for </span><span class="s1">flag </span><span class="s4">in </span><span class="s1">section_flags:</span>
                <span class="s4">if </span><span class="s1">getattr(section</span><span class="s4">, </span><span class="s1">flag[</span><span class="s5">0</span><span class="s1">]):</span>
                    <span class="s1">section_dict[</span><span class="s3">&quot;Flags&quot;</span><span class="s1">].append(flag[</span><span class="s5">0</span><span class="s1">])</span>

            <span class="s1">section_dict[</span><span class="s3">&quot;Entropy&quot;</span><span class="s1">] = section.get_entropy()</span>
            <span class="s4">if </span><span class="s1">md5 </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">section_dict[</span><span class="s3">&quot;MD5&quot;</span><span class="s1">] = section.get_hash_md5()</span>
            <span class="s4">if </span><span class="s1">sha1 </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">section_dict[</span><span class="s3">&quot;SHA1&quot;</span><span class="s1">] = section.get_hash_sha1()</span>
            <span class="s4">if </span><span class="s1">sha256 </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">section_dict[</span><span class="s3">&quot;SHA256&quot;</span><span class="s1">] = section.get_hash_sha256()</span>
            <span class="s4">if </span><span class="s1">sha512 </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">section_dict[</span><span class="s3">&quot;SHA512&quot;</span><span class="s1">] = section.get_hash_sha512()</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;OPTIONAL_HEADER&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">hasattr(</span>
            <span class="s1">self.OPTIONAL_HEADER</span><span class="s4">, </span><span class="s3">&quot;DATA_DIRECTORY&quot;</span>
        <span class="s1">):</span>

            <span class="s1">dump_dict[</span><span class="s3">&quot;Directories&quot;</span><span class="s1">] = []</span>

            <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">directory </span><span class="s4">in </span><span class="s1">enumerate(self.OPTIONAL_HEADER.DATA_DIRECTORY):</span>
                <span class="s4">if </span><span class="s1">directory </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s1">dump_dict[</span><span class="s3">&quot;Directories&quot;</span><span class="s1">].append(directory.dump_dict())</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;VS_VERSIONINFO&quot;</span><span class="s1">):</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;Version Information&quot;</span><span class="s1">] = []</span>
            <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">vs_vinfo </span><span class="s4">in </span><span class="s1">enumerate(self.VS_VERSIONINFO):</span>
                <span class="s1">version_info_list = []</span>
                <span class="s1">version_info_list.append(vs_vinfo.dump_dict())</span>

                <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;VS_FIXEDFILEINFO&quot;</span><span class="s1">):</span>
                    <span class="s1">version_info_list.append(self.VS_FIXEDFILEINFO[idx].dump_dict())</span>

                <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;FileInfo&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">len(self.FileInfo) &gt; idx:</span>
                    <span class="s1">fileinfo_list = []</span>
                    <span class="s1">version_info_list.append(fileinfo_list)</span>
                    <span class="s4">for </span><span class="s1">entry </span><span class="s4">in </span><span class="s1">self.FileInfo[idx]:</span>
                        <span class="s1">fileinfo_list.append(entry.dump_dict())</span>

                        <span class="s4">if </span><span class="s1">hasattr(entry</span><span class="s4">, </span><span class="s3">&quot;StringTable&quot;</span><span class="s1">):</span>
                            <span class="s1">stringtable_dict = {}</span>
                            <span class="s4">for </span><span class="s1">st_entry </span><span class="s4">in </span><span class="s1">entry.StringTable:</span>
                                <span class="s1">fileinfo_list.extend(st_entry.dump_dict())</span>
                                <span class="s1">stringtable_dict[</span><span class="s3">&quot;LangID&quot;</span><span class="s1">] = st_entry.LangID</span>
                                <span class="s4">for </span><span class="s1">str_entry </span><span class="s4">in </span><span class="s1">list(st_entry.entries.items()):</span>
                                    <span class="s1">stringtable_dict[str_entry[</span><span class="s5">0</span><span class="s1">]] = str_entry[</span><span class="s5">1</span><span class="s1">]</span>
                            <span class="s1">fileinfo_list.append(stringtable_dict)</span>

                        <span class="s4">elif </span><span class="s1">hasattr(entry</span><span class="s4">, </span><span class="s3">&quot;Var&quot;</span><span class="s1">):</span>
                            <span class="s4">for </span><span class="s1">var_entry </span><span class="s4">in </span><span class="s1">entry.Var:</span>
                                <span class="s1">var_dict = {}</span>
                                <span class="s4">if </span><span class="s1">hasattr(var_entry</span><span class="s4">, </span><span class="s3">&quot;entry&quot;</span><span class="s1">):</span>
                                    <span class="s1">fileinfo_list.extend(var_entry.dump_dict())</span>
                                    <span class="s1">var_dict[list(var_entry.entry.keys())[</span><span class="s5">0</span><span class="s1">]] = list(</span>
                                        <span class="s1">var_entry.entry.values()</span>
                                    <span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
                                    <span class="s1">fileinfo_list.append(var_dict)</span>

                <span class="s1">dump_dict[</span><span class="s3">&quot;Version Information&quot;</span><span class="s1">].append(version_info_list)</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_EXPORT&quot;</span><span class="s1">):</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;Exported symbols&quot;</span><span class="s1">] = []</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;Exported symbols&quot;</span><span class="s1">].append(</span>
                <span class="s1">self.DIRECTORY_ENTRY_EXPORT.struct.dump_dict()</span>
            <span class="s1">)</span>
            <span class="s4">for </span><span class="s1">export </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_EXPORT.symbols:</span>
                <span class="s1">export_dict = {}</span>
                <span class="s4">if </span><span class="s1">export.address </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s1">export_dict.update(</span>
                        <span class="s1">{</span>
                            <span class="s3">&quot;Ordinal&quot;</span><span class="s1">: export.ordinal</span><span class="s4">,</span>
                            <span class="s3">&quot;RVA&quot;</span><span class="s1">: export.address</span><span class="s4">,</span>
                            <span class="s3">&quot;Name&quot;</span><span class="s1">: export.name</span><span class="s4">,</span>
                        <span class="s1">}</span>
                    <span class="s1">)</span>
                    <span class="s4">if </span><span class="s1">export.forwarder:</span>
                        <span class="s1">export_dict[</span><span class="s3">&quot;forwarder&quot;</span><span class="s1">] = export.forwarder</span>
                <span class="s1">dump_dict[</span><span class="s3">&quot;Exported symbols&quot;</span><span class="s1">].append(export_dict)</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_IMPORT&quot;</span><span class="s1">):</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;Imported symbols&quot;</span><span class="s1">] = []</span>
            <span class="s4">for </span><span class="s1">module </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_IMPORT:</span>
                <span class="s1">import_list = []</span>
                <span class="s1">dump_dict[</span><span class="s3">&quot;Imported symbols&quot;</span><span class="s1">].append(import_list)</span>
                <span class="s1">import_list.append(module.struct.dump_dict())</span>
                <span class="s4">for </span><span class="s1">symbol </span><span class="s4">in </span><span class="s1">module.imports:</span>
                    <span class="s1">symbol_dict = {}</span>
                    <span class="s4">if </span><span class="s1">symbol.import_by_ordinal </span><span class="s4">is True</span><span class="s1">:</span>
                        <span class="s1">symbol_dict[</span><span class="s3">&quot;DLL&quot;</span><span class="s1">] = module.dll</span>
                        <span class="s1">symbol_dict[</span><span class="s3">&quot;Ordinal&quot;</span><span class="s1">] = symbol.ordinal</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">symbol_dict[</span><span class="s3">&quot;DLL&quot;</span><span class="s1">] = module.dll</span>
                        <span class="s1">symbol_dict[</span><span class="s3">&quot;Name&quot;</span><span class="s1">] = symbol.name</span>
                        <span class="s1">symbol_dict[</span><span class="s3">&quot;Hint&quot;</span><span class="s1">] = symbol.hint</span>

                    <span class="s4">if </span><span class="s1">symbol.bound:</span>
                        <span class="s1">symbol_dict[</span><span class="s3">&quot;Bound&quot;</span><span class="s1">] = symbol.bound</span>
                    <span class="s1">import_list.append(symbol_dict)</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_BOUND_IMPORT&quot;</span><span class="s1">):</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;Bound imports&quot;</span><span class="s1">] = []</span>
            <span class="s4">for </span><span class="s1">bound_imp_desc </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_BOUND_IMPORT:</span>
                <span class="s1">bound_imp_desc_dict = {}</span>
                <span class="s1">dump_dict[</span><span class="s3">&quot;Bound imports&quot;</span><span class="s1">].append(bound_imp_desc_dict)</span>

                <span class="s1">bound_imp_desc_dict.update(bound_imp_desc.struct.dump_dict())</span>
                <span class="s1">bound_imp_desc_dict[</span><span class="s3">&quot;DLL&quot;</span><span class="s1">] = bound_imp_desc.name</span>

                <span class="s4">for </span><span class="s1">bound_imp_ref </span><span class="s4">in </span><span class="s1">bound_imp_desc.entries:</span>
                    <span class="s1">bound_imp_ref_dict = {}</span>
                    <span class="s1">bound_imp_ref_dict.update(bound_imp_ref.struct.dump_dict())</span>
                    <span class="s1">bound_imp_ref_dict[</span><span class="s3">&quot;DLL&quot;</span><span class="s1">] = bound_imp_ref.name</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_DELAY_IMPORT&quot;</span><span class="s1">):</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;Delay Imported symbols&quot;</span><span class="s1">] = []</span>
            <span class="s4">for </span><span class="s1">module </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_DELAY_IMPORT:</span>
                <span class="s1">module_list = []</span>
                <span class="s1">dump_dict[</span><span class="s3">&quot;Delay Imported symbols&quot;</span><span class="s1">].append(module_list)</span>
                <span class="s1">module_list.append(module.struct.dump_dict())</span>

                <span class="s4">for </span><span class="s1">symbol </span><span class="s4">in </span><span class="s1">module.imports:</span>
                    <span class="s1">symbol_dict = {}</span>
                    <span class="s4">if </span><span class="s1">symbol.import_by_ordinal </span><span class="s4">is True</span><span class="s1">:</span>
                        <span class="s1">symbol_dict[</span><span class="s3">&quot;DLL&quot;</span><span class="s1">] = module.dll</span>
                        <span class="s1">symbol_dict[</span><span class="s3">&quot;Ordinal&quot;</span><span class="s1">] = symbol.ordinal</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s1">symbol_dict[</span><span class="s3">&quot;DLL&quot;</span><span class="s1">] = module.dll</span>
                        <span class="s1">symbol_dict[</span><span class="s3">&quot;Name&quot;</span><span class="s1">] = symbol.name</span>
                        <span class="s1">symbol_dict[</span><span class="s3">&quot;Hint&quot;</span><span class="s1">] = symbol.hint</span>

                    <span class="s4">if </span><span class="s1">symbol.bound:</span>
                        <span class="s1">symbol_dict[</span><span class="s3">&quot;Bound&quot;</span><span class="s1">] = symbol.bound</span>
                    <span class="s1">module_list.append(symbol_dict)</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_RESOURCE&quot;</span><span class="s1">):</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;Resource directory&quot;</span><span class="s1">] = []</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;Resource directory&quot;</span><span class="s1">].append(</span>
                <span class="s1">self.DIRECTORY_ENTRY_RESOURCE.struct.dump_dict()</span>
            <span class="s1">)</span>

            <span class="s4">for </span><span class="s1">res_type </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_RESOURCE.entries:</span>
                <span class="s1">resource_type_dict = {}</span>

                <span class="s4">if </span><span class="s1">res_type.name </span><span class="s4">is not None</span><span class="s1">:</span>
                    <span class="s1">resource_type_dict[</span><span class="s3">&quot;Name&quot;</span><span class="s1">] = res_type.name</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">resource_type_dict[</span><span class="s3">&quot;Id&quot;</span><span class="s1">] = (</span>
                        <span class="s1">res_type.struct.Id</span><span class="s4">,</span>
                        <span class="s1">RESOURCE_TYPE.get(res_type.struct.Id</span><span class="s4">, </span><span class="s3">&quot;-&quot;</span><span class="s1">)</span><span class="s4">,</span>
                    <span class="s1">)</span>

                <span class="s1">resource_type_dict.update(res_type.struct.dump_dict())</span>
                <span class="s1">dump_dict[</span><span class="s3">&quot;Resource directory&quot;</span><span class="s1">].append(resource_type_dict)</span>

                <span class="s4">if </span><span class="s1">hasattr(res_type</span><span class="s4">, </span><span class="s3">&quot;directory&quot;</span><span class="s1">):</span>
                    <span class="s1">directory_list = []</span>
                    <span class="s1">directory_list.append(res_type.directory.struct.dump_dict())</span>
                    <span class="s1">dump_dict[</span><span class="s3">&quot;Resource directory&quot;</span><span class="s1">].append(directory_list)</span>

                    <span class="s4">for </span><span class="s1">resource_id </span><span class="s4">in </span><span class="s1">res_type.directory.entries:</span>
                        <span class="s1">resource_id_dict = {}</span>

                        <span class="s4">if </span><span class="s1">resource_id.name </span><span class="s4">is not None</span><span class="s1">:</span>
                            <span class="s1">resource_id_dict[</span><span class="s3">&quot;Name&quot;</span><span class="s1">] = resource_id.name</span>
                        <span class="s4">else</span><span class="s1">:</span>
                            <span class="s1">resource_id_dict[</span><span class="s3">&quot;Id&quot;</span><span class="s1">] = resource_id.struct.Id</span>

                        <span class="s1">resource_id_dict.update(resource_id.struct.dump_dict())</span>
                        <span class="s1">directory_list.append(resource_id_dict)</span>

                        <span class="s4">if </span><span class="s1">hasattr(resource_id</span><span class="s4">, </span><span class="s3">&quot;directory&quot;</span><span class="s1">):</span>
                            <span class="s1">resource_id_list = []</span>
                            <span class="s1">resource_id_list.append(</span>
                                <span class="s1">resource_id.directory.struct.dump_dict()</span>
                            <span class="s1">)</span>
                            <span class="s1">directory_list.append(resource_id_list)</span>

                            <span class="s4">for </span><span class="s1">resource_lang </span><span class="s4">in </span><span class="s1">resource_id.directory.entries:</span>
                                <span class="s4">if </span><span class="s1">hasattr(resource_lang</span><span class="s4">, </span><span class="s3">&quot;data&quot;</span><span class="s1">):</span>
                                    <span class="s1">resource_lang_dict = {}</span>
                                    <span class="s1">resource_lang_dict[</span><span class="s3">&quot;LANG&quot;</span><span class="s1">] = resource_lang.data.lang</span>
                                    <span class="s1">resource_lang_dict[</span>
                                        <span class="s3">&quot;SUBLANG&quot;</span>
                                    <span class="s1">] = resource_lang.data.sublang</span>
                                    <span class="s1">resource_lang_dict[</span><span class="s3">&quot;LANG_NAME&quot;</span><span class="s1">] = LANG.get(</span>
                                        <span class="s1">resource_lang.data.lang</span><span class="s4">, </span><span class="s3">&quot;*unknown*&quot;</span>
                                    <span class="s1">)</span>
                                    <span class="s1">resource_lang_dict[</span>
                                        <span class="s3">&quot;SUBLANG_NAME&quot;</span>
                                    <span class="s1">] = get_sublang_name_for_lang(</span>
                                        <span class="s1">resource_lang.data.lang</span><span class="s4">,</span>
                                        <span class="s1">resource_lang.data.sublang</span><span class="s4">,</span>
                                    <span class="s1">)</span>
                                    <span class="s1">resource_lang_dict.update(</span>
                                        <span class="s1">resource_lang.struct.dump_dict()</span>
                                    <span class="s1">)</span>
                                    <span class="s1">resource_lang_dict.update(</span>
                                        <span class="s1">resource_lang.data.struct.dump_dict()</span>
                                    <span class="s1">)</span>
                                    <span class="s1">resource_id_list.append(resource_lang_dict)</span>
                            <span class="s4">if </span><span class="s1">(</span>
                                <span class="s1">hasattr(resource_id.directory</span><span class="s4">, </span><span class="s3">&quot;strings&quot;</span><span class="s1">)</span>
                                <span class="s4">and </span><span class="s1">resource_id.directory.strings</span>
                            <span class="s1">):</span>
                                <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">res_string </span><span class="s4">in </span><span class="s1">list(</span>
                                    <span class="s1">resource_id.directory.strings.items()</span>
                                <span class="s1">):</span>
                                    <span class="s1">resource_id_list.append(</span>
                                        <span class="s1">res_string.encode(</span>
                                            <span class="s3">&quot;unicode-escape&quot;</span><span class="s4">, </span><span class="s3">&quot;backslashreplace&quot;</span>
                                        <span class="s1">).decode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>
                                    <span class="s1">)</span>

        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_TLS&quot;</span><span class="s1">)</span>
            <span class="s4">and </span><span class="s1">self.DIRECTORY_ENTRY_TLS</span>
            <span class="s4">and </span><span class="s1">self.DIRECTORY_ENTRY_TLS.struct</span>
        <span class="s1">):</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;TLS&quot;</span><span class="s1">] = self.DIRECTORY_ENTRY_TLS.struct.dump_dict()</span>

        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_LOAD_CONFIG&quot;</span><span class="s1">)</span>
            <span class="s4">and </span><span class="s1">self.DIRECTORY_ENTRY_LOAD_CONFIG</span>
            <span class="s4">and </span><span class="s1">self.DIRECTORY_ENTRY_LOAD_CONFIG.struct</span>
        <span class="s1">):</span>
            <span class="s1">dump_dict[</span>
                <span class="s3">&quot;LOAD_CONFIG&quot;</span>
            <span class="s1">] = self.DIRECTORY_ENTRY_LOAD_CONFIG.struct.dump_dict()</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_DEBUG&quot;</span><span class="s1">):</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;Debug information&quot;</span><span class="s1">] = []</span>
            <span class="s4">for </span><span class="s1">dbg </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_DEBUG:</span>
                <span class="s1">dbg_dict = {}</span>
                <span class="s1">dump_dict[</span><span class="s3">&quot;Debug information&quot;</span><span class="s1">].append(dbg_dict)</span>
                <span class="s1">dbg_dict.update(dbg.struct.dump_dict())</span>
                <span class="s1">dbg_dict[</span><span class="s3">&quot;Type&quot;</span><span class="s1">] = DEBUG_TYPE.get(dbg.struct.Type</span><span class="s4">, </span><span class="s1">dbg.struct.Type)</span>

        <span class="s4">if </span><span class="s1">self.has_relocs():</span>
            <span class="s1">dump_dict[</span><span class="s3">&quot;Base relocations&quot;</span><span class="s1">] = []</span>
            <span class="s4">for </span><span class="s1">base_reloc </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_BASERELOC:</span>
                <span class="s1">base_reloc_list = []</span>
                <span class="s1">dump_dict[</span><span class="s3">&quot;Base relocations&quot;</span><span class="s1">].append(base_reloc_list)</span>
                <span class="s1">base_reloc_list.append(base_reloc.struct.dump_dict())</span>
                <span class="s4">for </span><span class="s1">reloc </span><span class="s4">in </span><span class="s1">base_reloc.entries:</span>
                    <span class="s1">reloc_dict = {}</span>
                    <span class="s1">base_reloc_list.append(reloc_dict)</span>
                    <span class="s1">reloc_dict[</span><span class="s3">&quot;RVA&quot;</span><span class="s1">] = reloc.rva</span>
                    <span class="s4">try</span><span class="s1">:</span>
                        <span class="s1">reloc_dict[</span><span class="s3">&quot;Type&quot;</span><span class="s1">] = RELOCATION_TYPE[reloc.type][</span><span class="s5">16</span><span class="s1">:]</span>
                    <span class="s4">except </span><span class="s1">KeyError:</span>
                        <span class="s1">reloc_dict[</span><span class="s3">&quot;Type&quot;</span><span class="s1">] = reloc.type</span>

        <span class="s4">return </span><span class="s1">dump_dict</span>

    <span class="s0"># OC Patch</span>
    <span class="s4">def </span><span class="s1">get_physical_by_rva(self</span><span class="s4">, </span><span class="s1">rva):</span>
        <span class="s2">&quot;&quot;&quot;Gets the physical address in the PE file from an RVA value.&quot;&quot;&quot;</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self.get_offset_from_rva(rva)</span>
        <span class="s4">except </span><span class="s1">Exception:</span>
            <span class="s4">return None</span>

    <span class="s0">##</span>
    <span class="s0"># Double-Word get / set</span>
    <span class="s0">##</span>

    <span class="s4">def </span><span class="s1">get_data_from_dword(self</span><span class="s4">, </span><span class="s1">dword):</span>
        <span class="s2">&quot;&quot;&quot;Return a four byte string representing the double word value (little endian).&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">struct.pack(</span><span class="s3">&quot;&lt;L&quot;</span><span class="s4">, </span><span class="s1">dword &amp; </span><span class="s5">0xFFFFFFFF</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">get_dword_from_data(self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">offset):</span>
        <span class="s2">&quot;&quot;&quot;Convert four bytes of data to a double word (little endian) 
 
        'offset' is assumed to index into a dword array. So setting it to 
        N will return a dword out of the data starting at offset N*4. 
 
        Returns None if the data can't be turned into a double word. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">(offset + </span><span class="s5">1</span><span class="s1">) * </span><span class="s5">4 </span><span class="s1">&gt; len(data):</span>
            <span class="s4">return None</span>

        <span class="s4">return </span><span class="s1">struct.unpack(</span><span class="s3">&quot;&lt;I&quot;</span><span class="s4">, </span><span class="s1">data[offset * </span><span class="s5">4 </span><span class="s1">: (offset + </span><span class="s5">1</span><span class="s1">) * </span><span class="s5">4</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s4">def </span><span class="s1">get_dword_at_rva(self</span><span class="s4">, </span><span class="s1">rva):</span>
        <span class="s2">&quot;&quot;&quot;Return the double word value at the given RVA. 
 
        Returns None if the value can't be read, i.e. the RVA can't be mapped 
        to a file offset. 
        &quot;&quot;&quot;</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self.get_dword_from_data(self.get_data(rva</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">get_dword_from_offset(self</span><span class="s4">, </span><span class="s1">offset):</span>
        <span class="s2">&quot;&quot;&quot;Return the double word value at the given file offset. (little endian)&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">offset + </span><span class="s5">4 </span><span class="s1">&gt; len(self.__data__):</span>
            <span class="s4">return None</span>

        <span class="s4">return </span><span class="s1">self.get_dword_from_data(self.__data__[offset : offset + </span><span class="s5">4</span><span class="s1">]</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">set_dword_at_rva(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">dword):</span>
        <span class="s2">&quot;&quot;&quot;Set the double word value at the file offset corresponding to the given RVA.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.set_bytes_at_rva(rva</span><span class="s4">, </span><span class="s1">self.get_data_from_dword(dword))</span>

    <span class="s4">def </span><span class="s1">set_dword_at_offset(self</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">, </span><span class="s1">dword):</span>
        <span class="s2">&quot;&quot;&quot;Set the double word value at the given file offset.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.set_bytes_at_offset(offset</span><span class="s4">, </span><span class="s1">self.get_data_from_dword(dword))</span>

    <span class="s0">##</span>
    <span class="s0"># Word get / set</span>
    <span class="s0">##</span>

    <span class="s4">def </span><span class="s1">get_data_from_word(self</span><span class="s4">, </span><span class="s1">word):</span>
        <span class="s2">&quot;&quot;&quot;Return a two byte string representing the word value. (little endian).&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">struct.pack(</span><span class="s3">&quot;&lt;H&quot;</span><span class="s4">, </span><span class="s1">word)</span>

    <span class="s4">def </span><span class="s1">get_word_from_data(self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">offset):</span>
        <span class="s2">&quot;&quot;&quot;Convert two bytes of data to a word (little endian) 
 
        'offset' is assumed to index into a word array. So setting it to 
        N will return a dword out of the data starting at offset N*2. 
 
        Returns None if the data can't be turned into a word. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">(offset + </span><span class="s5">1</span><span class="s1">) * </span><span class="s5">2 </span><span class="s1">&gt; len(data):</span>
            <span class="s4">return None</span>

        <span class="s4">return </span><span class="s1">struct.unpack(</span><span class="s3">&quot;&lt;H&quot;</span><span class="s4">, </span><span class="s1">data[offset * </span><span class="s5">2 </span><span class="s1">: (offset + </span><span class="s5">1</span><span class="s1">) * </span><span class="s5">2</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s4">def </span><span class="s1">get_word_at_rva(self</span><span class="s4">, </span><span class="s1">rva):</span>
        <span class="s2">&quot;&quot;&quot;Return the word value at the given RVA. 
 
        Returns None if the value can't be read, i.e. the RVA can't be mapped 
        to a file offset. 
        &quot;&quot;&quot;</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self.get_word_from_data(self.get_data(rva)[:</span><span class="s5">2</span><span class="s1">]</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">get_word_from_offset(self</span><span class="s4">, </span><span class="s1">offset):</span>
        <span class="s2">&quot;&quot;&quot;Return the word value at the given file offset. (little endian)&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">offset + </span><span class="s5">2 </span><span class="s1">&gt; len(self.__data__):</span>
            <span class="s4">return None</span>

        <span class="s4">return </span><span class="s1">self.get_word_from_data(self.__data__[offset : offset + </span><span class="s5">2</span><span class="s1">]</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">set_word_at_rva(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">word):</span>
        <span class="s2">&quot;&quot;&quot;Set the word value at the file offset corresponding to the given RVA.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.set_bytes_at_rva(rva</span><span class="s4">, </span><span class="s1">self.get_data_from_word(word))</span>

    <span class="s4">def </span><span class="s1">set_word_at_offset(self</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">, </span><span class="s1">word):</span>
        <span class="s2">&quot;&quot;&quot;Set the word value at the given file offset.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.set_bytes_at_offset(offset</span><span class="s4">, </span><span class="s1">self.get_data_from_word(word))</span>

    <span class="s0">##</span>
    <span class="s0"># Quad-Word get / set</span>
    <span class="s0">##</span>

    <span class="s4">def </span><span class="s1">get_data_from_qword(self</span><span class="s4">, </span><span class="s1">word):</span>
        <span class="s2">&quot;&quot;&quot;Return an eight byte string representing the quad-word value (little endian).&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">struct.pack(</span><span class="s3">&quot;&lt;Q&quot;</span><span class="s4">, </span><span class="s1">word)</span>

    <span class="s4">def </span><span class="s1">get_qword_from_data(self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">offset):</span>
        <span class="s2">&quot;&quot;&quot;Convert eight bytes of data to a word (little endian) 
 
        'offset' is assumed to index into a word array. So setting it to 
        N will return a dword out of the data starting at offset N*8. 
 
        Returns None if the data can't be turned into a quad word. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">(offset + </span><span class="s5">1</span><span class="s1">) * </span><span class="s5">8 </span><span class="s1">&gt; len(data):</span>
            <span class="s4">return None</span>

        <span class="s4">return </span><span class="s1">struct.unpack(</span><span class="s3">&quot;&lt;Q&quot;</span><span class="s4">, </span><span class="s1">data[offset * </span><span class="s5">8 </span><span class="s1">: (offset + </span><span class="s5">1</span><span class="s1">) * </span><span class="s5">8</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s4">def </span><span class="s1">get_qword_at_rva(self</span><span class="s4">, </span><span class="s1">rva):</span>
        <span class="s2">&quot;&quot;&quot;Return the quad-word value at the given RVA. 
 
        Returns None if the value can't be read, i.e. the RVA can't be mapped 
        to a file offset. 
        &quot;&quot;&quot;</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self.get_qword_from_data(self.get_data(rva)[:</span><span class="s5">8</span><span class="s1">]</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s4">except </span><span class="s1">PEFormatError:</span>
            <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">get_qword_from_offset(self</span><span class="s4">, </span><span class="s1">offset):</span>
        <span class="s2">&quot;&quot;&quot;Return the quad-word value at the given file offset. (little endian)&quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">offset + </span><span class="s5">8 </span><span class="s1">&gt; len(self.__data__):</span>
            <span class="s4">return None</span>

        <span class="s4">return </span><span class="s1">self.get_qword_from_data(self.__data__[offset : offset + </span><span class="s5">8</span><span class="s1">]</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">set_qword_at_rva(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">qword):</span>
        <span class="s2">&quot;&quot;&quot;Set the quad-word value at the file offset corresponding to the given RVA.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.set_bytes_at_rva(rva</span><span class="s4">, </span><span class="s1">self.get_data_from_qword(qword))</span>

    <span class="s4">def </span><span class="s1">set_qword_at_offset(self</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">, </span><span class="s1">qword):</span>
        <span class="s2">&quot;&quot;&quot;Set the quad-word value at the given file offset.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.set_bytes_at_offset(offset</span><span class="s4">, </span><span class="s1">self.get_data_from_qword(qword))</span>

    <span class="s0">##</span>
    <span class="s0"># Set bytes</span>
    <span class="s0">##</span>

    <span class="s4">def </span><span class="s1">set_bytes_at_rva(self</span><span class="s4">, </span><span class="s1">rva</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s2">&quot;&quot;&quot;Overwrite, with the given string, the bytes at the file offset corresponding 
        to the given RVA. 
 
        Return True if successful, False otherwise. It can fail if the 
        offset is outside the file's boundaries. 
        &quot;&quot;&quot;</span>

        <span class="s4">if not </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">bytes):</span>
            <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;data should be of type: bytes&quot;</span><span class="s1">)</span>

        <span class="s1">offset = self.get_physical_by_rva(rva)</span>
        <span class="s4">if not </span><span class="s1">offset:</span>
            <span class="s4">return False</span>

        <span class="s4">return </span><span class="s1">self.set_bytes_at_offset(offset</span><span class="s4">, </span><span class="s1">data)</span>

    <span class="s4">def </span><span class="s1">set_bytes_at_offset(self</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">, </span><span class="s1">data):</span>
        <span class="s2">&quot;&quot;&quot;Overwrite the bytes at the given file offset with the given string. 
 
        Return True if successful, False otherwise. It can fail if the 
        offset is outside the file's boundaries. 
        &quot;&quot;&quot;</span>

        <span class="s4">if not </span><span class="s1">isinstance(data</span><span class="s4">, </span><span class="s1">bytes):</span>
            <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;data should be of type: bytes&quot;</span><span class="s1">)</span>

        <span class="s4">if </span><span class="s5">0 </span><span class="s1">&lt;= offset &lt; len(self.__data__):</span>
            <span class="s1">self.set_data_bytes(offset</span><span class="s4">, </span><span class="s1">data)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">return False</span>

        <span class="s4">return True</span>

    <span class="s4">def </span><span class="s1">set_data_bytes(self</span><span class="s4">, </span><span class="s1">offset: int</span><span class="s4">, </span><span class="s1">data: bytes):</span>
        <span class="s4">if not </span><span class="s1">isinstance(self.__data__</span><span class="s4">, </span><span class="s1">bytearray):</span>
            <span class="s1">self.__data__ = bytearray(self.__data__)</span>

        <span class="s1">self.__data__[offset : offset + len(data)] = data</span>

    <span class="s4">def </span><span class="s1">merge_modified_section_data(self):</span>
        <span class="s2">&quot;&quot;&quot;Update the PE image content with any individual section data that has been 
        modified. 
        &quot;&quot;&quot;</span>

        <span class="s4">for </span><span class="s1">section </span><span class="s4">in </span><span class="s1">self.sections:</span>
            <span class="s1">section_data_start = self.adjust_FileAlignment(</span>
                <span class="s1">section.PointerToRawData</span><span class="s4">, </span><span class="s1">self.OPTIONAL_HEADER.FileAlignment</span>
            <span class="s1">)</span>
            <span class="s1">section_data_end = section_data_start + section.SizeOfRawData</span>
            <span class="s4">if </span><span class="s1">section_data_start &lt; len(self.__data__) </span><span class="s4">and </span><span class="s1">section_data_end &lt; len(</span>
                <span class="s1">self.__data__</span>
            <span class="s1">):</span>
                <span class="s1">self.set_data_bytes(section_data_start</span><span class="s4">, </span><span class="s1">section.get_data())</span>

    <span class="s4">def </span><span class="s1">relocate_image(self</span><span class="s4">, </span><span class="s1">new_ImageBase):</span>
        <span class="s2">&quot;&quot;&quot;Apply the relocation information to the image using the provided image base. 
 
        This method will apply the relocation information to the image. Given the new 
        base, all the relocations will be processed and both the raw data and the 
        section's data will be fixed accordingly. 
        The resulting image can be retrieved as well through the method: 
 
            get_memory_mapped_image() 
 
        In order to get something that would more closely match what could be found in 
        memory once the Windows loader finished its work. 
        &quot;&quot;&quot;</span>

        <span class="s1">relocation_difference = new_ImageBase - self.OPTIONAL_HEADER.ImageBase</span>

        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">len(self.OPTIONAL_HEADER.DATA_DIRECTORY) &gt;= </span><span class="s5">6</span>
            <span class="s4">and </span><span class="s1">self.OPTIONAL_HEADER.DATA_DIRECTORY[</span><span class="s5">5</span><span class="s1">].Size</span>
        <span class="s1">):</span>
            <span class="s4">if not </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_BASERELOC&quot;</span><span class="s1">):</span>
                <span class="s1">self.parse_data_directories(</span>
                    <span class="s1">directories=[DIRECTORY_ENTRY[</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_BASERELOC&quot;</span><span class="s1">]]</span>
                <span class="s1">)</span>
            <span class="s4">if not </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_BASERELOC&quot;</span><span class="s1">):</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;Relocating image but PE does not have (or pefile cannot &quot;</span>
                    <span class="s3">&quot;parse) a DIRECTORY_ENTRY_BASERELOC&quot;</span>
                <span class="s1">)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">for </span><span class="s1">reloc </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_BASERELOC:</span>

                    <span class="s0"># We iterate with an index because if the relocation is of type</span>
                    <span class="s0"># IMAGE_REL_BASED_HIGHADJ we need to also process the next entry</span>
                    <span class="s0"># at once and skip it for the next iteration</span>
                    <span class="s0">#</span>
                    <span class="s1">entry_idx = </span><span class="s5">0</span>
                    <span class="s4">while </span><span class="s1">entry_idx &lt; len(reloc.entries):</span>

                        <span class="s1">entry = reloc.entries[entry_idx]</span>
                        <span class="s1">entry_idx += </span><span class="s5">1</span>

                        <span class="s4">if </span><span class="s1">entry.type == RELOCATION_TYPE[</span><span class="s3">&quot;IMAGE_REL_BASED_ABSOLUTE&quot;</span><span class="s1">]:</span>
                            <span class="s0"># Nothing to do for this type of relocation</span>
                            <span class="s4">pass</span>

                        <span class="s4">elif </span><span class="s1">entry.type == RELOCATION_TYPE[</span><span class="s3">&quot;IMAGE_REL_BASED_HIGH&quot;</span><span class="s1">]:</span>
                            <span class="s0"># Fix the high 16-bits of a relocation</span>
                            <span class="s0">#</span>
                            <span class="s0"># Add high 16-bits of relocation_difference to the</span>
                            <span class="s0"># 16-bit value at RVA=entry.rva</span>

                            <span class="s1">self.set_word_at_rva(</span>
                                <span class="s1">entry.rva</span><span class="s4">,</span>
                                <span class="s1">(</span>
                                    <span class="s1">self.get_word_at_rva(entry.rva)</span>
                                    <span class="s1">+ relocation_difference</span>
                                    <span class="s1">&gt;&gt; </span><span class="s5">16</span>
                                <span class="s1">)</span>
                                <span class="s1">&amp; </span><span class="s5">0xFFFF</span><span class="s4">,</span>
                            <span class="s1">)</span>

                        <span class="s4">elif </span><span class="s1">entry.type == RELOCATION_TYPE[</span><span class="s3">&quot;IMAGE_REL_BASED_LOW&quot;</span><span class="s1">]:</span>
                            <span class="s0"># Fix the low 16-bits of a relocation</span>
                            <span class="s0">#</span>
                            <span class="s0"># Add low 16 bits of relocation_difference to the 16-bit</span>
                            <span class="s0"># value at RVA=entry.rva</span>

                            <span class="s1">self.set_word_at_rva(</span>
                                <span class="s1">entry.rva</span><span class="s4">,</span>
                                <span class="s1">(</span>
                                    <span class="s1">self.get_word_at_rva(entry.rva)</span>
                                    <span class="s1">+ relocation_difference</span>
                                <span class="s1">)</span>
                                <span class="s1">&amp; </span><span class="s5">0xFFFF</span><span class="s4">,</span>
                            <span class="s1">)</span>

                        <span class="s4">elif </span><span class="s1">entry.type == RELOCATION_TYPE[</span><span class="s3">&quot;IMAGE_REL_BASED_HIGHLOW&quot;</span><span class="s1">]:</span>
                            <span class="s0"># Handle all high and low parts of a 32-bit relocation</span>
                            <span class="s0">#</span>
                            <span class="s0"># Add relocation_difference to the value at RVA=entry.rva</span>

                            <span class="s1">self.set_dword_at_rva(</span>
                                <span class="s1">entry.rva</span><span class="s4">,</span>
                                <span class="s1">self.get_dword_at_rva(entry.rva)</span>
                                <span class="s1">+ relocation_difference</span><span class="s4">,</span>
                            <span class="s1">)</span>

                        <span class="s4">elif </span><span class="s1">entry.type == RELOCATION_TYPE[</span><span class="s3">&quot;IMAGE_REL_BASED_HIGHADJ&quot;</span><span class="s1">]:</span>
                            <span class="s0"># Fix the high 16-bits of a relocation and adjust</span>
                            <span class="s0">#</span>
                            <span class="s0"># Add high 16-bits of relocation_difference to the 32-bit</span>
                            <span class="s0"># value composed from the (16-bit value at</span>
                            <span class="s0"># RVA=entry.rva)&lt;&lt;16 plus the 16-bit value at the next</span>
                            <span class="s0"># relocation entry.</span>

                            <span class="s0"># If the next entry is beyond the array's limits,</span>
                            <span class="s0"># abort... the table is corrupt</span>
                            <span class="s4">if </span><span class="s1">entry_idx == len(reloc.entries):</span>
                                <span class="s4">break</span>

                            <span class="s1">next_entry = reloc.entries[entry_idx]</span>
                            <span class="s1">entry_idx += </span><span class="s5">1</span>
                            <span class="s1">self.set_word_at_rva(</span>
                                <span class="s1">entry.rva</span><span class="s4">,</span>
                                <span class="s1">(</span>
                                    <span class="s1">(self.get_word_at_rva(entry.rva) &lt;&lt; </span><span class="s5">16</span><span class="s1">)</span>
                                    <span class="s1">+ next_entry.rva</span>
                                    <span class="s1">+ relocation_difference</span>
                                    <span class="s1">&amp; </span><span class="s5">0xFFFF0000</span>
                                <span class="s1">)</span>
                                <span class="s1">&gt;&gt; </span><span class="s5">16</span><span class="s4">,</span>
                            <span class="s1">)</span>

                        <span class="s4">elif </span><span class="s1">entry.type == RELOCATION_TYPE[</span><span class="s3">&quot;IMAGE_REL_BASED_DIR64&quot;</span><span class="s1">]:</span>
                            <span class="s0"># Apply the difference to the 64-bit value at the offset</span>
                            <span class="s0"># RVA=entry.rva</span>

                            <span class="s1">self.set_qword_at_rva(</span>
                                <span class="s1">entry.rva</span><span class="s4">,</span>
                                <span class="s1">self.get_qword_at_rva(entry.rva)</span>
                                <span class="s1">+ relocation_difference</span><span class="s4">,</span>
                            <span class="s1">)</span>

            <span class="s1">self.OPTIONAL_HEADER.ImageBase = new_ImageBase</span>

            <span class="s0"># correct VAs(virtual addresses) occurrences in directory information</span>
            <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_IMPORT&quot;</span><span class="s1">):</span>
                <span class="s4">for </span><span class="s1">dll </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_IMPORT:</span>
                    <span class="s4">for </span><span class="s1">func </span><span class="s4">in </span><span class="s1">dll.imports:</span>
                        <span class="s1">func.address += relocation_difference</span>
            <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_TLS&quot;</span><span class="s1">):</span>
                <span class="s1">self.DIRECTORY_ENTRY_TLS.struct.StartAddressOfRawData += (</span>
                    <span class="s1">relocation_difference</span>
                <span class="s1">)</span>
                <span class="s1">self.DIRECTORY_ENTRY_TLS.struct.EndAddressOfRawData += (</span>
                    <span class="s1">relocation_difference</span>
                <span class="s1">)</span>
                <span class="s1">self.DIRECTORY_ENTRY_TLS.struct.AddressOfIndex += relocation_difference</span>
                <span class="s1">self.DIRECTORY_ENTRY_TLS.struct.AddressOfCallBacks += (</span>
                    <span class="s1">relocation_difference</span>
                <span class="s1">)</span>
            <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_LOAD_CONFIG&quot;</span><span class="s1">):</span>
                <span class="s1">load_config = self.DIRECTORY_ENTRY_LOAD_CONFIG.struct</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;LockPrefixTable&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.LockPrefixTable</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.LockPrefixTable += relocation_difference</span>
                <span class="s4">if </span><span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;EditList&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">load_config.EditList:</span>
                    <span class="s1">load_config.EditList += relocation_difference</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;SecurityCookie&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.SecurityCookie</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.SecurityCookie += relocation_difference</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;SEHandlerTable&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.SEHandlerTable</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.SEHandlerTable += relocation_difference</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;GuardCFCheckFunctionPointer&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.GuardCFCheckFunctionPointer</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.GuardCFCheckFunctionPointer += relocation_difference</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;GuardCFDispatchFunctionPointer&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.GuardCFDispatchFunctionPointer</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.GuardCFDispatchFunctionPointer += relocation_difference</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;GuardCFFunctionTable&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.GuardCFFunctionTable</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.GuardCFFunctionTable += relocation_difference</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;GuardAddressTakenIatEntryTable&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.GuardAddressTakenIatEntryTable</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.GuardAddressTakenIatEntryTable += relocation_difference</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;GuardLongJumpTargetTable&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.GuardLongJumpTargetTable</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.GuardLongJumpTargetTable += relocation_difference</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;DynamicValueRelocTable&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.DynamicValueRelocTable</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.DynamicValueRelocTable += relocation_difference</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE_PLUS</span>
                    <span class="s4">and </span><span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;CHPEMetadataPointer&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.CHPEMetadataPointer</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.CHPEMetadataPointer += relocation_difference</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;GuardRFFailureRoutine&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.GuardRFFailureRoutine</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.GuardRFFailureRoutine += relocation_difference</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;GuardRFFailureRoutineFunctionPointer&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.GuardRFFailureRoutineFunctionPointer</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.GuardRFVerifyStackPointerFunctionPointer += (</span>
                        <span class="s1">relocation_difference</span>
                    <span class="s1">)</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;GuardRFVerifyStackPointerFunctionPointer&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.GuardRFVerifyStackPointerFunctionPointer</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.GuardRFVerifyStackPointerFunctionPointer += (</span>
                        <span class="s1">relocation_difference</span>
                    <span class="s1">)</span>
                <span class="s4">if </span><span class="s1">(</span>
                    <span class="s1">hasattr(load_config</span><span class="s4">, </span><span class="s3">&quot;EnclaveConfigurationPointer&quot;</span><span class="s1">)</span>
                    <span class="s4">and </span><span class="s1">load_config.EnclaveConfigurationPointer</span>
                <span class="s1">):</span>
                    <span class="s1">load_config.EnclaveConfigurationPointer += relocation_difference</span>

    <span class="s4">def </span><span class="s1">verify_checksum(self):</span>

        <span class="s4">return </span><span class="s1">self.OPTIONAL_HEADER.CheckSum == self.generate_checksum()</span>

    <span class="s4">def </span><span class="s1">generate_checksum(self):</span>
        <span class="s0"># This will make sure that the data representing the PE image</span>
        <span class="s0"># is updated with any changes that might have been made by</span>
        <span class="s0"># assigning values to header fields as those are not automatically</span>
        <span class="s0"># updated upon assignment.</span>
        <span class="s0">#</span>
        <span class="s0"># data = self.write()</span>
        <span class="s0"># print('{0}'.format(len(data)))</span>
        <span class="s0"># for idx, b in enumerate(data):</span>
        <span class="s0">#     if b != ord(self.__data__[idx]) or (idx &gt; 1244440 and idx &lt; 1244460):</span>
        <span class="s0">#         print('Idx: {0} G {1:02x} {3} B {2:02x}'.format(</span>
        <span class="s0">#             idx, ord(self.__data__[idx]), b,</span>
        <span class="s0">#             self.__data__[idx], chr(b)))</span>
        <span class="s1">self.__data__ = self.write()</span>

        <span class="s0"># Get the offset to the CheckSum field in the OptionalHeader</span>
        <span class="s0"># (The offset is the same in PE32 and PE32+)</span>
        <span class="s1">checksum_offset = self.OPTIONAL_HEADER.get_file_offset() + </span><span class="s5">0x40  </span><span class="s0"># 64</span>

        <span class="s1">checksum = </span><span class="s5">0</span>
        <span class="s0"># Verify the data is dword-aligned. Add padding if needed</span>
        <span class="s0">#</span>
        <span class="s1">remainder = len(self.__data__) % </span><span class="s5">4</span>
        <span class="s1">data_len = len(self.__data__) + ((</span><span class="s5">4 </span><span class="s1">- remainder) * (remainder != </span><span class="s5">0</span><span class="s1">))</span>

        <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(int(data_len / </span><span class="s5">4</span><span class="s1">)):</span>
            <span class="s0"># Skip the checksum field</span>
            <span class="s4">if </span><span class="s1">i == int(checksum_offset / </span><span class="s5">4</span><span class="s1">):</span>
                <span class="s4">continue</span>
            <span class="s4">if </span><span class="s1">i + </span><span class="s5">1 </span><span class="s1">== (int(data_len / </span><span class="s5">4</span><span class="s1">)) </span><span class="s4">and </span><span class="s1">remainder:</span>
                <span class="s1">dword = struct.unpack(</span>
                    <span class="s3">&quot;I&quot;</span><span class="s4">, </span><span class="s1">self.__data__[i * </span><span class="s5">4 </span><span class="s1">:] + (</span><span class="s6">b&quot;</span><span class="s4">\0</span><span class="s6">&quot; </span><span class="s1">* (</span><span class="s5">4 </span><span class="s1">- remainder))</span>
                <span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">dword = struct.unpack(</span><span class="s3">&quot;I&quot;</span><span class="s4">, </span><span class="s1">self.__data__[i * </span><span class="s5">4 </span><span class="s1">: i * </span><span class="s5">4 </span><span class="s1">+ </span><span class="s5">4</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0"># Optimized the calculation (thanks to Emmanuel Bourg for pointing it out!)</span>
            <span class="s1">checksum += dword</span>
            <span class="s4">if </span><span class="s1">checksum &gt;= </span><span class="s5">2</span><span class="s1">**</span><span class="s5">32</span><span class="s1">:</span>
                <span class="s1">checksum = (checksum &amp; </span><span class="s5">0xFFFFFFFF</span><span class="s1">) + (checksum &gt;&gt; </span><span class="s5">32</span><span class="s1">)</span>

        <span class="s1">checksum = (checksum &amp; </span><span class="s5">0xFFFF</span><span class="s1">) + (checksum &gt;&gt; </span><span class="s5">16</span><span class="s1">)</span>
        <span class="s1">checksum = (checksum) + (checksum &gt;&gt; </span><span class="s5">16</span><span class="s1">)</span>
        <span class="s1">checksum = checksum &amp; </span><span class="s5">0xFFFF</span>

        <span class="s0"># The length is the one of the original data, not the padded one</span>
        <span class="s0">#</span>
        <span class="s4">return </span><span class="s1">checksum + len(self.__data__)</span>

    <span class="s4">def </span><span class="s1">is_exe(self):</span>
        <span class="s2">&quot;&quot;&quot;Check whether the file is a standard executable. 
 
        This will return true only if the file has the IMAGE_FILE_EXECUTABLE_IMAGE flag 
        set and the IMAGE_FILE_DLL not set and the file does not appear to be a driver 
        either. 
        &quot;&quot;&quot;</span>

        <span class="s1">EXE_flag = IMAGE_CHARACTERISTICS[</span><span class="s3">&quot;IMAGE_FILE_EXECUTABLE_IMAGE&quot;</span><span class="s1">]</span>

        <span class="s4">if </span><span class="s1">(</span>
            <span class="s1">(</span><span class="s4">not </span><span class="s1">self.is_dll())</span>
            <span class="s4">and </span><span class="s1">(</span><span class="s4">not </span><span class="s1">self.is_driver())</span>
            <span class="s4">and </span><span class="s1">(EXE_flag &amp; self.FILE_HEADER.Characteristics) == EXE_flag</span>
        <span class="s1">):</span>
            <span class="s4">return True</span>

        <span class="s4">return False</span>

    <span class="s4">def </span><span class="s1">is_dll(self):</span>
        <span class="s2">&quot;&quot;&quot;Check whether the file is a standard DLL. 
 
        This will return true only if the image has the IMAGE_FILE_DLL flag set. 
        &quot;&quot;&quot;</span>

        <span class="s1">DLL_flag = IMAGE_CHARACTERISTICS[</span><span class="s3">&quot;IMAGE_FILE_DLL&quot;</span><span class="s1">]</span>

        <span class="s4">if </span><span class="s1">(DLL_flag &amp; self.FILE_HEADER.Characteristics) == DLL_flag:</span>
            <span class="s4">return True</span>

        <span class="s4">return False</span>

    <span class="s4">def </span><span class="s1">is_driver(self):</span>
        <span class="s2">&quot;&quot;&quot;Check whether the file is a Windows driver. 
 
        This will return true only if there are reliable indicators of the image 
        being a driver. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Checking that the ImageBase field of the OptionalHeader is above or</span>
        <span class="s0"># equal to 0x80000000 (that is, whether it lies in the upper 2GB of</span>
        <span class="s0"># the address space, normally belonging to the kernel) is not a</span>
        <span class="s0"># reliable enough indicator.  For instance, PEs that play the invalid</span>
        <span class="s0"># ImageBase trick to get relocated could be incorrectly assumed to be</span>
        <span class="s0"># drivers.</span>

        <span class="s0"># This is not reliable either...</span>
        <span class="s0">#</span>
        <span class="s0"># if any((section.Characteristics &amp;</span>
        <span class="s0">#           SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_NOT_PAGED']) for</span>
        <span class="s0">#        section in self.sections ):</span>
        <span class="s0">#    return True</span>

        <span class="s0"># If the import directory was not parsed (fast_load = True); do it now.</span>
        <span class="s4">if not </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_IMPORT&quot;</span><span class="s1">):</span>
            <span class="s1">self.parse_data_directories(</span>
                <span class="s1">directories=[DIRECTORY_ENTRY[</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_IMPORT&quot;</span><span class="s1">]]</span>
            <span class="s1">)</span>

        <span class="s0"># If there's still no import directory (the PE doesn't have one or it's</span>
        <span class="s0"># malformed), give up.</span>
        <span class="s4">if not </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;DIRECTORY_ENTRY_IMPORT&quot;</span><span class="s1">):</span>
            <span class="s4">return False</span>

        <span class="s0"># self.DIRECTORY_ENTRY_IMPORT will now exist, although it may be empty.</span>
        <span class="s0"># If it imports from &quot;ntoskrnl.exe&quot; or other kernel components it should</span>
        <span class="s0"># be a driver</span>
        <span class="s0">#</span>
        <span class="s1">system_DLLs = set(</span>
            <span class="s1">(</span><span class="s6">b&quot;ntoskrnl.exe&quot;</span><span class="s4">, </span><span class="s6">b&quot;hal.dll&quot;</span><span class="s4">, </span><span class="s6">b&quot;ndis.sys&quot;</span><span class="s4">, </span><span class="s6">b&quot;bootvid.dll&quot;</span><span class="s4">, </span><span class="s6">b&quot;kdcom.dll&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s4">if </span><span class="s1">system_DLLs.intersection(</span>
            <span class="s1">[imp.dll.lower() </span><span class="s4">for </span><span class="s1">imp </span><span class="s4">in </span><span class="s1">self.DIRECTORY_ENTRY_IMPORT]</span>
        <span class="s1">):</span>
            <span class="s4">return True</span>

        <span class="s1">driver_like_section_names = set((</span><span class="s6">b&quot;page&quot;</span><span class="s4">, </span><span class="s6">b&quot;paged&quot;</span><span class="s1">))</span>
        <span class="s4">if </span><span class="s1">driver_like_section_names.intersection(</span>
            <span class="s1">[section.Name.lower().rstrip(</span><span class="s6">b&quot;</span><span class="s4">\x00</span><span class="s6">&quot;</span><span class="s1">) </span><span class="s4">for </span><span class="s1">section </span><span class="s4">in </span><span class="s1">self.sections]</span>
        <span class="s1">) </span><span class="s4">and </span><span class="s1">(</span>
            <span class="s1">self.OPTIONAL_HEADER.Subsystem</span>
            <span class="s4">in </span><span class="s1">(</span>
                <span class="s1">SUBSYSTEM_TYPE[</span><span class="s3">&quot;IMAGE_SUBSYSTEM_NATIVE&quot;</span><span class="s1">]</span><span class="s4">,</span>
                <span class="s1">SUBSYSTEM_TYPE[</span><span class="s3">&quot;IMAGE_SUBSYSTEM_NATIVE_WINDOWS&quot;</span><span class="s1">]</span><span class="s4">,</span>
            <span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s4">return True</span>

        <span class="s4">return False</span>

    <span class="s4">def </span><span class="s1">get_overlay_data_start_offset(self):</span>
        <span class="s2">&quot;&quot;&quot;Get the offset of data appended to the file and not contained within 
        the area described in the headers.&quot;&quot;&quot;</span>

        <span class="s1">largest_offset_and_size = (</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s4">def </span><span class="s1">update_if_sum_is_larger_and_within_file(</span>
            <span class="s1">offset_and_size</span><span class="s4">, </span><span class="s1">file_size=len(self.__data__)</span>
        <span class="s1">):</span>
            <span class="s4">if </span><span class="s1">sum(offset_and_size) &lt;= file_size </span><span class="s4">and </span><span class="s1">sum(offset_and_size) &gt; sum(</span>
                <span class="s1">largest_offset_and_size</span>
            <span class="s1">):</span>
                <span class="s4">return </span><span class="s1">offset_and_size</span>
            <span class="s4">return </span><span class="s1">largest_offset_and_size</span>

        <span class="s4">if </span><span class="s1">hasattr(self</span><span class="s4">, </span><span class="s3">&quot;OPTIONAL_HEADER&quot;</span><span class="s1">):</span>
            <span class="s1">largest_offset_and_size = update_if_sum_is_larger_and_within_file(</span>
                <span class="s1">(</span>
                    <span class="s1">self.OPTIONAL_HEADER.get_file_offset()</span><span class="s4">,</span>
                    <span class="s1">self.FILE_HEADER.SizeOfOptionalHeader</span><span class="s4">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s4">for </span><span class="s1">section </span><span class="s4">in </span><span class="s1">self.sections:</span>
            <span class="s1">largest_offset_and_size = update_if_sum_is_larger_and_within_file(</span>
                <span class="s1">(section.PointerToRawData</span><span class="s4">, </span><span class="s1">section.SizeOfRawData)</span>
            <span class="s1">)</span>

        <span class="s1">skip_directories = [DIRECTORY_ENTRY[</span><span class="s3">&quot;IMAGE_DIRECTORY_ENTRY_SECURITY&quot;</span><span class="s1">]]</span>

        <span class="s4">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">directory </span><span class="s4">in </span><span class="s1">enumerate(self.OPTIONAL_HEADER.DATA_DIRECTORY):</span>
            <span class="s4">if </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">skip_directories:</span>
                <span class="s4">continue</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">largest_offset_and_size = update_if_sum_is_larger_and_within_file(</span>
                    <span class="s1">(self.get_offset_from_rva(directory.VirtualAddress)</span><span class="s4">, </span><span class="s1">directory.Size)</span>
                <span class="s1">)</span>
            <span class="s0"># Ignore directories with RVA out of file</span>
            <span class="s4">except </span><span class="s1">PEFormatError:</span>
                <span class="s4">continue</span>

        <span class="s4">if </span><span class="s1">len(self.__data__) &gt; sum(largest_offset_and_size):</span>
            <span class="s4">return </span><span class="s1">sum(largest_offset_and_size)</span>

        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">get_overlay(self):</span>
        <span class="s2">&quot;&quot;&quot;Get the data appended to the file and not contained within the area described 
        in the headers.&quot;&quot;&quot;</span>

        <span class="s1">overlay_data_offset = self.get_overlay_data_start_offset()</span>

        <span class="s4">if </span><span class="s1">overlay_data_offset </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self.__data__[overlay_data_offset:]</span>

        <span class="s4">return None</span>

    <span class="s4">def </span><span class="s1">trim(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the just data defined by the PE headers, removing any overlaid data.&quot;&quot;&quot;</span>

        <span class="s1">overlay_data_offset = self.get_overlay_data_start_offset()</span>

        <span class="s4">if </span><span class="s1">overlay_data_offset </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">self.__data__[:overlay_data_offset]</span>

        <span class="s4">return </span><span class="s1">self.__data__[:]</span>

    <span class="s0"># According to http://corkami.blogspot.com/2010/01/parce-que-la-planche-aura-brule.html</span>
    <span class="s0"># if PointerToRawData is less that 0x200 it's rounded to zero. Loading the test file</span>
    <span class="s0"># in a debugger it's easy to verify that the PointerToRawData value of 1 is rounded</span>
    <span class="s0"># to zero. Hence we reproduce the behavior</span>
    <span class="s0">#</span>
    <span class="s0"># According to the document:</span>
    <span class="s0"># [ Microsoft Portable Executable and Common Object File Format Specification ]</span>
    <span class="s0"># &quot;The alignment factor (in bytes) that is used to align the raw data of sections in</span>
    <span class="s0">#  the image file. The value should be a power of 2 between 512 and 64 K, inclusive.</span>
    <span class="s0">#  The default is 512. If the SectionAlignment is less than the architecture's page</span>
    <span class="s0">#  size, then FileAlignment must match SectionAlignment.&quot;</span>
    <span class="s0">#</span>
    <span class="s0"># The following is a hard-coded constant if the Windows loader</span>
    <span class="s4">def </span><span class="s1">adjust_FileAlignment(self</span><span class="s4">, </span><span class="s1">val</span><span class="s4">, </span><span class="s1">file_alignment):</span>
        <span class="s4">if </span><span class="s1">file_alignment &gt; FILE_ALIGNMENT_HARDCODED_VALUE:</span>
            <span class="s0"># If it's not a power of two, report it:</span>
            <span class="s4">if </span><span class="s1">self.FileAlignment_Warning </span><span class="s4">is False and not </span><span class="s1">power_of_two(file_alignment):</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;If FileAlignment &gt; 0x200 it should be a power of 2. Value: %x&quot;</span>
                    <span class="s1">% (file_alignment)</span>
                <span class="s1">)</span>
                <span class="s1">self.FileAlignment_Warning = </span><span class="s4">True</span>

        <span class="s4">return </span><span class="s1">cache_adjust_FileAlignment(val</span><span class="s4">, </span><span class="s1">file_alignment)</span>

    <span class="s0"># According to the document:</span>
    <span class="s0"># [ Microsoft Portable Executable and Common Object File Format Specification ]</span>
    <span class="s0"># &quot;The alignment (in bytes) of sections when they are loaded into memory. It must be</span>
    <span class="s0">#  greater than or equal to FileAlignment. The default is the page size for the</span>
    <span class="s0">#  architecture.&quot;</span>
    <span class="s0">#</span>
    <span class="s4">def </span><span class="s1">adjust_SectionAlignment(self</span><span class="s4">, </span><span class="s1">val</span><span class="s4">, </span><span class="s1">section_alignment</span><span class="s4">, </span><span class="s1">file_alignment):</span>
        <span class="s4">if </span><span class="s1">file_alignment &lt; FILE_ALIGNMENT_HARDCODED_VALUE:</span>
            <span class="s4">if </span><span class="s1">(</span>
                <span class="s1">file_alignment != section_alignment</span>
                <span class="s4">and </span><span class="s1">self.SectionAlignment_Warning </span><span class="s4">is False</span>
            <span class="s1">):</span>
                <span class="s1">self.__warnings.append(</span>
                    <span class="s3">&quot;If FileAlignment(%x) &lt; 0x200 it should equal SectionAlignment(%x)&quot;</span>
                    <span class="s1">% (file_alignment</span><span class="s4">, </span><span class="s1">section_alignment)</span>
                <span class="s1">)</span>
                <span class="s1">self.SectionAlignment_Warning = </span><span class="s4">True</span>

        <span class="s4">return </span><span class="s1">cache_adjust_SectionAlignment(val</span><span class="s4">, </span><span class="s1">section_alignment</span><span class="s4">, </span><span class="s1">file_alignment)</span>


<span class="s4">def </span><span class="s1">main():</span>
    <span class="s4">import </span><span class="s1">sys</span>

    <span class="s1">usage = </span><span class="s3">&quot;&quot;&quot;</span><span class="s4">\ 
</span><span class="s3">pefile.py &lt;filename&gt; 
pefile.py exports &lt;filename&gt;&quot;&quot;&quot;</span>

    <span class="s4">if not </span><span class="s1">sys.argv[</span><span class="s5">1</span><span class="s1">:]:</span>
        <span class="s1">print(usage)</span>
    <span class="s4">elif </span><span class="s1">sys.argv[</span><span class="s5">1</span><span class="s1">] == </span><span class="s3">&quot;exports&quot;</span><span class="s1">:</span>
        <span class="s4">if not </span><span class="s1">sys.argv[</span><span class="s5">2</span><span class="s1">:]:</span>
            <span class="s1">sys.exit(</span><span class="s3">&quot;error: &lt;filename&gt; required&quot;</span><span class="s1">)</span>
        <span class="s1">pe = PE(sys.argv[</span><span class="s5">2</span><span class="s1">])</span>
        <span class="s4">for </span><span class="s1">exp </span><span class="s4">in </span><span class="s1">pe.DIRECTORY_ENTRY_EXPORT.symbols:</span>
            <span class="s1">print(</span>
                <span class="s1">hex(pe.OPTIONAL_HEADER.ImageBase + exp.address)</span><span class="s4">, </span><span class="s1">exp.name</span><span class="s4">, </span><span class="s1">exp.ordinal</span>
            <span class="s1">)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">print(PE(sys.argv[</span><span class="s5">1</span><span class="s1">]).dump_info())</span>


<span class="s4">if </span><span class="s1">__name__ == </span><span class="s3">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s1">main()</span>
</pre>
</body>
</html>