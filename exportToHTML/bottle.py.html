<html>
<head>
<title>bottle.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
bottle.py</font>
</center></td></tr></table>
<pre><span class="s0">#!C:\Users\Pe≈•a\PycharmProjects\BasicIncremental\venv\Scripts\python.exe</span>
<span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot; 
Bottle is a fast and simple micro-framework for small web applications. It 
offers request dispatching (Routes) with url parameter support, templates, 
a built-in HTTP Server and adapters for many third party WSGI/HTTP-server and 
template engines - all in a single file and with no dependencies other than the 
Python Standard Library. 
 
Homepage and documentation: http://bottlepy.org/ 
 
Copyright (c) 2016, Marcel Hellkamp. 
License: MIT (see LICENSE for details) 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">with_statement</span>

<span class="s1">__author__ = </span><span class="s4">'Marcel Hellkamp'</span>
<span class="s1">__version__ = </span><span class="s4">'0.12.25'</span>
<span class="s1">__license__ = </span><span class="s4">'MIT'</span>

<span class="s0"># The gevent server adapter needs to patch some modules before they are imported</span>
<span class="s0"># This is why we parse the commandline parameters here but handle them later</span>
<span class="s3">if </span><span class="s1">__name__ == </span><span class="s4">'__main__'</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">optparse </span><span class="s3">import </span><span class="s1">OptionParser</span>
    <span class="s1">_cmd_parser = OptionParser(usage=</span><span class="s4">&quot;usage: %prog [options] package.module:app&quot;</span><span class="s1">)</span>
    <span class="s1">_opt = _cmd_parser.add_option</span>
    <span class="s1">_opt(</span><span class="s4">&quot;--version&quot;</span><span class="s3">, </span><span class="s1">action=</span><span class="s4">&quot;store_true&quot;</span><span class="s3">, </span><span class="s1">help=</span><span class="s4">&quot;show version number.&quot;</span><span class="s1">)</span>
    <span class="s1">_opt(</span><span class="s4">&quot;-b&quot;</span><span class="s3">, </span><span class="s4">&quot;--bind&quot;</span><span class="s3">, </span><span class="s1">metavar=</span><span class="s4">&quot;ADDRESS&quot;</span><span class="s3">, </span><span class="s1">help=</span><span class="s4">&quot;bind socket to ADDRESS.&quot;</span><span class="s1">)</span>
    <span class="s1">_opt(</span><span class="s4">&quot;-s&quot;</span><span class="s3">, </span><span class="s4">&quot;--server&quot;</span><span class="s3">, </span><span class="s1">default=</span><span class="s4">'wsgiref'</span><span class="s3">, </span><span class="s1">help=</span><span class="s4">&quot;use SERVER as backend.&quot;</span><span class="s1">)</span>
    <span class="s1">_opt(</span><span class="s4">&quot;-p&quot;</span><span class="s3">, </span><span class="s4">&quot;--plugin&quot;</span><span class="s3">, </span><span class="s1">action=</span><span class="s4">&quot;append&quot;</span><span class="s3">, </span><span class="s1">help=</span><span class="s4">&quot;install additional plugin/s.&quot;</span><span class="s1">)</span>
    <span class="s1">_opt(</span><span class="s4">&quot;--debug&quot;</span><span class="s3">, </span><span class="s1">action=</span><span class="s4">&quot;store_true&quot;</span><span class="s3">, </span><span class="s1">help=</span><span class="s4">&quot;start server in debug mode.&quot;</span><span class="s1">)</span>
    <span class="s1">_opt(</span><span class="s4">&quot;--reload&quot;</span><span class="s3">, </span><span class="s1">action=</span><span class="s4">&quot;store_true&quot;</span><span class="s3">, </span><span class="s1">help=</span><span class="s4">&quot;auto-reload on file changes.&quot;</span><span class="s1">)</span>
    <span class="s1">_cmd_options</span><span class="s3">, </span><span class="s1">_cmd_args = _cmd_parser.parse_args()</span>
    <span class="s3">if </span><span class="s1">_cmd_options.server </span><span class="s3">and </span><span class="s1">_cmd_options.server.startswith(</span><span class="s4">'gevent'</span><span class="s1">):</span>
        <span class="s3">import </span><span class="s1">gevent.monkey; gevent.monkey.patch_all()</span>

<span class="s3">import </span><span class="s1">base64</span><span class="s3">, </span><span class="s1">cgi</span><span class="s3">, </span><span class="s1">email.utils</span><span class="s3">, </span><span class="s1">functools</span><span class="s3">, </span><span class="s1">hmac</span><span class="s3">, </span><span class="s1">itertools</span><span class="s3">, </span><span class="s1">mimetypes</span><span class="s3">,</span><span class="s1">\</span>
        <span class="s1">os</span><span class="s3">, </span><span class="s1">re</span><span class="s3">, </span><span class="s1">subprocess</span><span class="s3">, </span><span class="s1">sys</span><span class="s3">, </span><span class="s1">tempfile</span><span class="s3">, </span><span class="s1">threading</span><span class="s3">, </span><span class="s1">time</span><span class="s3">, </span><span class="s1">warnings</span><span class="s3">, </span><span class="s1">hashlib</span>

<span class="s3">from </span><span class="s1">datetime </span><span class="s3">import </span><span class="s1">date </span><span class="s3">as </span><span class="s1">datedate</span><span class="s3">, </span><span class="s1">datetime</span><span class="s3">, </span><span class="s1">timedelta</span>
<span class="s3">from </span><span class="s1">tempfile </span><span class="s3">import </span><span class="s1">TemporaryFile</span>
<span class="s3">from </span><span class="s1">traceback </span><span class="s3">import </span><span class="s1">format_exc</span><span class="s3">, </span><span class="s1">print_exc</span>
<span class="s3">from </span><span class="s1">unicodedata </span><span class="s3">import </span><span class="s1">normalize</span>


<span class="s3">try</span><span class="s1">: </span><span class="s3">from </span><span class="s1">simplejson </span><span class="s3">import </span><span class="s1">dumps </span><span class="s3">as </span><span class="s1">json_dumps</span><span class="s3">, </span><span class="s1">loads </span><span class="s3">as </span><span class="s1">json_lds</span>
<span class="s3">except </span><span class="s1">ImportError: </span><span class="s0"># pragma: no cover</span>
    <span class="s3">try</span><span class="s1">: </span><span class="s3">from </span><span class="s1">json </span><span class="s3">import </span><span class="s1">dumps </span><span class="s3">as </span><span class="s1">json_dumps</span><span class="s3">, </span><span class="s1">loads </span><span class="s3">as </span><span class="s1">json_lds</span>
    <span class="s3">except </span><span class="s1">ImportError:</span>
        <span class="s3">try</span><span class="s1">: </span><span class="s3">from </span><span class="s1">django.utils.simplejson </span><span class="s3">import </span><span class="s1">dumps </span><span class="s3">as </span><span class="s1">json_dumps</span><span class="s3">, </span><span class="s1">loads </span><span class="s3">as </span><span class="s1">json_lds</span>
        <span class="s3">except </span><span class="s1">ImportError:</span>
            <span class="s3">def </span><span class="s1">json_dumps(data):</span>
                <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s4">&quot;JSON support requires Python 2.6 or simplejson.&quot;</span><span class="s1">)</span>
            <span class="s1">json_lds = json_dumps</span>



<span class="s0"># We now try to fix 2.5/2.6/3.1/3.2 incompatibilities.</span>
<span class="s0"># It ain't pretty but it works... Sorry for the mess.</span>

<span class="s1">py   = sys.version_info</span>
<span class="s1">py3k = py &gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
<span class="s1">py25 = py &lt;  (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
<span class="s1">py31 = (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) &lt;= py &lt; (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

<span class="s0"># Workaround for the missing &quot;as&quot; keyword in py3k.</span>
<span class="s3">def </span><span class="s1">_e(): </span><span class="s3">return </span><span class="s1">sys.exc_info()[</span><span class="s5">1</span><span class="s1">]</span>

<span class="s0"># Workaround for the &quot;print is a keyword/function&quot; Python 2/3 dilemma</span>
<span class="s0"># and a fallback for mod_wsgi (resticts stdout/err attribute access)</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s1">_stdout</span><span class="s3">, </span><span class="s1">_stderr = sys.stdout.write</span><span class="s3">, </span><span class="s1">sys.stderr.write</span>
<span class="s3">except </span><span class="s1">IOError:</span>
    <span class="s1">_stdout = </span><span class="s3">lambda </span><span class="s1">x: sys.stdout.write(x)</span>
    <span class="s1">_stderr = </span><span class="s3">lambda </span><span class="s1">x: sys.stderr.write(x)</span>

<span class="s0"># Lots of stdlib and builtin differences.</span>
<span class="s3">if </span><span class="s1">py3k:</span>
    <span class="s3">import </span><span class="s1">http.client </span><span class="s3">as </span><span class="s1">httplib</span>
    <span class="s3">import </span><span class="s1">_thread </span><span class="s3">as </span><span class="s1">thread</span>
    <span class="s3">from </span><span class="s1">urllib.parse </span><span class="s3">import </span><span class="s1">urljoin</span><span class="s3">, </span><span class="s1">SplitResult </span><span class="s3">as </span><span class="s1">UrlSplitResult</span>
    <span class="s3">from </span><span class="s1">urllib.parse </span><span class="s3">import </span><span class="s1">urlencode</span><span class="s3">, </span><span class="s1">quote </span><span class="s3">as </span><span class="s1">urlquote</span><span class="s3">, </span><span class="s1">unquote </span><span class="s3">as </span><span class="s1">urlunquote</span>
    <span class="s1">urlunquote = functools.partial(urlunquote</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s4">'latin1'</span><span class="s1">)</span>
    <span class="s3">from </span><span class="s1">http.cookies </span><span class="s3">import </span><span class="s1">SimpleCookie</span>
    <span class="s3">if </span><span class="s1">py &gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">from </span><span class="s1">collections.abc </span><span class="s3">import </span><span class="s1">MutableMapping </span><span class="s3">as </span><span class="s1">DictMixin</span>
        <span class="s3">from </span><span class="s1">types </span><span class="s3">import </span><span class="s1">ModuleType </span><span class="s3">as </span><span class="s1">new_module</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">MutableMapping </span><span class="s3">as </span><span class="s1">DictMixin</span>
        <span class="s3">from </span><span class="s1">imp </span><span class="s3">import </span><span class="s1">new_module</span>
    <span class="s3">import </span><span class="s1">pickle</span>
    <span class="s3">from </span><span class="s1">io </span><span class="s3">import </span><span class="s1">BytesIO</span>
    <span class="s3">from </span><span class="s1">configparser </span><span class="s3">import </span><span class="s1">ConfigParser</span>
    <span class="s3">from </span><span class="s1">inspect </span><span class="s3">import </span><span class="s1">getfullargspec</span>
    <span class="s3">def </span><span class="s1">getargspec(func):</span>
        <span class="s1">spec = getfullargspec(func)</span>
        <span class="s1">kwargs = makelist(spec[</span><span class="s5">0</span><span class="s1">]) + makelist(spec.kwonlyargs)</span>
        <span class="s3">return </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">spec[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">spec[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">spec[</span><span class="s5">3</span><span class="s1">]</span>

    <span class="s1">basestring = str</span>
    <span class="s1">unicode = str</span>
    <span class="s1">json_loads = </span><span class="s3">lambda </span><span class="s1">s: json_lds(touni(s))</span>
    <span class="s1">callable = </span><span class="s3">lambda </span><span class="s1">x: hasattr(x</span><span class="s3">, </span><span class="s4">'__call__'</span><span class="s1">)</span>
    <span class="s1">imap = map</span>
    <span class="s3">def </span><span class="s1">_raise(*a): </span><span class="s3">raise </span><span class="s1">a[</span><span class="s5">0</span><span class="s1">](a[</span><span class="s5">1</span><span class="s1">]).with_traceback(a[</span><span class="s5">2</span><span class="s1">])</span>
<span class="s3">else</span><span class="s1">: </span><span class="s0"># 2.x</span>
    <span class="s3">import </span><span class="s1">httplib</span>
    <span class="s3">import </span><span class="s1">thread</span>
    <span class="s3">from </span><span class="s1">urlparse </span><span class="s3">import </span><span class="s1">urljoin</span><span class="s3">, </span><span class="s1">SplitResult </span><span class="s3">as </span><span class="s1">UrlSplitResult</span>
    <span class="s3">from </span><span class="s1">urllib </span><span class="s3">import </span><span class="s1">urlencode</span><span class="s3">, </span><span class="s1">quote </span><span class="s3">as </span><span class="s1">urlquote</span><span class="s3">, </span><span class="s1">unquote </span><span class="s3">as </span><span class="s1">urlunquote</span>
    <span class="s3">from </span><span class="s1">Cookie </span><span class="s3">import </span><span class="s1">SimpleCookie</span>
    <span class="s3">from </span><span class="s1">itertools </span><span class="s3">import </span><span class="s1">imap</span>
    <span class="s3">import </span><span class="s1">cPickle </span><span class="s3">as </span><span class="s1">pickle</span>
    <span class="s3">from </span><span class="s1">imp </span><span class="s3">import </span><span class="s1">new_module</span>
    <span class="s3">from </span><span class="s1">StringIO </span><span class="s3">import </span><span class="s1">StringIO </span><span class="s3">as </span><span class="s1">BytesIO</span>
    <span class="s3">from </span><span class="s1">ConfigParser </span><span class="s3">import </span><span class="s1">SafeConfigParser </span><span class="s3">as </span><span class="s1">ConfigParser</span>
    <span class="s3">from </span><span class="s1">inspect </span><span class="s3">import </span><span class="s1">getargspec</span>
    <span class="s3">if </span><span class="s1">py25:</span>
        <span class="s1">msg  = </span><span class="s4">&quot;Python 2.5 support may be dropped in future versions of Bottle.&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning)</span>
        <span class="s3">from </span><span class="s1">UserDict </span><span class="s3">import </span><span class="s1">DictMixin</span>
        <span class="s3">def </span><span class="s1">next(it): </span><span class="s3">return </span><span class="s1">it.next()</span>
        <span class="s1">bytes = str</span>
    <span class="s3">else</span><span class="s1">: </span><span class="s0"># 2.6, 2.7</span>
        <span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">MutableMapping </span><span class="s3">as </span><span class="s1">DictMixin</span>
    <span class="s1">unicode = unicode</span>
    <span class="s1">json_loads = json_lds</span>
    <span class="s1">eval(compile(</span><span class="s4">'def _raise(*a): raise a[0], a[1], a[2]'</span><span class="s3">, </span><span class="s4">'&lt;py3fix&gt;'</span><span class="s3">, </span><span class="s4">'exec'</span><span class="s1">))</span>

<span class="s0"># Some helpers for string/byte handling</span>
<span class="s3">def </span><span class="s1">tob(s</span><span class="s3">, </span><span class="s1">enc=</span><span class="s4">'utf8'</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">s.encode(enc) </span><span class="s3">if </span><span class="s1">isinstance(s</span><span class="s3">, </span><span class="s1">unicode) </span><span class="s3">else </span><span class="s1">bytes(s)</span>
<span class="s3">def </span><span class="s1">touni(s</span><span class="s3">, </span><span class="s1">enc=</span><span class="s4">'utf8'</span><span class="s3">, </span><span class="s1">err=</span><span class="s4">'strict'</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">s.decode(enc</span><span class="s3">, </span><span class="s1">err) </span><span class="s3">if </span><span class="s1">isinstance(s</span><span class="s3">, </span><span class="s1">bytes) </span><span class="s3">else </span><span class="s1">unicode(s)</span>
<span class="s1">tonat = touni </span><span class="s3">if </span><span class="s1">py3k </span><span class="s3">else </span><span class="s1">tob</span>

<span class="s0"># 3.2 fixes cgi.FieldStorage to accept bytes (which makes a lot of sense).</span>
<span class="s0"># 3.1 needs a workaround.</span>
<span class="s3">if </span><span class="s1">py31:</span>
    <span class="s3">from </span><span class="s1">io </span><span class="s3">import </span><span class="s1">TextIOWrapper</span>
    <span class="s3">class </span><span class="s1">NCTextIOWrapper(TextIOWrapper):</span>
        <span class="s3">def </span><span class="s1">close(self): </span><span class="s3">pass </span><span class="s0"># Keep wrapped buffer open.</span>


<span class="s0"># A bug in functools causes it to break if the wrapper is an instance method</span>
<span class="s3">def </span><span class="s1">update_wrapper(wrapper</span><span class="s3">, </span><span class="s1">wrapped</span><span class="s3">, </span><span class="s1">*a</span><span class="s3">, </span><span class="s1">**ka):</span>
    <span class="s3">try</span><span class="s1">: functools.update_wrapper(wrapper</span><span class="s3">, </span><span class="s1">wrapped</span><span class="s3">, </span><span class="s1">*a</span><span class="s3">, </span><span class="s1">**ka)</span>
    <span class="s3">except </span><span class="s1">AttributeError: </span><span class="s3">pass</span>



<span class="s0"># These helpers are used at module level and need to be defined first.</span>
<span class="s0"># And yes, I know PEP-8, but sometimes a lower-case classname makes more sense.</span>

<span class="s3">def </span><span class="s1">depr(message</span><span class="s3">, </span><span class="s1">hard=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s1">warnings.warn(message</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">makelist(data): </span><span class="s0"># This is just to handy</span>
    <span class="s3">if </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">dict)): </span><span class="s3">return </span><span class="s1">list(data)</span>
    <span class="s3">elif </span><span class="s1">data: </span><span class="s3">return </span><span class="s1">[data]</span>
    <span class="s3">else</span><span class="s1">: </span><span class="s3">return </span><span class="s1">[]</span>


<span class="s3">class </span><span class="s1">DictProperty(object):</span>
    <span class="s2">''' Property that maps to a key in a local dict-like attribute. '''</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">key=</span><span class="s3">None, </span><span class="s1">read_only=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">self.attr</span><span class="s3">, </span><span class="s1">self.key</span><span class="s3">, </span><span class="s1">self.read_only = attr</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">read_only</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">func):</span>
        <span class="s1">functools.update_wrapper(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">updated=[])</span>
        <span class="s1">self.getter</span><span class="s3">, </span><span class="s1">self.key = func</span><span class="s3">, </span><span class="s1">self.key </span><span class="s3">or </span><span class="s1">func.__name__</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__get__(self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">cls):</span>
        <span class="s3">if </span><span class="s1">obj </span><span class="s3">is None</span><span class="s1">: </span><span class="s3">return </span><span class="s1">self</span>
        <span class="s1">key</span><span class="s3">, </span><span class="s1">storage = self.key</span><span class="s3">, </span><span class="s1">getattr(obj</span><span class="s3">, </span><span class="s1">self.attr)</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">not in </span><span class="s1">storage: storage[key] = self.getter(obj)</span>
        <span class="s3">return </span><span class="s1">storage[key]</span>

    <span class="s3">def </span><span class="s1">__set__(self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">if </span><span class="s1">self.read_only: </span><span class="s3">raise </span><span class="s1">AttributeError(</span><span class="s4">&quot;Read-Only property.&quot;</span><span class="s1">)</span>
        <span class="s1">getattr(obj</span><span class="s3">, </span><span class="s1">self.attr)[self.key] = value</span>

    <span class="s3">def </span><span class="s1">__delete__(self</span><span class="s3">, </span><span class="s1">obj):</span>
        <span class="s3">if </span><span class="s1">self.read_only: </span><span class="s3">raise </span><span class="s1">AttributeError(</span><span class="s4">&quot;Read-Only property.&quot;</span><span class="s1">)</span>
        <span class="s3">del </span><span class="s1">getattr(obj</span><span class="s3">, </span><span class="s1">self.attr)[self.key]</span>


<span class="s3">class </span><span class="s1">cached_property(object):</span>
    <span class="s2">''' A property that is only computed once per instance and then replaces 
        itself with an ordinary attribute. Deleting the attribute resets the 
        property. '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">func):</span>
        <span class="s1">self.__doc__ = getattr(func</span><span class="s3">, </span><span class="s4">'__doc__'</span><span class="s1">)</span>
        <span class="s1">self.func = func</span>

    <span class="s3">def </span><span class="s1">__get__(self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">cls):</span>
        <span class="s3">if </span><span class="s1">obj </span><span class="s3">is None</span><span class="s1">: </span><span class="s3">return </span><span class="s1">self</span>
        <span class="s1">value = obj.__dict__[self.func.__name__] = self.func(obj)</span>
        <span class="s3">return </span><span class="s1">value</span>


<span class="s3">class </span><span class="s1">lazy_attribute(object):</span>
    <span class="s2">''' A property that caches itself to the class object. '''</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">func):</span>
        <span class="s1">functools.update_wrapper(self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">updated=[])</span>
        <span class="s1">self.getter = func</span>

    <span class="s3">def </span><span class="s1">__get__(self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">cls):</span>
        <span class="s1">value = self.getter(cls)</span>
        <span class="s1">setattr(cls</span><span class="s3">, </span><span class="s1">self.__name__</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s3">return </span><span class="s1">value</span>






<span class="s0">###############################################################################</span>
<span class="s0"># Exceptions and Events ########################################################</span>
<span class="s0">###############################################################################</span>


<span class="s3">class </span><span class="s1">BottleException(Exception):</span>
    <span class="s2">&quot;&quot;&quot; A base class for exceptions used by bottle. &quot;&quot;&quot;</span>
    <span class="s3">pass</span>






<span class="s0">###############################################################################</span>
<span class="s0"># Routing ######################################################################</span>
<span class="s0">###############################################################################</span>


<span class="s3">class </span><span class="s1">RouteError(BottleException):</span>
    <span class="s2">&quot;&quot;&quot; This is a base class for all routing related exceptions &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">RouteReset(BottleException):</span>
    <span class="s2">&quot;&quot;&quot; If raised by a plugin or request handler, the route is reset and all 
        plugins are re-applied. &quot;&quot;&quot;</span>

<span class="s3">class </span><span class="s1">RouterUnknownModeError(RouteError): </span><span class="s3">pass</span>


<span class="s3">class </span><span class="s1">RouteSyntaxError(RouteError):</span>
    <span class="s2">&quot;&quot;&quot; The route parser found something not supported by this router. &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">RouteBuildError(RouteError):</span>
    <span class="s2">&quot;&quot;&quot; The route could not be built. &quot;&quot;&quot;</span>


<span class="s3">def </span><span class="s1">_re_flatten(p):</span>
    <span class="s2">''' Turn all capturing groups in a regular expression pattern into 
        non-capturing groups. '''</span>
    <span class="s3">if </span><span class="s4">'(' </span><span class="s3">not in </span><span class="s1">p: </span><span class="s3">return </span><span class="s1">p</span>
    <span class="s3">return </span><span class="s1">re.sub(</span><span class="s4">r'(\\*)(\(\?P&lt;[^&gt;]+&gt;|\((?!\?))'</span><span class="s3">,</span>
        <span class="s3">lambda </span><span class="s1">m: m.group(</span><span class="s5">0</span><span class="s1">) </span><span class="s3">if </span><span class="s1">len(m.group(</span><span class="s5">1</span><span class="s1">)) % </span><span class="s5">2 </span><span class="s3">else </span><span class="s1">m.group(</span><span class="s5">1</span><span class="s1">) + </span><span class="s4">'(?:'</span><span class="s3">, </span><span class="s1">p)</span>


<span class="s3">class </span><span class="s1">Router(object):</span>
    <span class="s2">''' A Router is an ordered collection of route-&gt;target pairs. It is used to 
        efficiently match WSGI requests against a number of routes and return 
        the first target that satisfies the request. The target may be anything, 
        usually a string, ID or callable object. A route consists of a path-rule 
        and a HTTP method. 
 
        The path-rule is either a static path (e.g. `/contact`) or a dynamic 
        path that contains wildcards (e.g. `/wiki/&lt;page&gt;`). The wildcard syntax 
        and details on the matching order are described in docs:`routing`. 
    '''</span>

    <span class="s1">default_pattern = </span><span class="s4">'[^/]+'</span>
    <span class="s1">default_filter  = </span><span class="s4">'re'</span>

    <span class="s0">#: The current CPython regexp implementation does not allow more</span>
    <span class="s0">#: than 99 matching groups per regular expression.</span>
    <span class="s1">_MAX_GROUPS_PER_PATTERN = </span><span class="s5">99</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">self.rules    = [] </span><span class="s0"># All rules in order</span>
        <span class="s1">self._groups  = {} </span><span class="s0"># index of regexes to find them in dyna_routes</span>
        <span class="s1">self.builder  = {} </span><span class="s0"># Data structure for the url builder</span>
        <span class="s1">self.static   = {} </span><span class="s0"># Search structure for static routes</span>
        <span class="s1">self.dyna_routes   = {}</span>
        <span class="s1">self.dyna_regexes  = {} </span><span class="s0"># Search structure for dynamic routes</span>
        <span class="s0">#: If true, static routes are no longer checked first.</span>
        <span class="s1">self.strict_order = strict</span>
        <span class="s1">self.filters = {</span>
            <span class="s4">'re'</span><span class="s1">:    </span><span class="s3">lambda </span><span class="s1">conf:</span>
                <span class="s1">(_re_flatten(conf </span><span class="s3">or </span><span class="s1">self.default_pattern)</span><span class="s3">, None, None</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s4">'int'</span><span class="s1">:   </span><span class="s3">lambda </span><span class="s1">conf: (</span><span class="s4">r'-?\d+'</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, lambda </span><span class="s1">x: str(int(x)))</span><span class="s3">,</span>
            <span class="s4">'float'</span><span class="s1">: </span><span class="s3">lambda </span><span class="s1">conf: (</span><span class="s4">r'-?[\d.]+'</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, lambda </span><span class="s1">x: str(float(x)))</span><span class="s3">,</span>
            <span class="s4">'path'</span><span class="s1">:  </span><span class="s3">lambda </span><span class="s1">conf: (</span><span class="s4">r'.+?'</span><span class="s3">, None, None</span><span class="s1">)}</span>

    <span class="s3">def </span><span class="s1">add_filter(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">func):</span>
        <span class="s2">''' Add a filter. The provided function is called with the configuration 
        string as parameter and must return a (regexp, to_python, to_url) tuple. 
        The first element is a string, the last two are callables or None. '''</span>
        <span class="s1">self.filters[name] = func</span>

    <span class="s1">rule_syntax = re.compile(</span><span class="s4">'(</span><span class="s3">\\\\</span><span class="s4">*)'</span><span class="s1">\</span>
        <span class="s4">'(?:(?::([a-zA-Z_][a-zA-Z_0-9]*)?()(?:#(.*?)#)?)'</span><span class="s1">\</span>
          <span class="s4">'|(?:&lt;([a-zA-Z_][a-zA-Z_0-9]*)?(?::([a-zA-Z_]*)'</span><span class="s1">\</span>
            <span class="s4">'(?::((?:</span><span class="s3">\\\\</span><span class="s4">.|[^</span><span class="s3">\\\\</span><span class="s4">&gt;])+)?)?)?&gt;))'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_itertokens(self</span><span class="s3">, </span><span class="s1">rule):</span>
        <span class="s1">offset</span><span class="s3">, </span><span class="s1">prefix = </span><span class="s5">0</span><span class="s3">, </span><span class="s4">''</span>
        <span class="s3">for </span><span class="s1">match </span><span class="s3">in </span><span class="s1">self.rule_syntax.finditer(rule):</span>
            <span class="s1">prefix += rule[offset:match.start()]</span>
            <span class="s1">g = match.groups()</span>
            <span class="s3">if </span><span class="s1">len(g[</span><span class="s5">0</span><span class="s1">])%</span><span class="s5">2</span><span class="s1">: </span><span class="s0"># Escaped wildcard</span>
                <span class="s1">prefix += match.group(</span><span class="s5">0</span><span class="s1">)[len(g[</span><span class="s5">0</span><span class="s1">]):]</span>
                <span class="s1">offset = match.end()</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">prefix:</span>
                <span class="s3">yield </span><span class="s1">prefix</span><span class="s3">, None, None</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">filtr</span><span class="s3">, </span><span class="s1">conf = g[</span><span class="s5">4</span><span class="s1">:</span><span class="s5">7</span><span class="s1">] </span><span class="s3">if </span><span class="s1">g[</span><span class="s5">2</span><span class="s1">] </span><span class="s3">is None else </span><span class="s1">g[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">4</span><span class="s1">]</span>
            <span class="s3">yield </span><span class="s1">name</span><span class="s3">, </span><span class="s1">filtr </span><span class="s3">or </span><span class="s4">'default'</span><span class="s3">, </span><span class="s1">conf </span><span class="s3">or None</span>
            <span class="s1">offset</span><span class="s3">, </span><span class="s1">prefix = match.end()</span><span class="s3">, </span><span class="s4">''</span>
        <span class="s3">if </span><span class="s1">offset &lt;= len(rule) </span><span class="s3">or </span><span class="s1">prefix:</span>
            <span class="s3">yield </span><span class="s1">prefix+rule[offset:]</span><span class="s3">, None, None</span>

    <span class="s3">def </span><span class="s1">add(self</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">''' Add a new rule or replace the target for an existing rule. '''</span>
        <span class="s1">anons     = </span><span class="s5">0    </span><span class="s0"># Number of anonymous wildcards found</span>
        <span class="s1">keys      = []   </span><span class="s0"># Names of keys</span>
        <span class="s1">pattern   = </span><span class="s4">''   </span><span class="s0"># Regular expression pattern with named groups</span>
        <span class="s1">filters   = []   </span><span class="s0"># Lists of wildcard input filters</span>
        <span class="s1">builder   = []   </span><span class="s0"># Data structure for the URL builder</span>
        <span class="s1">is_static = </span><span class="s3">True</span>

        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">conf </span><span class="s3">in </span><span class="s1">self._itertokens(rule):</span>
            <span class="s3">if </span><span class="s1">mode:</span>
                <span class="s1">is_static = </span><span class="s3">False</span>
                <span class="s3">if </span><span class="s1">mode == </span><span class="s4">'default'</span><span class="s1">: mode = self.default_filter</span>
                <span class="s1">mask</span><span class="s3">, </span><span class="s1">in_filter</span><span class="s3">, </span><span class="s1">out_filter = self.filters[mode](conf)</span>
                <span class="s3">if not </span><span class="s1">key:</span>
                    <span class="s1">pattern += </span><span class="s4">'(?:%s)' </span><span class="s1">% mask</span>
                    <span class="s1">key = </span><span class="s4">'anon%d' </span><span class="s1">% anons</span>
                    <span class="s1">anons += </span><span class="s5">1</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">pattern += </span><span class="s4">'(?P&lt;%s&gt;%s)' </span><span class="s1">% (key</span><span class="s3">, </span><span class="s1">mask)</span>
                    <span class="s1">keys.append(key)</span>
                <span class="s3">if </span><span class="s1">in_filter: filters.append((key</span><span class="s3">, </span><span class="s1">in_filter))</span>
                <span class="s1">builder.append((key</span><span class="s3">, </span><span class="s1">out_filter </span><span class="s3">or </span><span class="s1">str))</span>
            <span class="s3">elif </span><span class="s1">key:</span>
                <span class="s1">pattern += re.escape(key)</span>
                <span class="s1">builder.append((</span><span class="s3">None, </span><span class="s1">key))</span>

        <span class="s1">self.builder[rule] = builder</span>
        <span class="s3">if </span><span class="s1">name: self.builder[name] = builder</span>

        <span class="s3">if </span><span class="s1">is_static </span><span class="s3">and not </span><span class="s1">self.strict_order:</span>
            <span class="s1">self.static.setdefault(method</span><span class="s3">, </span><span class="s1">{})</span>
            <span class="s1">self.static[method][self.build(rule)] = (target</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s3">return</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">re_pattern = re.compile(</span><span class="s4">'^(%s)$' </span><span class="s1">% pattern)</span>
            <span class="s1">re_match = re_pattern.match</span>
        <span class="s3">except </span><span class="s1">re.error:</span>
            <span class="s3">raise </span><span class="s1">RouteSyntaxError(</span><span class="s4">&quot;Could not add Route: %s (%s)&quot; </span><span class="s1">% (rule</span><span class="s3">, </span><span class="s1">_e()))</span>

        <span class="s3">if </span><span class="s1">filters:</span>
            <span class="s3">def </span><span class="s1">getargs(path):</span>
                <span class="s1">url_args = re_match(path).groupdict()</span>
                <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">wildcard_filter </span><span class="s3">in </span><span class="s1">filters:</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">url_args[name] = wildcard_filter(url_args[name])</span>
                    <span class="s3">except </span><span class="s1">ValueError:</span>
                        <span class="s3">raise </span><span class="s1">HTTPError(</span><span class="s5">400</span><span class="s3">, </span><span class="s4">'Path has wrong format.'</span><span class="s1">)</span>
                <span class="s3">return </span><span class="s1">url_args</span>
        <span class="s3">elif </span><span class="s1">re_pattern.groupindex:</span>
            <span class="s3">def </span><span class="s1">getargs(path):</span>
                <span class="s3">return </span><span class="s1">re_match(path).groupdict()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">getargs = </span><span class="s3">None</span>

        <span class="s1">flatpat = _re_flatten(pattern)</span>
        <span class="s1">whole_rule = (rule</span><span class="s3">, </span><span class="s1">flatpat</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">getargs)</span>

        <span class="s3">if </span><span class="s1">(flatpat</span><span class="s3">, </span><span class="s1">method) </span><span class="s3">in </span><span class="s1">self._groups:</span>
            <span class="s3">if </span><span class="s1">DEBUG:</span>
                <span class="s1">msg = </span><span class="s4">'Route &lt;%s %s&gt; overwrites a previously defined route'</span>
                <span class="s1">warnings.warn(msg % (method</span><span class="s3">, </span><span class="s1">rule)</span><span class="s3">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s1">self.dyna_routes[method][self._groups[flatpat</span><span class="s3">, </span><span class="s1">method]] = whole_rule</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.dyna_routes.setdefault(method</span><span class="s3">, </span><span class="s1">[]).append(whole_rule)</span>
            <span class="s1">self._groups[flatpat</span><span class="s3">, </span><span class="s1">method] = len(self.dyna_routes[method]) - </span><span class="s5">1</span>

        <span class="s1">self._compile(method)</span>

    <span class="s3">def </span><span class="s1">_compile(self</span><span class="s3">, </span><span class="s1">method):</span>
        <span class="s1">all_rules = self.dyna_routes[method]</span>
        <span class="s1">comborules = self.dyna_regexes[method] = []</span>
        <span class="s1">maxgroups = self._MAX_GROUPS_PER_PATTERN</span>
        <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">len(all_rules)</span><span class="s3">, </span><span class="s1">maxgroups):</span>
            <span class="s1">some = all_rules[x:x+maxgroups]</span>
            <span class="s1">combined = (flatpat </span><span class="s3">for </span><span class="s1">(_</span><span class="s3">, </span><span class="s1">flatpat</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_) </span><span class="s3">in </span><span class="s1">some)</span>
            <span class="s1">combined = </span><span class="s4">'|'</span><span class="s1">.join(</span><span class="s4">'(^%s$)' </span><span class="s1">% flatpat </span><span class="s3">for </span><span class="s1">flatpat </span><span class="s3">in </span><span class="s1">combined)</span>
            <span class="s1">combined = re.compile(combined).match</span>
            <span class="s1">rules = [(target</span><span class="s3">, </span><span class="s1">getargs) </span><span class="s3">for </span><span class="s1">(_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">getargs) </span><span class="s3">in </span><span class="s1">some]</span>
            <span class="s1">comborules.append((combined</span><span class="s3">, </span><span class="s1">rules))</span>

    <span class="s3">def </span><span class="s1">build(self</span><span class="s3">, </span><span class="s1">_name</span><span class="s3">, </span><span class="s1">*anons</span><span class="s3">, </span><span class="s1">**query):</span>
        <span class="s2">''' Build an URL by filling the wildcards in a rule. '''</span>
        <span class="s1">builder = self.builder.get(_name)</span>
        <span class="s3">if not </span><span class="s1">builder: </span><span class="s3">raise </span><span class="s1">RouteBuildError(</span><span class="s4">&quot;No route with that name.&quot;</span><span class="s3">, </span><span class="s1">_name)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">enumerate(anons): query[</span><span class="s4">'anon%d'</span><span class="s1">%i] = value</span>
            <span class="s1">url = </span><span class="s4">''</span><span class="s1">.join([f(query.pop(n)) </span><span class="s3">if </span><span class="s1">n </span><span class="s3">else </span><span class="s1">f </span><span class="s3">for </span><span class="s1">(n</span><span class="s3">,</span><span class="s1">f) </span><span class="s3">in </span><span class="s1">builder])</span>
            <span class="s3">return </span><span class="s1">url </span><span class="s3">if not </span><span class="s1">query </span><span class="s3">else </span><span class="s1">url+</span><span class="s4">'?'</span><span class="s1">+urlencode(query)</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">raise </span><span class="s1">RouteBuildError(</span><span class="s4">'Missing URL argument: %r' </span><span class="s1">% _e().args[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">match(self</span><span class="s3">, </span><span class="s1">environ):</span>
        <span class="s2">''' Return a (target, url_agrs) tuple or raise HTTPError(400/404/405). '''</span>
        <span class="s1">verb = environ[</span><span class="s4">'REQUEST_METHOD'</span><span class="s1">].upper()</span>
        <span class="s1">path = environ[</span><span class="s4">'PATH_INFO'</span><span class="s1">] </span><span class="s3">or </span><span class="s4">'/'</span>
        <span class="s1">target = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">verb == </span><span class="s4">'HEAD'</span><span class="s1">:</span>
            <span class="s1">methods = [</span><span class="s4">'PROXY'</span><span class="s3">, </span><span class="s1">verb</span><span class="s3">, </span><span class="s4">'GET'</span><span class="s3">, </span><span class="s4">'ANY'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">methods = [</span><span class="s4">'PROXY'</span><span class="s3">, </span><span class="s1">verb</span><span class="s3">, </span><span class="s4">'ANY'</span><span class="s1">]</span>

        <span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">methods:</span>
            <span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">self.static </span><span class="s3">and </span><span class="s1">path </span><span class="s3">in </span><span class="s1">self.static[method]:</span>
                <span class="s1">target</span><span class="s3">, </span><span class="s1">getargs = self.static[method][path]</span>
                <span class="s3">return </span><span class="s1">target</span><span class="s3">, </span><span class="s1">getargs(path) </span><span class="s3">if </span><span class="s1">getargs </span><span class="s3">else </span><span class="s1">{}</span>
            <span class="s3">elif </span><span class="s1">method </span><span class="s3">in </span><span class="s1">self.dyna_regexes:</span>
                <span class="s3">for </span><span class="s1">combined</span><span class="s3">, </span><span class="s1">rules </span><span class="s3">in </span><span class="s1">self.dyna_regexes[method]:</span>
                    <span class="s1">match = combined(path)</span>
                    <span class="s3">if </span><span class="s1">match:</span>
                        <span class="s1">target</span><span class="s3">, </span><span class="s1">getargs = rules[match.lastindex - </span><span class="s5">1</span><span class="s1">]</span>
                        <span class="s3">return </span><span class="s1">target</span><span class="s3">, </span><span class="s1">getargs(path) </span><span class="s3">if </span><span class="s1">getargs </span><span class="s3">else </span><span class="s1">{}</span>

        <span class="s0"># No matching route found. Collect alternative methods for 405 response</span>
        <span class="s1">allowed = set([])</span>
        <span class="s1">nocheck = set(methods)</span>
        <span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">set(self.static) - nocheck:</span>
            <span class="s3">if </span><span class="s1">path </span><span class="s3">in </span><span class="s1">self.static[method]:</span>
                <span class="s1">allowed.add(method)</span>
        <span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">set(self.dyna_regexes) - allowed - nocheck:</span>
            <span class="s3">for </span><span class="s1">combined</span><span class="s3">, </span><span class="s1">rules </span><span class="s3">in </span><span class="s1">self.dyna_regexes[method]:</span>
                <span class="s1">match = combined(path)</span>
                <span class="s3">if </span><span class="s1">match:</span>
                    <span class="s1">allowed.add(method)</span>
        <span class="s3">if </span><span class="s1">allowed:</span>
            <span class="s1">allow_header = </span><span class="s4">&quot;,&quot;</span><span class="s1">.join(sorted(allowed))</span>
            <span class="s3">raise </span><span class="s1">HTTPError(</span><span class="s5">405</span><span class="s3">, </span><span class="s4">&quot;Method not allowed.&quot;</span><span class="s3">, </span><span class="s1">Allow=allow_header)</span>

        <span class="s0"># No matching route and no alternative method found. We give up</span>
        <span class="s3">raise </span><span class="s1">HTTPError(</span><span class="s5">404</span><span class="s3">, </span><span class="s4">&quot;Not found: &quot; </span><span class="s1">+ repr(path))</span>






<span class="s3">class </span><span class="s1">Route(object):</span>
    <span class="s2">''' This class wraps a route callback along with route specific metadata and 
        configuration and applies Plugins on demand. It is also responsible for 
        turing an URL path rule into a regular expression usable by the Router. 
    '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">app</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None,</span>
                 <span class="s1">plugins=</span><span class="s3">None, </span><span class="s1">skiplist=</span><span class="s3">None, </span><span class="s1">**config):</span>
        <span class="s0">#: The application this route is installed to.</span>
        <span class="s1">self.app = app</span>
        <span class="s0">#: The path-rule string (e.g. ``/wiki/:page``).</span>
        <span class="s1">self.rule = rule</span>
        <span class="s0">#: The HTTP method as a string (e.g. ``GET``).</span>
        <span class="s1">self.method = method</span>
        <span class="s0">#: The original callback with no plugins applied. Useful for introspection.</span>
        <span class="s1">self.callback = callback</span>
        <span class="s0">#: The name of the route (if specified) or ``None``.</span>
        <span class="s1">self.name = name </span><span class="s3">or None</span>
        <span class="s0">#: A list of route-specific plugins (see :meth:`Bottle.route`).</span>
        <span class="s1">self.plugins = plugins </span><span class="s3">or </span><span class="s1">[]</span>
        <span class="s0">#: A list of plugins to not apply to this route (see :meth:`Bottle.route`).</span>
        <span class="s1">self.skiplist = skiplist </span><span class="s3">or </span><span class="s1">[]</span>
        <span class="s0">#: Additional keyword arguments passed to the :meth:`Bottle.route`</span>
        <span class="s0">#: decorator are stored in this dictionary. Used for route-specific</span>
        <span class="s0">#: plugin configuration and meta-data.</span>
        <span class="s1">self.config = ConfigDict().load_dict(config</span><span class="s3">, </span><span class="s1">make_namespaces=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">*a</span><span class="s3">, </span><span class="s1">**ka):</span>
        <span class="s1">depr(</span><span class="s4">&quot;Some APIs changed to return Route() instances instead of&quot;</span><span class="s1">\</span>
             <span class="s4">&quot; callables. Make sure to use the Route.call method and not to&quot;</span><span class="s1">\</span>
             <span class="s4">&quot; call Route instances directly.&quot;</span><span class="s1">) </span><span class="s0">#0.12</span>
        <span class="s3">return </span><span class="s1">self.call(*a</span><span class="s3">, </span><span class="s1">**ka)</span>

    <span class="s1">@cached_property</span>
    <span class="s3">def </span><span class="s1">call(self):</span>
        <span class="s2">''' The route callback with all plugins applied. This property is 
            created on demand and then cached to speed up subsequent requests.'''</span>
        <span class="s3">return </span><span class="s1">self._make_callback()</span>

    <span class="s3">def </span><span class="s1">reset(self):</span>
        <span class="s2">''' Forget any cached values. The next time :attr:`call` is accessed, 
            all plugins are re-applied. '''</span>
        <span class="s1">self.__dict__.pop(</span><span class="s4">'call'</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">prepare(self):</span>
        <span class="s2">''' Do all on-demand work immediately (useful for debugging).'''</span>
        <span class="s1">self.call</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_context(self):</span>
        <span class="s1">depr(</span><span class="s4">'Switch to Plugin API v2 and access the Route object directly.'</span><span class="s1">)  </span><span class="s0">#0.12</span>
        <span class="s3">return </span><span class="s1">dict(rule=self.rule</span><span class="s3">, </span><span class="s1">method=self.method</span><span class="s3">, </span><span class="s1">callback=self.callback</span><span class="s3">,</span>
                    <span class="s1">name=self.name</span><span class="s3">, </span><span class="s1">app=self.app</span><span class="s3">, </span><span class="s1">config=self.config</span><span class="s3">,</span>
                    <span class="s1">apply=self.plugins</span><span class="s3">, </span><span class="s1">skip=self.skiplist)</span>

    <span class="s3">def </span><span class="s1">all_plugins(self):</span>
        <span class="s2">''' Yield all Plugins affecting this route. '''</span>
        <span class="s1">unique = set()</span>
        <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">reversed(self.app.plugins + self.plugins):</span>
            <span class="s3">if True in </span><span class="s1">self.skiplist: </span><span class="s3">break</span>
            <span class="s1">name = getattr(p</span><span class="s3">, </span><span class="s4">'name'</span><span class="s3">, False</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">and </span><span class="s1">(name </span><span class="s3">in </span><span class="s1">self.skiplist </span><span class="s3">or </span><span class="s1">name </span><span class="s3">in </span><span class="s1">unique): </span><span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">p </span><span class="s3">in </span><span class="s1">self.skiplist </span><span class="s3">or </span><span class="s1">type(p) </span><span class="s3">in </span><span class="s1">self.skiplist: </span><span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">name: unique.add(name)</span>
            <span class="s3">yield </span><span class="s1">p</span>

    <span class="s3">def </span><span class="s1">_make_callback(self):</span>
        <span class="s1">callback = self.callback</span>
        <span class="s3">for </span><span class="s1">plugin </span><span class="s3">in </span><span class="s1">self.all_plugins():</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">hasattr(plugin</span><span class="s3">, </span><span class="s4">'apply'</span><span class="s1">):</span>
                    <span class="s1">api = getattr(plugin</span><span class="s3">, </span><span class="s4">'api'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s1">context = self </span><span class="s3">if </span><span class="s1">api &gt; </span><span class="s5">1 </span><span class="s3">else </span><span class="s1">self._context</span>
                    <span class="s1">callback = plugin.apply(callback</span><span class="s3">, </span><span class="s1">context)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">callback = plugin(callback)</span>
            <span class="s3">except </span><span class="s1">RouteReset: </span><span class="s0"># Try again with changed configuration.</span>
                <span class="s3">return </span><span class="s1">self._make_callback()</span>
            <span class="s3">if not </span><span class="s1">callback </span><span class="s3">is </span><span class="s1">self.callback:</span>
                <span class="s1">update_wrapper(callback</span><span class="s3">, </span><span class="s1">self.callback)</span>
        <span class="s3">return </span><span class="s1">callback</span>

    <span class="s3">def </span><span class="s1">get_undecorated_callback(self):</span>
        <span class="s2">''' Return the callback. If the callback is a decorated function, try to 
            recover the original function. '''</span>
        <span class="s1">func = self.callback</span>
        <span class="s1">func = getattr(func</span><span class="s3">, </span><span class="s4">'__func__' </span><span class="s3">if </span><span class="s1">py3k </span><span class="s3">else </span><span class="s4">'im_func'</span><span class="s3">, </span><span class="s1">func)</span>
        <span class="s1">closure_attr = </span><span class="s4">'__closure__' </span><span class="s3">if </span><span class="s1">py3k </span><span class="s3">else </span><span class="s4">'func_closure'</span>
        <span class="s3">while </span><span class="s1">hasattr(func</span><span class="s3">, </span><span class="s1">closure_attr) </span><span class="s3">and </span><span class="s1">getattr(func</span><span class="s3">, </span><span class="s1">closure_attr):</span>
            <span class="s1">func = getattr(func</span><span class="s3">, </span><span class="s1">closure_attr)[</span><span class="s5">0</span><span class="s1">].cell_contents</span>
        <span class="s3">return </span><span class="s1">func</span>

    <span class="s3">def </span><span class="s1">get_callback_args(self):</span>
        <span class="s2">''' Return a list of argument names the callback (most likely) accepts 
            as keyword arguments. If the callback is a decorated function, try 
            to recover the original function before inspection. '''</span>
        <span class="s3">return </span><span class="s1">getargspec(self.get_undecorated_callback())[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">get_config(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">''' Lookup a config field and return its value, first checking the 
            route.config, then route.app.config.'''</span>
        <span class="s3">for </span><span class="s1">conf </span><span class="s3">in </span><span class="s1">(self.config</span><span class="s3">, </span><span class="s1">self.app.config):</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">conf: </span><span class="s3">return </span><span class="s1">conf[key]</span>
        <span class="s3">return </span><span class="s1">default</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">cb = self.get_undecorated_callback()</span>
        <span class="s3">return </span><span class="s4">'&lt;%s %r %r&gt;' </span><span class="s1">% (self.method</span><span class="s3">, </span><span class="s1">self.rule</span><span class="s3">, </span><span class="s1">cb)</span>






<span class="s0">###############################################################################</span>
<span class="s0"># Application Object ###########################################################</span>
<span class="s0">###############################################################################</span>


<span class="s3">class </span><span class="s1">Bottle(object):</span>
    <span class="s2">&quot;&quot;&quot; Each Bottle object represents a single, distinct web application and 
        consists of routes, callbacks, plugins, resources and configuration. 
        Instances are callable WSGI applications. 
 
        :param catchall: If true (default), handle all exceptions. Turn off to 
                         let debugging middleware handle exceptions. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">catchall=</span><span class="s3">True, </span><span class="s1">autojson=</span><span class="s3">True</span><span class="s1">):</span>

        <span class="s0">#: A :class:`ConfigDict` for app specific configuration.</span>
        <span class="s1">self.config = ConfigDict()</span>
        <span class="s1">self.config._on_change = functools.partial(self.trigger_hook</span><span class="s3">, </span><span class="s4">'config'</span><span class="s1">)</span>
        <span class="s1">self.config.meta_set(</span><span class="s4">'autojson'</span><span class="s3">, </span><span class="s4">'validate'</span><span class="s3">, </span><span class="s1">bool)</span>
        <span class="s1">self.config.meta_set(</span><span class="s4">'catchall'</span><span class="s3">, </span><span class="s4">'validate'</span><span class="s3">, </span><span class="s1">bool)</span>
        <span class="s1">self.config[</span><span class="s4">'catchall'</span><span class="s1">] = catchall</span>
        <span class="s1">self.config[</span><span class="s4">'autojson'</span><span class="s1">] = autojson</span>

        <span class="s0">#: A :class:`ResourceManager` for application files</span>
        <span class="s1">self.resources = ResourceManager()</span>

        <span class="s1">self.routes = [] </span><span class="s0"># List of installed :class:`Route` instances.</span>
        <span class="s1">self.router = Router() </span><span class="s0"># Maps requests to :class:`Route` instances.</span>
        <span class="s1">self.error_handler = {}</span>

        <span class="s0"># Core plugins</span>
        <span class="s1">self.plugins = [] </span><span class="s0"># List of installed plugins.</span>
        <span class="s3">if </span><span class="s1">self.config[</span><span class="s4">'autojson'</span><span class="s1">]:</span>
            <span class="s1">self.install(JSONPlugin())</span>
        <span class="s1">self.install(TemplatePlugin())</span>

    <span class="s0">#: If true, most exceptions are caught and returned as :exc:`HTTPError`</span>
    <span class="s1">catchall = DictProperty(</span><span class="s4">'config'</span><span class="s3">, </span><span class="s4">'catchall'</span><span class="s1">)</span>

    <span class="s1">__hook_names = </span><span class="s4">'before_request'</span><span class="s3">, </span><span class="s4">'after_request'</span><span class="s3">, </span><span class="s4">'app_reset'</span><span class="s3">, </span><span class="s4">'config'</span>
    <span class="s1">__hook_reversed = </span><span class="s4">'after_request'</span>

    <span class="s1">@cached_property</span>
    <span class="s3">def </span><span class="s1">_hooks(self):</span>
        <span class="s3">return </span><span class="s1">dict((name</span><span class="s3">, </span><span class="s1">[]) </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self.__hook_names)</span>

    <span class="s3">def </span><span class="s1">add_hook(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">func):</span>
        <span class="s2">''' Attach a callback to a hook. Three hooks are currently implemented: 
 
            before_request 
                Executed once before each request. The request context is 
                available, but no routing has happened yet. 
            after_request 
                Executed once after each request regardless of its outcome. 
            app_reset 
                Called whenever :meth:`Bottle.reset` is called. 
        '''</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self.__hook_reversed:</span>
            <span class="s1">self._hooks[name].insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">func)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._hooks[name].append(func)</span>

    <span class="s3">def </span><span class="s1">remove_hook(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">func):</span>
        <span class="s2">''' Remove a callback from a hook. '''</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self._hooks </span><span class="s3">and </span><span class="s1">func </span><span class="s3">in </span><span class="s1">self._hooks[name]:</span>
            <span class="s1">self._hooks[name].remove(func)</span>
            <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">trigger_hook(self</span><span class="s3">, </span><span class="s1">__name</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">''' Trigger a hook and return a list of results. '''</span>
        <span class="s3">return </span><span class="s1">[hook(*args</span><span class="s3">, </span><span class="s1">**kwargs) </span><span class="s3">for </span><span class="s1">hook </span><span class="s3">in </span><span class="s1">self._hooks[__name][:]]</span>

    <span class="s3">def </span><span class="s1">hook(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s2">&quot;&quot;&quot; Return a decorator that attaches a callback to a hook. See 
            :meth:`add_hook` for details.&quot;&quot;&quot;</span>
        <span class="s3">def </span><span class="s1">decorator(func):</span>
            <span class="s1">self.add_hook(name</span><span class="s3">, </span><span class="s1">func)</span>
            <span class="s3">return </span><span class="s1">func</span>
        <span class="s3">return </span><span class="s1">decorator</span>

    <span class="s3">def </span><span class="s1">mount(self</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">app</span><span class="s3">, </span><span class="s1">**options):</span>
        <span class="s2">''' Mount an application (:class:`Bottle` or plain WSGI) to a specific 
            URL prefix. Example:: 
 
                root_app.mount('/admin/', admin_app) 
 
            :param prefix: path prefix or `mount-point`. If it ends in a slash, 
                that slash is mandatory. 
            :param app: an instance of :class:`Bottle` or a WSGI application. 
 
            All other parameters are passed to the underlying :meth:`route` call. 
        '''</span>
        <span class="s3">if </span><span class="s1">isinstance(app</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">depr(</span><span class="s4">'Parameter order of Bottle.mount() changed.'</span><span class="s3">, True</span><span class="s1">) </span><span class="s0"># 0.10</span>

        <span class="s1">segments = [p </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">prefix.split(</span><span class="s4">'/'</span><span class="s1">) </span><span class="s3">if </span><span class="s1">p]</span>
        <span class="s3">if not </span><span class="s1">segments: </span><span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Empty path prefix.'</span><span class="s1">)</span>
        <span class="s1">path_depth = len(segments)</span>

        <span class="s3">def </span><span class="s1">mountpoint_wrapper():</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">request.path_shift(path_depth)</span>
                <span class="s1">rs = HTTPResponse([])</span>
                <span class="s3">def </span><span class="s1">start_response(status</span><span class="s3">, </span><span class="s1">headerlist</span><span class="s3">, </span><span class="s1">exc_info=</span><span class="s3">None</span><span class="s1">):</span>
                    <span class="s3">if </span><span class="s1">exc_info:</span>
                        <span class="s3">try</span><span class="s1">:</span>
                            <span class="s1">_raise(*exc_info)</span>
                        <span class="s3">finally</span><span class="s1">:</span>
                            <span class="s1">exc_info = </span><span class="s3">None</span>
                    <span class="s1">rs.status = status</span>
                    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">headerlist: rs.add_header(name</span><span class="s3">, </span><span class="s1">value)</span>
                    <span class="s3">return </span><span class="s1">rs.body.append</span>
                <span class="s1">body = app(request.environ</span><span class="s3">, </span><span class="s1">start_response)</span>
                <span class="s3">if </span><span class="s1">body </span><span class="s3">and </span><span class="s1">rs.body: body = itertools.chain(rs.body</span><span class="s3">, </span><span class="s1">body)</span>
                <span class="s1">rs.body = body </span><span class="s3">or </span><span class="s1">rs.body</span>
                <span class="s3">return </span><span class="s1">rs</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s1">request.path_shift(-path_depth)</span>

        <span class="s1">options.setdefault(</span><span class="s4">'skip'</span><span class="s3">, True</span><span class="s1">)</span>
        <span class="s1">options.setdefault(</span><span class="s4">'method'</span><span class="s3">, </span><span class="s4">'PROXY'</span><span class="s1">)</span>
        <span class="s1">options.setdefault(</span><span class="s4">'mountpoint'</span><span class="s3">, </span><span class="s1">{</span><span class="s4">'prefix'</span><span class="s1">: prefix</span><span class="s3">, </span><span class="s4">'target'</span><span class="s1">: app})</span>
        <span class="s1">options[</span><span class="s4">'callback'</span><span class="s1">] = mountpoint_wrapper</span>

        <span class="s1">self.route(</span><span class="s4">'/%s/&lt;:re:.*&gt;' </span><span class="s1">% </span><span class="s4">'/'</span><span class="s1">.join(segments)</span><span class="s3">, </span><span class="s1">**options)</span>
        <span class="s3">if not </span><span class="s1">prefix.endswith(</span><span class="s4">'/'</span><span class="s1">):</span>
            <span class="s1">self.route(</span><span class="s4">'/' </span><span class="s1">+ </span><span class="s4">'/'</span><span class="s1">.join(segments)</span><span class="s3">, </span><span class="s1">**options)</span>

    <span class="s3">def </span><span class="s1">merge(self</span><span class="s3">, </span><span class="s1">routes):</span>
        <span class="s2">''' Merge the routes of another :class:`Bottle` application or a list of 
            :class:`Route` objects into this application. The routes keep their 
            'owner', meaning that the :data:`Route.app` attribute is not 
            changed. '''</span>
        <span class="s3">if </span><span class="s1">isinstance(routes</span><span class="s3">, </span><span class="s1">Bottle):</span>
            <span class="s1">routes = routes.routes</span>
        <span class="s3">for </span><span class="s1">route </span><span class="s3">in </span><span class="s1">routes:</span>
            <span class="s1">self.add_route(route)</span>

    <span class="s3">def </span><span class="s1">install(self</span><span class="s3">, </span><span class="s1">plugin):</span>
        <span class="s2">''' Add a plugin to the list of plugins and prepare it for being 
            applied to all routes of this application. A plugin may be a simple 
            decorator or an object that implements the :class:`Plugin` API. 
        '''</span>
        <span class="s3">if </span><span class="s1">hasattr(plugin</span><span class="s3">, </span><span class="s4">'setup'</span><span class="s1">): plugin.setup(self)</span>
        <span class="s3">if not </span><span class="s1">callable(plugin) </span><span class="s3">and not </span><span class="s1">hasattr(plugin</span><span class="s3">, </span><span class="s4">'apply'</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Plugins must be callable or implement .apply()&quot;</span><span class="s1">)</span>
        <span class="s1">self.plugins.append(plugin)</span>
        <span class="s1">self.reset()</span>
        <span class="s3">return </span><span class="s1">plugin</span>

    <span class="s3">def </span><span class="s1">uninstall(self</span><span class="s3">, </span><span class="s1">plugin):</span>
        <span class="s2">''' Uninstall plugins. Pass an instance to remove a specific plugin, a type 
            object to remove all plugins that match that type, a string to remove 
            all plugins with a matching ``name`` attribute or ``True`` to remove all 
            plugins. Return the list of removed plugins. '''</span>
        <span class="s1">removed</span><span class="s3">, </span><span class="s1">remove = []</span><span class="s3">, </span><span class="s1">plugin</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">plugin </span><span class="s3">in </span><span class="s1">list(enumerate(self.plugins))[::-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">remove </span><span class="s3">is True or </span><span class="s1">remove </span><span class="s3">is </span><span class="s1">plugin </span><span class="s3">or </span><span class="s1">remove </span><span class="s3">is </span><span class="s1">type(plugin) \</span>
            <span class="s3">or </span><span class="s1">getattr(plugin</span><span class="s3">, </span><span class="s4">'name'</span><span class="s3">, True</span><span class="s1">) == remove:</span>
                <span class="s1">removed.append(plugin)</span>
                <span class="s3">del </span><span class="s1">self.plugins[i]</span>
                <span class="s3">if </span><span class="s1">hasattr(plugin</span><span class="s3">, </span><span class="s4">'close'</span><span class="s1">): plugin.close()</span>
        <span class="s3">if </span><span class="s1">removed: self.reset()</span>
        <span class="s3">return </span><span class="s1">removed</span>

    <span class="s3">def </span><span class="s1">reset(self</span><span class="s3">, </span><span class="s1">route=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">''' Reset all routes (force plugins to be re-applied) and clear all 
            caches. If an ID or route object is given, only that specific route 
            is affected. '''</span>
        <span class="s3">if </span><span class="s1">route </span><span class="s3">is None</span><span class="s1">: routes = self.routes</span>
        <span class="s3">elif </span><span class="s1">isinstance(route</span><span class="s3">, </span><span class="s1">Route): routes = [route]</span>
        <span class="s3">else</span><span class="s1">: routes = [self.routes[route]]</span>
        <span class="s3">for </span><span class="s1">route </span><span class="s3">in </span><span class="s1">routes: route.reset()</span>
        <span class="s3">if </span><span class="s1">DEBUG:</span>
            <span class="s3">for </span><span class="s1">route </span><span class="s3">in </span><span class="s1">routes: route.prepare()</span>
        <span class="s1">self.trigger_hook(</span><span class="s4">'app_reset'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s2">''' Close the application and all installed plugins. '''</span>
        <span class="s3">for </span><span class="s1">plugin </span><span class="s3">in </span><span class="s1">self.plugins:</span>
            <span class="s3">if </span><span class="s1">hasattr(plugin</span><span class="s3">, </span><span class="s4">'close'</span><span class="s1">): plugin.close()</span>
        <span class="s1">self.stopped = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">''' Calls :func:`run` with the same parameters. '''</span>
        <span class="s1">run(self</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">match(self</span><span class="s3">, </span><span class="s1">environ):</span>
        <span class="s2">&quot;&quot;&quot; Search for a matching route and return a (:class:`Route` , urlargs) 
            tuple. The second value is a dictionary with parameters extracted 
            from the URL. Raise :exc:`HTTPError` (404/405) on a non-match.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.router.match(environ)</span>

    <span class="s3">def </span><span class="s1">get_url(self</span><span class="s3">, </span><span class="s1">routename</span><span class="s3">, </span><span class="s1">**kargs):</span>
        <span class="s2">&quot;&quot;&quot; Return a string that matches a named route &quot;&quot;&quot;</span>
        <span class="s1">scriptname = request.environ.get(</span><span class="s4">'SCRIPT_NAME'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">).strip(</span><span class="s4">'/'</span><span class="s1">) + </span><span class="s4">'/'</span>
        <span class="s1">location = self.router.build(routename</span><span class="s3">, </span><span class="s1">**kargs).lstrip(</span><span class="s4">'/'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">urljoin(urljoin(</span><span class="s4">'/'</span><span class="s3">, </span><span class="s1">scriptname)</span><span class="s3">, </span><span class="s1">location)</span>

    <span class="s3">def </span><span class="s1">add_route(self</span><span class="s3">, </span><span class="s1">route):</span>
        <span class="s2">''' Add a route object, but do not change the :data:`Route.app` 
            attribute.'''</span>
        <span class="s1">self.routes.append(route)</span>
        <span class="s1">self.router.add(route.rule</span><span class="s3">, </span><span class="s1">route.method</span><span class="s3">, </span><span class="s1">route</span><span class="s3">, </span><span class="s1">name=route.name)</span>
        <span class="s3">if </span><span class="s1">DEBUG: route.prepare()</span>

    <span class="s3">def </span><span class="s1">route(self</span><span class="s3">, </span><span class="s1">path=</span><span class="s3">None, </span><span class="s1">method=</span><span class="s4">'GET'</span><span class="s3">, </span><span class="s1">callback=</span><span class="s3">None, </span><span class="s1">name=</span><span class="s3">None,</span>
              <span class="s1">apply=</span><span class="s3">None, </span><span class="s1">skip=</span><span class="s3">None, </span><span class="s1">**config):</span>
        <span class="s2">&quot;&quot;&quot; A decorator to bind a function to a request URL. Example:: 
 
                @app.route('/hello/:name') 
                def hello(name): 
                    return 'Hello %s' % name 
 
            The ``:name`` part is a wildcard. See :class:`Router` for syntax 
            details. 
 
            :param path: Request path or a list of paths to listen to. If no 
              path is specified, it is automatically generated from the 
              signature of the function. 
            :param method: HTTP method (`GET`, `POST`, `PUT`, ...) or a list of 
              methods to listen to. (default: `GET`) 
            :param callback: An optional shortcut to avoid the decorator 
              syntax. ``route(..., callback=func)`` equals ``route(...)(func)`` 
            :param name: The name for this route. (default: None) 
            :param apply: A decorator or plugin or a list of plugins. These are 
              applied to the route callback in addition to installed plugins. 
            :param skip: A list of plugins, plugin classes or names. Matching 
              plugins are not installed to this route. ``True`` skips all. 
 
            Any additional keyword arguments are stored as route-specific 
            configuration and passed to plugins (see :meth:`Plugin.apply`). 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">callable(path): path</span><span class="s3">, </span><span class="s1">callback = </span><span class="s3">None, </span><span class="s1">path</span>
        <span class="s1">plugins = makelist(apply)</span>
        <span class="s1">skiplist = makelist(skip)</span>
        <span class="s3">def </span><span class="s1">decorator(callback):</span>
            <span class="s0"># TODO: Documentation and tests</span>
            <span class="s3">if </span><span class="s1">isinstance(callback</span><span class="s3">, </span><span class="s1">basestring): callback = load(callback)</span>
            <span class="s3">for </span><span class="s1">rule </span><span class="s3">in </span><span class="s1">makelist(path) </span><span class="s3">or </span><span class="s1">yieldroutes(callback):</span>
                <span class="s3">for </span><span class="s1">verb </span><span class="s3">in </span><span class="s1">makelist(method):</span>
                    <span class="s1">verb = verb.upper()</span>
                    <span class="s1">route = Route(self</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">, </span><span class="s1">verb</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">name=name</span><span class="s3">,</span>
                                  <span class="s1">plugins=plugins</span><span class="s3">, </span><span class="s1">skiplist=skiplist</span><span class="s3">, </span><span class="s1">**config)</span>
                    <span class="s1">self.add_route(route)</span>
            <span class="s3">return </span><span class="s1">callback</span>
        <span class="s3">return </span><span class="s1">decorator(callback) </span><span class="s3">if </span><span class="s1">callback </span><span class="s3">else </span><span class="s1">decorator</span>

    <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">path=</span><span class="s3">None, </span><span class="s1">method=</span><span class="s4">'GET'</span><span class="s3">, </span><span class="s1">**options):</span>
        <span class="s2">&quot;&quot;&quot; Equals :meth:`route`. &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.route(path</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">**options)</span>

    <span class="s3">def </span><span class="s1">post(self</span><span class="s3">, </span><span class="s1">path=</span><span class="s3">None, </span><span class="s1">method=</span><span class="s4">'POST'</span><span class="s3">, </span><span class="s1">**options):</span>
        <span class="s2">&quot;&quot;&quot; Equals :meth:`route` with a ``POST`` method parameter. &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.route(path</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">**options)</span>

    <span class="s3">def </span><span class="s1">put(self</span><span class="s3">, </span><span class="s1">path=</span><span class="s3">None, </span><span class="s1">method=</span><span class="s4">'PUT'</span><span class="s3">, </span><span class="s1">**options):</span>
        <span class="s2">&quot;&quot;&quot; Equals :meth:`route` with a ``PUT`` method parameter. &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.route(path</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">**options)</span>

    <span class="s3">def </span><span class="s1">delete(self</span><span class="s3">, </span><span class="s1">path=</span><span class="s3">None, </span><span class="s1">method=</span><span class="s4">'DELETE'</span><span class="s3">, </span><span class="s1">**options):</span>
        <span class="s2">&quot;&quot;&quot; Equals :meth:`route` with a ``DELETE`` method parameter. &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.route(path</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">**options)</span>

    <span class="s3">def </span><span class="s1">error(self</span><span class="s3">, </span><span class="s1">code=</span><span class="s5">500</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; Decorator: Register an output handler for a HTTP error code&quot;&quot;&quot;</span>
        <span class="s3">def </span><span class="s1">wrapper(handler):</span>
            <span class="s1">self.error_handler[int(code)] = handler</span>
            <span class="s3">return </span><span class="s1">handler</span>
        <span class="s3">return </span><span class="s1">wrapper</span>

    <span class="s3">def </span><span class="s1">default_error_handler(self</span><span class="s3">, </span><span class="s1">res):</span>
        <span class="s3">return </span><span class="s1">tob(template(ERROR_PAGE_TEMPLATE</span><span class="s3">, </span><span class="s1">e=res))</span>

    <span class="s3">def </span><span class="s1">_handle(self</span><span class="s3">, </span><span class="s1">environ):</span>
        <span class="s3">try</span><span class="s1">:</span>

            <span class="s1">environ[</span><span class="s4">'bottle.app'</span><span class="s1">] = self</span>
            <span class="s1">request.bind(environ)</span>
            <span class="s1">response.bind()</span>

            <span class="s1">path = environ[</span><span class="s4">'bottle.raw_path'</span><span class="s1">] = environ[</span><span class="s4">'PATH_INFO'</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">py3k:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">environ[</span><span class="s4">'PATH_INFO'</span><span class="s1">] = path.encode(</span><span class="s4">'latin1'</span><span class="s1">).decode(</span><span class="s4">'utf8'</span><span class="s1">)</span>
                <span class="s3">except </span><span class="s1">UnicodeError:</span>
                    <span class="s3">return </span><span class="s1">HTTPError(</span><span class="s5">400</span><span class="s3">, </span><span class="s4">'Invalid path string. Expected UTF-8'</span><span class="s1">)</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.trigger_hook(</span><span class="s4">'before_request'</span><span class="s1">)</span>
                <span class="s1">route</span><span class="s3">, </span><span class="s1">args = self.router.match(environ)</span>
                <span class="s1">environ[</span><span class="s4">'route.handle'</span><span class="s1">] = route</span>
                <span class="s1">environ[</span><span class="s4">'bottle.route'</span><span class="s1">] = route</span>
                <span class="s1">environ[</span><span class="s4">'route.url_args'</span><span class="s1">] = args</span>
                <span class="s3">return </span><span class="s1">route.call(**args)</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s1">self.trigger_hook(</span><span class="s4">'after_request'</span><span class="s1">)</span>

        <span class="s3">except </span><span class="s1">HTTPResponse:</span>
            <span class="s3">return </span><span class="s1">_e()</span>
        <span class="s3">except </span><span class="s1">RouteReset:</span>
            <span class="s1">route.reset()</span>
            <span class="s3">return </span><span class="s1">self._handle(environ)</span>
        <span class="s3">except </span><span class="s1">(KeyboardInterrupt</span><span class="s3">, </span><span class="s1">SystemExit</span><span class="s3">, </span><span class="s1">MemoryError):</span>
            <span class="s3">raise</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s3">if not </span><span class="s1">self.catchall: </span><span class="s3">raise</span>
            <span class="s1">stacktrace = format_exc()</span>
            <span class="s1">environ[</span><span class="s4">'wsgi.errors'</span><span class="s1">].write(stacktrace)</span>
            <span class="s3">return </span><span class="s1">HTTPError(</span><span class="s5">500</span><span class="s3">, </span><span class="s4">&quot;Internal Server Error&quot;</span><span class="s3">, </span><span class="s1">_e()</span><span class="s3">, </span><span class="s1">stacktrace)</span>

    <span class="s3">def </span><span class="s1">_cast(self</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">peek=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; Try to convert the parameter into something WSGI compatible and set 
        correct HTTP headers when possible. 
        Support: False, str, unicode, dict, HTTPResponse, HTTPError, file-like, 
        iterable of strings and iterable of unicodes 
        &quot;&quot;&quot;</span>

        <span class="s0"># Empty output is done here</span>
        <span class="s3">if not </span><span class="s1">out:</span>
            <span class="s3">if </span><span class="s4">'Content-Length' </span><span class="s3">not in </span><span class="s1">response:</span>
                <span class="s1">response[</span><span class="s4">'Content-Length'</span><span class="s1">] = </span><span class="s5">0</span>
            <span class="s3">return </span><span class="s1">[]</span>
        <span class="s0"># Join lists of byte or unicode strings. Mixed lists are NOT supported</span>
        <span class="s3">if </span><span class="s1">isinstance(out</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list))\</span>
        <span class="s3">and </span><span class="s1">isinstance(out[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">(bytes</span><span class="s3">, </span><span class="s1">unicode)):</span>
            <span class="s1">out = out[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">:</span><span class="s5">0</span><span class="s1">].join(out) </span><span class="s0"># b'abc'[0:0] -&gt; b''</span>
        <span class="s0"># Encode unicode strings</span>
        <span class="s3">if </span><span class="s1">isinstance(out</span><span class="s3">, </span><span class="s1">unicode):</span>
            <span class="s1">out = out.encode(response.charset)</span>
        <span class="s0"># Byte Strings are just returned</span>
        <span class="s3">if </span><span class="s1">isinstance(out</span><span class="s3">, </span><span class="s1">bytes):</span>
            <span class="s3">if </span><span class="s4">'Content-Length' </span><span class="s3">not in </span><span class="s1">response:</span>
                <span class="s1">response[</span><span class="s4">'Content-Length'</span><span class="s1">] = len(out)</span>
            <span class="s3">return </span><span class="s1">[out]</span>
        <span class="s0"># HTTPError or HTTPException (recursive, because they may wrap anything)</span>
        <span class="s0"># TODO: Handle these explicitly in handle() or make them iterable.</span>
        <span class="s3">if </span><span class="s1">isinstance(out</span><span class="s3">, </span><span class="s1">HTTPError):</span>
            <span class="s1">out.apply(response)</span>
            <span class="s1">out = self.error_handler.get(out.status_code</span><span class="s3">, </span><span class="s1">self.default_error_handler)(out)</span>
            <span class="s3">return </span><span class="s1">self._cast(out)</span>
        <span class="s3">if </span><span class="s1">isinstance(out</span><span class="s3">, </span><span class="s1">HTTPResponse):</span>
            <span class="s1">out.apply(response)</span>
            <span class="s3">return </span><span class="s1">self._cast(out.body)</span>

        <span class="s0"># File-like objects.</span>
        <span class="s3">if </span><span class="s1">hasattr(out</span><span class="s3">, </span><span class="s4">'read'</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s4">'wsgi.file_wrapper' </span><span class="s3">in </span><span class="s1">request.environ:</span>
                <span class="s3">return </span><span class="s1">request.environ[</span><span class="s4">'wsgi.file_wrapper'</span><span class="s1">](out)</span>
            <span class="s3">elif </span><span class="s1">hasattr(out</span><span class="s3">, </span><span class="s4">'close'</span><span class="s1">) </span><span class="s3">or not </span><span class="s1">hasattr(out</span><span class="s3">, </span><span class="s4">'__iter__'</span><span class="s1">):</span>
                <span class="s3">return </span><span class="s1">WSGIFileWrapper(out)</span>

        <span class="s0"># Handle Iterables. We peek into them to detect their inner type.</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">iout = iter(out)</span>
            <span class="s1">first = next(iout)</span>
            <span class="s3">while not </span><span class="s1">first:</span>
                <span class="s1">first = next(iout)</span>
        <span class="s3">except </span><span class="s1">StopIteration:</span>
            <span class="s3">return </span><span class="s1">self._cast(</span><span class="s4">''</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">HTTPResponse:</span>
            <span class="s1">first = _e()</span>
        <span class="s3">except </span><span class="s1">(KeyboardInterrupt</span><span class="s3">, </span><span class="s1">SystemExit</span><span class="s3">, </span><span class="s1">MemoryError):</span>
            <span class="s3">raise</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s3">if not </span><span class="s1">self.catchall: </span><span class="s3">raise</span>
            <span class="s1">first = HTTPError(</span><span class="s5">500</span><span class="s3">, </span><span class="s4">'Unhandled exception'</span><span class="s3">, </span><span class="s1">_e()</span><span class="s3">, </span><span class="s1">format_exc())</span>

        <span class="s0"># These are the inner types allowed in iterator or generator objects.</span>
        <span class="s3">if </span><span class="s1">isinstance(first</span><span class="s3">, </span><span class="s1">HTTPResponse):</span>
            <span class="s3">return </span><span class="s1">self._cast(first)</span>
        <span class="s3">elif </span><span class="s1">isinstance(first</span><span class="s3">, </span><span class="s1">bytes):</span>
            <span class="s1">new_iter = itertools.chain([first]</span><span class="s3">, </span><span class="s1">iout)</span>
        <span class="s3">elif </span><span class="s1">isinstance(first</span><span class="s3">, </span><span class="s1">unicode):</span>
            <span class="s1">encoder = </span><span class="s3">lambda </span><span class="s1">x: x.encode(response.charset)</span>
            <span class="s1">new_iter = imap(encoder</span><span class="s3">, </span><span class="s1">itertools.chain([first]</span><span class="s3">, </span><span class="s1">iout))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">'Unsupported response type: %s' </span><span class="s1">% type(first)</span>
            <span class="s3">return </span><span class="s1">self._cast(HTTPError(</span><span class="s5">500</span><span class="s3">, </span><span class="s1">msg))</span>
        <span class="s3">if </span><span class="s1">hasattr(out</span><span class="s3">, </span><span class="s4">'close'</span><span class="s1">):</span>
            <span class="s1">new_iter = _closeiter(new_iter</span><span class="s3">, </span><span class="s1">out.close)</span>
        <span class="s3">return </span><span class="s1">new_iter</span>

    <span class="s3">def </span><span class="s1">wsgi(self</span><span class="s3">, </span><span class="s1">environ</span><span class="s3">, </span><span class="s1">start_response):</span>
        <span class="s2">&quot;&quot;&quot; The bottle WSGI-interface. &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">out = self._cast(self._handle(environ))</span>
            <span class="s0"># rfc2616 section 4.3</span>
            <span class="s3">if </span><span class="s1">response._status_code </span><span class="s3">in </span><span class="s1">(</span><span class="s5">100</span><span class="s3">, </span><span class="s5">101</span><span class="s3">, </span><span class="s5">204</span><span class="s3">, </span><span class="s5">304</span><span class="s1">)\</span>
            <span class="s3">or </span><span class="s1">environ[</span><span class="s4">'REQUEST_METHOD'</span><span class="s1">] == </span><span class="s4">'HEAD'</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">hasattr(out</span><span class="s3">, </span><span class="s4">'close'</span><span class="s1">): out.close()</span>
                <span class="s1">out = []</span>
            <span class="s1">start_response(response._status_line</span><span class="s3">, </span><span class="s1">response.headerlist)</span>
            <span class="s3">return </span><span class="s1">out</span>
        <span class="s3">except </span><span class="s1">(KeyboardInterrupt</span><span class="s3">, </span><span class="s1">SystemExit</span><span class="s3">, </span><span class="s1">MemoryError):</span>
            <span class="s3">raise</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s3">if not </span><span class="s1">self.catchall: </span><span class="s3">raise</span>
            <span class="s1">err = </span><span class="s4">'&lt;h1&gt;Critical error while processing request: %s&lt;/h1&gt;' </span><span class="s1">\</span>
                  <span class="s1">% html_escape(environ.get(</span><span class="s4">'PATH_INFO'</span><span class="s3">, </span><span class="s4">'/'</span><span class="s1">))</span>
            <span class="s3">if </span><span class="s1">DEBUG:</span>
                <span class="s1">err += </span><span class="s4">'&lt;h2&gt;Error:&lt;/h2&gt;</span><span class="s3">\n</span><span class="s4">&lt;pre&gt;</span><span class="s3">\n</span><span class="s4">%s</span><span class="s3">\n</span><span class="s4">&lt;/pre&gt;</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">\</span>
                       <span class="s4">'&lt;h2&gt;Traceback:&lt;/h2&gt;</span><span class="s3">\n</span><span class="s4">&lt;pre&gt;</span><span class="s3">\n</span><span class="s4">%s</span><span class="s3">\n</span><span class="s4">&lt;/pre&gt;</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">\</span>
                       <span class="s1">% (html_escape(repr(_e()))</span><span class="s3">, </span><span class="s1">html_escape(format_exc()))</span>
            <span class="s1">environ[</span><span class="s4">'wsgi.errors'</span><span class="s1">].write(err)</span>
            <span class="s1">headers = [(</span><span class="s4">'Content-Type'</span><span class="s3">, </span><span class="s4">'text/html; charset=UTF-8'</span><span class="s1">)]</span>
            <span class="s1">start_response(</span><span class="s4">'500 INTERNAL SERVER ERROR'</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">sys.exc_info())</span>
            <span class="s3">return </span><span class="s1">[tob(err)]</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">environ</span><span class="s3">, </span><span class="s1">start_response):</span>
        <span class="s2">''' Each instance of :class:'Bottle' is a WSGI application. '''</span>
        <span class="s3">return </span><span class="s1">self.wsgi(environ</span><span class="s3">, </span><span class="s1">start_response)</span>






<span class="s0">###############################################################################</span>
<span class="s0"># HTTP and WSGI Tools ##########################################################</span>
<span class="s0">###############################################################################</span>

<span class="s3">class </span><span class="s1">BaseRequest(object):</span>
    <span class="s2">&quot;&quot;&quot; A wrapper for WSGI environment dictionaries that adds a lot of 
        convenient access methods and properties. Most of them are read-only. 
 
        Adding new attributes to a request actually adds them to the environ 
        dictionary (as 'bottle.request.ext.&lt;name&gt;'). This is the recommended 
        way to store and access request-specific data. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s4">'environ'</span><span class="s1">)</span>

    <span class="s0">#: Maximum size of memory buffer for :attr:`body` in bytes.</span>
    <span class="s1">MEMFILE_MAX = </span><span class="s5">102400</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">environ=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; Wrap a WSGI environ dictionary. &quot;&quot;&quot;</span>
        <span class="s0">#: The wrapped WSGI environ dictionary. This is the only real attribute.</span>
        <span class="s0">#: All other attributes actually are read-only properties.</span>
        <span class="s1">self.environ = {} </span><span class="s3">if </span><span class="s1">environ </span><span class="s3">is None else </span><span class="s1">environ</span>
        <span class="s1">self.environ[</span><span class="s4">'bottle.request'</span><span class="s1">] = self</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'bottle.app'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">app(self):</span>
        <span class="s2">''' Bottle application handling this request. '''</span>
        <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">'This request is not connected to an application.'</span><span class="s1">)</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'bottle.route'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">route(self):</span>
        <span class="s2">&quot;&quot;&quot; The bottle :class:`Route` object that matches this request. &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">'This request is not connected to a route.'</span><span class="s1">)</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'route.url_args'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">url_args(self):</span>
        <span class="s2">&quot;&quot;&quot; The arguments extracted from the URL. &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">'This request is not connected to a route.'</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">path(self):</span>
        <span class="s2">''' The value of ``PATH_INFO`` with exactly one prefixed slash (to fix 
            broken clients and avoid the &quot;empty path&quot; edge case). '''</span>
        <span class="s3">return </span><span class="s4">'/' </span><span class="s1">+ self.environ.get(</span><span class="s4">'PATH_INFO'</span><span class="s3">,</span><span class="s4">''</span><span class="s1">).lstrip(</span><span class="s4">'/'</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">method(self):</span>
        <span class="s2">''' The ``REQUEST_METHOD`` value as an uppercase string. '''</span>
        <span class="s3">return </span><span class="s1">self.environ.get(</span><span class="s4">'REQUEST_METHOD'</span><span class="s3">, </span><span class="s4">'GET'</span><span class="s1">).upper()</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'bottle.request.headers'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">headers(self):</span>
        <span class="s2">''' A :class:`WSGIHeaderDict` that provides case-insensitive access to 
            HTTP request headers. '''</span>
        <span class="s3">return </span><span class="s1">WSGIHeaderDict(self.environ)</span>

    <span class="s3">def </span><span class="s1">get_header(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">''' Return the value of a request header, or a given default value. '''</span>
        <span class="s3">return </span><span class="s1">self.headers.get(name</span><span class="s3">, </span><span class="s1">default)</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'bottle.request.cookies'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">cookies(self):</span>
        <span class="s2">&quot;&quot;&quot; Cookies parsed into a :class:`FormsDict`. Signed cookies are NOT 
            decoded. Use :meth:`get_cookie` if you expect signed cookies. &quot;&quot;&quot;</span>
        <span class="s1">cookies = SimpleCookie(self.environ.get(</span><span class="s4">'HTTP_COOKIE'</span><span class="s3">,</span><span class="s4">''</span><span class="s1">)).values()</span>
        <span class="s3">return </span><span class="s1">FormsDict((c.key</span><span class="s3">, </span><span class="s1">c.value) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">cookies)</span>

    <span class="s3">def </span><span class="s1">get_cookie(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None, </span><span class="s1">secret=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; Return the content of a cookie. To read a `Signed Cookie`, the 
            `secret` must match the one used to create the cookie (see 
            :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing 
            cookie or wrong signature), return a default value. &quot;&quot;&quot;</span>
        <span class="s1">value = self.cookies.get(key)</span>
        <span class="s3">if </span><span class="s1">secret </span><span class="s3">and </span><span class="s1">value:</span>
            <span class="s1">dec = cookie_decode(value</span><span class="s3">, </span><span class="s1">secret) </span><span class="s0"># (key, value) tuple or None</span>
            <span class="s3">return </span><span class="s1">dec[</span><span class="s5">1</span><span class="s1">] </span><span class="s3">if </span><span class="s1">dec </span><span class="s3">and </span><span class="s1">dec[</span><span class="s5">0</span><span class="s1">] == key </span><span class="s3">else </span><span class="s1">default</span>
        <span class="s3">return </span><span class="s1">value </span><span class="s3">or </span><span class="s1">default</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'bottle.request.query'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">query(self):</span>
        <span class="s2">''' The :attr:`query_string` parsed into a :class:`FormsDict`. These 
            values are sometimes called &quot;URL arguments&quot; or &quot;GET parameters&quot;, but 
            not to be confused with &quot;URL wildcards&quot; as they are provided by the 
            :class:`Router`. '''</span>
        <span class="s1">get = self.environ[</span><span class="s4">'bottle.get'</span><span class="s1">] = FormsDict()</span>
        <span class="s1">pairs = _parse_qsl(self.environ.get(</span><span class="s4">'QUERY_STRING'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">))</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">pairs:</span>
            <span class="s1">get[key] = value</span>
        <span class="s3">return </span><span class="s1">get</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'bottle.request.forms'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">forms(self):</span>
        <span class="s2">&quot;&quot;&quot; Form values parsed from an `url-encoded` or `multipart/form-data` 
            encoded POST or PUT request body. The result is returned as a 
            :class:`FormsDict`. All keys and values are strings. File uploads 
            are stored separately in :attr:`files`. &quot;&quot;&quot;</span>
        <span class="s1">forms = FormsDict()</span>
        <span class="s1">forms.recode_unicode = self.POST.recode_unicode</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">item </span><span class="s3">in </span><span class="s1">self.POST.allitems():</span>
            <span class="s3">if not </span><span class="s1">isinstance(item</span><span class="s3">, </span><span class="s1">FileUpload):</span>
                <span class="s1">forms[name] = item</span>
        <span class="s3">return </span><span class="s1">forms</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'bottle.request.params'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">params(self):</span>
        <span class="s2">&quot;&quot;&quot; A :class:`FormsDict` with the combined values of :attr:`query` and 
            :attr:`forms`. File uploads are stored in :attr:`files`. &quot;&quot;&quot;</span>
        <span class="s1">params = FormsDict()</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self.query.allitems():</span>
            <span class="s1">params[key] = value</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self.forms.allitems():</span>
            <span class="s1">params[key] = value</span>
        <span class="s3">return </span><span class="s1">params</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'bottle.request.files'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">files(self):</span>
        <span class="s2">&quot;&quot;&quot; File uploads parsed from `multipart/form-data` encoded POST or PUT 
            request body. The values are instances of :class:`FileUpload`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">files = FormsDict()</span>
        <span class="s1">files.recode_unicode = self.POST.recode_unicode</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">item </span><span class="s3">in </span><span class="s1">self.POST.allitems():</span>
            <span class="s3">if </span><span class="s1">isinstance(item</span><span class="s3">, </span><span class="s1">FileUpload):</span>
                <span class="s1">files[name] = item</span>
        <span class="s3">return </span><span class="s1">files</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'bottle.request.json'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">json(self):</span>
        <span class="s2">''' If the ``Content-Type`` header is ``application/json``, this 
            property holds the parsed content of the request body. Only requests 
            smaller than :attr:`MEMFILE_MAX` are processed to avoid memory 
            exhaustion. '''</span>
        <span class="s1">ctype = self.environ.get(</span><span class="s4">'CONTENT_TYPE'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">).lower().split(</span><span class="s4">';'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">ctype == </span><span class="s4">'application/json'</span><span class="s1">:</span>
            <span class="s1">b = self._get_body_string()</span>
            <span class="s3">if not </span><span class="s1">b:</span>
                <span class="s3">return None</span>
            <span class="s3">return </span><span class="s1">json_loads(b)</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">_iter_body(self</span><span class="s3">, </span><span class="s1">read</span><span class="s3">, </span><span class="s1">bufsize):</span>
        <span class="s1">maxread = max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">self.content_length)</span>
        <span class="s3">while </span><span class="s1">maxread:</span>
            <span class="s1">part = read(min(maxread</span><span class="s3">, </span><span class="s1">bufsize))</span>
            <span class="s3">if not </span><span class="s1">part: </span><span class="s3">break</span>
            <span class="s3">yield </span><span class="s1">part</span>
            <span class="s1">maxread -= len(part)</span>

    <span class="s3">def </span><span class="s1">_iter_chunked(self</span><span class="s3">, </span><span class="s1">read</span><span class="s3">, </span><span class="s1">bufsize):</span>
        <span class="s1">err = HTTPError(</span><span class="s5">400</span><span class="s3">, </span><span class="s4">'Error while parsing chunked transfer body.'</span><span class="s1">)</span>
        <span class="s1">rn</span><span class="s3">, </span><span class="s1">sem</span><span class="s3">, </span><span class="s1">bs = tob(</span><span class="s4">'</span><span class="s3">\r\n</span><span class="s4">'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">tob(</span><span class="s4">';'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">tob(</span><span class="s4">''</span><span class="s1">)</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s1">header = read(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3">while </span><span class="s1">header[-</span><span class="s5">2</span><span class="s1">:] != rn:</span>
                <span class="s1">c = read(</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">header += c</span>
                <span class="s3">if not </span><span class="s1">c: </span><span class="s3">raise </span><span class="s1">err</span>
                <span class="s3">if </span><span class="s1">len(header) &gt; bufsize: </span><span class="s3">raise </span><span class="s1">err</span>
            <span class="s1">size</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ = header.partition(sem)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">maxread = int(tonat(size.strip())</span><span class="s3">, </span><span class="s5">16</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">ValueError:</span>
                <span class="s3">raise </span><span class="s1">err</span>
            <span class="s3">if </span><span class="s1">maxread == </span><span class="s5">0</span><span class="s1">: </span><span class="s3">break</span>
            <span class="s1">buff = bs</span>
            <span class="s3">while </span><span class="s1">maxread &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">if not </span><span class="s1">buff:</span>
                    <span class="s1">buff = read(min(maxread</span><span class="s3">, </span><span class="s1">bufsize))</span>
                <span class="s1">part</span><span class="s3">, </span><span class="s1">buff = buff[:maxread]</span><span class="s3">, </span><span class="s1">buff[maxread:]</span>
                <span class="s3">if not </span><span class="s1">part: </span><span class="s3">raise </span><span class="s1">err</span>
                <span class="s3">yield </span><span class="s1">part</span>
                <span class="s1">maxread -= len(part)</span>
            <span class="s3">if </span><span class="s1">read(</span><span class="s5">2</span><span class="s1">) != rn:</span>
                <span class="s3">raise </span><span class="s1">err</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'bottle.request.body'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">_body(self):</span>
        <span class="s1">body_iter = self._iter_chunked </span><span class="s3">if </span><span class="s1">self.chunked </span><span class="s3">else </span><span class="s1">self._iter_body</span>
        <span class="s1">read_func = self.environ[</span><span class="s4">'wsgi.input'</span><span class="s1">].read</span>
        <span class="s1">body</span><span class="s3">, </span><span class="s1">body_size</span><span class="s3">, </span><span class="s1">is_temp_file = BytesIO()</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, False</span>
        <span class="s3">for </span><span class="s1">part </span><span class="s3">in </span><span class="s1">body_iter(read_func</span><span class="s3">, </span><span class="s1">self.MEMFILE_MAX):</span>
            <span class="s1">body.write(part)</span>
            <span class="s1">body_size += len(part)</span>
            <span class="s3">if not </span><span class="s1">is_temp_file </span><span class="s3">and </span><span class="s1">body_size &gt; self.MEMFILE_MAX:</span>
                <span class="s1">body</span><span class="s3">, </span><span class="s1">tmp = TemporaryFile(mode=</span><span class="s4">'w+b'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">body</span>
                <span class="s1">body.write(tmp.getvalue())</span>
                <span class="s3">del </span><span class="s1">tmp</span>
                <span class="s1">is_temp_file = </span><span class="s3">True</span>
        <span class="s1">self.environ[</span><span class="s4">'wsgi.input'</span><span class="s1">] = body</span>
        <span class="s1">body.seek(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">body</span>

    <span class="s3">def </span><span class="s1">_get_body_string(self):</span>
        <span class="s2">''' read body until content-length or MEMFILE_MAX into a string. Raise 
            HTTPError(413) on requests that are to large. '''</span>
        <span class="s1">clen = self.content_length</span>
        <span class="s3">if </span><span class="s1">clen &gt; self.MEMFILE_MAX:</span>
            <span class="s3">raise </span><span class="s1">HTTPError(</span><span class="s5">413</span><span class="s3">, </span><span class="s4">'Request to large'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">clen &lt; </span><span class="s5">0</span><span class="s1">: clen = self.MEMFILE_MAX + </span><span class="s5">1</span>
        <span class="s1">data = self.body.read(clen)</span>
        <span class="s3">if </span><span class="s1">len(data) &gt; self.MEMFILE_MAX: </span><span class="s0"># Fail fast</span>
            <span class="s3">raise </span><span class="s1">HTTPError(</span><span class="s5">413</span><span class="s3">, </span><span class="s4">'Request to large'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">data</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">body(self):</span>
        <span class="s2">&quot;&quot;&quot; The HTTP request body as a seek-able file-like object. Depending on 
            :attr:`MEMFILE_MAX`, this is either a temporary file or a 
            :class:`io.BytesIO` instance. Accessing this property for the first 
            time reads and replaces the ``wsgi.input`` environ variable. 
            Subsequent accesses just do a `seek(0)` on the file object. &quot;&quot;&quot;</span>
        <span class="s1">self._body.seek(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._body</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">chunked(self):</span>
        <span class="s2">''' True if Chunked transfer encoding was. '''</span>
        <span class="s3">return </span><span class="s4">'chunked' </span><span class="s3">in </span><span class="s1">self.environ.get(</span><span class="s4">'HTTP_TRANSFER_ENCODING'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">).lower()</span>

    <span class="s0">#: An alias for :attr:`query`.</span>
    <span class="s1">GET = query</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'bottle.request.post'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">POST(self):</span>
        <span class="s2">&quot;&quot;&quot; The values of :attr:`forms` and :attr:`files` combined into a single 
            :class:`FormsDict`. Values are either strings (form values) or 
            instances of :class:`cgi.FieldStorage` (file uploads). 
        &quot;&quot;&quot;</span>
        <span class="s1">post = FormsDict()</span>
        <span class="s0"># We default to application/x-www-form-urlencoded for everything that</span>
        <span class="s0"># is not multipart and take the fast path (also: 3.1 workaround)</span>
        <span class="s3">if not </span><span class="s1">self.content_type.startswith(</span><span class="s4">'multipart/'</span><span class="s1">):</span>
            <span class="s1">pairs = _parse_qsl(tonat(self._get_body_string()</span><span class="s3">, </span><span class="s4">'latin1'</span><span class="s1">))</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">pairs:</span>
                <span class="s1">post[key] = value</span>
            <span class="s3">return </span><span class="s1">post</span>

        <span class="s1">safe_env = {</span><span class="s4">'QUERY_STRING'</span><span class="s1">:</span><span class="s4">''</span><span class="s1">} </span><span class="s0"># Build a safe environment for cgi</span>
        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'REQUEST_METHOD'</span><span class="s3">, </span><span class="s4">'CONTENT_TYPE'</span><span class="s3">, </span><span class="s4">'CONTENT_LENGTH'</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.environ: safe_env[key] = self.environ[key]</span>
        <span class="s1">args = dict(fp=self.body</span><span class="s3">, </span><span class="s1">environ=safe_env</span><span class="s3">, </span><span class="s1">keep_blank_values=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">py31:</span>
            <span class="s1">args[</span><span class="s4">'fp'</span><span class="s1">] = NCTextIOWrapper(args[</span><span class="s4">'fp'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s4">'utf8'</span><span class="s3">,</span>
                                         <span class="s1">newline=</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">py3k:</span>
            <span class="s1">args[</span><span class="s4">'encoding'</span><span class="s1">] = </span><span class="s4">'utf8'</span>
            <span class="s1">post.recode_unicode = </span><span class="s3">False</span>
        <span class="s1">data = cgi.FieldStorage(**args)</span>
        <span class="s1">self[</span><span class="s4">'_cgi.FieldStorage'</span><span class="s1">] = data </span><span class="s0">#http://bugs.python.org/issue18394#msg207958</span>
        <span class="s1">data = data.list </span><span class="s3">or </span><span class="s1">[]</span>
        <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">data:</span>
            <span class="s3">if </span><span class="s1">item.filename </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">post[item.name] = item.value</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">post[item.name] = FileUpload(item.file</span><span class="s3">, </span><span class="s1">item.name</span><span class="s3">,</span>
                                             <span class="s1">item.filename</span><span class="s3">, </span><span class="s1">item.headers)</span>
        <span class="s3">return </span><span class="s1">post</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">url(self):</span>
        <span class="s2">&quot;&quot;&quot; The full request URI including hostname and scheme. If your app 
            lives behind a reverse proxy or load balancer and you get confusing 
            results, make sure that the ``X-Forwarded-Host`` header is set 
            correctly. &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.urlparts.geturl()</span>

    <span class="s1">@DictProperty(</span><span class="s4">'environ'</span><span class="s3">, </span><span class="s4">'bottle.request.urlparts'</span><span class="s3">, </span><span class="s1">read_only=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">urlparts(self):</span>
        <span class="s2">''' The :attr:`url` string as an :class:`urlparse.SplitResult` tuple. 
            The tuple contains (scheme, host, path, query_string and fragment), 
            but the fragment is always empty because it is not visible to the 
            server. '''</span>
        <span class="s1">env = self.environ</span>
        <span class="s1">http = env.get(</span><span class="s4">'HTTP_X_FORWARDED_PROTO'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">env.get(</span><span class="s4">'wsgi.url_scheme'</span><span class="s3">, </span><span class="s4">'http'</span><span class="s1">)</span>
        <span class="s1">host = env.get(</span><span class="s4">'HTTP_X_FORWARDED_HOST'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">env.get(</span><span class="s4">'HTTP_HOST'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">host:</span>
            <span class="s0"># HTTP 1.1 requires a Host-header. This is for HTTP/1.0 clients.</span>
            <span class="s1">host = env.get(</span><span class="s4">'SERVER_NAME'</span><span class="s3">, </span><span class="s4">'127.0.0.1'</span><span class="s1">)</span>
            <span class="s1">port = env.get(</span><span class="s4">'SERVER_PORT'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">port </span><span class="s3">and </span><span class="s1">port != (</span><span class="s4">'80' </span><span class="s3">if </span><span class="s1">http == </span><span class="s4">'http' </span><span class="s3">else </span><span class="s4">'443'</span><span class="s1">):</span>
                <span class="s1">host += </span><span class="s4">':' </span><span class="s1">+ port</span>
        <span class="s1">path = urlquote(self.fullpath)</span>
        <span class="s3">return </span><span class="s1">UrlSplitResult(http</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">env.get(</span><span class="s4">'QUERY_STRING'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">fullpath(self):</span>
        <span class="s2">&quot;&quot;&quot; Request path including :attr:`script_name` (if present). &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">urljoin(self.script_name</span><span class="s3">, </span><span class="s1">self.path.lstrip(</span><span class="s4">'/'</span><span class="s1">))</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">query_string(self):</span>
        <span class="s2">&quot;&quot;&quot; The raw :attr:`query` part of the URL (everything in between ``?`` 
            and ``#``) as a string. &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.environ.get(</span><span class="s4">'QUERY_STRING'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">script_name(self):</span>
        <span class="s2">''' The initial portion of the URL's `path` that was removed by a higher 
            level (server or routing middleware) before the application was 
            called. This script path is returned with leading and tailing 
            slashes. '''</span>
        <span class="s1">script_name = self.environ.get(</span><span class="s4">'SCRIPT_NAME'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">).strip(</span><span class="s4">'/'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s4">'/' </span><span class="s1">+ script_name + </span><span class="s4">'/' </span><span class="s3">if </span><span class="s1">script_name </span><span class="s3">else </span><span class="s4">'/'</span>

    <span class="s3">def </span><span class="s1">path_shift(self</span><span class="s3">, </span><span class="s1">shift=</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s2">''' Shift path segments from :attr:`path` to :attr:`script_name` and 
            vice versa. 
 
           :param shift: The number of path segments to shift. May be negative 
                         to change the shift direction. (default: 1) 
        '''</span>
        <span class="s1">script = self.environ.get(</span><span class="s4">'SCRIPT_NAME'</span><span class="s3">,</span><span class="s4">'/'</span><span class="s1">)</span>
        <span class="s1">self[</span><span class="s4">'SCRIPT_NAME'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self[</span><span class="s4">'PATH_INFO'</span><span class="s1">] = path_shift(script</span><span class="s3">, </span><span class="s1">self.path</span><span class="s3">, </span><span class="s1">shift)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">content_length(self):</span>
        <span class="s2">''' The request body length as an integer. The client is responsible to 
            set this header. Otherwise, the real length of the body is unknown 
            and -1 is returned. In this case, :attr:`body` will be empty. '''</span>
        <span class="s3">return </span><span class="s1">int(self.environ.get(</span><span class="s4">'CONTENT_LENGTH'</span><span class="s1">) </span><span class="s3">or </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">content_type(self):</span>
        <span class="s2">''' The Content-Type header as a lowercase-string (default: empty). '''</span>
        <span class="s3">return </span><span class="s1">self.environ.get(</span><span class="s4">'CONTENT_TYPE'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">).lower()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_xhr(self):</span>
        <span class="s2">''' True if the request was triggered by a XMLHttpRequest. This only 
            works with JavaScript libraries that support the `X-Requested-With` 
            header (most of the popular libraries do). '''</span>
        <span class="s1">requested_with = self.environ.get(</span><span class="s4">'HTTP_X_REQUESTED_WITH'</span><span class="s3">,</span><span class="s4">''</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">requested_with.lower() == </span><span class="s4">'xmlhttprequest'</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_ajax(self):</span>
        <span class="s2">''' Alias for :attr:`is_xhr`. &quot;Ajax&quot; is not the right term. '''</span>
        <span class="s3">return </span><span class="s1">self.is_xhr</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">auth(self):</span>
        <span class="s2">&quot;&quot;&quot; HTTP authentication data as a (user, password) tuple. This 
            implementation currently supports basic (not digest) authentication 
            only. If the authentication happened at a higher level (e.g. in the 
            front web-server or a middleware), the password field is None, but 
            the user field is looked up from the ``REMOTE_USER`` environ 
            variable. On any errors, None is returned. &quot;&quot;&quot;</span>
        <span class="s1">basic = parse_auth(self.environ.get(</span><span class="s4">'HTTP_AUTHORIZATION'</span><span class="s3">,</span><span class="s4">''</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">basic: </span><span class="s3">return </span><span class="s1">basic</span>
        <span class="s1">ruser = self.environ.get(</span><span class="s4">'REMOTE_USER'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">ruser: </span><span class="s3">return </span><span class="s1">(ruser</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">return None</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">remote_route(self):</span>
        <span class="s2">&quot;&quot;&quot; A list of all IPs that were involved in this request, starting with 
            the client IP and followed by zero or more proxies. This does only 
            work if all proxies support the ```X-Forwarded-For`` header. Note 
            that this information can be forged by malicious clients. &quot;&quot;&quot;</span>
        <span class="s1">proxy = self.environ.get(</span><span class="s4">'HTTP_X_FORWARDED_FOR'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">proxy: </span><span class="s3">return </span><span class="s1">[ip.strip() </span><span class="s3">for </span><span class="s1">ip </span><span class="s3">in </span><span class="s1">proxy.split(</span><span class="s4">','</span><span class="s1">)]</span>
        <span class="s1">remote = self.environ.get(</span><span class="s4">'REMOTE_ADDR'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">[remote] </span><span class="s3">if </span><span class="s1">remote </span><span class="s3">else </span><span class="s1">[]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">remote_addr(self):</span>
        <span class="s2">&quot;&quot;&quot; The client IP as a string. Note that this information can be forged 
            by malicious clients. &quot;&quot;&quot;</span>
        <span class="s1">route = self.remote_route</span>
        <span class="s3">return </span><span class="s1">route[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">if </span><span class="s1">route </span><span class="s3">else None</span>

    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s2">&quot;&quot;&quot; Return a new :class:`Request` with a shallow :attr:`environ` copy. &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Request(self.environ.copy())</span>

    <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">): </span><span class="s3">return </span><span class="s1">self.environ.get(value</span><span class="s3">, </span><span class="s1">default)</span>
    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key): </span><span class="s3">return </span><span class="s1">self.environ[key]</span>
    <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">key): self[key] = </span><span class="s4">&quot;&quot;</span><span class="s1">; </span><span class="s3">del</span><span class="s1">(self.environ[key])</span>
    <span class="s3">def </span><span class="s1">__iter__(self): </span><span class="s3">return </span><span class="s1">iter(self.environ)</span>
    <span class="s3">def </span><span class="s1">__len__(self): </span><span class="s3">return </span><span class="s1">len(self.environ)</span>
    <span class="s3">def </span><span class="s1">keys(self): </span><span class="s3">return </span><span class="s1">self.environ.keys()</span>
    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s2">&quot;&quot;&quot; Change an environ value and clear all caches that depend on it. &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self.environ.get(</span><span class="s4">'bottle.request.readonly'</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">KeyError(</span><span class="s4">'The environ dictionary is read-only.'</span><span class="s1">)</span>

        <span class="s1">self.environ[key] = value</span>
        <span class="s1">todelete = ()</span>

        <span class="s3">if </span><span class="s1">key == </span><span class="s4">'wsgi.input'</span><span class="s1">:</span>
            <span class="s1">todelete = (</span><span class="s4">'body'</span><span class="s3">, </span><span class="s4">'forms'</span><span class="s3">, </span><span class="s4">'files'</span><span class="s3">, </span><span class="s4">'params'</span><span class="s3">, </span><span class="s4">'post'</span><span class="s3">, </span><span class="s4">'json'</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">key == </span><span class="s4">'QUERY_STRING'</span><span class="s1">:</span>
            <span class="s1">todelete = (</span><span class="s4">'query'</span><span class="s3">, </span><span class="s4">'params'</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">key.startswith(</span><span class="s4">'HTTP_'</span><span class="s1">):</span>
            <span class="s1">todelete = (</span><span class="s4">'headers'</span><span class="s3">, </span><span class="s4">'cookies'</span><span class="s1">)</span>

        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">todelete:</span>
            <span class="s1">self.environ.pop(</span><span class="s4">'bottle.request.'</span><span class="s1">+key</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">'&lt;%s: %s %s&gt;' </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">self.method</span><span class="s3">, </span><span class="s1">self.url)</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s2">''' Search in self.environ for additional user defined attributes. '''</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">var = self.environ[</span><span class="s4">'bottle.request.ext.%s'</span><span class="s1">%name]</span>
            <span class="s3">return </span><span class="s1">var.__get__(self) </span><span class="s3">if </span><span class="s1">hasattr(var</span><span class="s3">, </span><span class="s4">'__get__'</span><span class="s1">) </span><span class="s3">else </span><span class="s1">var</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span><span class="s4">'Attribute %r not defined.' </span><span class="s1">% name)</span>

    <span class="s3">def </span><span class="s1">__setattr__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">if </span><span class="s1">name == </span><span class="s4">'environ'</span><span class="s1">: </span><span class="s3">return </span><span class="s1">object.__setattr__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s1">self.environ[</span><span class="s4">'bottle.request.ext.%s'</span><span class="s1">%name] = value</span>


<span class="s3">def </span><span class="s1">_hkey(key):</span>
    <span class="s3">if </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">' </span><span class="s3">in </span><span class="s1">key </span><span class="s3">or </span><span class="s4">'</span><span class="s3">\r</span><span class="s4">' </span><span class="s3">in </span><span class="s1">key </span><span class="s3">or </span><span class="s4">'</span><span class="s3">\0</span><span class="s4">' </span><span class="s3">in </span><span class="s1">key:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Header names must not contain control characters: %r&quot; </span><span class="s1">% key)</span>
    <span class="s3">return </span><span class="s1">key.title().replace(</span><span class="s4">'_'</span><span class="s3">, </span><span class="s4">'-'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_hval(value):</span>
    <span class="s1">value = tonat(value)</span>
    <span class="s3">if </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">' </span><span class="s3">in </span><span class="s1">value </span><span class="s3">or </span><span class="s4">'</span><span class="s3">\r</span><span class="s4">' </span><span class="s3">in </span><span class="s1">value </span><span class="s3">or </span><span class="s4">'</span><span class="s3">\0</span><span class="s4">' </span><span class="s3">in </span><span class="s1">value:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Header value must not contain control characters: %r&quot; </span><span class="s1">% value)</span>
    <span class="s3">return </span><span class="s1">value</span>



<span class="s3">class </span><span class="s1">HeaderProperty(object):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">reader=</span><span class="s3">None, </span><span class="s1">writer=</span><span class="s3">None, </span><span class="s1">default=</span><span class="s4">''</span><span class="s1">):</span>
        <span class="s1">self.name</span><span class="s3">, </span><span class="s1">self.default = name</span><span class="s3">, </span><span class="s1">default</span>
        <span class="s1">self.reader</span><span class="s3">, </span><span class="s1">self.writer = reader</span><span class="s3">, </span><span class="s1">writer</span>
        <span class="s1">self.__doc__ = </span><span class="s4">'Current value of the %r header.' </span><span class="s1">% name.title()</span>

    <span class="s3">def </span><span class="s1">__get__(self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">cls):</span>
        <span class="s3">if </span><span class="s1">obj </span><span class="s3">is None</span><span class="s1">: </span><span class="s3">return </span><span class="s1">self</span>
        <span class="s1">value = obj.get_header(self.name</span><span class="s3">, </span><span class="s1">self.default)</span>
        <span class="s3">return </span><span class="s1">self.reader(value) </span><span class="s3">if </span><span class="s1">self.reader </span><span class="s3">else </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">__set__(self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s1">obj[self.name] = self.writer(value) </span><span class="s3">if </span><span class="s1">self.writer </span><span class="s3">else </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">__delete__(self</span><span class="s3">, </span><span class="s1">obj):</span>
        <span class="s3">del </span><span class="s1">obj[self.name]</span>


<span class="s3">class </span><span class="s1">BaseResponse(object):</span>
    <span class="s2">&quot;&quot;&quot; Storage class for a response body as well as headers and cookies. 
 
        This class does support dict-like case-insensitive item-access to 
        headers, but is NOT a dict. Most notably, iterating over a response 
        yields parts of the body and not the headers. 
 
        :param body: The response body as one of the supported types. 
        :param status: Either an HTTP status code (e.g. 200) or a status line 
                       including the reason phrase (e.g. '200 OK'). 
        :param headers: A dictionary or a list of name-value pairs. 
 
        Additional keyword arguments are added to the list of headers. 
        Underscores in the header name are replaced with dashes. 
    &quot;&quot;&quot;</span>

    <span class="s1">default_status = </span><span class="s5">200</span>
    <span class="s1">default_content_type = </span><span class="s4">'text/html; charset=UTF-8'</span>

    <span class="s0"># Header blacklist for specific response codes</span>
    <span class="s0"># (rfc2616 section 10.2.3 and 10.3.5)</span>
    <span class="s1">bad_headers = {</span>
        <span class="s5">204</span><span class="s1">: set((</span><span class="s4">'Content-Type'</span><span class="s3">,</span><span class="s1">))</span><span class="s3">,</span>
        <span class="s5">304</span><span class="s1">: set((</span><span class="s4">'Allow'</span><span class="s3">, </span><span class="s4">'Content-Encoding'</span><span class="s3">, </span><span class="s4">'Content-Language'</span><span class="s3">,</span>
                  <span class="s4">'Content-Length'</span><span class="s3">, </span><span class="s4">'Content-Range'</span><span class="s3">, </span><span class="s4">'Content-Type'</span><span class="s3">,</span>
                  <span class="s4">'Content-Md5'</span><span class="s3">, </span><span class="s4">'Last-Modified'</span><span class="s1">))}</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">body=</span><span class="s4">''</span><span class="s3">, </span><span class="s1">status=</span><span class="s3">None, </span><span class="s1">headers=</span><span class="s3">None, </span><span class="s1">**more_headers):</span>
        <span class="s1">self._cookies = </span><span class="s3">None</span>
        <span class="s1">self._headers = {}</span>
        <span class="s1">self.body = body</span>
        <span class="s1">self.status = status </span><span class="s3">or </span><span class="s1">self.default_status</span>
        <span class="s3">if </span><span class="s1">headers:</span>
            <span class="s3">if </span><span class="s1">isinstance(headers</span><span class="s3">, </span><span class="s1">dict):</span>
                <span class="s1">headers = headers.items()</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">headers:</span>
                <span class="s1">self.add_header(name</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s3">if </span><span class="s1">more_headers:</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">more_headers.items():</span>
                <span class="s1">self.add_header(name</span><span class="s3">, </span><span class="s1">value)</span>

    <span class="s3">def </span><span class="s1">copy(self</span><span class="s3">, </span><span class="s1">cls=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">''' Returns a copy of self. '''</span>
        <span class="s1">cls = cls </span><span class="s3">or </span><span class="s1">BaseResponse</span>
        <span class="s3">assert </span><span class="s1">issubclass(cls</span><span class="s3">, </span><span class="s1">BaseResponse)</span>
        <span class="s1">copy = cls()</span>
        <span class="s1">copy.status = self.status</span>
        <span class="s1">copy._headers = dict((k</span><span class="s3">, </span><span class="s1">v[:]) </span><span class="s3">for </span><span class="s1">(k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">in </span><span class="s1">self._headers.items())</span>
        <span class="s3">if </span><span class="s1">self._cookies:</span>
            <span class="s1">copy._cookies = SimpleCookie()</span>
            <span class="s1">copy._cookies.load(self._cookies.output(header=</span><span class="s4">''</span><span class="s1">))</span>
        <span class="s3">return </span><span class="s1">copy</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s3">return </span><span class="s1">iter(self.body)</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self.body</span><span class="s3">, </span><span class="s4">'close'</span><span class="s1">):</span>
            <span class="s1">self.body.close()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">status_line(self):</span>
        <span class="s2">''' The HTTP status line as a string (e.g. ``404 Not Found``).'''</span>
        <span class="s3">return </span><span class="s1">self._status_line</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">status_code(self):</span>
        <span class="s2">''' The HTTP status code as an integer (e.g. 404).'''</span>
        <span class="s3">return </span><span class="s1">self._status_code</span>

    <span class="s3">def </span><span class="s1">_set_status(self</span><span class="s3">, </span><span class="s1">status):</span>
        <span class="s3">if </span><span class="s1">isinstance(status</span><span class="s3">, </span><span class="s1">int):</span>
            <span class="s1">code</span><span class="s3">, </span><span class="s1">status = status</span><span class="s3">, </span><span class="s1">_HTTP_STATUS_LINES.get(status)</span>
        <span class="s3">elif </span><span class="s4">' ' </span><span class="s3">in </span><span class="s1">status:</span>
            <span class="s1">status = status.strip()</span>
            <span class="s1">code   = int(status.split()[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'String status line without a reason phrase.'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s5">100 </span><span class="s1">&lt;= code &lt;= </span><span class="s5">999</span><span class="s1">: </span><span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Status code out of range.'</span><span class="s1">)</span>
        <span class="s1">self._status_code = code</span>
        <span class="s1">self._status_line = str(status </span><span class="s3">or </span><span class="s1">(</span><span class="s4">'%d Unknown' </span><span class="s1">% code))</span>

    <span class="s3">def </span><span class="s1">_get_status(self):</span>
        <span class="s3">return </span><span class="s1">self._status_line</span>

    <span class="s1">status = property(_get_status</span><span class="s3">, </span><span class="s1">_set_status</span><span class="s3">, None,</span>
        <span class="s4">''' A writeable property to change the HTTP response status. It accepts 
            either a numeric code (100-999) or a string with a custom reason 
            phrase (e.g. &quot;404 Brain not found&quot;). Both :data:`status_line` and 
            :data:`status_code` are updated accordingly. The return value is 
            always a status string. '''</span><span class="s1">)</span>
    <span class="s3">del </span><span class="s1">_get_status</span><span class="s3">, </span><span class="s1">_set_status</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">headers(self):</span>
        <span class="s2">''' An instance of :class:`HeaderDict`, a case-insensitive dict-like 
            view on the response headers. '''</span>
        <span class="s1">hdict = HeaderDict()</span>
        <span class="s1">hdict.dict = self._headers</span>
        <span class="s3">return </span><span class="s1">hdict</span>

    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">name): </span><span class="s3">return </span><span class="s1">_hkey(name) </span><span class="s3">in </span><span class="s1">self._headers</span>
    <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">name):  </span><span class="s3">del </span><span class="s1">self._headers[_hkey(name)]</span>
    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">name):  </span><span class="s3">return </span><span class="s1">self._headers[_hkey(name)][-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value): self._headers[_hkey(name)] = [_hval(value)]</span>

    <span class="s3">def </span><span class="s1">get_header(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">''' Return the value of a previously defined header. If there is no 
            header with that name, return a default value. '''</span>
        <span class="s3">return </span><span class="s1">self._headers.get(_hkey(name)</span><span class="s3">, </span><span class="s1">[default])[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">set_header(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s2">''' Create a new response header, replacing any previously defined 
            headers with the same name. '''</span>
        <span class="s1">self._headers[_hkey(name)] = [_hval(value)]</span>

    <span class="s3">def </span><span class="s1">add_header(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s2">''' Add an additional response header, not removing duplicates. '''</span>
        <span class="s1">self._headers.setdefault(_hkey(name)</span><span class="s3">, </span><span class="s1">[]).append(_hval(value))</span>

    <span class="s3">def </span><span class="s1">iter_headers(self):</span>
        <span class="s2">''' Yield (header, value) tuples, skipping headers that are not 
            allowed with the current response status code. '''</span>
        <span class="s3">return </span><span class="s1">self.headerlist</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">headerlist(self):</span>
        <span class="s2">&quot;&quot;&quot; WSGI conform list of (header, value) tuples. &quot;&quot;&quot;</span>
        <span class="s1">out = []</span>
        <span class="s1">headers = list(self._headers.items())</span>
        <span class="s3">if </span><span class="s4">'Content-Type' </span><span class="s3">not in </span><span class="s1">self._headers:</span>
            <span class="s1">headers.append((</span><span class="s4">'Content-Type'</span><span class="s3">, </span><span class="s1">[self.default_content_type]))</span>
        <span class="s3">if </span><span class="s1">self._status_code </span><span class="s3">in </span><span class="s1">self.bad_headers:</span>
            <span class="s1">bad_headers = self.bad_headers[self._status_code]</span>
            <span class="s1">headers = [h </span><span class="s3">for </span><span class="s1">h </span><span class="s3">in </span><span class="s1">headers </span><span class="s3">if </span><span class="s1">h[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">bad_headers]</span>
        <span class="s1">out += [(name</span><span class="s3">, </span><span class="s1">val) </span><span class="s3">for </span><span class="s1">(name</span><span class="s3">, </span><span class="s1">vals) </span><span class="s3">in </span><span class="s1">headers </span><span class="s3">for </span><span class="s1">val </span><span class="s3">in </span><span class="s1">vals]</span>
        <span class="s3">if </span><span class="s1">self._cookies:</span>
            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self._cookies.values():</span>
                <span class="s1">out.append((</span><span class="s4">'Set-Cookie'</span><span class="s3">, </span><span class="s1">_hval(c.OutputString())))</span>
        <span class="s3">if </span><span class="s1">py3k:</span>
            <span class="s1">out = [(k</span><span class="s3">, </span><span class="s1">v.encode(</span><span class="s4">'utf8'</span><span class="s1">).decode(</span><span class="s4">'latin1'</span><span class="s1">)) </span><span class="s3">for </span><span class="s1">(k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">in </span><span class="s1">out]</span>
        <span class="s3">return </span><span class="s1">out</span>

    <span class="s1">content_type = HeaderProperty(</span><span class="s4">'Content-Type'</span><span class="s1">)</span>
    <span class="s1">content_length = HeaderProperty(</span><span class="s4">'Content-Length'</span><span class="s3">, </span><span class="s1">reader=int)</span>
    <span class="s1">expires = HeaderProperty(</span><span class="s4">'Expires'</span><span class="s3">,</span>
        <span class="s1">reader=</span><span class="s3">lambda </span><span class="s1">x: datetime.utcfromtimestamp(parse_date(x))</span><span class="s3">,</span>
        <span class="s1">writer=</span><span class="s3">lambda </span><span class="s1">x: http_date(x))</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">charset(self</span><span class="s3">, </span><span class="s1">default=</span><span class="s4">'UTF-8'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; Return the charset specified in the content-type header (default: utf8). &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s4">'charset=' </span><span class="s3">in </span><span class="s1">self.content_type:</span>
            <span class="s3">return </span><span class="s1">self.content_type.split(</span><span class="s4">'charset='</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">].split(</span><span class="s4">';'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">].strip()</span>
        <span class="s3">return </span><span class="s1">default</span>

    <span class="s3">def </span><span class="s1">set_cookie(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">secret=</span><span class="s3">None, </span><span class="s1">**options):</span>
        <span class="s2">''' Create a new cookie or replace an old one. If the `secret` parameter is 
            set, create a `Signed Cookie` (described below). 
 
            :param name: the name of the cookie. 
            :param value: the value of the cookie. 
            :param secret: a signature key required for signed cookies. 
 
            Additionally, this method accepts all RFC 2109 attributes that are 
            supported by :class:`cookie.Morsel`, including: 
 
            :param max_age: maximum age in seconds. (default: None) 
            :param expires: a datetime object or UNIX timestamp. (default: None) 
            :param domain: the domain that is allowed to read the cookie. 
              (default: current domain) 
            :param path: limits the cookie to a given path (default: current path) 
            :param secure: limit the cookie to HTTPS connections (default: off). 
            :param httponly: prevents client-side javascript to read this cookie 
              (default: off, requires Python 2.6 or newer). 
 
            If neither `expires` nor `max_age` is set (default), the cookie will 
            expire at the end of the browser session (as soon as the browser 
            window is closed). 
 
            Signed cookies may store any pickle-able object and are 
            cryptographically signed to prevent manipulation. Keep in mind that 
            cookies are limited to 4kb in most browsers. 
 
            Warning: Signed cookies are not encrypted (the client can still see 
            the content) and not copy-protected (the client can restore an old 
            cookie). The main intention is to make pickling and unpickling 
            save, not to store secret information at client side. 
        '''</span>
        <span class="s3">if not </span><span class="s1">self._cookies:</span>
            <span class="s1">self._cookies = SimpleCookie()</span>

        <span class="s3">if </span><span class="s1">secret:</span>
            <span class="s1">value = touni(cookie_encode((name</span><span class="s3">, </span><span class="s1">value)</span><span class="s3">, </span><span class="s1">secret))</span>
        <span class="s3">elif not </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'Secret key missing for non-string Cookie.'</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">len(value) &gt; </span><span class="s5">4096</span><span class="s1">: </span><span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Cookie value to long.'</span><span class="s1">)</span>
        <span class="s1">self._cookies[name] = value</span>

        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">options.items():</span>
            <span class="s3">if </span><span class="s1">key == </span><span class="s4">'max_age'</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">timedelta):</span>
                    <span class="s1">value = value.seconds + value.days * </span><span class="s5">24 </span><span class="s1">* </span><span class="s5">3600</span>
            <span class="s3">if </span><span class="s1">key == </span><span class="s4">'expires'</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">(datedate</span><span class="s3">, </span><span class="s1">datetime)):</span>
                    <span class="s1">value = value.timetuple()</span>
                <span class="s3">elif </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">(int</span><span class="s3">, </span><span class="s1">float)):</span>
                    <span class="s1">value = time.gmtime(value)</span>
                <span class="s1">value = time.strftime(</span><span class="s4">&quot;%a, %d %b %Y %H:%M:%S GMT&quot;</span><span class="s3">, </span><span class="s1">value)</span>
            <span class="s1">self._cookies[name][key.replace(</span><span class="s4">'_'</span><span class="s3">, </span><span class="s4">'-'</span><span class="s1">)] = value</span>

    <span class="s3">def </span><span class="s1">delete_cookie(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">''' Delete a cookie. Be sure to use the same `domain` and `path` 
            settings as used to create the cookie. '''</span>
        <span class="s1">kwargs[</span><span class="s4">'max_age'</span><span class="s1">] = -</span><span class="s5">1</span>
        <span class="s1">kwargs[</span><span class="s4">'expires'</span><span class="s1">] = </span><span class="s5">0</span>
        <span class="s1">self.set_cookie(key</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">out = </span><span class="s4">''</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self.headerlist:</span>
            <span class="s1">out += </span><span class="s4">'%s: %s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (name.title()</span><span class="s3">, </span><span class="s1">value.strip())</span>
        <span class="s3">return </span><span class="s1">out</span>


<span class="s3">def </span><span class="s1">local_property(name=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s1">name: depr(</span><span class="s4">'local_property() is deprecated and will be removed.'</span><span class="s1">) </span><span class="s0">#0.12</span>
    <span class="s1">ls = threading.local()</span>
    <span class="s3">def </span><span class="s1">fget(self):</span>
        <span class="s3">try</span><span class="s1">: </span><span class="s3">return </span><span class="s1">ls.var</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;Request context not initialized.&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">fset(self</span><span class="s3">, </span><span class="s1">value): ls.var = value</span>
    <span class="s3">def </span><span class="s1">fdel(self): </span><span class="s3">del </span><span class="s1">ls.var</span>
    <span class="s3">return </span><span class="s1">property(fget</span><span class="s3">, </span><span class="s1">fset</span><span class="s3">, </span><span class="s1">fdel</span><span class="s3">, </span><span class="s4">'Thread-local property'</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">LocalRequest(BaseRequest):</span>
    <span class="s2">''' A thread-local subclass of :class:`BaseRequest` with a different 
        set of attributes for each thread. There is usually only one global 
        instance of this class (:data:`request`). If accessed during a 
        request/response cycle, this instance always refers to the *current* 
        request (even on a multithreaded server). '''</span>
    <span class="s1">bind = BaseRequest.__init__</span>
    <span class="s1">environ = local_property()</span>


<span class="s3">class </span><span class="s1">LocalResponse(BaseResponse):</span>
    <span class="s2">''' A thread-local subclass of :class:`BaseResponse` with a different 
        set of attributes for each thread. There is usually only one global 
        instance of this class (:data:`response`). Its attributes are used 
        to build the HTTP response at the end of the request/response cycle. 
    '''</span>
    <span class="s1">bind = BaseResponse.__init__</span>
    <span class="s1">_status_line = local_property()</span>
    <span class="s1">_status_code = local_property()</span>
    <span class="s1">_cookies     = local_property()</span>
    <span class="s1">_headers     = local_property()</span>
    <span class="s1">body         = local_property()</span>


<span class="s1">Request = BaseRequest</span>
<span class="s1">Response = BaseResponse</span>


<span class="s3">class </span><span class="s1">HTTPResponse(Response</span><span class="s3">, </span><span class="s1">BottleException):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">body=</span><span class="s4">''</span><span class="s3">, </span><span class="s1">status=</span><span class="s3">None, </span><span class="s1">headers=</span><span class="s3">None, </span><span class="s1">**more_headers):</span>
        <span class="s1">super(HTTPResponse</span><span class="s3">, </span><span class="s1">self).__init__(body</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">**more_headers)</span>

    <span class="s3">def </span><span class="s1">apply(self</span><span class="s3">, </span><span class="s1">response):</span>
        <span class="s1">response._status_code = self._status_code</span>
        <span class="s1">response._status_line = self._status_line</span>
        <span class="s1">response._headers = self._headers</span>
        <span class="s1">response._cookies = self._cookies</span>
        <span class="s1">response.body = self.body</span>


<span class="s3">class </span><span class="s1">HTTPError(HTTPResponse):</span>
    <span class="s1">default_status = </span><span class="s5">500</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">status=</span><span class="s3">None, </span><span class="s1">body=</span><span class="s3">None, </span><span class="s1">exception=</span><span class="s3">None, </span><span class="s1">traceback=</span><span class="s3">None,</span>
                 <span class="s1">**options):</span>
        <span class="s1">self.exception = exception</span>
        <span class="s1">self.traceback = traceback</span>
        <span class="s1">super(HTTPError</span><span class="s3">, </span><span class="s1">self).__init__(body</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">**options)</span>





<span class="s0">###############################################################################</span>
<span class="s0"># Plugins ######################################################################</span>
<span class="s0">###############################################################################</span>

<span class="s3">class </span><span class="s1">PluginError(BottleException): </span><span class="s3">pass</span>


<span class="s3">class </span><span class="s1">JSONPlugin(object):</span>
    <span class="s1">name = </span><span class="s4">'json'</span>
    <span class="s1">api  = </span><span class="s5">2</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">json_dumps=json_dumps):</span>
        <span class="s1">self.json_dumps = json_dumps</span>

    <span class="s3">def </span><span class="s1">apply(self</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">route):</span>
        <span class="s1">dumps = self.json_dumps</span>
        <span class="s3">if not </span><span class="s1">dumps: </span><span class="s3">return </span><span class="s1">callback</span>
        <span class="s3">def </span><span class="s1">wrapper(*a</span><span class="s3">, </span><span class="s1">**ka):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">rv = callback(*a</span><span class="s3">, </span><span class="s1">**ka)</span>
            <span class="s3">except </span><span class="s1">HTTPResponse:</span>
                <span class="s1">rv = _e()</span>

            <span class="s3">if </span><span class="s1">isinstance(rv</span><span class="s3">, </span><span class="s1">dict):</span>
                <span class="s0">#Attempt to serialize, raises exception on failure</span>
                <span class="s1">json_response = dumps(rv)</span>
                <span class="s0">#Set content type only if serialization succesful</span>
                <span class="s1">response.content_type = </span><span class="s4">'application/json'</span>
                <span class="s3">return </span><span class="s1">json_response</span>
            <span class="s3">elif </span><span class="s1">isinstance(rv</span><span class="s3">, </span><span class="s1">HTTPResponse) </span><span class="s3">and </span><span class="s1">isinstance(rv.body</span><span class="s3">, </span><span class="s1">dict):</span>
                <span class="s1">rv.body = dumps(rv.body)</span>
                <span class="s1">rv.content_type = </span><span class="s4">'application/json'</span>
            <span class="s3">return </span><span class="s1">rv</span>

        <span class="s3">return </span><span class="s1">wrapper</span>


<span class="s3">class </span><span class="s1">TemplatePlugin(object):</span>
    <span class="s2">''' This plugin applies the :func:`view` decorator to all routes with a 
        `template` config parameter. If the parameter is a tuple, the second 
        element must be a dict with additional options (e.g. `template_engine`) 
        or default variables for the template. '''</span>
    <span class="s1">name = </span><span class="s4">'template'</span>
    <span class="s1">api  = </span><span class="s5">2</span>

    <span class="s3">def </span><span class="s1">apply(self</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">route):</span>
        <span class="s1">conf = route.config.get(</span><span class="s4">'template'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">isinstance(conf</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">list)) </span><span class="s3">and </span><span class="s1">len(conf) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">view(conf[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">**conf[</span><span class="s5">1</span><span class="s1">])(callback)</span>
        <span class="s3">elif </span><span class="s1">isinstance(conf</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s3">return </span><span class="s1">view(conf)(callback)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">callback</span>


<span class="s0">#: Not a plugin, but part of the plugin API. TODO: Find a better place.</span>
<span class="s3">class </span><span class="s1">_ImportRedirect(object):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">impmask):</span>
        <span class="s2">''' Create a virtual package that redirects imports (see PEP 302). '''</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.impmask = impmask</span>
        <span class="s1">self.module = sys.modules.setdefault(name</span><span class="s3">, </span><span class="s1">new_module(name))</span>
        <span class="s1">self.module.__dict__.update({</span><span class="s4">'__file__'</span><span class="s1">: __file__</span><span class="s3">, </span><span class="s4">'__path__'</span><span class="s1">: []</span><span class="s3">,</span>
                                    <span class="s4">'__all__'</span><span class="s1">: []</span><span class="s3">, </span><span class="s4">'__loader__'</span><span class="s1">: self})</span>
        <span class="s1">sys.meta_path.append(self)</span>

    <span class="s3">def </span><span class="s1">find_module(self</span><span class="s3">, </span><span class="s1">fullname</span><span class="s3">, </span><span class="s1">path=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s4">'.' </span><span class="s3">not in </span><span class="s1">fullname: </span><span class="s3">return</span>
        <span class="s1">packname = fullname.rsplit(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">packname != self.name: </span><span class="s3">return</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">load_module(self</span><span class="s3">, </span><span class="s1">fullname):</span>
        <span class="s3">if </span><span class="s1">fullname </span><span class="s3">in </span><span class="s1">sys.modules: </span><span class="s3">return </span><span class="s1">sys.modules[fullname]</span>
        <span class="s1">modname = fullname.rsplit(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">realname = self.impmask % modname</span>
        <span class="s1">__import__(realname)</span>
        <span class="s1">module = sys.modules[fullname] = sys.modules[realname]</span>
        <span class="s1">setattr(self.module</span><span class="s3">, </span><span class="s1">modname</span><span class="s3">, </span><span class="s1">module)</span>
        <span class="s1">module.__loader__ = self</span>
        <span class="s3">return </span><span class="s1">module</span>






<span class="s0">###############################################################################</span>
<span class="s0"># Common Utilities #############################################################</span>
<span class="s0">###############################################################################</span>


<span class="s3">class </span><span class="s1">MultiDict(DictMixin):</span>
    <span class="s2">&quot;&quot;&quot; This dict stores multiple values per key, but behaves exactly like a 
        normal dict in that it returns only the newest value for any given key. 
        There are special methods available to access the full list of values. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*a</span><span class="s3">, </span><span class="s1">**k):</span>
        <span class="s1">self.dict = dict((k</span><span class="s3">, </span><span class="s1">[v]) </span><span class="s3">for </span><span class="s1">(k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">in </span><span class="s1">dict(*a</span><span class="s3">, </span><span class="s1">**k).items())</span>

    <span class="s3">def </span><span class="s1">__len__(self): </span><span class="s3">return </span><span class="s1">len(self.dict)</span>
    <span class="s3">def </span><span class="s1">__iter__(self): </span><span class="s3">return </span><span class="s1">iter(self.dict)</span>
    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">key): </span><span class="s3">return </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.dict</span>
    <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">key): </span><span class="s3">del </span><span class="s1">self.dict[key]</span>
    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key): </span><span class="s3">return </span><span class="s1">self.dict[key][-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value): self.append(key</span><span class="s3">, </span><span class="s1">value)</span>
    <span class="s3">def </span><span class="s1">keys(self): </span><span class="s3">return </span><span class="s1">self.dict.keys()</span>

    <span class="s3">if </span><span class="s1">py3k:</span>
        <span class="s3">def </span><span class="s1">values(self): </span><span class="s3">return </span><span class="s1">(v[-</span><span class="s5">1</span><span class="s1">] </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.dict.values())</span>
        <span class="s3">def </span><span class="s1">items(self): </span><span class="s3">return </span><span class="s1">((k</span><span class="s3">, </span><span class="s1">v[-</span><span class="s5">1</span><span class="s1">]) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.dict.items())</span>
        <span class="s3">def </span><span class="s1">allitems(self):</span>
            <span class="s3">return </span><span class="s1">((k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">vl </span><span class="s3">in </span><span class="s1">self.dict.items() </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">vl)</span>
        <span class="s1">iterkeys = keys</span>
        <span class="s1">itervalues = values</span>
        <span class="s1">iteritems = items</span>
        <span class="s1">iterallitems = allitems</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">def </span><span class="s1">values(self): </span><span class="s3">return </span><span class="s1">[v[-</span><span class="s5">1</span><span class="s1">] </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.dict.values()]</span>
        <span class="s3">def </span><span class="s1">items(self): </span><span class="s3">return </span><span class="s1">[(k</span><span class="s3">, </span><span class="s1">v[-</span><span class="s5">1</span><span class="s1">]) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.dict.items()]</span>
        <span class="s3">def </span><span class="s1">iterkeys(self): </span><span class="s3">return </span><span class="s1">self.dict.iterkeys()</span>
        <span class="s3">def </span><span class="s1">itervalues(self): </span><span class="s3">return </span><span class="s1">(v[-</span><span class="s5">1</span><span class="s1">] </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.dict.itervalues())</span>
        <span class="s3">def </span><span class="s1">iteritems(self):</span>
            <span class="s3">return </span><span class="s1">((k</span><span class="s3">, </span><span class="s1">v[-</span><span class="s5">1</span><span class="s1">]) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.dict.iteritems())</span>
        <span class="s3">def </span><span class="s1">iterallitems(self):</span>
            <span class="s3">return </span><span class="s1">((k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">vl </span><span class="s3">in </span><span class="s1">self.dict.iteritems() </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">vl)</span>
        <span class="s3">def </span><span class="s1">allitems(self):</span>
            <span class="s3">return </span><span class="s1">[(k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">vl </span><span class="s3">in </span><span class="s1">self.dict.iteritems() </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">vl]</span>

    <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None, </span><span class="s1">index=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">type=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">''' Return the most recent value for a key. 
 
            :param default: The default value to be returned if the key is not 
                   present or the type conversion fails. 
            :param index: An index for the list of available values. 
            :param type: If defined, this callable is used to cast the value 
                    into a specific type. Exception are suppressed and result in 
                    the default value to be returned. 
        '''</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">val = self.dict[key][index]</span>
            <span class="s3">return </span><span class="s1">type(val) </span><span class="s3">if </span><span class="s1">type </span><span class="s3">else </span><span class="s1">val</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s3">pass</span>
        <span class="s3">return </span><span class="s1">default</span>

    <span class="s3">def </span><span class="s1">append(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s2">''' Add a new value to the list of values for this key. '''</span>
        <span class="s1">self.dict.setdefault(key</span><span class="s3">, </span><span class="s1">[]).append(value)</span>

    <span class="s3">def </span><span class="s1">replace(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s2">''' Replace the list of values with a single value. '''</span>
        <span class="s1">self.dict[key] = [value]</span>

    <span class="s3">def </span><span class="s1">getall(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s2">''' Return a (possibly empty) list of values for a key. '''</span>
        <span class="s3">return </span><span class="s1">self.dict.get(key) </span><span class="s3">or </span><span class="s1">[]</span>

    <span class="s0">#: Aliases for WTForms to mimic other multi-dict APIs (Django)</span>
    <span class="s1">getone = get</span>
    <span class="s1">getlist = getall</span>


<span class="s3">class </span><span class="s1">FormsDict(MultiDict):</span>
    <span class="s2">''' This :class:`MultiDict` subclass is used to store request form data. 
        Additionally to the normal dict-like item access methods (which return 
        unmodified data as native strings), this container also supports 
        attribute-like access to its values. Attributes are automatically de- 
        or recoded to match :attr:`input_encoding` (default: 'utf8'). Missing 
        attributes default to an empty string. '''</span>

    <span class="s0">#: Encoding used for attribute values.</span>
    <span class="s1">input_encoding = </span><span class="s4">'utf8'</span>
    <span class="s0">#: If true (default), unicode strings are first encoded with `latin1`</span>
    <span class="s0">#: and then decoded to match :attr:`input_encoding`.</span>
    <span class="s1">recode_unicode = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">_fix(self</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">isinstance(s</span><span class="s3">, </span><span class="s1">unicode) </span><span class="s3">and </span><span class="s1">self.recode_unicode: </span><span class="s0"># Python 3 WSGI</span>
            <span class="s3">return </span><span class="s1">s.encode(</span><span class="s4">'latin1'</span><span class="s1">).decode(encoding </span><span class="s3">or </span><span class="s1">self.input_encoding)</span>
        <span class="s3">elif </span><span class="s1">isinstance(s</span><span class="s3">, </span><span class="s1">bytes): </span><span class="s0"># Python 2 WSGI</span>
            <span class="s3">return </span><span class="s1">s.decode(encoding </span><span class="s3">or </span><span class="s1">self.input_encoding)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">s</span>

    <span class="s3">def </span><span class="s1">decode(self</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">''' Returns a copy with all keys and values de- or recoded to match 
            :attr:`input_encoding`. Some libraries (e.g. WTForms) want a 
            unicode dictionary. '''</span>
        <span class="s1">copy = FormsDict()</span>
        <span class="s1">enc = copy.input_encoding = encoding </span><span class="s3">or </span><span class="s1">self.input_encoding</span>
        <span class="s1">copy.recode_unicode = </span><span class="s3">False</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self.allitems():</span>
            <span class="s1">copy.append(self._fix(key</span><span class="s3">, </span><span class="s1">enc)</span><span class="s3">, </span><span class="s1">self._fix(value</span><span class="s3">, </span><span class="s1">enc))</span>
        <span class="s3">return </span><span class="s1">copy</span>

    <span class="s3">def </span><span class="s1">getunicode(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None, </span><span class="s1">encoding=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">''' Return the value as a unicode string, or the default. '''</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._fix(self[name]</span><span class="s3">, </span><span class="s1">encoding)</span>
        <span class="s3">except </span><span class="s1">(UnicodeError</span><span class="s3">, </span><span class="s1">KeyError):</span>
            <span class="s3">return </span><span class="s1">default</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default=unicode()):</span>
        <span class="s0"># Without this guard, pickle generates a cryptic TypeError:</span>
        <span class="s3">if </span><span class="s1">name.startswith(</span><span class="s4">'__'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">name.endswith(</span><span class="s4">'__'</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">super(FormsDict</span><span class="s3">, </span><span class="s1">self).__getattr__(name)</span>
        <span class="s3">return </span><span class="s1">self.getunicode(name</span><span class="s3">, </span><span class="s1">default=default)</span>

<span class="s3">class </span><span class="s1">HeaderDict(MultiDict):</span>
    <span class="s2">&quot;&quot;&quot; A case-insensitive version of :class:`MultiDict` that defaults to 
        replace the old value instead of appending it. &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*a</span><span class="s3">, </span><span class="s1">**ka):</span>
        <span class="s1">self.dict = {}</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">or </span><span class="s1">ka: self.update(*a</span><span class="s3">, </span><span class="s1">**ka)</span>

    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">key): </span><span class="s3">return </span><span class="s1">_hkey(key) </span><span class="s3">in </span><span class="s1">self.dict</span>
    <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">key): </span><span class="s3">del </span><span class="s1">self.dict[_hkey(key)]</span>
    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key): </span><span class="s3">return </span><span class="s1">self.dict[_hkey(key)][-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value): self.dict[_hkey(key)] = [_hval(value)]</span>
    <span class="s3">def </span><span class="s1">append(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value): self.dict.setdefault(_hkey(key)</span><span class="s3">, </span><span class="s1">[]).append(_hval(value))</span>
    <span class="s3">def </span><span class="s1">replace(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value): self.dict[_hkey(key)] = [_hval(value)]</span>
    <span class="s3">def </span><span class="s1">getall(self</span><span class="s3">, </span><span class="s1">key): </span><span class="s3">return </span><span class="s1">self.dict.get(_hkey(key)) </span><span class="s3">or </span><span class="s1">[]</span>
    <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None, </span><span class="s1">index=-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">MultiDict.get(self</span><span class="s3">, </span><span class="s1">_hkey(key)</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">index)</span>
    <span class="s3">def </span><span class="s1">filter(self</span><span class="s3">, </span><span class="s1">names):</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">(_hkey(n) </span><span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">names):</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self.dict:</span>
                <span class="s3">del </span><span class="s1">self.dict[name]</span>


<span class="s3">class </span><span class="s1">WSGIHeaderDict(DictMixin):</span>
    <span class="s2">''' This dict-like class wraps a WSGI environ dict and provides convenient 
        access to HTTP_* fields. Keys and values are native strings 
        (2.x bytes or 3.x unicode) and keys are case-insensitive. If the WSGI 
        environment contains non-native string values, these are de- or encoded 
        using a lossless 'latin1' character set. 
 
        The API will remain stable even on changes to the relevant PEPs. 
        Currently PEP 333, 444 and 3333 are supported. (PEP 444 is the only one 
        that uses non-native strings.) 
    '''</span>
    <span class="s0">#: List of keys that do not have a ``HTTP_`` prefix.</span>
    <span class="s1">cgikeys = (</span><span class="s4">'CONTENT_TYPE'</span><span class="s3">, </span><span class="s4">'CONTENT_LENGTH'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">environ):</span>
        <span class="s1">self.environ = environ</span>

    <span class="s3">def </span><span class="s1">_ekey(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s2">''' Translate header field name to CGI/WSGI environ key. '''</span>
        <span class="s1">key = key.replace(</span><span class="s4">'-'</span><span class="s3">,</span><span class="s4">'_'</span><span class="s1">).upper()</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.cgikeys:</span>
            <span class="s3">return </span><span class="s1">key</span>
        <span class="s3">return </span><span class="s4">'HTTP_' </span><span class="s1">+ key</span>

    <span class="s3">def </span><span class="s1">raw(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">''' Return the header value as is (may be bytes or unicode). '''</span>
        <span class="s3">return </span><span class="s1">self.environ.get(self._ekey(key)</span><span class="s3">, </span><span class="s1">default)</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s3">return </span><span class="s1">tonat(self.environ[self._ekey(key)]</span><span class="s3">, </span><span class="s4">'latin1'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;%s is read-only.&quot; </span><span class="s1">% self.__class__)</span>

    <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;%s is read-only.&quot; </span><span class="s1">% self.__class__)</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.environ:</span>
            <span class="s3">if </span><span class="s1">key[:</span><span class="s5">5</span><span class="s1">] == </span><span class="s4">'HTTP_'</span><span class="s1">:</span>
                <span class="s3">yield </span><span class="s1">key[</span><span class="s5">5</span><span class="s1">:].replace(</span><span class="s4">'_'</span><span class="s3">, </span><span class="s4">'-'</span><span class="s1">).title()</span>
            <span class="s3">elif </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.cgikeys:</span>
                <span class="s3">yield </span><span class="s1">key.replace(</span><span class="s4">'_'</span><span class="s3">, </span><span class="s4">'-'</span><span class="s1">).title()</span>

    <span class="s3">def </span><span class="s1">keys(self): </span><span class="s3">return </span><span class="s1">[x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self]</span>
    <span class="s3">def </span><span class="s1">__len__(self): </span><span class="s3">return </span><span class="s1">len(self.keys())</span>
    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">key): </span><span class="s3">return </span><span class="s1">self._ekey(key) </span><span class="s3">in </span><span class="s1">self.environ</span>



<span class="s3">class </span><span class="s1">ConfigDict(dict):</span>
    <span class="s2">''' A dict-like configuration storage with additional support for 
        namespaces, validators, meta-data, on_change listeners and more. 
 
        This storage is optimized for fast read access. Retrieving a key 
        or using non-altering dict methods (e.g. `dict.get()`) has no overhead 
        compared to a native dict. 
    '''</span>
    <span class="s1">__slots__ = (</span><span class="s4">'_meta'</span><span class="s3">, </span><span class="s4">'_on_change'</span><span class="s1">)</span>

    <span class="s3">class </span><span class="s1">Namespace(DictMixin):</span>

        <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">config</span><span class="s3">, </span><span class="s1">namespace):</span>
            <span class="s1">self._config = config</span>
            <span class="s1">self._prefix = namespace</span>

        <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key):</span>
            <span class="s1">depr(</span><span class="s4">'Accessing namespaces as dicts is discouraged. '</span>
                 <span class="s4">'Only use flat item access: '</span>
                 <span class="s4">'cfg[&quot;names&quot;][&quot;pace&quot;][&quot;key&quot;] -&gt; cfg[&quot;name.space.key&quot;]'</span><span class="s1">) </span><span class="s0">#0.12</span>
            <span class="s3">return </span><span class="s1">self._config[self._prefix + </span><span class="s4">'.' </span><span class="s1">+ key]</span>

        <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
            <span class="s1">self._config[self._prefix + </span><span class="s4">'.' </span><span class="s1">+ key] = value</span>

        <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">key):</span>
            <span class="s3">del </span><span class="s1">self._config[self._prefix + </span><span class="s4">'.' </span><span class="s1">+ key]</span>

        <span class="s3">def </span><span class="s1">__iter__(self):</span>
            <span class="s1">ns_prefix = self._prefix + </span><span class="s4">'.'</span>
            <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self._config:</span>
                <span class="s1">ns</span><span class="s3">, </span><span class="s1">dot</span><span class="s3">, </span><span class="s1">name = key.rpartition(</span><span class="s4">'.'</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">ns == self._prefix </span><span class="s3">and </span><span class="s1">name:</span>
                    <span class="s3">yield </span><span class="s1">name</span>

        <span class="s3">def </span><span class="s1">keys(self): </span><span class="s3">return </span><span class="s1">[x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self]</span>
        <span class="s3">def </span><span class="s1">__len__(self): </span><span class="s3">return </span><span class="s1">len(self.keys())</span>
        <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">key): </span><span class="s3">return </span><span class="s1">self._prefix + </span><span class="s4">'.' </span><span class="s1">+ key </span><span class="s3">in </span><span class="s1">self._config</span>
        <span class="s3">def </span><span class="s1">__repr__(self): </span><span class="s3">return </span><span class="s4">'&lt;Config.Namespace %s.*&gt;' </span><span class="s1">% self._prefix</span>
        <span class="s3">def </span><span class="s1">__str__(self): </span><span class="s3">return </span><span class="s4">'&lt;Config.Namespace %s.*&gt;' </span><span class="s1">% self._prefix</span>

        <span class="s0"># Deprecated ConfigDict features</span>
        <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">key):</span>
            <span class="s1">depr(</span><span class="s4">'Attribute access is deprecated.'</span><span class="s1">) </span><span class="s0">#0.12</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">not in </span><span class="s1">self </span><span class="s3">and </span><span class="s1">key[</span><span class="s5">0</span><span class="s1">].isupper():</span>
                <span class="s1">self[key] = ConfigDict.Namespace(self._config</span><span class="s3">, </span><span class="s1">self._prefix + </span><span class="s4">'.' </span><span class="s1">+ key)</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">not in </span><span class="s1">self </span><span class="s3">and </span><span class="s1">key.startswith(</span><span class="s4">'__'</span><span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">AttributeError(key)</span>
            <span class="s3">return </span><span class="s1">self.get(key)</span>

        <span class="s3">def </span><span class="s1">__setattr__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'_config'</span><span class="s3">, </span><span class="s4">'_prefix'</span><span class="s1">):</span>
                <span class="s1">self.__dict__[key] = value</span>
                <span class="s3">return</span>
            <span class="s1">depr(</span><span class="s4">'Attribute assignment is deprecated.'</span><span class="s1">) </span><span class="s0">#0.12</span>
            <span class="s3">if </span><span class="s1">hasattr(DictMixin</span><span class="s3">, </span><span class="s1">key):</span>
                <span class="s3">raise </span><span class="s1">AttributeError(</span><span class="s4">'Read-only attribute.'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self </span><span class="s3">and </span><span class="s1">self[key] </span><span class="s3">and </span><span class="s1">isinstance(self[key]</span><span class="s3">, </span><span class="s1">self.__class__):</span>
                <span class="s3">raise </span><span class="s1">AttributeError(</span><span class="s4">'Non-empty namespace attribute.'</span><span class="s1">)</span>
            <span class="s1">self[key] = value</span>

        <span class="s3">def </span><span class="s1">__delattr__(self</span><span class="s3">, </span><span class="s1">key):</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self:</span>
                <span class="s1">val = self.pop(key)</span>
                <span class="s3">if </span><span class="s1">isinstance(val</span><span class="s3">, </span><span class="s1">self.__class__):</span>
                    <span class="s1">prefix = key + </span><span class="s4">'.'</span>
                    <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self:</span>
                        <span class="s3">if </span><span class="s1">key.startswith(prefix):</span>
                            <span class="s3">del </span><span class="s1">self[prefix+key]</span>

        <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">*a</span><span class="s3">, </span><span class="s1">**ka):</span>
            <span class="s1">depr(</span><span class="s4">'Calling ConfDict is deprecated. Use the update() method.'</span><span class="s1">) </span><span class="s0">#0.12</span>
            <span class="s1">self.update(*a</span><span class="s3">, </span><span class="s1">**ka)</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*a</span><span class="s3">, </span><span class="s1">**ka):</span>
        <span class="s1">self._meta = {}</span>
        <span class="s1">self._on_change = </span><span class="s3">lambda </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value: </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">or </span><span class="s1">ka:</span>
            <span class="s1">depr(</span><span class="s4">'Constructor does no longer accept parameters.'</span><span class="s1">) </span><span class="s0">#0.12</span>
            <span class="s1">self.update(*a</span><span class="s3">, </span><span class="s1">**ka)</span>

    <span class="s3">def </span><span class="s1">load_config(self</span><span class="s3">, </span><span class="s1">filename):</span>
        <span class="s2">''' Load values from an *.ini style config file. 
 
            If the config file contains sections, their names are used as 
            namespaces for the values within. The two special sections 
            ``DEFAULT`` and ``bottle`` refer to the root namespace (no prefix). 
        '''</span>
        <span class="s1">conf = ConfigParser()</span>
        <span class="s1">conf.read(filename)</span>
        <span class="s3">for </span><span class="s1">section </span><span class="s3">in </span><span class="s1">conf.sections():</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">conf.items(section):</span>
                <span class="s3">if </span><span class="s1">section </span><span class="s3">not in </span><span class="s1">(</span><span class="s4">'DEFAULT'</span><span class="s3">, </span><span class="s4">'bottle'</span><span class="s1">):</span>
                    <span class="s1">key = section + </span><span class="s4">'.' </span><span class="s1">+ key</span>
                <span class="s1">self[key] = value</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">load_dict(self</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">namespace=</span><span class="s4">''</span><span class="s3">, </span><span class="s1">make_namespaces=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">''' Import values from a dictionary structure. Nesting can be used to 
            represent namespaces. 
 
            &gt;&gt;&gt; ConfigDict().load_dict({'name': {'space': {'key': 'value'}}}) 
            {'name.space.key': 'value'} 
        '''</span>
        <span class="s1">stack = [(namespace</span><span class="s3">, </span><span class="s1">source)]</span>
        <span class="s3">while </span><span class="s1">stack:</span>
            <span class="s1">prefix</span><span class="s3">, </span><span class="s1">source = stack.pop()</span>
            <span class="s3">if not </span><span class="s1">isinstance(source</span><span class="s3">, </span><span class="s1">dict):</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'Source is not a dict (r)' </span><span class="s1">% type(key))</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">source.items():</span>
                <span class="s3">if not </span><span class="s1">isinstance(key</span><span class="s3">, </span><span class="s1">basestring):</span>
                    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'Key is not a string (%r)' </span><span class="s1">% type(key))</span>
                <span class="s1">full_key = prefix + </span><span class="s4">'.' </span><span class="s1">+ key </span><span class="s3">if </span><span class="s1">prefix </span><span class="s3">else </span><span class="s1">key</span>
                <span class="s3">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">dict):</span>
                    <span class="s1">stack.append((full_key</span><span class="s3">, </span><span class="s1">value))</span>
                    <span class="s3">if </span><span class="s1">make_namespaces:</span>
                        <span class="s1">self[full_key] = self.Namespace(self</span><span class="s3">, </span><span class="s1">full_key)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self[full_key] = value</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">update(self</span><span class="s3">, </span><span class="s1">*a</span><span class="s3">, </span><span class="s1">**ka):</span>
        <span class="s2">''' If the first parameter is a string, all keys are prefixed with this 
            namespace. Apart from that it works just as the usual dict.update(). 
            Example: ``update('some.namespace', key='value')`` '''</span>
        <span class="s1">prefix = </span><span class="s4">''</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">and </span><span class="s1">isinstance(a[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">prefix = a[</span><span class="s5">0</span><span class="s1">].strip(</span><span class="s4">'.'</span><span class="s1">) + </span><span class="s4">'.'</span>
            <span class="s1">a = a[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">dict(*a</span><span class="s3">, </span><span class="s1">**ka).items():</span>
            <span class="s1">self[prefix+key] = value</span>

    <span class="s3">def </span><span class="s1">setdefault(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">not in </span><span class="s1">self:</span>
            <span class="s1">self[key] = value</span>
        <span class="s3">return </span><span class="s1">self[key]</span>

    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">if not </span><span class="s1">isinstance(key</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'Key has type %r (not a string)' </span><span class="s1">% type(key))</span>

        <span class="s1">value = self.meta_get(key</span><span class="s3">, </span><span class="s4">'filter'</span><span class="s3">, lambda </span><span class="s1">x: x)(value)</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self </span><span class="s3">and </span><span class="s1">self[key] </span><span class="s3">is </span><span class="s1">value:</span>
            <span class="s3">return</span>
        <span class="s1">self._on_change(key</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s1">dict.__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value)</span>

    <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s1">dict.__delitem__(self</span><span class="s3">, </span><span class="s1">key)</span>

    <span class="s3">def </span><span class="s1">clear(self):</span>
        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self:</span>
            <span class="s3">del </span><span class="s1">self[key]</span>

    <span class="s3">def </span><span class="s1">meta_get(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">metafield</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">''' Return the value of a meta field for a key. '''</span>
        <span class="s3">return </span><span class="s1">self._meta.get(key</span><span class="s3">, </span><span class="s1">{}).get(metafield</span><span class="s3">, </span><span class="s1">default)</span>

    <span class="s3">def </span><span class="s1">meta_set(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">metafield</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s2">''' Set the meta field for a key to a new value. This triggers the 
            on-change handler for existing keys. '''</span>
        <span class="s1">self._meta.setdefault(key</span><span class="s3">, </span><span class="s1">{})[metafield] = value</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self:</span>
            <span class="s1">self[key] = self[key]</span>

    <span class="s3">def </span><span class="s1">meta_list(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s2">''' Return an iterable of meta field names defined for a key. '''</span>
        <span class="s3">return </span><span class="s1">self._meta.get(key</span><span class="s3">, </span><span class="s1">{}).keys()</span>

    <span class="s0"># Deprecated ConfigDict features</span>
    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s1">depr(</span><span class="s4">'Attribute access is deprecated.'</span><span class="s1">) </span><span class="s0">#0.12</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">not in </span><span class="s1">self </span><span class="s3">and </span><span class="s1">key[</span><span class="s5">0</span><span class="s1">].isupper():</span>
            <span class="s1">self[key] = self.Namespace(self</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">not in </span><span class="s1">self </span><span class="s3">and </span><span class="s1">key.startswith(</span><span class="s4">'__'</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">AttributeError(key)</span>
        <span class="s3">return </span><span class="s1">self.get(key)</span>

    <span class="s3">def </span><span class="s1">__setattr__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.__slots__:</span>
            <span class="s3">return </span><span class="s1">dict.__setattr__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s1">depr(</span><span class="s4">'Attribute assignment is deprecated.'</span><span class="s1">) </span><span class="s0">#0.12</span>
        <span class="s3">if </span><span class="s1">hasattr(dict</span><span class="s3">, </span><span class="s1">key):</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span><span class="s4">'Read-only attribute.'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self </span><span class="s3">and </span><span class="s1">self[key] </span><span class="s3">and </span><span class="s1">isinstance(self[key]</span><span class="s3">, </span><span class="s1">self.Namespace):</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span><span class="s4">'Non-empty namespace attribute.'</span><span class="s1">)</span>
        <span class="s1">self[key] = value</span>

    <span class="s3">def </span><span class="s1">__delattr__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self:</span>
            <span class="s1">val = self.pop(key)</span>
            <span class="s3">if </span><span class="s1">isinstance(val</span><span class="s3">, </span><span class="s1">self.Namespace):</span>
                <span class="s1">prefix = key + </span><span class="s4">'.'</span>
                <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self:</span>
                    <span class="s3">if </span><span class="s1">key.startswith(prefix):</span>
                        <span class="s3">del </span><span class="s1">self[prefix+key]</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">*a</span><span class="s3">, </span><span class="s1">**ka):</span>
        <span class="s1">depr(</span><span class="s4">'Calling ConfDict is deprecated. Use the update() method.'</span><span class="s1">) </span><span class="s0">#0.12</span>
        <span class="s1">self.update(*a</span><span class="s3">, </span><span class="s1">**ka)</span>
        <span class="s3">return </span><span class="s1">self</span>



<span class="s3">class </span><span class="s1">AppStack(list):</span>
    <span class="s2">&quot;&quot;&quot; A stack-like list. Calling it returns the head of the stack. &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__call__(self):</span>
        <span class="s2">&quot;&quot;&quot; Return the current default application. &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">push(self</span><span class="s3">, </span><span class="s1">value=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; Add a new :class:`Bottle` instance to the stack &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">Bottle):</span>
            <span class="s1">value = Bottle()</span>
        <span class="s1">self.append(value)</span>
        <span class="s3">return </span><span class="s1">value</span>


<span class="s3">class </span><span class="s1">WSGIFileWrapper(object):</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">buffer_size=</span><span class="s5">1024</span><span class="s1">*</span><span class="s5">64</span><span class="s1">):</span>
        <span class="s1">self.fp</span><span class="s3">, </span><span class="s1">self.buffer_size = fp</span><span class="s3">, </span><span class="s1">buffer_size</span>
        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'fileno'</span><span class="s3">, </span><span class="s4">'close'</span><span class="s3">, </span><span class="s4">'read'</span><span class="s3">, </span><span class="s4">'readlines'</span><span class="s3">, </span><span class="s4">'tell'</span><span class="s3">, </span><span class="s4">'seek'</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">hasattr(fp</span><span class="s3">, </span><span class="s1">attr): setattr(self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">getattr(fp</span><span class="s3">, </span><span class="s1">attr))</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s1">buff</span><span class="s3">, </span><span class="s1">read = self.buffer_size</span><span class="s3">, </span><span class="s1">self.read</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s1">part = read(buff)</span>
            <span class="s3">if not </span><span class="s1">part: </span><span class="s3">return</span>
            <span class="s3">yield </span><span class="s1">part</span>


<span class="s3">class </span><span class="s1">_closeiter(object):</span>
    <span class="s2">''' This only exists to be able to attach a .close method to iterators that 
        do not support attribute assignment (most of itertools). '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">iterator</span><span class="s3">, </span><span class="s1">close=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self.iterator = iterator</span>
        <span class="s1">self.close_callbacks = makelist(close)</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s3">return </span><span class="s1">iter(self.iterator)</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s3">for </span><span class="s1">func </span><span class="s3">in </span><span class="s1">self.close_callbacks:</span>
            <span class="s1">func()</span>


<span class="s3">class </span><span class="s1">ResourceManager(object):</span>
    <span class="s2">''' This class manages a list of search paths and helps to find and open 
        application-bound resources (files). 
 
        :param base: default value for :meth:`add_path` calls. 
        :param opener: callable used to open resources. 
        :param cachemode: controls which lookups are cached. One of 'all', 
                         'found' or 'none'. 
    '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">base=</span><span class="s4">'./'</span><span class="s3">, </span><span class="s1">opener=open</span><span class="s3">, </span><span class="s1">cachemode=</span><span class="s4">'all'</span><span class="s1">):</span>
        <span class="s1">self.opener = open</span>
        <span class="s1">self.base = base</span>
        <span class="s1">self.cachemode = cachemode</span>

        <span class="s0">#: A list of search paths. See :meth:`add_path` for details.</span>
        <span class="s1">self.path = []</span>
        <span class="s0">#: A cache for resolved paths. ``res.cache.clear()`` clears the cache.</span>
        <span class="s1">self.cache = {}</span>

    <span class="s3">def </span><span class="s1">add_path(self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">base=</span><span class="s3">None, </span><span class="s1">index=</span><span class="s3">None, </span><span class="s1">create=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">''' Add a new path to the list of search paths. Return False if the 
            path does not exist. 
 
            :param path: The new search path. Relative paths are turned into 
                an absolute and normalized form. If the path looks like a file 
                (not ending in `/`), the filename is stripped off. 
            :param base: Path used to absolutize relative search paths. 
                Defaults to :attr:`base` which defaults to ``os.getcwd()``. 
            :param index: Position within the list of search paths. Defaults 
                to last index (appends to the list). 
 
            The `base` parameter makes it easy to reference files installed 
            along with a python module or package:: 
 
                res.add_path('./resources/', __file__) 
        '''</span>
        <span class="s1">base = os.path.abspath(os.path.dirname(base </span><span class="s3">or </span><span class="s1">self.base))</span>
        <span class="s1">path = os.path.abspath(os.path.join(base</span><span class="s3">, </span><span class="s1">os.path.dirname(path)))</span>
        <span class="s1">path += os.sep</span>
        <span class="s3">if </span><span class="s1">path </span><span class="s3">in </span><span class="s1">self.path:</span>
            <span class="s1">self.path.remove(path)</span>
        <span class="s3">if </span><span class="s1">create </span><span class="s3">and not </span><span class="s1">os.path.isdir(path):</span>
            <span class="s1">os.makedirs(path)</span>
        <span class="s3">if </span><span class="s1">index </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.path.append(path)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.path.insert(index</span><span class="s3">, </span><span class="s1">path)</span>
        <span class="s1">self.cache.clear()</span>
        <span class="s3">return </span><span class="s1">os.path.exists(path)</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">''' Iterate over all existing files in all registered paths. '''</span>
        <span class="s1">search = self.path[:]</span>
        <span class="s3">while </span><span class="s1">search:</span>
            <span class="s1">path = search.pop()</span>
            <span class="s3">if not </span><span class="s1">os.path.isdir(path): </span><span class="s3">continue</span>
            <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">os.listdir(path):</span>
                <span class="s1">full = os.path.join(path</span><span class="s3">, </span><span class="s1">name)</span>
                <span class="s3">if </span><span class="s1">os.path.isdir(full): search.append(full)</span>
                <span class="s3">else</span><span class="s1">: </span><span class="s3">yield </span><span class="s1">full</span>

    <span class="s3">def </span><span class="s1">lookup(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s2">''' Search for a resource and return an absolute file path, or `None`. 
 
            The :attr:`path` list is searched in order. The first match is 
            returend. Symlinks are followed. The result is cached to speed up 
            future lookups. '''</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">self.cache </span><span class="s3">or </span><span class="s1">DEBUG:</span>
            <span class="s3">for </span><span class="s1">path </span><span class="s3">in </span><span class="s1">self.path:</span>
                <span class="s1">fpath = os.path.join(path</span><span class="s3">, </span><span class="s1">name)</span>
                <span class="s3">if </span><span class="s1">os.path.isfile(fpath):</span>
                    <span class="s3">if </span><span class="s1">self.cachemode </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'all'</span><span class="s3">, </span><span class="s4">'found'</span><span class="s1">):</span>
                        <span class="s1">self.cache[name] = fpath</span>
                    <span class="s3">return </span><span class="s1">fpath</span>
            <span class="s3">if </span><span class="s1">self.cachemode == </span><span class="s4">'all'</span><span class="s1">:</span>
                <span class="s1">self.cache[name] = </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">self.cache[name]</span>

    <span class="s3">def </span><span class="s1">open(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">mode=</span><span class="s4">'r'</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">''' Find a resource and return a file object, or raise IOError. '''</span>
        <span class="s1">fname = self.lookup(name)</span>
        <span class="s3">if not </span><span class="s1">fname: </span><span class="s3">raise </span><span class="s1">IOError(</span><span class="s4">&quot;Resource %r not found.&quot; </span><span class="s1">% name)</span>
        <span class="s3">return </span><span class="s1">self.opener(fname</span><span class="s3">, </span><span class="s1">mode=mode</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s3">class </span><span class="s1">FileUpload(object):</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">fileobj</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">headers=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">''' Wrapper for file uploads. '''</span>
        <span class="s0">#: Open file(-like) object (BytesIO buffer or temporary file)</span>
        <span class="s1">self.file = fileobj</span>
        <span class="s0">#: Name of the upload form field</span>
        <span class="s1">self.name = name</span>
        <span class="s0">#: Raw filename as sent by the client (may contain unsafe characters)</span>
        <span class="s1">self.raw_filename = filename</span>
        <span class="s0">#: A :class:`HeaderDict` with additional headers (e.g. content-type)</span>
        <span class="s1">self.headers = HeaderDict(headers) </span><span class="s3">if </span><span class="s1">headers </span><span class="s3">else </span><span class="s1">HeaderDict()</span>

    <span class="s1">content_type = HeaderProperty(</span><span class="s4">'Content-Type'</span><span class="s1">)</span>
    <span class="s1">content_length = HeaderProperty(</span><span class="s4">'Content-Length'</span><span class="s3">, </span><span class="s1">reader=int</span><span class="s3">, </span><span class="s1">default=-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_header(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; Return the value of a header within the mulripart part. &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.headers.get(name</span><span class="s3">, </span><span class="s1">default)</span>

    <span class="s1">@cached_property</span>
    <span class="s3">def </span><span class="s1">filename(self):</span>
        <span class="s2">''' Name of the file on the client file system, but normalized to ensure 
            file system compatibility. An empty filename is returned as 'empty'. 
 
            Only ASCII letters, digits, dashes, underscores and dots are 
            allowed in the final filename. Accents are removed, if possible. 
            Whitespace is replaced by a single dash. Leading or tailing dots 
            or dashes are removed. The filename is limited to 255 characters. 
        '''</span>
        <span class="s1">fname = self.raw_filename</span>
        <span class="s3">if not </span><span class="s1">isinstance(fname</span><span class="s3">, </span><span class="s1">unicode):</span>
            <span class="s1">fname = fname.decode(</span><span class="s4">'utf8'</span><span class="s3">, </span><span class="s4">'ignore'</span><span class="s1">)</span>
        <span class="s1">fname = normalize(</span><span class="s4">'NFKD'</span><span class="s3">, </span><span class="s1">fname).encode(</span><span class="s4">'ASCII'</span><span class="s3">, </span><span class="s4">'ignore'</span><span class="s1">).decode(</span><span class="s4">'ASCII'</span><span class="s1">)</span>
        <span class="s1">fname = os.path.basename(fname.replace(</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">'</span><span class="s3">, </span><span class="s1">os.path.sep))</span>
        <span class="s1">fname = re.sub(</span><span class="s4">r'[^a-zA-Z0-9-_.\s]'</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s1">fname).strip()</span>
        <span class="s1">fname = re.sub(</span><span class="s4">r'[-\s]+'</span><span class="s3">, </span><span class="s4">'-'</span><span class="s3">, </span><span class="s1">fname).strip(</span><span class="s4">'.-'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">fname[:</span><span class="s5">255</span><span class="s1">] </span><span class="s3">or </span><span class="s4">'empty'</span>

    <span class="s3">def </span><span class="s1">_copy_file(self</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">chunk_size=</span><span class="s5">2</span><span class="s1">**</span><span class="s5">16</span><span class="s1">):</span>
        <span class="s1">read</span><span class="s3">, </span><span class="s1">write</span><span class="s3">, </span><span class="s1">offset = self.file.read</span><span class="s3">, </span><span class="s1">fp.write</span><span class="s3">, </span><span class="s1">self.file.tell()</span>
        <span class="s3">while </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">buf = read(chunk_size)</span>
            <span class="s3">if not </span><span class="s1">buf: </span><span class="s3">break</span>
            <span class="s1">write(buf)</span>
        <span class="s1">self.file.seek(offset)</span>

    <span class="s3">def </span><span class="s1">save(self</span><span class="s3">, </span><span class="s1">destination</span><span class="s3">, </span><span class="s1">overwrite=</span><span class="s3">False, </span><span class="s1">chunk_size=</span><span class="s5">2</span><span class="s1">**</span><span class="s5">16</span><span class="s1">):</span>
        <span class="s2">''' Save file to disk or copy its content to an open file(-like) object. 
            If *destination* is a directory, :attr:`filename` is added to the 
            path. Existing files are not overwritten by default (IOError). 
 
            :param destination: File path, directory or file(-like) object. 
            :param overwrite: If True, replace existing files. (default: False) 
            :param chunk_size: Bytes to read at a time. (default: 64kb) 
        '''</span>
        <span class="s3">if </span><span class="s1">isinstance(destination</span><span class="s3">, </span><span class="s1">basestring): </span><span class="s0"># Except file-likes here</span>
            <span class="s3">if </span><span class="s1">os.path.isdir(destination):</span>
                <span class="s1">destination = os.path.join(destination</span><span class="s3">, </span><span class="s1">self.filename)</span>
            <span class="s3">if not </span><span class="s1">overwrite </span><span class="s3">and </span><span class="s1">os.path.exists(destination):</span>
                <span class="s3">raise </span><span class="s1">IOError(</span><span class="s4">'File exists.'</span><span class="s1">)</span>
            <span class="s3">with </span><span class="s1">open(destination</span><span class="s3">, </span><span class="s4">'wb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">fp:</span>
                <span class="s1">self._copy_file(fp</span><span class="s3">, </span><span class="s1">chunk_size)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._copy_file(destination</span><span class="s3">, </span><span class="s1">chunk_size)</span>






<span class="s0">###############################################################################</span>
<span class="s0"># Application Helper ###########################################################</span>
<span class="s0">###############################################################################</span>


<span class="s3">def </span><span class="s1">abort(code=</span><span class="s5">500</span><span class="s3">, </span><span class="s1">text=</span><span class="s4">'Unknown Error.'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; Aborts execution and causes a HTTP error. &quot;&quot;&quot;</span>
    <span class="s3">raise </span><span class="s1">HTTPError(code</span><span class="s3">, </span><span class="s1">text)</span>


<span class="s3">def </span><span class="s1">redirect(url</span><span class="s3">, </span><span class="s1">code=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; Aborts execution and causes a 303 or 302 redirect, depending on 
        the HTTP protocol version. &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">code:</span>
        <span class="s1">code = </span><span class="s5">303 </span><span class="s3">if </span><span class="s1">request.get(</span><span class="s4">'SERVER_PROTOCOL'</span><span class="s1">) == </span><span class="s4">&quot;HTTP/1.1&quot; </span><span class="s3">else </span><span class="s5">302</span>
    <span class="s1">res = response.copy(cls=HTTPResponse)</span>
    <span class="s1">res.status = code</span>
    <span class="s1">res.body = </span><span class="s4">&quot;&quot;</span>
    <span class="s1">res.set_header(</span><span class="s4">'Location'</span><span class="s3">, </span><span class="s1">urljoin(request.url</span><span class="s3">, </span><span class="s1">url))</span>
    <span class="s3">raise </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">_file_iter_range(fp</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">maxread=</span><span class="s5">1024</span><span class="s1">*</span><span class="s5">1024</span><span class="s1">):</span>
    <span class="s2">''' Yield chunks from a range in a file. No chunk is bigger than maxread.'''</span>
    <span class="s1">fp.seek(offset)</span>
    <span class="s3">while </span><span class="s1">bytes &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">part = fp.read(min(bytes</span><span class="s3">, </span><span class="s1">maxread))</span>
        <span class="s3">if not </span><span class="s1">part: </span><span class="s3">break</span>
        <span class="s1">bytes -= len(part)</span>
        <span class="s3">yield </span><span class="s1">part</span>


<span class="s3">def </span><span class="s1">static_file(filename</span><span class="s3">, </span><span class="s1">root</span><span class="s3">, </span><span class="s1">mimetype=</span><span class="s4">'auto'</span><span class="s3">, </span><span class="s1">download=</span><span class="s3">False, </span><span class="s1">charset=</span><span class="s4">'UTF-8'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; Open a file in a safe way and return :exc:`HTTPResponse` with status 
        code 200, 305, 403 or 404. The ``Content-Type``, ``Content-Encoding``, 
        ``Content-Length`` and ``Last-Modified`` headers are set if possible. 
        Special support for ``If-Modified-Since``, ``Range`` and ``HEAD`` 
        requests. 
 
        :param filename: Name or path of the file to send. 
        :param root: Root path for file lookups. Should be an absolute directory 
            path. 
        :param mimetype: Defines the content-type header (default: guess from 
            file extension) 
        :param download: If True, ask the browser to open a `Save as...` dialog 
            instead of opening the file with the associated program. You can 
            specify a custom filename as a string. If not specified, the 
            original filename is used (default: False). 
        :param charset: The charset to use for files with a ``text/*`` 
            mime-type. (default: UTF-8) 
    &quot;&quot;&quot;</span>

    <span class="s1">root = os.path.abspath(root) + os.sep</span>
    <span class="s1">filename = os.path.abspath(os.path.join(root</span><span class="s3">, </span><span class="s1">filename.strip(</span><span class="s4">'/</span><span class="s3">\\</span><span class="s4">'</span><span class="s1">)))</span>
    <span class="s1">headers = dict()</span>

    <span class="s3">if not </span><span class="s1">filename.startswith(root):</span>
        <span class="s3">return </span><span class="s1">HTTPError(</span><span class="s5">403</span><span class="s3">, </span><span class="s4">&quot;Access denied.&quot;</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">os.path.exists(filename) </span><span class="s3">or not </span><span class="s1">os.path.isfile(filename):</span>
        <span class="s3">return </span><span class="s1">HTTPError(</span><span class="s5">404</span><span class="s3">, </span><span class="s4">&quot;File does not exist.&quot;</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">os.access(filename</span><span class="s3">, </span><span class="s1">os.R_OK):</span>
        <span class="s3">return </span><span class="s1">HTTPError(</span><span class="s5">403</span><span class="s3">, </span><span class="s4">&quot;You do not have permission to access this file.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">mimetype == </span><span class="s4">'auto'</span><span class="s1">:</span>
        <span class="s1">mimetype</span><span class="s3">, </span><span class="s1">encoding = mimetypes.guess_type(filename)</span>
        <span class="s3">if </span><span class="s1">encoding: headers[</span><span class="s4">'Content-Encoding'</span><span class="s1">] = encoding</span>

    <span class="s3">if </span><span class="s1">mimetype:</span>
        <span class="s3">if </span><span class="s1">mimetype[:</span><span class="s5">5</span><span class="s1">] == </span><span class="s4">'text/' </span><span class="s3">and </span><span class="s1">charset </span><span class="s3">and </span><span class="s4">'charset' </span><span class="s3">not in </span><span class="s1">mimetype:</span>
            <span class="s1">mimetype += </span><span class="s4">'; charset=%s' </span><span class="s1">% charset</span>
        <span class="s1">headers[</span><span class="s4">'Content-Type'</span><span class="s1">] = mimetype</span>

    <span class="s3">if </span><span class="s1">download:</span>
        <span class="s1">download = os.path.basename(filename </span><span class="s3">if </span><span class="s1">download == </span><span class="s3">True else </span><span class="s1">download)</span>
        <span class="s1">headers[</span><span class="s4">'Content-Disposition'</span><span class="s1">] = </span><span class="s4">'attachment; filename=&quot;%s&quot;' </span><span class="s1">% download</span>

    <span class="s1">stats = os.stat(filename)</span>
    <span class="s1">headers[</span><span class="s4">'Content-Length'</span><span class="s1">] = clen = stats.st_size</span>
    <span class="s1">lm = time.strftime(</span><span class="s4">&quot;%a, %d %b %Y %H:%M:%S GMT&quot;</span><span class="s3">, </span><span class="s1">time.gmtime(stats.st_mtime))</span>
    <span class="s1">headers[</span><span class="s4">'Last-Modified'</span><span class="s1">] = lm</span>

    <span class="s1">ims = request.environ.get(</span><span class="s4">'HTTP_IF_MODIFIED_SINCE'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">ims:</span>
        <span class="s1">ims = parse_date(ims.split(</span><span class="s4">&quot;;&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">].strip())</span>
    <span class="s3">if </span><span class="s1">ims </span><span class="s3">is not None and </span><span class="s1">ims &gt;= int(stats.st_mtime):</span>
        <span class="s1">headers[</span><span class="s4">'Date'</span><span class="s1">] = time.strftime(</span><span class="s4">&quot;%a, %d %b %Y %H:%M:%S GMT&quot;</span><span class="s3">, </span><span class="s1">time.gmtime())</span>
        <span class="s3">return </span><span class="s1">HTTPResponse(status=</span><span class="s5">304</span><span class="s3">, </span><span class="s1">**headers)</span>

    <span class="s1">body = </span><span class="s4">'' </span><span class="s3">if </span><span class="s1">request.method == </span><span class="s4">'HEAD' </span><span class="s3">else </span><span class="s1">open(filename</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">)</span>

    <span class="s1">headers[</span><span class="s4">&quot;Accept-Ranges&quot;</span><span class="s1">] = </span><span class="s4">&quot;bytes&quot;</span>
    <span class="s1">ranges = request.environ.get(</span><span class="s4">'HTTP_RANGE'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s4">'HTTP_RANGE' </span><span class="s3">in </span><span class="s1">request.environ:</span>
        <span class="s1">ranges = list(parse_range_header(request.environ[</span><span class="s4">'HTTP_RANGE'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">clen))</span>
        <span class="s3">if not </span><span class="s1">ranges:</span>
            <span class="s3">return </span><span class="s1">HTTPError(</span><span class="s5">416</span><span class="s3">, </span><span class="s4">&quot;Requested Range Not Satisfiable&quot;</span><span class="s1">)</span>
        <span class="s1">offset</span><span class="s3">, </span><span class="s1">end = ranges[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">headers[</span><span class="s4">&quot;Content-Range&quot;</span><span class="s1">] = </span><span class="s4">&quot;bytes %d-%d/%d&quot; </span><span class="s1">% (offset</span><span class="s3">, </span><span class="s1">end-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">clen)</span>
        <span class="s1">headers[</span><span class="s4">&quot;Content-Length&quot;</span><span class="s1">] = str(end-offset)</span>
        <span class="s3">if </span><span class="s1">body: body = _file_iter_range(body</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">end-offset)</span>
        <span class="s3">return </span><span class="s1">HTTPResponse(body</span><span class="s3">, </span><span class="s1">status=</span><span class="s5">206</span><span class="s3">, </span><span class="s1">**headers)</span>
    <span class="s3">return </span><span class="s1">HTTPResponse(body</span><span class="s3">, </span><span class="s1">**headers)</span>






<span class="s0">###############################################################################</span>
<span class="s0"># HTTP Utilities and MISC (TODO) ###############################################</span>
<span class="s0">###############################################################################</span>


<span class="s3">def </span><span class="s1">debug(mode=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; Change the debug level. 
    There is only one debug level supported at the moment.&quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">DEBUG</span>
    <span class="s3">if </span><span class="s1">mode: warnings.simplefilter(</span><span class="s4">'default'</span><span class="s1">)</span>
    <span class="s1">DEBUG = bool(mode)</span>

<span class="s3">def </span><span class="s1">http_date(value):</span>
    <span class="s3">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">(datedate</span><span class="s3">, </span><span class="s1">datetime)):</span>
        <span class="s1">value = value.utctimetuple()</span>
    <span class="s3">elif </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">(int</span><span class="s3">, </span><span class="s1">float)):</span>
        <span class="s1">value = time.gmtime(value)</span>
    <span class="s3">if not </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">basestring):</span>
        <span class="s1">value = time.strftime(</span><span class="s4">&quot;%a, %d %b %Y %H:%M:%S GMT&quot;</span><span class="s3">, </span><span class="s1">value)</span>
    <span class="s3">return </span><span class="s1">value</span>

<span class="s3">def </span><span class="s1">parse_date(ims):</span>
    <span class="s2">&quot;&quot;&quot; Parse rfc1123, rfc850 and asctime timestamps and return UTC epoch. &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">ts = email.utils.parsedate_tz(ims)</span>
        <span class="s3">return </span><span class="s1">time.mktime(ts[:</span><span class="s5">8</span><span class="s1">] + (</span><span class="s5">0</span><span class="s3">,</span><span class="s1">)) - (ts[</span><span class="s5">9</span><span class="s1">] </span><span class="s3">or </span><span class="s5">0</span><span class="s1">) - time.timezone</span>
    <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">IndexError</span><span class="s3">, </span><span class="s1">OverflowError):</span>
        <span class="s3">return None</span>

<span class="s3">def </span><span class="s1">parse_auth(header):</span>
    <span class="s2">&quot;&quot;&quot; Parse rfc2617 HTTP authentication header string (basic) and return (user,pass) tuple or None&quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">method</span><span class="s3">, </span><span class="s1">data = header.split(</span><span class="s3">None, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">method.lower() == </span><span class="s4">'basic'</span><span class="s1">:</span>
            <span class="s1">user</span><span class="s3">, </span><span class="s1">pwd = touni(base64.b64decode(tob(data))).split(</span><span class="s4">':'</span><span class="s3">,</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">user</span><span class="s3">, </span><span class="s1">pwd</span>
    <span class="s3">except </span><span class="s1">(KeyError</span><span class="s3">, </span><span class="s1">ValueError):</span>
        <span class="s3">return None</span>

<span class="s3">def </span><span class="s1">parse_range_header(header</span><span class="s3">, </span><span class="s1">maxlen=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2">''' Yield (start, end) ranges parsed from a HTTP Range header. Skip 
        unsatisfiable ranges. The end index is non-inclusive.'''</span>
    <span class="s3">if not </span><span class="s1">header </span><span class="s3">or </span><span class="s1">header[:</span><span class="s5">6</span><span class="s1">] != </span><span class="s4">'bytes='</span><span class="s1">: </span><span class="s3">return</span>
    <span class="s1">ranges = [r.split(</span><span class="s4">'-'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">) </span><span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">header[</span><span class="s5">6</span><span class="s1">:].split(</span><span class="s4">','</span><span class="s1">) </span><span class="s3">if </span><span class="s4">'-' </span><span class="s3">in </span><span class="s1">r]</span>
    <span class="s3">for </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end </span><span class="s3">in </span><span class="s1">ranges:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">start:  </span><span class="s0"># bytes=-100    -&gt; last 100 bytes</span>
                <span class="s1">start</span><span class="s3">, </span><span class="s1">end = max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">maxlen-int(end))</span><span class="s3">, </span><span class="s1">maxlen</span>
            <span class="s3">elif not </span><span class="s1">end:  </span><span class="s0"># bytes=100-    -&gt; all but the first 99 bytes</span>
                <span class="s1">start</span><span class="s3">, </span><span class="s1">end = int(start)</span><span class="s3">, </span><span class="s1">maxlen</span>
            <span class="s3">else</span><span class="s1">:          </span><span class="s0"># bytes=100-200 -&gt; bytes 100-200 (inclusive)</span>
                <span class="s1">start</span><span class="s3">, </span><span class="s1">end = int(start)</span><span class="s3">, </span><span class="s1">min(int(end)+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">maxlen)</span>
            <span class="s3">if </span><span class="s5">0 </span><span class="s1">&lt;= start &lt; end &lt;= maxlen:</span>
                <span class="s3">yield </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span>
        <span class="s3">except </span><span class="s1">ValueError:</span>
            <span class="s3">pass</span>

<span class="s3">def </span><span class="s1">_parse_qsl(qs):</span>
    <span class="s1">r = []</span>
    <span class="s3">for </span><span class="s1">pair </span><span class="s3">in </span><span class="s1">qs.split(</span><span class="s4">'&amp;'</span><span class="s1">):</span>
        <span class="s3">if not </span><span class="s1">pair: </span><span class="s3">continue</span>
        <span class="s1">nv = pair.split(</span><span class="s4">'='</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">len(nv) != </span><span class="s5">2</span><span class="s1">: nv.append(</span><span class="s4">''</span><span class="s1">)</span>
        <span class="s1">key = urlunquote(nv[</span><span class="s5">0</span><span class="s1">].replace(</span><span class="s4">'+'</span><span class="s3">, </span><span class="s4">' '</span><span class="s1">))</span>
        <span class="s1">value = urlunquote(nv[</span><span class="s5">1</span><span class="s1">].replace(</span><span class="s4">'+'</span><span class="s3">, </span><span class="s4">' '</span><span class="s1">))</span>
        <span class="s1">r.append((key</span><span class="s3">, </span><span class="s1">value))</span>
    <span class="s3">return </span><span class="s1">r</span>

<span class="s3">def </span><span class="s1">_lscmp(a</span><span class="s3">, </span><span class="s1">b):</span>
    <span class="s2">''' Compares two strings in a cryptographically safe way: 
        Runtime is not affected by length of common prefix. '''</span>
    <span class="s3">return not </span><span class="s1">sum(</span><span class="s5">0 </span><span class="s3">if </span><span class="s1">x==y </span><span class="s3">else </span><span class="s5">1 </span><span class="s3">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">in </span><span class="s1">zip(a</span><span class="s3">, </span><span class="s1">b)) </span><span class="s3">and </span><span class="s1">len(a) == len(b)</span>


<span class="s3">def </span><span class="s1">cookie_encode(data</span><span class="s3">, </span><span class="s1">key):</span>
    <span class="s2">''' Encode and sign a pickle-able object. Return a (byte) string '''</span>
    <span class="s1">msg = base64.b64encode(pickle.dumps(data</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">sig = base64.b64encode(hmac.new(tob(key)</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">digestmod=hashlib.md5).digest())</span>
    <span class="s3">return </span><span class="s1">tob(</span><span class="s4">'!'</span><span class="s1">) + sig + tob(</span><span class="s4">'?'</span><span class="s1">) + msg</span>


<span class="s3">def </span><span class="s1">cookie_decode(data</span><span class="s3">, </span><span class="s1">key):</span>
    <span class="s2">''' Verify and decode an encoded string. Return an object or None.'''</span>
    <span class="s1">data = tob(data)</span>
    <span class="s3">if </span><span class="s1">cookie_is_encoded(data):</span>
        <span class="s1">sig</span><span class="s3">, </span><span class="s1">msg = data.split(tob(</span><span class="s4">'?'</span><span class="s1">)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">_lscmp(sig[</span><span class="s5">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s1">base64.b64encode(hmac.new(tob(key)</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">digestmod=hashlib.md5).digest())):</span>
            <span class="s3">return </span><span class="s1">pickle.loads(base64.b64decode(msg))</span>
    <span class="s3">return None</span>


<span class="s3">def </span><span class="s1">cookie_is_encoded(data):</span>
    <span class="s2">''' Return True if the argument looks like a encoded cookie.'''</span>
    <span class="s3">return </span><span class="s1">bool(data.startswith(tob(</span><span class="s4">'!'</span><span class="s1">)) </span><span class="s3">and </span><span class="s1">tob(</span><span class="s4">'?'</span><span class="s1">) </span><span class="s3">in </span><span class="s1">data)</span>


<span class="s3">def </span><span class="s1">html_escape(string):</span>
    <span class="s2">''' Escape HTML special characters ``&amp;&lt;&gt;`` and quotes ``'&quot;``. '''</span>
    <span class="s3">return </span><span class="s1">string.replace(</span><span class="s4">'&amp;'</span><span class="s3">,</span><span class="s4">'&amp;amp;'</span><span class="s1">).replace(</span><span class="s4">'&lt;'</span><span class="s3">,</span><span class="s4">'&amp;lt;'</span><span class="s1">).replace(</span><span class="s4">'&gt;'</span><span class="s3">,</span><span class="s4">'&amp;gt;'</span><span class="s1">)\</span>
                 <span class="s1">.replace(</span><span class="s4">'&quot;'</span><span class="s3">,</span><span class="s4">'&amp;quot;'</span><span class="s1">).replace(</span><span class="s4">&quot;'&quot;</span><span class="s3">,</span><span class="s4">'&amp;#039;'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">html_quote(string):</span>
    <span class="s2">''' Escape and quote a string to be used as an HTTP attribute.'''</span>
    <span class="s3">return </span><span class="s4">'&quot;%s&quot;' </span><span class="s1">% html_escape(string).replace(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s3">,</span><span class="s4">'&amp;#10;'</span><span class="s1">)\</span>
                    <span class="s1">.replace(</span><span class="s4">'</span><span class="s3">\r</span><span class="s4">'</span><span class="s3">,</span><span class="s4">'&amp;#13;'</span><span class="s1">).replace(</span><span class="s4">'</span><span class="s3">\t</span><span class="s4">'</span><span class="s3">,</span><span class="s4">'&amp;#9;'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">yieldroutes(func):</span>
    <span class="s2">&quot;&quot;&quot; Return a generator for routes that match the signature (name, args) 
    of the func parameter. This may yield more than one route if the function 
    takes optional keyword arguments. The output is best described by example:: 
 
        a()         -&gt; '/a' 
        b(x, y)     -&gt; '/b/&lt;x&gt;/&lt;y&gt;' 
        c(x, y=5)   -&gt; '/c/&lt;x&gt;' and '/c/&lt;x&gt;/&lt;y&gt;' 
        d(x=5, y=6) -&gt; '/d' and '/d/&lt;x&gt;' and '/d/&lt;x&gt;/&lt;y&gt;' 
    &quot;&quot;&quot;</span>
    <span class="s1">path = </span><span class="s4">'/' </span><span class="s1">+ func.__name__.replace(</span><span class="s4">'__'</span><span class="s3">,</span><span class="s4">'/'</span><span class="s1">).lstrip(</span><span class="s4">'/'</span><span class="s1">)</span>
    <span class="s1">spec = getargspec(func)</span>
    <span class="s1">argc = len(spec[</span><span class="s5">0</span><span class="s1">]) - len(spec[</span><span class="s5">3</span><span class="s1">] </span><span class="s3">or </span><span class="s1">[])</span>
    <span class="s1">path += (</span><span class="s4">'/&lt;%s&gt;' </span><span class="s1">* argc) % tuple(spec[</span><span class="s5">0</span><span class="s1">][:argc])</span>
    <span class="s3">yield </span><span class="s1">path</span>
    <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">spec[</span><span class="s5">0</span><span class="s1">][argc:]:</span>
        <span class="s1">path += </span><span class="s4">'/&lt;%s&gt;' </span><span class="s1">% arg</span>
        <span class="s3">yield </span><span class="s1">path</span>


<span class="s3">def </span><span class="s1">path_shift(script_name</span><span class="s3">, </span><span class="s1">path_info</span><span class="s3">, </span><span class="s1">shift=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s2">''' Shift path fragments from PATH_INFO to SCRIPT_NAME and vice versa. 
 
        :return: The modified paths. 
        :param script_name: The SCRIPT_NAME path. 
        :param script_name: The PATH_INFO path. 
        :param shift: The number of path fragments to shift. May be negative to 
          change the shift direction. (default: 1) 
    '''</span>
    <span class="s3">if </span><span class="s1">shift == </span><span class="s5">0</span><span class="s1">: </span><span class="s3">return </span><span class="s1">script_name</span><span class="s3">, </span><span class="s1">path_info</span>
    <span class="s1">pathlist = path_info.strip(</span><span class="s4">'/'</span><span class="s1">).split(</span><span class="s4">'/'</span><span class="s1">)</span>
    <span class="s1">scriptlist = script_name.strip(</span><span class="s4">'/'</span><span class="s1">).split(</span><span class="s4">'/'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">pathlist </span><span class="s3">and </span><span class="s1">pathlist[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">''</span><span class="s1">: pathlist = []</span>
    <span class="s3">if </span><span class="s1">scriptlist </span><span class="s3">and </span><span class="s1">scriptlist[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">''</span><span class="s1">: scriptlist = []</span>
    <span class="s3">if </span><span class="s1">shift &gt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">shift &lt;= len(pathlist):</span>
        <span class="s1">moved = pathlist[:shift]</span>
        <span class="s1">scriptlist = scriptlist + moved</span>
        <span class="s1">pathlist = pathlist[shift:]</span>
    <span class="s3">elif </span><span class="s1">shift &lt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">shift &gt;= -len(scriptlist):</span>
        <span class="s1">moved = scriptlist[shift:]</span>
        <span class="s1">pathlist = moved + pathlist</span>
        <span class="s1">scriptlist = scriptlist[:shift]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">empty = </span><span class="s4">'SCRIPT_NAME' </span><span class="s3">if </span><span class="s1">shift &lt; </span><span class="s5">0 </span><span class="s3">else </span><span class="s4">'PATH_INFO'</span>
        <span class="s3">raise </span><span class="s1">AssertionError(</span><span class="s4">&quot;Cannot shift. Nothing left from %s&quot; </span><span class="s1">% empty)</span>
    <span class="s1">new_script_name = </span><span class="s4">'/' </span><span class="s1">+ </span><span class="s4">'/'</span><span class="s1">.join(scriptlist)</span>
    <span class="s1">new_path_info = </span><span class="s4">'/' </span><span class="s1">+ </span><span class="s4">'/'</span><span class="s1">.join(pathlist)</span>
    <span class="s3">if </span><span class="s1">path_info.endswith(</span><span class="s4">'/'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">pathlist: new_path_info += </span><span class="s4">'/'</span>
    <span class="s3">return </span><span class="s1">new_script_name</span><span class="s3">, </span><span class="s1">new_path_info</span>


<span class="s3">def </span><span class="s1">auth_basic(check</span><span class="s3">, </span><span class="s1">realm=</span><span class="s4">&quot;private&quot;</span><span class="s3">, </span><span class="s1">text=</span><span class="s4">&quot;Access denied&quot;</span><span class="s1">):</span>
    <span class="s2">''' Callback decorator to require HTTP auth (basic). 
        TODO: Add route(check_auth=...) parameter. '''</span>
    <span class="s3">def </span><span class="s1">decorator(func):</span>
        <span class="s1">@functools.wraps(func)</span>
        <span class="s3">def </span><span class="s1">wrapper(*a</span><span class="s3">, </span><span class="s1">**ka):</span>
            <span class="s1">user</span><span class="s3">, </span><span class="s1">password = request.auth </span><span class="s3">or </span><span class="s1">(</span><span class="s3">None, None</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">user </span><span class="s3">is None or not </span><span class="s1">check(user</span><span class="s3">, </span><span class="s1">password):</span>
                <span class="s1">err = HTTPError(</span><span class="s5">401</span><span class="s3">, </span><span class="s1">text)</span>
                <span class="s1">err.add_header(</span><span class="s4">'WWW-Authenticate'</span><span class="s3">, </span><span class="s4">'Basic realm=&quot;%s&quot;' </span><span class="s1">% realm)</span>
                <span class="s3">return </span><span class="s1">err</span>
            <span class="s3">return </span><span class="s1">func(*a</span><span class="s3">, </span><span class="s1">**ka)</span>
        <span class="s3">return </span><span class="s1">wrapper</span>
    <span class="s3">return </span><span class="s1">decorator</span>


<span class="s0"># Shortcuts for common Bottle methods.</span>
<span class="s0"># They all refer to the current default application.</span>

<span class="s3">def </span><span class="s1">make_default_app_wrapper(name):</span>
    <span class="s2">''' Return a callable that relays calls to the current default app. '''</span>
    <span class="s1">@functools.wraps(getattr(Bottle</span><span class="s3">, </span><span class="s1">name))</span>
    <span class="s3">def </span><span class="s1">wrapper(*a</span><span class="s3">, </span><span class="s1">**ka):</span>
        <span class="s3">return </span><span class="s1">getattr(app()</span><span class="s3">, </span><span class="s1">name)(*a</span><span class="s3">, </span><span class="s1">**ka)</span>
    <span class="s3">return </span><span class="s1">wrapper</span>

<span class="s1">route     = make_default_app_wrapper(</span><span class="s4">'route'</span><span class="s1">)</span>
<span class="s1">get       = make_default_app_wrapper(</span><span class="s4">'get'</span><span class="s1">)</span>
<span class="s1">post      = make_default_app_wrapper(</span><span class="s4">'post'</span><span class="s1">)</span>
<span class="s1">put       = make_default_app_wrapper(</span><span class="s4">'put'</span><span class="s1">)</span>
<span class="s1">delete    = make_default_app_wrapper(</span><span class="s4">'delete'</span><span class="s1">)</span>
<span class="s1">error     = make_default_app_wrapper(</span><span class="s4">'error'</span><span class="s1">)</span>
<span class="s1">mount     = make_default_app_wrapper(</span><span class="s4">'mount'</span><span class="s1">)</span>
<span class="s1">hook      = make_default_app_wrapper(</span><span class="s4">'hook'</span><span class="s1">)</span>
<span class="s1">install   = make_default_app_wrapper(</span><span class="s4">'install'</span><span class="s1">)</span>
<span class="s1">uninstall = make_default_app_wrapper(</span><span class="s4">'uninstall'</span><span class="s1">)</span>
<span class="s1">url       = make_default_app_wrapper(</span><span class="s4">'get_url'</span><span class="s1">)</span>







<span class="s0">###############################################################################</span>
<span class="s0"># Server Adapter ###############################################################</span>
<span class="s0">###############################################################################</span>


<span class="s3">class </span><span class="s1">ServerAdapter(object):</span>
    <span class="s1">quiet = </span><span class="s3">False</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">host=</span><span class="s4">'127.0.0.1'</span><span class="s3">, </span><span class="s1">port=</span><span class="s5">8080</span><span class="s3">, </span><span class="s1">**options):</span>
        <span class="s1">self.options = options</span>
        <span class="s1">self.host = host</span>
        <span class="s1">self.port = int(port)</span>

    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler): </span><span class="s0"># pragma: no cover</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">args = </span><span class="s4">', '</span><span class="s1">.join([</span><span class="s4">'%s=%s'</span><span class="s1">%(k</span><span class="s3">,</span><span class="s1">repr(v)) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.options.items()])</span>
        <span class="s3">return </span><span class="s4">&quot;%s(%s)&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">args)</span>


<span class="s3">class </span><span class="s1">CGIServer(ServerAdapter):</span>
    <span class="s1">quiet = </span><span class="s3">True</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler): </span><span class="s0"># pragma: no cover</span>
        <span class="s3">from </span><span class="s1">wsgiref.handlers </span><span class="s3">import </span><span class="s1">CGIHandler</span>
        <span class="s3">def </span><span class="s1">fixed_environ(environ</span><span class="s3">, </span><span class="s1">start_response):</span>
            <span class="s1">environ.setdefault(</span><span class="s4">'PATH_INFO'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">handler(environ</span><span class="s3">, </span><span class="s1">start_response)</span>
        <span class="s1">CGIHandler().run(fixed_environ)</span>


<span class="s3">class </span><span class="s1">FlupFCGIServer(ServerAdapter):</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler): </span><span class="s0"># pragma: no cover</span>
        <span class="s3">import </span><span class="s1">flup.server.fcgi</span>
        <span class="s1">self.options.setdefault(</span><span class="s4">'bindAddress'</span><span class="s3">, </span><span class="s1">(self.host</span><span class="s3">, </span><span class="s1">self.port))</span>
        <span class="s1">flup.server.fcgi.WSGIServer(handler</span><span class="s3">, </span><span class="s1">**self.options).run()</span>


<span class="s3">class </span><span class="s1">WSGIRefServer(ServerAdapter):</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">app): </span><span class="s0"># pragma: no cover</span>
        <span class="s3">from </span><span class="s1">wsgiref.simple_server </span><span class="s3">import </span><span class="s1">WSGIRequestHandler</span><span class="s3">, </span><span class="s1">WSGIServer</span>
        <span class="s3">from </span><span class="s1">wsgiref.simple_server </span><span class="s3">import </span><span class="s1">make_server</span>
        <span class="s3">import </span><span class="s1">socket</span>

        <span class="s3">class </span><span class="s1">FixedHandler(WSGIRequestHandler):</span>
            <span class="s3">def </span><span class="s1">address_string(self): </span><span class="s0"># Prevent reverse DNS lookups please.</span>
                <span class="s3">return </span><span class="s1">self.client_address[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">def </span><span class="s1">log_request(*args</span><span class="s3">, </span><span class="s1">**kw):</span>
                <span class="s3">if not </span><span class="s1">self.quiet:</span>
                    <span class="s3">return </span><span class="s1">WSGIRequestHandler.log_request(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

        <span class="s1">handler_cls = self.options.get(</span><span class="s4">'handler_class'</span><span class="s3">, </span><span class="s1">FixedHandler)</span>
        <span class="s1">server_cls  = self.options.get(</span><span class="s4">'server_class'</span><span class="s3">, </span><span class="s1">WSGIServer)</span>

        <span class="s3">if </span><span class="s4">':' </span><span class="s3">in </span><span class="s1">self.host: </span><span class="s0"># Fix wsgiref for IPv6 addresses.</span>
            <span class="s3">if </span><span class="s1">getattr(server_cls</span><span class="s3">, </span><span class="s4">'address_family'</span><span class="s1">) == socket.AF_INET:</span>
                <span class="s3">class </span><span class="s1">server_cls(server_cls):</span>
                    <span class="s1">address_family = socket.AF_INET6</span>

        <span class="s1">srv = make_server(self.host</span><span class="s3">, </span><span class="s1">self.port</span><span class="s3">, </span><span class="s1">app</span><span class="s3">, </span><span class="s1">server_cls</span><span class="s3">, </span><span class="s1">handler_cls)</span>
        <span class="s1">srv.serve_forever()</span>


<span class="s3">class </span><span class="s1">CherryPyServer(ServerAdapter):</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler): </span><span class="s0"># pragma: no cover</span>
        <span class="s1">depr(</span><span class="s4">&quot;The wsgi server part of cherrypy was split into a new &quot;</span>
             <span class="s4">&quot;project called 'cheroot'. Use the 'cheroot' server &quot;</span>
             <span class="s4">&quot;adapter instead of cherrypy.&quot;</span><span class="s1">)</span>
        <span class="s3">from </span><span class="s1">cherrypy </span><span class="s3">import </span><span class="s1">wsgiserver </span><span class="s0"># This will fail for CherryPy &gt;= 9</span>

        <span class="s1">self.options[</span><span class="s4">'bind_addr'</span><span class="s1">] = (self.host</span><span class="s3">, </span><span class="s1">self.port)</span>
        <span class="s1">self.options[</span><span class="s4">'wsgi_app'</span><span class="s1">] = handler</span>

        <span class="s1">certfile = self.options.get(</span><span class="s4">'certfile'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">certfile:</span>
            <span class="s3">del </span><span class="s1">self.options[</span><span class="s4">'certfile'</span><span class="s1">]</span>
        <span class="s1">keyfile = self.options.get(</span><span class="s4">'keyfile'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">keyfile:</span>
            <span class="s3">del </span><span class="s1">self.options[</span><span class="s4">'keyfile'</span><span class="s1">]</span>

        <span class="s1">server = wsgiserver.CherryPyWSGIServer(**self.options)</span>
        <span class="s3">if </span><span class="s1">certfile:</span>
            <span class="s1">server.ssl_certificate = certfile</span>
        <span class="s3">if </span><span class="s1">keyfile:</span>
            <span class="s1">server.ssl_private_key = keyfile</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">server.start()</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">server.stop()</span>


<span class="s3">class </span><span class="s1">CherootServer(ServerAdapter):</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler): </span><span class="s0"># pragma: no cover</span>
        <span class="s3">from </span><span class="s1">cheroot </span><span class="s3">import </span><span class="s1">wsgi</span>
        <span class="s3">from </span><span class="s1">cheroot.ssl </span><span class="s3">import </span><span class="s1">builtin</span>
        <span class="s1">self.options[</span><span class="s4">'bind_addr'</span><span class="s1">] = (self.host</span><span class="s3">, </span><span class="s1">self.port)</span>
        <span class="s1">self.options[</span><span class="s4">'wsgi_app'</span><span class="s1">] = handler</span>
        <span class="s1">certfile = self.options.pop(</span><span class="s4">'certfile'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">keyfile = self.options.pop(</span><span class="s4">'keyfile'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">chainfile = self.options.pop(</span><span class="s4">'chainfile'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">server = wsgi.Server(**self.options)</span>
        <span class="s3">if </span><span class="s1">certfile </span><span class="s3">and </span><span class="s1">keyfile:</span>
            <span class="s1">server.ssl_adapter = builtin.BuiltinSSLAdapter(</span>
                    <span class="s1">certfile</span><span class="s3">, </span><span class="s1">keyfile</span><span class="s3">, </span><span class="s1">chainfile)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">server.start()</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">server.stop()</span>


<span class="s3">class </span><span class="s1">WaitressServer(ServerAdapter):</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">from </span><span class="s1">waitress </span><span class="s3">import </span><span class="s1">serve</span>
        <span class="s1">serve(handler</span><span class="s3">, </span><span class="s1">host=self.host</span><span class="s3">, </span><span class="s1">port=self.port)</span>


<span class="s3">class </span><span class="s1">PasteServer(ServerAdapter):</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler): </span><span class="s0"># pragma: no cover</span>
        <span class="s3">from </span><span class="s1">paste </span><span class="s3">import </span><span class="s1">httpserver</span>
        <span class="s3">from </span><span class="s1">paste.translogger </span><span class="s3">import </span><span class="s1">TransLogger</span>
        <span class="s1">handler = TransLogger(handler</span><span class="s3">, </span><span class="s1">setup_console_handler=(</span><span class="s3">not </span><span class="s1">self.quiet))</span>
        <span class="s1">httpserver.serve(handler</span><span class="s3">, </span><span class="s1">host=self.host</span><span class="s3">, </span><span class="s1">port=str(self.port)</span><span class="s3">,</span>
                         <span class="s1">**self.options)</span>


<span class="s3">class </span><span class="s1">MeinheldServer(ServerAdapter):</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">from </span><span class="s1">meinheld </span><span class="s3">import </span><span class="s1">server</span>
        <span class="s1">server.listen((self.host</span><span class="s3">, </span><span class="s1">self.port))</span>
        <span class="s1">server.run(handler)</span>


<span class="s3">class </span><span class="s1">FapwsServer(ServerAdapter):</span>
    <span class="s2">&quot;&quot;&quot; Extremely fast webserver using libev. See https://github.com/william-os4y/fapws3 &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler): </span><span class="s0"># pragma: no cover</span>
        <span class="s3">import </span><span class="s1">fapws._evwsgi </span><span class="s3">as </span><span class="s1">evwsgi</span>
        <span class="s3">from </span><span class="s1">fapws </span><span class="s3">import </span><span class="s1">base</span><span class="s3">, </span><span class="s1">config</span>
        <span class="s1">port = self.port</span>
        <span class="s3">if </span><span class="s1">float(config.SERVER_IDENT[-</span><span class="s5">2</span><span class="s1">:]) &gt; </span><span class="s5">0.4</span><span class="s1">:</span>
            <span class="s0"># fapws3 silently changed its API in 0.5</span>
            <span class="s1">port = str(port)</span>
        <span class="s1">evwsgi.start(self.host</span><span class="s3">, </span><span class="s1">port)</span>
        <span class="s0"># fapws3 never releases the GIL. Complain upstream. I tried. No luck.</span>
        <span class="s3">if </span><span class="s4">'BOTTLE_CHILD' </span><span class="s3">in </span><span class="s1">os.environ </span><span class="s3">and not </span><span class="s1">self.quiet:</span>
            <span class="s1">_stderr(</span><span class="s4">&quot;WARNING: Auto-reloading does not work with Fapws3.</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s1">_stderr(</span><span class="s4">&quot;         (Fapws3 breaks python thread support)</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">evwsgi.set_base_module(base)</span>
        <span class="s3">def </span><span class="s1">app(environ</span><span class="s3">, </span><span class="s1">start_response):</span>
            <span class="s1">environ[</span><span class="s4">'wsgi.multiprocess'</span><span class="s1">] = </span><span class="s3">False</span>
            <span class="s3">return </span><span class="s1">handler(environ</span><span class="s3">, </span><span class="s1">start_response)</span>
        <span class="s1">evwsgi.wsgi_cb((</span><span class="s4">''</span><span class="s3">, </span><span class="s1">app))</span>
        <span class="s1">evwsgi.run()</span>


<span class="s3">class </span><span class="s1">TornadoServer(ServerAdapter):</span>
    <span class="s2">&quot;&quot;&quot; The super hyped asynchronous server by facebook. Untested. &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler): </span><span class="s0"># pragma: no cover</span>
        <span class="s3">import </span><span class="s1">tornado.wsgi</span><span class="s3">, </span><span class="s1">tornado.httpserver</span><span class="s3">, </span><span class="s1">tornado.ioloop</span>
        <span class="s1">container = tornado.wsgi.WSGIContainer(handler)</span>
        <span class="s1">server = tornado.httpserver.HTTPServer(container)</span>
        <span class="s1">server.listen(port=self.port</span><span class="s3">,</span><span class="s1">address=self.host)</span>
        <span class="s1">tornado.ioloop.IOLoop.instance().start()</span>


<span class="s3">class </span><span class="s1">AppEngineServer(ServerAdapter):</span>
    <span class="s2">&quot;&quot;&quot; Adapter for Google App Engine. &quot;&quot;&quot;</span>
    <span class="s1">quiet = </span><span class="s3">True</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">from </span><span class="s1">google.appengine.ext.webapp </span><span class="s3">import </span><span class="s1">util</span>
        <span class="s0"># A main() function in the handler script enables 'App Caching'.</span>
        <span class="s0"># Lets makes sure it is there. This _really_ improves performance.</span>
        <span class="s1">module = sys.modules.get(</span><span class="s4">'__main__'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">module </span><span class="s3">and not </span><span class="s1">hasattr(module</span><span class="s3">, </span><span class="s4">'main'</span><span class="s1">):</span>
            <span class="s1">module.main = </span><span class="s3">lambda</span><span class="s1">: util.run_wsgi_app(handler)</span>
        <span class="s1">util.run_wsgi_app(handler)</span>


<span class="s3">class </span><span class="s1">TwistedServer(ServerAdapter):</span>
    <span class="s2">&quot;&quot;&quot; Untested. &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">from </span><span class="s1">twisted.web </span><span class="s3">import </span><span class="s1">server</span><span class="s3">, </span><span class="s1">wsgi</span>
        <span class="s3">from </span><span class="s1">twisted.python.threadpool </span><span class="s3">import </span><span class="s1">ThreadPool</span>
        <span class="s3">from </span><span class="s1">twisted.internet </span><span class="s3">import </span><span class="s1">reactor</span>
        <span class="s1">thread_pool = ThreadPool()</span>
        <span class="s1">thread_pool.start()</span>
        <span class="s1">reactor.addSystemEventTrigger(</span><span class="s4">'after'</span><span class="s3">, </span><span class="s4">'shutdown'</span><span class="s3">, </span><span class="s1">thread_pool.stop)</span>
        <span class="s1">factory = server.Site(wsgi.WSGIResource(reactor</span><span class="s3">, </span><span class="s1">thread_pool</span><span class="s3">, </span><span class="s1">handler))</span>
        <span class="s1">reactor.listenTCP(self.port</span><span class="s3">, </span><span class="s1">factory</span><span class="s3">, </span><span class="s1">interface=self.host)</span>
        <span class="s1">reactor.run()</span>


<span class="s3">class </span><span class="s1">DieselServer(ServerAdapter):</span>
    <span class="s2">&quot;&quot;&quot; Untested. &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">from </span><span class="s1">diesel.protocols.wsgi </span><span class="s3">import </span><span class="s1">WSGIApplication</span>
        <span class="s1">app = WSGIApplication(handler</span><span class="s3">, </span><span class="s1">port=self.port)</span>
        <span class="s1">app.run()</span>


<span class="s3">class </span><span class="s1">GeventServer(ServerAdapter):</span>
    <span class="s2">&quot;&quot;&quot; Untested. Options: 
 
        * `fast` (default: False) uses libevent's http server, but has some 
          issues: No streaming, no pipelining, no SSL. 
        * See gevent.wsgi.WSGIServer() documentation for more options. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">from </span><span class="s1">gevent </span><span class="s3">import </span><span class="s1">pywsgi</span><span class="s3">, </span><span class="s1">local</span>
        <span class="s3">if not </span><span class="s1">isinstance(threading.local()</span><span class="s3">, </span><span class="s1">local.local):</span>
            <span class="s1">msg = </span><span class="s4">&quot;Bottle requires gevent.monkey.patch_all() (before import)&quot;</span>
            <span class="s3">raise </span><span class="s1">RuntimeError(msg)</span>
        <span class="s3">if </span><span class="s1">self.options.pop(</span><span class="s4">'fast'</span><span class="s3">, None</span><span class="s1">):</span>
            <span class="s1">depr(</span><span class="s4">'The &quot;fast&quot; option has been deprecated and removed by Gevent.'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.quiet:</span>
            <span class="s1">self.options[</span><span class="s4">'log'</span><span class="s1">] = </span><span class="s3">None</span>
        <span class="s1">address = (self.host</span><span class="s3">, </span><span class="s1">self.port)</span>
        <span class="s1">server = pywsgi.WSGIServer(address</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s1">**self.options)</span>
        <span class="s3">if </span><span class="s4">'BOTTLE_CHILD' </span><span class="s3">in </span><span class="s1">os.environ:</span>
            <span class="s3">import </span><span class="s1">signal</span>
            <span class="s1">signal.signal(signal.SIGINT</span><span class="s3">, lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">f: server.stop())</span>
        <span class="s1">server.serve_forever()</span>


<span class="s3">class </span><span class="s1">GeventSocketIOServer(ServerAdapter):</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">,</span><span class="s1">handler):</span>
        <span class="s3">from </span><span class="s1">socketio </span><span class="s3">import </span><span class="s1">server</span>
        <span class="s1">address = (self.host</span><span class="s3">, </span><span class="s1">self.port)</span>
        <span class="s1">server.SocketIOServer(address</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s1">**self.options).serve_forever()</span>


<span class="s3">class </span><span class="s1">GunicornServer(ServerAdapter):</span>
    <span class="s2">&quot;&quot;&quot; Untested. See http://gunicorn.org/configure.html for options. &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">from </span><span class="s1">gunicorn.app.base </span><span class="s3">import </span><span class="s1">Application</span>

        <span class="s1">config = {</span><span class="s4">'bind'</span><span class="s1">: </span><span class="s4">&quot;%s:%d&quot; </span><span class="s1">% (self.host</span><span class="s3">, </span><span class="s1">int(self.port))}</span>
        <span class="s1">config.update(self.options)</span>

        <span class="s3">class </span><span class="s1">GunicornApplication(Application):</span>
            <span class="s3">def </span><span class="s1">init(self</span><span class="s3">, </span><span class="s1">parser</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">args):</span>
                <span class="s3">return </span><span class="s1">config</span>

            <span class="s3">def </span><span class="s1">load(self):</span>
                <span class="s3">return </span><span class="s1">handler</span>

        <span class="s1">GunicornApplication().run()</span>


<span class="s3">class </span><span class="s1">EventletServer(ServerAdapter):</span>
    <span class="s2">&quot;&quot;&quot; Untested &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">from </span><span class="s1">eventlet </span><span class="s3">import </span><span class="s1">wsgi</span><span class="s3">, </span><span class="s1">listen</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">wsgi.server(listen((self.host</span><span class="s3">, </span><span class="s1">self.port))</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">,</span>
                        <span class="s1">log_output=(</span><span class="s3">not </span><span class="s1">self.quiet))</span>
        <span class="s3">except </span><span class="s1">TypeError:</span>
            <span class="s0"># Fallback, if we have old version of eventlet</span>
            <span class="s1">wsgi.server(listen((self.host</span><span class="s3">, </span><span class="s1">self.port))</span><span class="s3">, </span><span class="s1">handler)</span>


<span class="s3">class </span><span class="s1">RocketServer(ServerAdapter):</span>
    <span class="s2">&quot;&quot;&quot; Untested. &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">from </span><span class="s1">rocket </span><span class="s3">import </span><span class="s1">Rocket</span>
        <span class="s1">server = Rocket((self.host</span><span class="s3">, </span><span class="s1">self.port)</span><span class="s3">, </span><span class="s4">'wsgi'</span><span class="s3">, </span><span class="s1">{ </span><span class="s4">'wsgi_app' </span><span class="s1">: handler })</span>
        <span class="s1">server.start()</span>


<span class="s3">class </span><span class="s1">BjoernServer(ServerAdapter):</span>
    <span class="s2">&quot;&quot;&quot; Fast server written in C: https://github.com/jonashaag/bjoern &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">from </span><span class="s1">bjoern </span><span class="s3">import </span><span class="s1">run</span>
        <span class="s1">run(handler</span><span class="s3">, </span><span class="s1">self.host</span><span class="s3">, </span><span class="s1">self.port)</span>


<span class="s3">class </span><span class="s1">AutoServer(ServerAdapter):</span>
    <span class="s2">&quot;&quot;&quot; Untested. &quot;&quot;&quot;</span>
    <span class="s1">adapters = [WaitressServer</span><span class="s3">, </span><span class="s1">PasteServer</span><span class="s3">, </span><span class="s1">TwistedServer</span><span class="s3">, </span><span class="s1">CherryPyServer</span><span class="s3">,</span>
                <span class="s1">CherootServer</span><span class="s3">, </span><span class="s1">WSGIRefServer]</span>

    <span class="s3">def </span><span class="s1">run(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">for </span><span class="s1">sa </span><span class="s3">in </span><span class="s1">self.adapters:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">sa(self.host</span><span class="s3">, </span><span class="s1">self.port</span><span class="s3">, </span><span class="s1">**self.options).run(handler)</span>
            <span class="s3">except </span><span class="s1">ImportError:</span>
                <span class="s3">pass</span>

<span class="s1">server_names = {</span>
    <span class="s4">'cgi'</span><span class="s1">: CGIServer</span><span class="s3">,</span>
    <span class="s4">'flup'</span><span class="s1">: FlupFCGIServer</span><span class="s3">,</span>
    <span class="s4">'wsgiref'</span><span class="s1">: WSGIRefServer</span><span class="s3">,</span>
    <span class="s4">'waitress'</span><span class="s1">: WaitressServer</span><span class="s3">,</span>
    <span class="s4">'cherrypy'</span><span class="s1">: CherryPyServer</span><span class="s3">,</span>
    <span class="s4">'cheroot'</span><span class="s1">: CherootServer</span><span class="s3">,</span>
    <span class="s4">'paste'</span><span class="s1">: PasteServer</span><span class="s3">,</span>
    <span class="s4">'fapws3'</span><span class="s1">: FapwsServer</span><span class="s3">,</span>
    <span class="s4">'tornado'</span><span class="s1">: TornadoServer</span><span class="s3">,</span>
    <span class="s4">'gae'</span><span class="s1">: AppEngineServer</span><span class="s3">,</span>
    <span class="s4">'twisted'</span><span class="s1">: TwistedServer</span><span class="s3">,</span>
    <span class="s4">'diesel'</span><span class="s1">: DieselServer</span><span class="s3">,</span>
    <span class="s4">'meinheld'</span><span class="s1">: MeinheldServer</span><span class="s3">,</span>
    <span class="s4">'gunicorn'</span><span class="s1">: GunicornServer</span><span class="s3">,</span>
    <span class="s4">'eventlet'</span><span class="s1">: EventletServer</span><span class="s3">,</span>
    <span class="s4">'gevent'</span><span class="s1">: GeventServer</span><span class="s3">,</span>
    <span class="s4">'geventSocketIO'</span><span class="s1">:GeventSocketIOServer</span><span class="s3">,</span>
    <span class="s4">'rocket'</span><span class="s1">: RocketServer</span><span class="s3">,</span>
    <span class="s4">'bjoern' </span><span class="s1">: BjoernServer</span><span class="s3">,</span>
    <span class="s4">'auto'</span><span class="s1">: AutoServer</span><span class="s3">,</span>
<span class="s1">}</span>






<span class="s0">###############################################################################</span>
<span class="s0"># Application Control ##########################################################</span>
<span class="s0">###############################################################################</span>


<span class="s3">def </span><span class="s1">load(target</span><span class="s3">, </span><span class="s1">**namespace):</span>
    <span class="s2">&quot;&quot;&quot; Import a module or fetch an object from a module. 
 
        * ``package.module`` returns `module` as a module object. 
        * ``pack.mod:name`` returns the module variable `name` from `pack.mod`. 
        * ``pack.mod:func()`` calls `pack.mod.func()` and returns the result. 
 
        The last form accepts not only function calls, but any type of 
        expression. Keyword arguments passed to this function are available as 
        local variables. Example: ``import_string('re:compile(x)', x='[a-z]')`` 
    &quot;&quot;&quot;</span>
    <span class="s1">module</span><span class="s3">, </span><span class="s1">target = target.split(</span><span class="s4">&quot;:&quot;</span><span class="s3">, </span><span class="s5">1</span><span class="s1">) </span><span class="s3">if </span><span class="s4">':' </span><span class="s3">in </span><span class="s1">target </span><span class="s3">else </span><span class="s1">(target</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">module </span><span class="s3">not in </span><span class="s1">sys.modules: __import__(module)</span>
    <span class="s3">if not </span><span class="s1">target: </span><span class="s3">return </span><span class="s1">sys.modules[module]</span>
    <span class="s3">if </span><span class="s1">target.isalnum(): </span><span class="s3">return </span><span class="s1">getattr(sys.modules[module]</span><span class="s3">, </span><span class="s1">target)</span>
    <span class="s1">package_name = module.split(</span><span class="s4">'.'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">namespace[package_name] = sys.modules[package_name]</span>
    <span class="s3">return </span><span class="s1">eval(</span><span class="s4">'%s.%s' </span><span class="s1">% (module</span><span class="s3">, </span><span class="s1">target)</span><span class="s3">, </span><span class="s1">namespace)</span>


<span class="s3">def </span><span class="s1">load_app(target):</span>
    <span class="s2">&quot;&quot;&quot; Load a bottle application from a module and make sure that the import 
        does not affect the current default application, but returns a separate 
        application object. See :func:`load` for the target parameter. &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">NORUN; NORUN</span><span class="s3">, </span><span class="s1">nr_old = </span><span class="s3">True, </span><span class="s1">NORUN</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">tmp = default_app.push() </span><span class="s0"># Create a new &quot;default application&quot;</span>
        <span class="s1">rv = load(target) </span><span class="s0"># Import the target module</span>
        <span class="s3">return </span><span class="s1">rv </span><span class="s3">if </span><span class="s1">callable(rv) </span><span class="s3">else </span><span class="s1">tmp</span>
    <span class="s3">finally</span><span class="s1">:</span>
        <span class="s1">default_app.remove(tmp) </span><span class="s0"># Remove the temporary added default application</span>
        <span class="s1">NORUN = nr_old</span>

<span class="s1">_debug = debug</span>
<span class="s3">def </span><span class="s1">run(app=</span><span class="s3">None, </span><span class="s1">server=</span><span class="s4">'wsgiref'</span><span class="s3">, </span><span class="s1">host=</span><span class="s4">'127.0.0.1'</span><span class="s3">, </span><span class="s1">port=</span><span class="s5">8080</span><span class="s3">,</span>
        <span class="s1">interval=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">reloader=</span><span class="s3">False, </span><span class="s1">quiet=</span><span class="s3">False, </span><span class="s1">plugins=</span><span class="s3">None,</span>
        <span class="s1">debug=</span><span class="s3">None, </span><span class="s1">**kargs):</span>
    <span class="s2">&quot;&quot;&quot; Start a server instance. This method blocks until the server terminates. 
 
        :param app: WSGI application or target string supported by 
               :func:`load_app`. (default: :func:`default_app`) 
        :param server: Server adapter to use. See :data:`server_names` keys 
               for valid names or pass a :class:`ServerAdapter` subclass. 
               (default: `wsgiref`) 
        :param host: Server address to bind to. Pass ``0.0.0.0`` to listens on 
               all interfaces including the external one. (default: 127.0.0.1) 
        :param port: Server port to bind to. Values below 1024 require root 
               privileges. (default: 8080) 
        :param reloader: Start auto-reloading server? (default: False) 
        :param interval: Auto-reloader interval in seconds (default: 1) 
        :param quiet: Suppress output to stdout and stderr? (default: False) 
        :param options: Options passed to the server adapter. 
     &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">NORUN: </span><span class="s3">return</span>
    <span class="s3">if </span><span class="s1">reloader </span><span class="s3">and not </span><span class="s1">os.environ.get(</span><span class="s4">'BOTTLE_CHILD'</span><span class="s1">):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">lockfile = </span><span class="s3">None</span>
            <span class="s1">fd</span><span class="s3">, </span><span class="s1">lockfile = tempfile.mkstemp(prefix=</span><span class="s4">'bottle.'</span><span class="s3">, </span><span class="s1">suffix=</span><span class="s4">'.lock'</span><span class="s1">)</span>
            <span class="s1">os.close(fd) </span><span class="s0"># We only need this file to exist. We never write to it</span>
            <span class="s3">while </span><span class="s1">os.path.exists(lockfile):</span>
                <span class="s1">args = [sys.executable] + sys.argv</span>
                <span class="s1">environ = os.environ.copy()</span>
                <span class="s1">environ[</span><span class="s4">'BOTTLE_CHILD'</span><span class="s1">] = </span><span class="s4">'true'</span>
                <span class="s1">environ[</span><span class="s4">'BOTTLE_LOCKFILE'</span><span class="s1">] = lockfile</span>
                <span class="s1">p = subprocess.Popen(args</span><span class="s3">, </span><span class="s1">env=environ)</span>
                <span class="s3">while </span><span class="s1">p.poll() </span><span class="s3">is None</span><span class="s1">: </span><span class="s0"># Busy wait...</span>
                    <span class="s1">os.utime(lockfile</span><span class="s3">, None</span><span class="s1">) </span><span class="s0"># I am alive!</span>
                    <span class="s1">time.sleep(interval)</span>
                <span class="s3">if </span><span class="s1">p.poll() != </span><span class="s5">3</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">os.path.exists(lockfile): os.unlink(lockfile)</span>
                    <span class="s1">sys.exit(p.poll())</span>
        <span class="s3">except </span><span class="s1">KeyboardInterrupt:</span>
            <span class="s3">pass</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">os.path.exists(lockfile):</span>
                <span class="s1">os.unlink(lockfile)</span>
        <span class="s3">return</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">debug </span><span class="s3">is not None</span><span class="s1">: _debug(debug)</span>
        <span class="s1">app = app </span><span class="s3">or </span><span class="s1">default_app()</span>
        <span class="s3">if </span><span class="s1">isinstance(app</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">app = load_app(app)</span>
        <span class="s3">if not </span><span class="s1">callable(app):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Application is not callable: %r&quot; </span><span class="s1">% app)</span>

        <span class="s3">for </span><span class="s1">plugin </span><span class="s3">in </span><span class="s1">plugins </span><span class="s3">or </span><span class="s1">[]:</span>
            <span class="s1">app.install(plugin)</span>

        <span class="s3">if </span><span class="s1">server </span><span class="s3">in </span><span class="s1">server_names:</span>
            <span class="s1">server = server_names.get(server)</span>
        <span class="s3">if </span><span class="s1">isinstance(server</span><span class="s3">, </span><span class="s1">basestring):</span>
            <span class="s1">server = load(server)</span>
        <span class="s3">if </span><span class="s1">isinstance(server</span><span class="s3">, </span><span class="s1">type):</span>
            <span class="s1">server = server(host=host</span><span class="s3">, </span><span class="s1">port=port</span><span class="s3">, </span><span class="s1">**kargs)</span>
        <span class="s3">if not </span><span class="s1">isinstance(server</span><span class="s3">, </span><span class="s1">ServerAdapter):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unknown or unsupported server: %r&quot; </span><span class="s1">% server)</span>

        <span class="s1">server.quiet = server.quiet </span><span class="s3">or </span><span class="s1">quiet</span>
        <span class="s3">if not </span><span class="s1">server.quiet:</span>
            <span class="s1">_stderr(</span><span class="s4">&quot;Bottle v%s server starting up (using %s)...</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">% (__version__</span><span class="s3">, </span><span class="s1">repr(server)))</span>
            <span class="s1">_stderr(</span><span class="s4">&quot;Listening on http://%s:%d/</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">% (server.host</span><span class="s3">, </span><span class="s1">server.port))</span>
            <span class="s1">_stderr(</span><span class="s4">&quot;Hit Ctrl-C to quit.</span><span class="s3">\n\n</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">reloader:</span>
            <span class="s1">lockfile = os.environ.get(</span><span class="s4">'BOTTLE_LOCKFILE'</span><span class="s1">)</span>
            <span class="s1">bgcheck = FileCheckerThread(lockfile</span><span class="s3">, </span><span class="s1">interval)</span>
            <span class="s3">with </span><span class="s1">bgcheck:</span>
                <span class="s1">server.run(app)</span>
            <span class="s3">if </span><span class="s1">bgcheck.status == </span><span class="s4">'reload'</span><span class="s1">:</span>
                <span class="s1">sys.exit(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">server.run(app)</span>
    <span class="s3">except </span><span class="s1">KeyboardInterrupt:</span>
        <span class="s3">pass</span>
    <span class="s3">except </span><span class="s1">(SystemExit</span><span class="s3">, </span><span class="s1">MemoryError):</span>
        <span class="s3">raise</span>
    <span class="s3">except</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">reloader: </span><span class="s3">raise</span>
        <span class="s3">if not </span><span class="s1">getattr(server</span><span class="s3">, </span><span class="s4">'quiet'</span><span class="s3">, </span><span class="s1">quiet):</span>
            <span class="s1">print_exc()</span>
        <span class="s1">time.sleep(interval)</span>
        <span class="s1">sys.exit(</span><span class="s5">3</span><span class="s1">)</span>



<span class="s3">class </span><span class="s1">FileCheckerThread(threading.Thread):</span>
    <span class="s2">''' Interrupt main-thread as soon as a changed module file is detected, 
        the lockfile gets deleted or gets to old. '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">lockfile</span><span class="s3">, </span><span class="s1">interval):</span>
        <span class="s1">threading.Thread.__init__(self)</span>
        <span class="s1">self.lockfile</span><span class="s3">, </span><span class="s1">self.interval = lockfile</span><span class="s3">, </span><span class="s1">interval</span>
        <span class="s0">#: Is one of 'reload', 'error' or 'exit'</span>
        <span class="s1">self.status = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">run(self):</span>
        <span class="s1">exists = os.path.exists</span>
        <span class="s1">mtime = </span><span class="s3">lambda </span><span class="s1">path: os.stat(path).st_mtime</span>
        <span class="s1">files = dict()</span>

        <span class="s3">for </span><span class="s1">module </span><span class="s3">in </span><span class="s1">list(sys.modules.values()):</span>
            <span class="s1">path = getattr(module</span><span class="s3">, </span><span class="s4">'__file__'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">) </span><span class="s3">or </span><span class="s4">''</span>
            <span class="s3">if </span><span class="s1">path[-</span><span class="s5">4</span><span class="s1">:] </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'.pyo'</span><span class="s3">, </span><span class="s4">'.pyc'</span><span class="s1">): path = path[:-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">path </span><span class="s3">and </span><span class="s1">exists(path): files[path] = mtime(path)</span>

        <span class="s3">while not </span><span class="s1">self.status:</span>
            <span class="s3">if not </span><span class="s1">exists(self.lockfile)\</span>
            <span class="s3">or </span><span class="s1">mtime(self.lockfile) &lt; time.time() - self.interval - </span><span class="s5">5</span><span class="s1">:</span>
                <span class="s1">self.status = </span><span class="s4">'error'</span>
                <span class="s1">thread.interrupt_main()</span>
            <span class="s3">for </span><span class="s1">path</span><span class="s3">, </span><span class="s1">lmtime </span><span class="s3">in </span><span class="s1">list(files.items()):</span>
                <span class="s3">if not </span><span class="s1">exists(path) </span><span class="s3">or </span><span class="s1">mtime(path) &gt; lmtime:</span>
                    <span class="s1">self.status = </span><span class="s4">'reload'</span>
                    <span class="s1">thread.interrupt_main()</span>
                    <span class="s3">break</span>
            <span class="s1">time.sleep(self.interval)</span>

    <span class="s3">def </span><span class="s1">__enter__(self):</span>
        <span class="s1">self.start()</span>

    <span class="s3">def </span><span class="s1">__exit__(self</span><span class="s3">, </span><span class="s1">exc_type</span><span class="s3">, </span><span class="s1">exc_val</span><span class="s3">, </span><span class="s1">exc_tb):</span>
        <span class="s3">if not </span><span class="s1">self.status: self.status = </span><span class="s4">'exit' </span><span class="s0"># silent exit</span>
        <span class="s1">self.join()</span>
        <span class="s3">return </span><span class="s1">exc_type </span><span class="s3">is not None and </span><span class="s1">issubclass(exc_type</span><span class="s3">, </span><span class="s1">KeyboardInterrupt)</span>





<span class="s0">###############################################################################</span>
<span class="s0"># Template Adapters ############################################################</span>
<span class="s0">###############################################################################</span>


<span class="s3">class </span><span class="s1">TemplateError(HTTPError):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">message):</span>
        <span class="s1">HTTPError.__init__(self</span><span class="s3">, </span><span class="s5">500</span><span class="s3">, </span><span class="s1">message)</span>


<span class="s3">class </span><span class="s1">BaseTemplate(object):</span>
    <span class="s2">&quot;&quot;&quot; Base class and minimal API for template adapters &quot;&quot;&quot;</span>
    <span class="s1">extensions = [</span><span class="s4">'tpl'</span><span class="s3">,</span><span class="s4">'html'</span><span class="s3">,</span><span class="s4">'thtml'</span><span class="s3">,</span><span class="s4">'stpl'</span><span class="s1">]</span>
    <span class="s1">settings = {} </span><span class="s0">#used in prepare()</span>
    <span class="s1">defaults = {} </span><span class="s0">#used in render()</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">source=</span><span class="s3">None, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">lookup=[]</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s4">'utf8'</span><span class="s3">, </span><span class="s1">**settings):</span>
        <span class="s2">&quot;&quot;&quot; Create a new template. 
        If the source parameter (str or buffer) is missing, the name argument 
        is used to guess a template filename. Subclasses can assume that 
        self.source and/or self.filename are set. Both are strings. 
        The lookup, encoding and settings parameters are stored as instance 
        variables. 
        The lookup parameter stores a list containing directory paths. 
        The encoding parameter should be used to decode byte strings or files. 
        The settings parameter contains a dict for engine-specific settings. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.source = source.read() </span><span class="s3">if </span><span class="s1">hasattr(source</span><span class="s3">, </span><span class="s4">'read'</span><span class="s1">) </span><span class="s3">else </span><span class="s1">source</span>
        <span class="s1">self.filename = source.filename </span><span class="s3">if </span><span class="s1">hasattr(source</span><span class="s3">, </span><span class="s4">'filename'</span><span class="s1">) </span><span class="s3">else None</span>
        <span class="s1">self.lookup = [os.path.abspath(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">lookup]</span>
        <span class="s1">self.encoding = encoding</span>
        <span class="s1">self.settings = self.settings.copy() </span><span class="s0"># Copy from class variable</span>
        <span class="s1">self.settings.update(settings) </span><span class="s0"># Apply</span>
        <span class="s3">if not </span><span class="s1">self.source </span><span class="s3">and </span><span class="s1">self.name:</span>
            <span class="s1">self.filename = self.search(self.name</span><span class="s3">, </span><span class="s1">self.lookup)</span>
            <span class="s3">if not </span><span class="s1">self.filename:</span>
                <span class="s3">raise </span><span class="s1">TemplateError(</span><span class="s4">'Template %s not found.' </span><span class="s1">% repr(name))</span>
        <span class="s3">if not </span><span class="s1">self.source </span><span class="s3">and not </span><span class="s1">self.filename:</span>
            <span class="s3">raise </span><span class="s1">TemplateError(</span><span class="s4">'No template specified.'</span><span class="s1">)</span>
        <span class="s1">self.prepare(**self.settings)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">search(cls</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">lookup=[]):</span>
        <span class="s2">&quot;&quot;&quot; Search name in all directories specified in lookup. 
        First without, then with common extensions. Return first hit. &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">lookup:</span>
            <span class="s1">depr(</span><span class="s4">'The template lookup path list should not be empty.'</span><span class="s1">) </span><span class="s0">#0.12</span>
            <span class="s1">lookup = [</span><span class="s4">'.'</span><span class="s1">]</span>

        <span class="s3">if </span><span class="s1">os.path.isabs(name) </span><span class="s3">and </span><span class="s1">os.path.isfile(name):</span>
            <span class="s1">depr(</span><span class="s4">'Absolute template path names are deprecated.'</span><span class="s1">) </span><span class="s0">#0.12</span>
            <span class="s3">return </span><span class="s1">os.path.abspath(name)</span>

        <span class="s3">for </span><span class="s1">spath </span><span class="s3">in </span><span class="s1">lookup:</span>
            <span class="s1">spath = os.path.abspath(spath) + os.sep</span>
            <span class="s1">fname = os.path.abspath(os.path.join(spath</span><span class="s3">, </span><span class="s1">name))</span>
            <span class="s3">if not </span><span class="s1">fname.startswith(spath): </span><span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">os.path.isfile(fname): </span><span class="s3">return </span><span class="s1">fname</span>
            <span class="s3">for </span><span class="s1">ext </span><span class="s3">in </span><span class="s1">cls.extensions:</span>
                <span class="s3">if </span><span class="s1">os.path.isfile(</span><span class="s4">'%s.%s' </span><span class="s1">% (fname</span><span class="s3">, </span><span class="s1">ext)):</span>
                    <span class="s3">return </span><span class="s4">'%s.%s' </span><span class="s1">% (fname</span><span class="s3">, </span><span class="s1">ext)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">global_config(cls</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s2">''' This reads or sets the global settings stored in class.settings. '''</span>
        <span class="s3">if </span><span class="s1">args:</span>
            <span class="s1">cls.settings = cls.settings.copy() </span><span class="s0"># Make settings local to class</span>
            <span class="s1">cls.settings[key] = args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">cls.settings[key]</span>

    <span class="s3">def </span><span class="s1">prepare(self</span><span class="s3">, </span><span class="s1">**options):</span>
        <span class="s2">&quot;&quot;&quot; Run preparations (parsing, caching, ...). 
        It should be possible to call this again to refresh a template or to 
        update settings. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">render(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; Render the template with the specified local variables and return 
        a single byte or unicode string. If it is a byte string, the encoding 
        must match self.encoding. This method must be thread-safe! 
        Local variables may be provided in dictionaries (args) 
        or directly, as keywords (kwargs). 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">class </span><span class="s1">MakoTemplate(BaseTemplate):</span>
    <span class="s3">def </span><span class="s1">prepare(self</span><span class="s3">, </span><span class="s1">**options):</span>
        <span class="s3">from </span><span class="s1">mako.template </span><span class="s3">import </span><span class="s1">Template</span>
        <span class="s3">from </span><span class="s1">mako.lookup </span><span class="s3">import </span><span class="s1">TemplateLookup</span>
        <span class="s1">options.update({</span><span class="s4">'input_encoding'</span><span class="s1">:self.encoding})</span>
        <span class="s1">options.setdefault(</span><span class="s4">'format_exceptions'</span><span class="s3">, </span><span class="s1">bool(DEBUG))</span>
        <span class="s1">lookup = TemplateLookup(directories=self.lookup</span><span class="s3">, </span><span class="s1">**options)</span>
        <span class="s3">if </span><span class="s1">self.source:</span>
            <span class="s1">self.tpl = Template(self.source</span><span class="s3">, </span><span class="s1">lookup=lookup</span><span class="s3">, </span><span class="s1">**options)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.tpl = Template(uri=self.name</span><span class="s3">, </span><span class="s1">filename=self.filename</span><span class="s3">, </span><span class="s1">lookup=lookup</span><span class="s3">, </span><span class="s1">**options)</span>

    <span class="s3">def </span><span class="s1">render(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">for </span><span class="s1">dictarg </span><span class="s3">in </span><span class="s1">args: kwargs.update(dictarg)</span>
        <span class="s1">_defaults = self.defaults.copy()</span>
        <span class="s1">_defaults.update(kwargs)</span>
        <span class="s3">return </span><span class="s1">self.tpl.render(**_defaults)</span>


<span class="s3">class </span><span class="s1">CheetahTemplate(BaseTemplate):</span>
    <span class="s3">def </span><span class="s1">prepare(self</span><span class="s3">, </span><span class="s1">**options):</span>
        <span class="s3">from </span><span class="s1">Cheetah.Template </span><span class="s3">import </span><span class="s1">Template</span>
        <span class="s1">self.context = threading.local()</span>
        <span class="s1">self.context.vars = {}</span>
        <span class="s1">options[</span><span class="s4">'searchList'</span><span class="s1">] = [self.context.vars]</span>
        <span class="s3">if </span><span class="s1">self.source:</span>
            <span class="s1">self.tpl = Template(source=self.source</span><span class="s3">, </span><span class="s1">**options)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.tpl = Template(file=self.filename</span><span class="s3">, </span><span class="s1">**options)</span>

    <span class="s3">def </span><span class="s1">render(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">for </span><span class="s1">dictarg </span><span class="s3">in </span><span class="s1">args: kwargs.update(dictarg)</span>
        <span class="s1">self.context.vars.update(self.defaults)</span>
        <span class="s1">self.context.vars.update(kwargs)</span>
        <span class="s1">out = str(self.tpl)</span>
        <span class="s1">self.context.vars.clear()</span>
        <span class="s3">return </span><span class="s1">out</span>


<span class="s3">class </span><span class="s1">Jinja2Template(BaseTemplate):</span>
    <span class="s3">def </span><span class="s1">prepare(self</span><span class="s3">, </span><span class="s1">filters=</span><span class="s3">None, </span><span class="s1">tests=</span><span class="s3">None, </span><span class="s1">globals={}</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">from </span><span class="s1">jinja2 </span><span class="s3">import </span><span class="s1">Environment</span><span class="s3">, </span><span class="s1">FunctionLoader</span>
        <span class="s3">if </span><span class="s4">'prefix' </span><span class="s3">in </span><span class="s1">kwargs: </span><span class="s0"># TODO: to be removed after a while</span>
            <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">'The keyword argument `prefix` has been removed. '</span>
                <span class="s4">'Use the full jinja2 environment name line_statement_prefix instead.'</span><span class="s1">)</span>
        <span class="s1">self.env = Environment(loader=FunctionLoader(self.loader)</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">if </span><span class="s1">filters: self.env.filters.update(filters)</span>
        <span class="s3">if </span><span class="s1">tests: self.env.tests.update(tests)</span>
        <span class="s3">if </span><span class="s1">globals: self.env.globals.update(globals)</span>
        <span class="s3">if </span><span class="s1">self.source:</span>
            <span class="s1">self.tpl = self.env.from_string(self.source)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.tpl = self.env.get_template(self.filename)</span>

    <span class="s3">def </span><span class="s1">render(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">for </span><span class="s1">dictarg </span><span class="s3">in </span><span class="s1">args: kwargs.update(dictarg)</span>
        <span class="s1">_defaults = self.defaults.copy()</span>
        <span class="s1">_defaults.update(kwargs)</span>
        <span class="s3">return </span><span class="s1">self.tpl.render(**_defaults)</span>

    <span class="s3">def </span><span class="s1">loader(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s1">fname = self.search(name</span><span class="s3">, </span><span class="s1">self.lookup)</span>
        <span class="s3">if not </span><span class="s1">fname: </span><span class="s3">return</span>
        <span class="s3">with </span><span class="s1">open(fname</span><span class="s3">, </span><span class="s4">&quot;rb&quot;</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s3">return </span><span class="s1">f.read().decode(self.encoding)</span>


<span class="s3">class </span><span class="s1">SimpleTemplate(BaseTemplate):</span>

    <span class="s3">def </span><span class="s1">prepare(self</span><span class="s3">, </span><span class="s1">escape_func=html_escape</span><span class="s3">, </span><span class="s1">noescape=</span><span class="s3">False, </span><span class="s1">syntax=</span><span class="s3">None, </span><span class="s1">**ka):</span>
        <span class="s1">self.cache = {}</span>
        <span class="s1">enc = self.encoding</span>
        <span class="s1">self._str = </span><span class="s3">lambda </span><span class="s1">x: touni(x</span><span class="s3">, </span><span class="s1">enc)</span>
        <span class="s1">self._escape = </span><span class="s3">lambda </span><span class="s1">x: escape_func(touni(x</span><span class="s3">, </span><span class="s1">enc))</span>
        <span class="s1">self.syntax = syntax</span>
        <span class="s3">if </span><span class="s1">noescape:</span>
            <span class="s1">self._str</span><span class="s3">, </span><span class="s1">self._escape = self._escape</span><span class="s3">, </span><span class="s1">self._str</span>

    <span class="s1">@cached_property</span>
    <span class="s3">def </span><span class="s1">co(self):</span>
        <span class="s3">return </span><span class="s1">compile(self.code</span><span class="s3">, </span><span class="s1">self.filename </span><span class="s3">or </span><span class="s4">'&lt;string&gt;'</span><span class="s3">, </span><span class="s4">'exec'</span><span class="s1">)</span>

    <span class="s1">@cached_property</span>
    <span class="s3">def </span><span class="s1">code(self):</span>
        <span class="s1">source = self.source</span>
        <span class="s3">if not </span><span class="s1">source:</span>
            <span class="s3">with </span><span class="s1">open(self.filename</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
                <span class="s1">source = f.read()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">source</span><span class="s3">, </span><span class="s1">encoding = touni(source)</span><span class="s3">, </span><span class="s4">'utf8'</span>
        <span class="s3">except </span><span class="s1">UnicodeError:</span>
            <span class="s1">depr(</span><span class="s4">'Template encodings other than utf8 are no longer supported.'</span><span class="s1">) </span><span class="s0">#0.11</span>
            <span class="s1">source</span><span class="s3">, </span><span class="s1">encoding = touni(source</span><span class="s3">, </span><span class="s4">'latin1'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">'latin1'</span>
        <span class="s1">parser = StplParser(source</span><span class="s3">, </span><span class="s1">encoding=encoding</span><span class="s3">, </span><span class="s1">syntax=self.syntax)</span>
        <span class="s1">code = parser.translate()</span>
        <span class="s1">self.encoding = parser.encoding</span>
        <span class="s3">return </span><span class="s1">code</span>

    <span class="s3">def </span><span class="s1">_rebase(self</span><span class="s3">, </span><span class="s1">_env</span><span class="s3">, </span><span class="s1">_name=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s3">if </span><span class="s1">_name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">depr(</span><span class="s4">'Rebase function called without arguments.'</span>
                 <span class="s4">' You were probably looking for {{base}}?'</span><span class="s3">, True</span><span class="s1">) </span><span class="s0">#0.12</span>
        <span class="s1">_env[</span><span class="s4">'_rebase'</span><span class="s1">] = (_name</span><span class="s3">, </span><span class="s1">kwargs)</span>

    <span class="s3">def </span><span class="s1">_include(self</span><span class="s3">, </span><span class="s1">_env</span><span class="s3">, </span><span class="s1">_name=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s3">if </span><span class="s1">_name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">depr(</span><span class="s4">'Rebase function called without arguments.'</span>
                 <span class="s4">' You were probably looking for {{base}}?'</span><span class="s3">, True</span><span class="s1">) </span><span class="s0">#0.12</span>
        <span class="s1">env = _env.copy()</span>
        <span class="s1">env.update(kwargs)</span>
        <span class="s3">if </span><span class="s1">_name </span><span class="s3">not in </span><span class="s1">self.cache:</span>
            <span class="s1">self.cache[_name] = self.__class__(name=_name</span><span class="s3">, </span><span class="s1">lookup=self.lookup)</span>
        <span class="s3">return </span><span class="s1">self.cache[_name].execute(env[</span><span class="s4">'_stdout'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">env)</span>

    <span class="s3">def </span><span class="s1">execute(self</span><span class="s3">, </span><span class="s1">_stdout</span><span class="s3">, </span><span class="s1">kwargs):</span>
        <span class="s1">env = self.defaults.copy()</span>
        <span class="s1">env.update(kwargs)</span>
        <span class="s1">env.update({</span><span class="s4">'_stdout'</span><span class="s1">: _stdout</span><span class="s3">, </span><span class="s4">'_printlist'</span><span class="s1">: _stdout.extend</span><span class="s3">,</span>
            <span class="s4">'include'</span><span class="s1">: functools.partial(self._include</span><span class="s3">, </span><span class="s1">env)</span><span class="s3">,</span>
            <span class="s4">'rebase'</span><span class="s1">: functools.partial(self._rebase</span><span class="s3">, </span><span class="s1">env)</span><span class="s3">, </span><span class="s4">'_rebase'</span><span class="s1">: </span><span class="s3">None,</span>
            <span class="s4">'_str'</span><span class="s1">: self._str</span><span class="s3">, </span><span class="s4">'_escape'</span><span class="s1">: self._escape</span><span class="s3">, </span><span class="s4">'get'</span><span class="s1">: env.get</span><span class="s3">,</span>
            <span class="s4">'setdefault'</span><span class="s1">: env.setdefault</span><span class="s3">, </span><span class="s4">'defined'</span><span class="s1">: env.__contains__ })</span>
        <span class="s1">eval(self.co</span><span class="s3">, </span><span class="s1">env)</span>
        <span class="s3">if </span><span class="s1">env.get(</span><span class="s4">'_rebase'</span><span class="s1">):</span>
            <span class="s1">subtpl</span><span class="s3">, </span><span class="s1">rargs = env.pop(</span><span class="s4">'_rebase'</span><span class="s1">)</span>
            <span class="s1">rargs[</span><span class="s4">'base'</span><span class="s1">] = </span><span class="s4">''</span><span class="s1">.join(_stdout) </span><span class="s0">#copy stdout</span>
            <span class="s3">del </span><span class="s1">_stdout[:] </span><span class="s0"># clear stdout</span>
            <span class="s3">return </span><span class="s1">self._include(env</span><span class="s3">, </span><span class="s1">subtpl</span><span class="s3">, </span><span class="s1">**rargs)</span>
        <span class="s3">return </span><span class="s1">env</span>

    <span class="s3">def </span><span class="s1">render(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; Render the template using keyword arguments as local variables. &quot;&quot;&quot;</span>
        <span class="s1">env = {}; stdout = []</span>
        <span class="s3">for </span><span class="s1">dictarg </span><span class="s3">in </span><span class="s1">args: env.update(dictarg)</span>
        <span class="s1">env.update(kwargs)</span>
        <span class="s1">self.execute(stdout</span><span class="s3">, </span><span class="s1">env)</span>
        <span class="s3">return </span><span class="s4">''</span><span class="s1">.join(stdout)</span>


<span class="s3">class </span><span class="s1">StplSyntaxError(TemplateError): </span><span class="s3">pass</span>


<span class="s3">class </span><span class="s1">StplParser(object):</span>
    <span class="s2">''' Parser for stpl templates. '''</span>
    <span class="s1">_re_cache = {} </span><span class="s0">#: Cache for compiled re patterns</span>
    <span class="s0"># This huge pile of voodoo magic splits python code into 8 different tokens.</span>
    <span class="s0"># 1: All kinds of python strings (trust me, it works)</span>
    <span class="s1">_re_tok = </span><span class="s4">'([urbURB]?(?:</span><span class="s3">\'\'</span><span class="s4">(?!</span><span class="s3">\'</span><span class="s4">)|&quot;&quot;(?!&quot;)|</span><span class="s3">\'</span><span class="s4">{6}|&quot;{6}' </span><span class="s1">\</span>
               <span class="s4">'|</span><span class="s3">\'</span><span class="s4">(?:[^</span><span class="s3">\\\\\'</span><span class="s4">]|</span><span class="s3">\\\\</span><span class="s4">.)+?</span><span class="s3">\'</span><span class="s4">|&quot;(?:[^</span><span class="s3">\\\\</span><span class="s4">&quot;]|</span><span class="s3">\\\\</span><span class="s4">.)+?&quot;' </span><span class="s1">\</span>
               <span class="s4">'|</span><span class="s3">\'</span><span class="s4">{3}(?:[^</span><span class="s3">\\\\</span><span class="s4">]|</span><span class="s3">\\\\</span><span class="s4">.|</span><span class="s3">\\</span><span class="s4">n)+?</span><span class="s3">\'</span><span class="s4">{3}' </span><span class="s1">\</span>
               <span class="s4">'|&quot;{3}(?:[^</span><span class="s3">\\\\</span><span class="s4">]|</span><span class="s3">\\\\</span><span class="s4">.|</span><span class="s3">\\</span><span class="s4">n)+?&quot;{3}))'</span>
    <span class="s1">_re_inl = _re_tok.replace(</span><span class="s4">'|</span><span class="s3">\\</span><span class="s4">n'</span><span class="s3">,</span><span class="s4">''</span><span class="s1">) </span><span class="s0"># We re-use this string pattern later</span>
    <span class="s0"># 2: Comments (until end of line, but not the newline itself)</span>
    <span class="s1">_re_tok += </span><span class="s4">'|(#.*)'</span>
    <span class="s0"># 3,4: Open and close grouping tokens</span>
    <span class="s1">_re_tok += </span><span class="s4">'|([</span><span class="s3">\\</span><span class="s4">[</span><span class="s3">\\</span><span class="s4">{</span><span class="s3">\\</span><span class="s4">(])'</span>
    <span class="s1">_re_tok += </span><span class="s4">'|([</span><span class="s3">\\</span><span class="s4">]</span><span class="s3">\\</span><span class="s4">}</span><span class="s3">\\</span><span class="s4">)])'</span>
    <span class="s0"># 5,6: Keywords that start or continue a python block (only start of line)</span>
    <span class="s1">_re_tok += </span><span class="s4">'|^([ </span><span class="s3">\\</span><span class="s4">t]*(?:if|for|while|with|try|def|class)</span><span class="s3">\\</span><span class="s4">b)' </span><span class="s1">\</span>
               <span class="s4">'|^([ </span><span class="s3">\\</span><span class="s4">t]*(?:elif|else|except|finally)</span><span class="s3">\\</span><span class="s4">b)'</span>
    <span class="s0"># 7: Our special 'end' keyword (but only if it stands alone)</span>
    <span class="s1">_re_tok += </span><span class="s4">'|((?:^|;)[ </span><span class="s3">\\</span><span class="s4">t]*end[ </span><span class="s3">\\</span><span class="s4">t]*(?=(?:%(block_close)s[ </span><span class="s3">\\</span><span class="s4">t]*)?</span><span class="s3">\\</span><span class="s4">r?$|;|#))'</span>
    <span class="s0"># 8: A customizable end-of-code-block template token (only end of line)</span>
    <span class="s1">_re_tok += </span><span class="s4">'|(%(block_close)s[ </span><span class="s3">\\</span><span class="s4">t]*(?=</span><span class="s3">\\</span><span class="s4">r?$))'</span>
    <span class="s0"># 9: And finally, a single newline. The 10th token is 'everything else'</span>
    <span class="s1">_re_tok += </span><span class="s4">'|(</span><span class="s3">\\</span><span class="s4">r?</span><span class="s3">\\</span><span class="s4">n)'</span>

    <span class="s0"># Match the start tokens of code areas in a template</span>
    <span class="s1">_re_split = </span><span class="s4">'(?m)^[ </span><span class="s3">\t</span><span class="s4">]*(</span><span class="s3">\\\\</span><span class="s4">?)((%(line_start)s)|(%(block_start)s))(%%?)'</span>
    <span class="s0"># Match inline statements (may contain python strings)</span>
    <span class="s1">_re_inl = </span><span class="s4">'(?m)%%(inline_start)s((?:%s|[^</span><span class="s3">\'</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">])*?)%%(inline_end)s' </span><span class="s1">% _re_inl</span>
    <span class="s1">_re_tok = </span><span class="s4">'(?m)' </span><span class="s1">+ _re_tok</span>

    <span class="s1">default_syntax = </span><span class="s4">'&lt;% %&gt; % {{ }}'</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">source</span><span class="s3">, </span><span class="s1">syntax=</span><span class="s3">None, </span><span class="s1">encoding=</span><span class="s4">'utf8'</span><span class="s1">):</span>
        <span class="s1">self.source</span><span class="s3">, </span><span class="s1">self.encoding = touni(source</span><span class="s3">, </span><span class="s1">encoding)</span><span class="s3">, </span><span class="s1">encoding</span>
        <span class="s1">self.set_syntax(syntax </span><span class="s3">or </span><span class="s1">self.default_syntax)</span>
        <span class="s1">self.code_buffer</span><span class="s3">, </span><span class="s1">self.text_buffer = []</span><span class="s3">, </span><span class="s1">[]</span>
        <span class="s1">self.lineno</span><span class="s3">, </span><span class="s1">self.offset = </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span>
        <span class="s1">self.indent</span><span class="s3">, </span><span class="s1">self.indent_mod = </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span>
        <span class="s1">self.paren_depth = </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">get_syntax(self):</span>
        <span class="s2">''' Tokens as a space separated string (default: &lt;% %&gt; % {{ }}) '''</span>
        <span class="s3">return </span><span class="s1">self._syntax</span>

    <span class="s3">def </span><span class="s1">set_syntax(self</span><span class="s3">, </span><span class="s1">syntax):</span>
        <span class="s1">self._syntax = syntax</span>
        <span class="s1">self._tokens = syntax.split()</span>
        <span class="s3">if not </span><span class="s1">syntax </span><span class="s3">in </span><span class="s1">self._re_cache:</span>
            <span class="s1">names = </span><span class="s4">'block_start block_close line_start inline_start inline_end'</span>
            <span class="s1">etokens = map(re.escape</span><span class="s3">, </span><span class="s1">self._tokens)</span>
            <span class="s1">pattern_vars = dict(zip(names.split()</span><span class="s3">, </span><span class="s1">etokens))</span>
            <span class="s1">patterns = (self._re_split</span><span class="s3">, </span><span class="s1">self._re_tok</span><span class="s3">, </span><span class="s1">self._re_inl)</span>
            <span class="s1">patterns = [re.compile(p%pattern_vars) </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">patterns]</span>
            <span class="s1">self._re_cache[syntax] = patterns</span>
        <span class="s1">self.re_split</span><span class="s3">, </span><span class="s1">self.re_tok</span><span class="s3">, </span><span class="s1">self.re_inl = self._re_cache[syntax]</span>

    <span class="s1">syntax = property(get_syntax</span><span class="s3">, </span><span class="s1">set_syntax)</span>

    <span class="s3">def </span><span class="s1">translate(self):</span>
        <span class="s3">if </span><span class="s1">self.offset: </span><span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">'Parser is a one time instance.'</span><span class="s1">)</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s1">m = self.re_split.search(self.source[self.offset:])</span>
            <span class="s3">if </span><span class="s1">m:</span>
                <span class="s1">text = self.source[self.offset:self.offset+m.start()]</span>
                <span class="s1">self.text_buffer.append(text)</span>
                <span class="s1">self.offset += m.end()</span>
                <span class="s3">if </span><span class="s1">m.group(</span><span class="s5">1</span><span class="s1">): </span><span class="s0"># New escape syntax</span>
                    <span class="s1">line</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">, </span><span class="s1">_ = self.source[self.offset:].partition(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
                    <span class="s1">self.text_buffer.append(m.group(</span><span class="s5">2</span><span class="s1">)+m.group(</span><span class="s5">5</span><span class="s1">)+line+sep)</span>
                    <span class="s1">self.offset += len(line+sep)+</span><span class="s5">1</span>
                    <span class="s3">continue</span>
                <span class="s3">elif </span><span class="s1">m.group(</span><span class="s5">5</span><span class="s1">): </span><span class="s0"># Old escape syntax</span>
                    <span class="s1">depr(</span><span class="s4">'Escape code lines with a backslash.'</span><span class="s1">) </span><span class="s0">#0.12</span>
                    <span class="s1">line</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">, </span><span class="s1">_ = self.source[self.offset:].partition(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
                    <span class="s1">self.text_buffer.append(m.group(</span><span class="s5">2</span><span class="s1">)+line+sep)</span>
                    <span class="s1">self.offset += len(line+sep)+</span><span class="s5">1</span>
                    <span class="s3">continue</span>
                <span class="s1">self.flush_text()</span>
                <span class="s1">self.read_code(multiline=bool(m.group(</span><span class="s5">4</span><span class="s1">)))</span>
            <span class="s3">else</span><span class="s1">: </span><span class="s3">break</span>
        <span class="s1">self.text_buffer.append(self.source[self.offset:])</span>
        <span class="s1">self.flush_text()</span>
        <span class="s3">return </span><span class="s4">''</span><span class="s1">.join(self.code_buffer)</span>

    <span class="s3">def </span><span class="s1">read_code(self</span><span class="s3">, </span><span class="s1">multiline):</span>
        <span class="s1">code_line</span><span class="s3">, </span><span class="s1">comment = </span><span class="s4">''</span><span class="s3">, </span><span class="s4">''</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s1">m = self.re_tok.search(self.source[self.offset:])</span>
            <span class="s3">if not </span><span class="s1">m:</span>
                <span class="s1">code_line += self.source[self.offset:]</span>
                <span class="s1">self.offset = len(self.source)</span>
                <span class="s1">self.write_code(code_line.strip()</span><span class="s3">, </span><span class="s1">comment)</span>
                <span class="s3">return</span>
            <span class="s1">code_line += self.source[self.offset:self.offset+m.start()]</span>
            <span class="s1">self.offset += m.end()</span>
            <span class="s1">_str</span><span class="s3">, </span><span class="s1">_com</span><span class="s3">, </span><span class="s1">_po</span><span class="s3">, </span><span class="s1">_pc</span><span class="s3">, </span><span class="s1">_blk1</span><span class="s3">, </span><span class="s1">_blk2</span><span class="s3">, </span><span class="s1">_end</span><span class="s3">, </span><span class="s1">_cend</span><span class="s3">, </span><span class="s1">_nl = m.groups()</span>
            <span class="s3">if </span><span class="s1">(code_line </span><span class="s3">or </span><span class="s1">self.paren_depth &gt; </span><span class="s5">0</span><span class="s1">) </span><span class="s3">and </span><span class="s1">(_blk1 </span><span class="s3">or </span><span class="s1">_blk2): </span><span class="s0"># a if b else c</span>
                <span class="s1">code_line += _blk1 </span><span class="s3">or </span><span class="s1">_blk2</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">_str:    </span><span class="s0"># Python string</span>
                <span class="s1">code_line += _str</span>
            <span class="s3">elif </span><span class="s1">_com:  </span><span class="s0"># Python comment (up to EOL)</span>
                <span class="s1">comment = _com</span>
                <span class="s3">if </span><span class="s1">multiline </span><span class="s3">and </span><span class="s1">_com.strip().endswith(self._tokens[</span><span class="s5">1</span><span class="s1">]):</span>
                    <span class="s1">multiline = </span><span class="s3">False </span><span class="s0"># Allow end-of-block in comments</span>
            <span class="s3">elif </span><span class="s1">_po:  </span><span class="s0"># open parenthesis</span>
                <span class="s1">self.paren_depth += </span><span class="s5">1</span>
                <span class="s1">code_line += _po</span>
            <span class="s3">elif </span><span class="s1">_pc:  </span><span class="s0"># close parenthesis</span>
                <span class="s3">if </span><span class="s1">self.paren_depth &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s0"># we could check for matching parentheses here, but it's</span>
                    <span class="s0"># easier to leave that to python - just check counts</span>
                    <span class="s1">self.paren_depth -= </span><span class="s5">1</span>
                <span class="s1">code_line += _pc</span>
            <span class="s3">elif </span><span class="s1">_blk1: </span><span class="s0"># Start-block keyword (if/for/while/def/try/...)</span>
                <span class="s1">code_line</span><span class="s3">, </span><span class="s1">self.indent_mod = _blk1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span>
                <span class="s1">self.indent += </span><span class="s5">1</span>
            <span class="s3">elif </span><span class="s1">_blk2: </span><span class="s0"># Continue-block keyword (else/elif/except/...)</span>
                <span class="s1">code_line</span><span class="s3">, </span><span class="s1">self.indent_mod = _blk2</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span>
            <span class="s3">elif </span><span class="s1">_end:  </span><span class="s0"># The non-standard 'end'-keyword (ends a block)</span>
                <span class="s1">self.indent -= </span><span class="s5">1</span>
            <span class="s3">elif </span><span class="s1">_cend: </span><span class="s0"># The end-code-block template token (usually '%&gt;')</span>
                <span class="s3">if </span><span class="s1">multiline: multiline = </span><span class="s3">False</span>
                <span class="s3">else</span><span class="s1">: code_line += _cend</span>
            <span class="s3">else</span><span class="s1">: </span><span class="s0"># \n</span>
                <span class="s1">self.write_code(code_line.strip()</span><span class="s3">, </span><span class="s1">comment)</span>
                <span class="s1">self.lineno += </span><span class="s5">1</span>
                <span class="s1">code_line</span><span class="s3">, </span><span class="s1">comment</span><span class="s3">, </span><span class="s1">self.indent_mod = </span><span class="s4">''</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s5">0</span>
                <span class="s3">if not </span><span class="s1">multiline:</span>
                    <span class="s3">break</span>

    <span class="s3">def </span><span class="s1">flush_text(self):</span>
        <span class="s1">text = </span><span class="s4">''</span><span class="s1">.join(self.text_buffer)</span>
        <span class="s3">del </span><span class="s1">self.text_buffer[:]</span>
        <span class="s3">if not </span><span class="s1">text: </span><span class="s3">return</span>
        <span class="s1">parts</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">, </span><span class="s1">nl = []</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s4">'</span><span class="s3">\\\n</span><span class="s4">'</span><span class="s1">+</span><span class="s4">'  '</span><span class="s1">*self.indent</span>
        <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">self.re_inl.finditer(text):</span>
            <span class="s1">prefix</span><span class="s3">, </span><span class="s1">pos = text[pos:m.start()]</span><span class="s3">, </span><span class="s1">m.end()</span>
            <span class="s3">if </span><span class="s1">prefix:</span>
                <span class="s1">parts.append(nl.join(map(repr</span><span class="s3">, </span><span class="s1">prefix.splitlines(</span><span class="s3">True</span><span class="s1">))))</span>
            <span class="s3">if </span><span class="s1">prefix.endswith(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">): parts[-</span><span class="s5">1</span><span class="s1">] += nl</span>
            <span class="s1">parts.append(self.process_inline(m.group(</span><span class="s5">1</span><span class="s1">).strip()))</span>
        <span class="s3">if </span><span class="s1">pos &lt; len(text):</span>
            <span class="s1">prefix = text[pos:]</span>
            <span class="s1">lines = prefix.splitlines(</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">lines[-</span><span class="s5">1</span><span class="s1">].endswith(</span><span class="s4">'</span><span class="s3">\\\\\n</span><span class="s4">'</span><span class="s1">): lines[-</span><span class="s5">1</span><span class="s1">] = lines[-</span><span class="s5">1</span><span class="s1">][:-</span><span class="s5">3</span><span class="s1">]</span>
            <span class="s3">elif </span><span class="s1">lines[-</span><span class="s5">1</span><span class="s1">].endswith(</span><span class="s4">'</span><span class="s3">\\\\\r\n</span><span class="s4">'</span><span class="s1">): lines[-</span><span class="s5">1</span><span class="s1">] = lines[-</span><span class="s5">1</span><span class="s1">][:-</span><span class="s5">4</span><span class="s1">]</span>
            <span class="s1">parts.append(nl.join(map(repr</span><span class="s3">, </span><span class="s1">lines)))</span>
        <span class="s1">code = </span><span class="s4">'_printlist((%s,))' </span><span class="s1">% </span><span class="s4">', '</span><span class="s1">.join(parts)</span>
        <span class="s1">self.lineno += code.count(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)+</span><span class="s5">1</span>
        <span class="s1">self.write_code(code)</span>

    <span class="s3">def </span><span class="s1">process_inline(self</span><span class="s3">, </span><span class="s1">chunk):</span>
        <span class="s3">if </span><span class="s1">chunk[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'!'</span><span class="s1">: </span><span class="s3">return </span><span class="s4">'_str(%s)' </span><span class="s1">% chunk[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s3">return </span><span class="s4">'_escape(%s)' </span><span class="s1">% chunk</span>

    <span class="s3">def </span><span class="s1">write_code(self</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">comment=</span><span class="s4">''</span><span class="s1">):</span>
        <span class="s1">line</span><span class="s3">, </span><span class="s1">comment = self.fix_backward_compatibility(line</span><span class="s3">, </span><span class="s1">comment)</span>
        <span class="s1">code  = </span><span class="s4">'  ' </span><span class="s1">* (self.indent+self.indent_mod)</span>
        <span class="s1">code += line.lstrip() + comment + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span>
        <span class="s1">self.code_buffer.append(code)</span>

    <span class="s3">def </span><span class="s1">fix_backward_compatibility(self</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">comment):</span>
        <span class="s1">parts = line.strip().split(</span><span class="s3">None, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">parts </span><span class="s3">and </span><span class="s1">parts[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'include'</span><span class="s3">, </span><span class="s4">'rebase'</span><span class="s1">):</span>
            <span class="s1">depr(</span><span class="s4">'The include and rebase keywords are functions now.'</span><span class="s1">) </span><span class="s0">#0.12</span>
            <span class="s3">if </span><span class="s1">len(parts) == </span><span class="s5">1</span><span class="s1">:   </span><span class="s3">return </span><span class="s4">&quot;_printlist([base])&quot;</span><span class="s3">, </span><span class="s1">comment</span>
            <span class="s3">elif </span><span class="s1">len(parts) == </span><span class="s5">2</span><span class="s1">: </span><span class="s3">return </span><span class="s4">&quot;_=%s(%r)&quot; </span><span class="s1">% tuple(parts)</span><span class="s3">, </span><span class="s1">comment</span>
            <span class="s3">else</span><span class="s1">:                 </span><span class="s3">return </span><span class="s4">&quot;_=%s(%r, %s)&quot; </span><span class="s1">% tuple(parts)</span><span class="s3">, </span><span class="s1">comment</span>
        <span class="s3">if </span><span class="s1">self.lineno &lt;= </span><span class="s5">2 </span><span class="s3">and not </span><span class="s1">line.strip() </span><span class="s3">and </span><span class="s4">'coding' </span><span class="s3">in </span><span class="s1">comment:</span>
            <span class="s1">m = re.match(</span><span class="s4">r&quot;#.*coding[:=]\s*([-\w.]+)&quot;</span><span class="s3">, </span><span class="s1">comment)</span>
            <span class="s3">if </span><span class="s1">m:</span>
                <span class="s1">depr(</span><span class="s4">'PEP263 encoding strings in templates are deprecated.'</span><span class="s1">) </span><span class="s0">#0.12</span>
                <span class="s1">enc = m.group(</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">self.source = self.source.encode(self.encoding).decode(enc)</span>
                <span class="s1">self.encoding = enc</span>
                <span class="s3">return </span><span class="s1">line</span><span class="s3">, </span><span class="s1">comment.replace(</span><span class="s4">'coding'</span><span class="s3">,</span><span class="s4">'coding*'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">line</span><span class="s3">, </span><span class="s1">comment</span>


<span class="s3">def </span><span class="s1">template(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s2">''' 
    Get a rendered template as a string iterator. 
    You can use a name, a filename or a template string as first parameter. 
    Template rendering arguments can be passed as dictionaries 
    or directly (as keyword arguments). 
    '''</span>
    <span class="s1">tpl = args[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">if </span><span class="s1">args </span><span class="s3">else None</span>
    <span class="s1">adapter = kwargs.pop(</span><span class="s4">'template_adapter'</span><span class="s3">, </span><span class="s1">SimpleTemplate)</span>
    <span class="s1">lookup = kwargs.pop(</span><span class="s4">'template_lookup'</span><span class="s3">, </span><span class="s1">TEMPLATE_PATH)</span>
    <span class="s1">tplid = (id(lookup)</span><span class="s3">, </span><span class="s1">tpl)</span>
    <span class="s3">if </span><span class="s1">tplid </span><span class="s3">not in </span><span class="s1">TEMPLATES </span><span class="s3">or </span><span class="s1">DEBUG:</span>
        <span class="s1">settings = kwargs.pop(</span><span class="s4">'template_settings'</span><span class="s3">, </span><span class="s1">{})</span>
        <span class="s3">if </span><span class="s1">isinstance(tpl</span><span class="s3">, </span><span class="s1">adapter):</span>
            <span class="s1">TEMPLATES[tplid] = tpl</span>
            <span class="s3">if </span><span class="s1">settings: TEMPLATES[tplid].prepare(**settings)</span>
        <span class="s3">elif </span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s3">in </span><span class="s1">tpl </span><span class="s3">or </span><span class="s4">&quot;{&quot; </span><span class="s3">in </span><span class="s1">tpl </span><span class="s3">or </span><span class="s4">&quot;%&quot; </span><span class="s3">in </span><span class="s1">tpl </span><span class="s3">or </span><span class="s4">'$' </span><span class="s3">in </span><span class="s1">tpl:</span>
            <span class="s1">TEMPLATES[tplid] = adapter(source=tpl</span><span class="s3">, </span><span class="s1">lookup=lookup</span><span class="s3">, </span><span class="s1">**settings)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">TEMPLATES[tplid] = adapter(name=tpl</span><span class="s3">, </span><span class="s1">lookup=lookup</span><span class="s3">, </span><span class="s1">**settings)</span>
    <span class="s3">if not </span><span class="s1">TEMPLATES[tplid]:</span>
        <span class="s1">abort(</span><span class="s5">500</span><span class="s3">, </span><span class="s4">'Template (%s) not found' </span><span class="s1">% tpl)</span>
    <span class="s3">for </span><span class="s1">dictarg </span><span class="s3">in </span><span class="s1">args[</span><span class="s5">1</span><span class="s1">:]: kwargs.update(dictarg)</span>
    <span class="s3">return </span><span class="s1">TEMPLATES[tplid].render(kwargs)</span>

<span class="s1">mako_template = functools.partial(template</span><span class="s3">, </span><span class="s1">template_adapter=MakoTemplate)</span>
<span class="s1">cheetah_template = functools.partial(template</span><span class="s3">, </span><span class="s1">template_adapter=CheetahTemplate)</span>
<span class="s1">jinja2_template = functools.partial(template</span><span class="s3">, </span><span class="s1">template_adapter=Jinja2Template)</span>


<span class="s3">def </span><span class="s1">view(tpl_name</span><span class="s3">, </span><span class="s1">**defaults):</span>
    <span class="s2">''' Decorator: renders a template for a handler. 
        The handler can control its behavior like that: 
 
          - return a dict of template vars to fill out the template 
          - return something other than a dict and the view decorator will not 
            process the template, but return the handler result as is. 
            This includes returning a HTTPResponse(dict) to get, 
            for instance, JSON with autojson or other castfilters. 
    '''</span>
    <span class="s3">def </span><span class="s1">decorator(func):</span>
        <span class="s1">@functools.wraps(func)</span>
        <span class="s3">def </span><span class="s1">wrapper(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
            <span class="s1">result = func(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
            <span class="s3">if </span><span class="s1">isinstance(result</span><span class="s3">, </span><span class="s1">(dict</span><span class="s3">, </span><span class="s1">DictMixin)):</span>
                <span class="s1">tplvars = defaults.copy()</span>
                <span class="s1">tplvars.update(result)</span>
                <span class="s3">return </span><span class="s1">template(tpl_name</span><span class="s3">, </span><span class="s1">**tplvars)</span>
            <span class="s3">elif </span><span class="s1">result </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">template(tpl_name</span><span class="s3">, </span><span class="s1">**defaults)</span>
            <span class="s3">return </span><span class="s1">result</span>
        <span class="s3">return </span><span class="s1">wrapper</span>
    <span class="s3">return </span><span class="s1">decorator</span>

<span class="s1">mako_view = functools.partial(view</span><span class="s3">, </span><span class="s1">template_adapter=MakoTemplate)</span>
<span class="s1">cheetah_view = functools.partial(view</span><span class="s3">, </span><span class="s1">template_adapter=CheetahTemplate)</span>
<span class="s1">jinja2_view = functools.partial(view</span><span class="s3">, </span><span class="s1">template_adapter=Jinja2Template)</span>






<span class="s0">###############################################################################</span>
<span class="s0"># Constants and Globals ########################################################</span>
<span class="s0">###############################################################################</span>


<span class="s1">TEMPLATE_PATH = [</span><span class="s4">'./'</span><span class="s3">, </span><span class="s4">'./views/'</span><span class="s1">]</span>
<span class="s1">TEMPLATES = {}</span>
<span class="s1">DEBUG = </span><span class="s3">False</span>
<span class="s1">NORUN = </span><span class="s3">False </span><span class="s0"># If set, run() does nothing. Used by load_app()</span>

<span class="s0">#: A dict to map HTTP status codes (e.g. 404) to phrases (e.g. 'Not Found')</span>
<span class="s1">HTTP_CODES = httplib.responses</span>
<span class="s1">HTTP_CODES[</span><span class="s5">418</span><span class="s1">] = </span><span class="s4">&quot;I'm a teapot&quot; </span><span class="s0"># RFC 2324</span>
<span class="s1">HTTP_CODES[</span><span class="s5">422</span><span class="s1">] = </span><span class="s4">&quot;Unprocessable Entity&quot; </span><span class="s0"># RFC 4918</span>
<span class="s1">HTTP_CODES[</span><span class="s5">428</span><span class="s1">] = </span><span class="s4">&quot;Precondition Required&quot;</span>
<span class="s1">HTTP_CODES[</span><span class="s5">429</span><span class="s1">] = </span><span class="s4">&quot;Too Many Requests&quot;</span>
<span class="s1">HTTP_CODES[</span><span class="s5">431</span><span class="s1">] = </span><span class="s4">&quot;Request Header Fields Too Large&quot;</span>
<span class="s1">HTTP_CODES[</span><span class="s5">511</span><span class="s1">] = </span><span class="s4">&quot;Network Authentication Required&quot;</span>
<span class="s1">_HTTP_STATUS_LINES = dict((k</span><span class="s3">, </span><span class="s4">'%d %s'</span><span class="s1">%(k</span><span class="s3">,</span><span class="s1">v)) </span><span class="s3">for </span><span class="s1">(k</span><span class="s3">,</span><span class="s1">v) </span><span class="s3">in </span><span class="s1">HTTP_CODES.items())</span>

<span class="s0">#: The default template used for error pages. Override with @error()</span>
<span class="s1">ERROR_PAGE_TEMPLATE = </span><span class="s4">&quot;&quot;&quot; 
%%try: 
    %%from %s import DEBUG, HTTP_CODES, request, touni 
    &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; 
    &lt;html&gt; 
        &lt;head&gt; 
            &lt;title&gt;Error: {{e.status}}&lt;/title&gt; 
            &lt;style type=&quot;text/css&quot;&gt; 
              html {background-color: #eee; font-family: sans;} 
              body {background-color: #fff; border: 1px solid #ddd; 
                    padding: 15px; margin: 15px;} 
              pre {background-color: #eee; border: 1px solid #ddd; padding: 5px;} 
            &lt;/style&gt; 
        &lt;/head&gt; 
        &lt;body&gt; 
            &lt;h1&gt;Error: {{e.status}}&lt;/h1&gt; 
            &lt;p&gt;Sorry, the requested URL &lt;tt&gt;{{repr(request.url)}}&lt;/tt&gt; 
               caused an error:&lt;/p&gt; 
            &lt;pre&gt;{{e.body}}&lt;/pre&gt; 
            %%if DEBUG and e.exception: 
              &lt;h2&gt;Exception:&lt;/h2&gt; 
              &lt;pre&gt;{{repr(e.exception)}}&lt;/pre&gt; 
            %%end 
            %%if DEBUG and e.traceback: 
              &lt;h2&gt;Traceback:&lt;/h2&gt; 
              &lt;pre&gt;{{e.traceback}}&lt;/pre&gt; 
            %%end 
        &lt;/body&gt; 
    &lt;/html&gt; 
%%except ImportError: 
    &lt;b&gt;ImportError:&lt;/b&gt; Could not generate the error page. Please add bottle to 
    the import path. 
%%end 
&quot;&quot;&quot; </span><span class="s1">% __name__</span>

<span class="s0">#: A thread-safe instance of :class:`LocalRequest`. If accessed from within a</span>
<span class="s0">#: request callback, this instance always refers to the *current* request</span>
<span class="s0">#: (even on a multithreaded server).</span>
<span class="s1">request = LocalRequest()</span>

<span class="s0">#: A thread-safe instance of :class:`LocalResponse`. It is used to change the</span>
<span class="s0">#: HTTP response for the *current* request.</span>
<span class="s1">response = LocalResponse()</span>

<span class="s0">#: A thread-safe namespace. Not used by Bottle.</span>
<span class="s1">local = threading.local()</span>

<span class="s0"># Initialize app stack (create first empty Bottle app)</span>
<span class="s0"># BC: 0.6.4 and needed for run()</span>
<span class="s1">app = default_app = AppStack()</span>
<span class="s1">app.push()</span>

<span class="s0">#: A virtual package that redirects import statements.</span>
<span class="s0">#: Example: ``import bottle.ext.sqlite`` actually imports `bottle_sqlite`.</span>
<span class="s1">ext = _ImportRedirect(</span><span class="s4">'bottle.ext' </span><span class="s3">if </span><span class="s1">__name__ == </span><span class="s4">'__main__' </span><span class="s3">else </span><span class="s1">__name__+</span><span class="s4">&quot;.ext&quot;</span><span class="s3">, </span><span class="s4">'bottle_%s'</span><span class="s1">).module</span>

<span class="s3">if </span><span class="s1">__name__ == </span><span class="s4">'__main__'</span><span class="s1">:</span>
    <span class="s1">opt</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">parser = _cmd_options</span><span class="s3">, </span><span class="s1">_cmd_args</span><span class="s3">, </span><span class="s1">_cmd_parser</span>
    <span class="s3">if </span><span class="s1">opt.version:</span>
        <span class="s1">_stdout(</span><span class="s4">'Bottle %s</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">%__version__)</span>
        <span class="s1">sys.exit(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">args:</span>
        <span class="s1">parser.print_help()</span>
        <span class="s1">_stderr(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">Error: No application specified.</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
        <span class="s1">sys.exit(</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">sys.path.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s4">'.'</span><span class="s1">)</span>
    <span class="s1">sys.modules.setdefault(</span><span class="s4">'bottle'</span><span class="s3">, </span><span class="s1">sys.modules[</span><span class="s4">'__main__'</span><span class="s1">])</span>

    <span class="s1">host</span><span class="s3">, </span><span class="s1">port = (opt.bind </span><span class="s3">or </span><span class="s4">'localhost'</span><span class="s1">)</span><span class="s3">, </span><span class="s5">8080</span>
    <span class="s3">if </span><span class="s4">':' </span><span class="s3">in </span><span class="s1">host </span><span class="s3">and </span><span class="s1">host.rfind(</span><span class="s4">']'</span><span class="s1">) &lt; host.rfind(</span><span class="s4">':'</span><span class="s1">):</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">port = host.rsplit(</span><span class="s4">':'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">host = host.strip(</span><span class="s4">'[]'</span><span class="s1">)</span>

    <span class="s1">run(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">host=host</span><span class="s3">, </span><span class="s1">port=int(port)</span><span class="s3">, </span><span class="s1">server=opt.server</span><span class="s3">,</span>
        <span class="s1">reloader=opt.reload</span><span class="s3">, </span><span class="s1">plugins=opt.plugin</span><span class="s3">, </span><span class="s1">debug=opt.debug)</span>




<span class="s0"># THE END</span>
</pre>
</body>
</html>