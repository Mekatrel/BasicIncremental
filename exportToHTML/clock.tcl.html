<html>
<head>
<title>clock.tcl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
clock.tcl</font>
</center></td></tr></table>
<pre><span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># clock.tcl --</span>
<span class="s0">#</span>
<span class="s0">#	This file implements the portions of the [clock] ensemble that are</span>
<span class="s0">#	coded in Tcl.  Refer to the users' manual to see the description of</span>
<span class="s0">#	the [clock] command and its subcommands.</span>
<span class="s0">#</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># Copyright (c) 2004,2005,2006,2007 by Kevin B. Kenny</span>
<span class="s0"># See the file &quot;license.terms&quot; for information on usage and redistribution</span>
<span class="s0"># of this file, and for a DISCLAIMER OF ALL WARRANTIES.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0"># We must have message catalogs that support the root locale, and we need</span>
<span class="s0"># access to the Registry on Windows systems.</span>

<span class="s0">uplevel \#0 {</span>
    <span class="s0">package require msgcat 1.6</span>
    <span class="s0">if { $::tcl_platform(platform) eq {windows} } {</span>
	<span class="s0">if { [catch { package require registry 1.1 }] } {</span>
	    <span class="s0">namespace eval ::tcl::clock [list variable NoRegistry {}]</span>
	<span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0"># Put the library directory into the namespace for the ensemble so that the</span>
<span class="s0"># library code can find message catalogs and time zone definition files.</span>

<span class="s0">namespace eval ::tcl::clock \</span>
    <span class="s0">[list variable LibDir [file dirname [info script]]]</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># clock --</span>
<span class="s0">#</span>
<span class="s0">#	Manipulate times.</span>
<span class="s0">#</span>
<span class="s0"># The 'clock' command manipulates time.  Refer to the user documentation for</span>
<span class="s0"># the available subcommands and what they do.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">namespace eval ::tcl::clock {</span>

    <span class="s0"># Export the subcommands</span>

    <span class="s0">namespace export format</span>
    <span class="s0">namespace export clicks</span>
    <span class="s0">namespace export microseconds</span>
    <span class="s0">namespace export milliseconds</span>
    <span class="s0">namespace export scan</span>
    <span class="s0">namespace export seconds</span>
    <span class="s0">namespace export add</span>

    <span class="s0"># Import the message catalog commands that we use.</span>

    <span class="s0">namespace import ::msgcat::mcload</span>
    <span class="s0">namespace import ::msgcat::mclocale</span>
    <span class="s0">namespace import ::msgcat::mc</span>
    <span class="s0">namespace import ::msgcat::mcpackagelocale</span>

<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># ::tcl::clock::Initialize --</span>
<span class="s0">#</span>
<span class="s0">#	Finish initializing the 'clock' subsystem</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	Namespace variable in the 'clock' subsystem are initialized.</span>
<span class="s0">#</span>
<span class="s0"># The '::tcl::clock::Initialize' procedure initializes the namespace variables</span>
<span class="s0"># and root locale message catalog for the 'clock' subsystem.  It is broken</span>
<span class="s0"># into a procedure rather than simply evaluated as a script so that it will be</span>
<span class="s0"># able to use local variables, avoiding the dangers of 'creative writing' as</span>
<span class="s0"># in Bug 1185933.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::Initialize {} {</span>

    <span class="s0">rename ::tcl::clock::Initialize {}</span>

    <span class="s0">variable LibDir</span>

    <span class="s0"># Define the Greenwich time zone</span>

    <span class="s0">proc InitTZData {} {</span>
	<span class="s0">variable TZData</span>
	<span class="s0">array unset TZData</span>
	<span class="s0">set TZData(:Etc/GMT) {</span>
	    <span class="s0">{-9223372036854775808 0 0 GMT}</span>
	<span class="s0">}</span>
	<span class="s0">set TZData(:GMT) $TZData(:Etc/GMT)</span>
	<span class="s0">set TZData(:Etc/UTC) {</span>
	    <span class="s0">{-9223372036854775808 0 0 UTC}</span>
	<span class="s0">}</span>
	<span class="s0">set TZData(:UTC) $TZData(:Etc/UTC)</span>
	<span class="s0">set TZData(:localtime) {}</span>
    <span class="s0">}</span>
    <span class="s0">InitTZData</span>

    <span class="s0">mcpackagelocale set {}</span>
    <span class="s0">::msgcat::mcpackageconfig set mcfolder [file join $LibDir msgs]</span>
    <span class="s0">::msgcat::mcpackageconfig set unknowncmd &quot;&quot;</span>
    <span class="s0">::msgcat::mcpackageconfig set changecmd ChangeCurrentLocale</span>

    <span class="s0"># Define the message catalog for the root locale.</span>

    <span class="s0">::msgcat::mcmset {} {</span>
	<span class="s0">AM {am}</span>
	<span class="s0">BCE {B.C.E.}</span>
	<span class="s0">CE {C.E.}</span>
	<span class="s0">DATE_FORMAT {%m/%d/%Y}</span>
	<span class="s0">DATE_TIME_FORMAT {%a %b %e %H:%M:%S %Y}</span>
	<span class="s0">DAYS_OF_WEEK_ABBREV	{</span>
	    <span class="s0">Sun Mon Tue Wed Thu Fri Sat</span>
	<span class="s0">}</span>
	<span class="s0">DAYS_OF_WEEK_FULL	{</span>
	    <span class="s0">Sunday Monday Tuesday Wednesday Thursday Friday Saturday</span>
	<span class="s0">}</span>
	<span class="s0">GREGORIAN_CHANGE_DATE	2299161</span>
	<span class="s0">LOCALE_DATE_FORMAT {%m/%d/%Y}</span>
	<span class="s0">LOCALE_DATE_TIME_FORMAT {%a %b %e %H:%M:%S %Y}</span>
	<span class="s0">LOCALE_ERAS {}</span>
	<span class="s0">LOCALE_NUMERALS		{</span>
	    <span class="s0">00 01 02 03 04 05 06 07 08 09</span>
	    <span class="s0">10 11 12 13 14 15 16 17 18 19</span>
	    <span class="s0">20 21 22 23 24 25 26 27 28 29</span>
	    <span class="s0">30 31 32 33 34 35 36 37 38 39</span>
	    <span class="s0">40 41 42 43 44 45 46 47 48 49</span>
	    <span class="s0">50 51 52 53 54 55 56 57 58 59</span>
	    <span class="s0">60 61 62 63 64 65 66 67 68 69</span>
	    <span class="s0">70 71 72 73 74 75 76 77 78 79</span>
	    <span class="s0">80 81 82 83 84 85 86 87 88 89</span>
	    <span class="s0">90 91 92 93 94 95 96 97 98 99</span>
	<span class="s0">}</span>
	<span class="s0">LOCALE_TIME_FORMAT {%H:%M:%S}</span>
	<span class="s0">LOCALE_YEAR_FORMAT {%EC%Ey}</span>
	<span class="s0">MONTHS_ABBREV		{</span>
	    <span class="s0">Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec</span>
	<span class="s0">}</span>
	<span class="s0">MONTHS_FULL		{</span>
	    	<span class="s0">January		February	March</span>
	    	<span class="s0">April		May		June</span>
	    	<span class="s0">July		August		September</span>
		<span class="s0">October		November	December</span>
	<span class="s0">}</span>
	<span class="s0">PM {pm}</span>
	<span class="s0">TIME_FORMAT {%H:%M:%S}</span>
	<span class="s0">TIME_FORMAT_12 {%I:%M:%S %P}</span>
	<span class="s0">TIME_FORMAT_24 {%H:%M}</span>
	<span class="s0">TIME_FORMAT_24_SECS {%H:%M:%S}</span>
    <span class="s0">}</span>

    <span class="s0"># Define a few Gregorian change dates for other locales.  In most cases</span>
    <span class="s0"># the change date follows a language, because a nation's colonies changed</span>
    <span class="s0"># at the same time as the nation itself.  In many cases, different</span>
    <span class="s0"># national boundaries existed; the dominating rule is to follow the</span>
    <span class="s0"># nation's capital.</span>

    <span class="s0"># Italy, Spain, Portugal, Poland</span>

    <span class="s0">::msgcat::mcset it GREGORIAN_CHANGE_DATE 2299161</span>
    <span class="s0">::msgcat::mcset es GREGORIAN_CHANGE_DATE 2299161</span>
    <span class="s0">::msgcat::mcset pt GREGORIAN_CHANGE_DATE 2299161</span>
    <span class="s0">::msgcat::mcset pl GREGORIAN_CHANGE_DATE 2299161</span>

    <span class="s0"># France, Austria</span>

    <span class="s0">::msgcat::mcset fr GREGORIAN_CHANGE_DATE 2299227</span>

    <span class="s0"># For Belgium, we follow Southern Netherlands; Liege Diocese changed</span>
    <span class="s0"># several weeks later.</span>

    <span class="s0">::msgcat::mcset fr_BE GREGORIAN_CHANGE_DATE 2299238</span>
    <span class="s0">::msgcat::mcset nl_BE GREGORIAN_CHANGE_DATE 2299238</span>

    <span class="s0"># Austria</span>

    <span class="s0">::msgcat::mcset de_AT GREGORIAN_CHANGE_DATE 2299527</span>

    <span class="s0"># Hungary</span>

    <span class="s0">::msgcat::mcset hu GREGORIAN_CHANGE_DATE 2301004</span>

    <span class="s0"># Germany, Norway, Denmark (Catholic Germany changed earlier)</span>

    <span class="s0">::msgcat::mcset de_DE GREGORIAN_CHANGE_DATE 2342032</span>
    <span class="s0">::msgcat::mcset nb GREGORIAN_CHANGE_DATE 2342032</span>
    <span class="s0">::msgcat::mcset nn GREGORIAN_CHANGE_DATE 2342032</span>
    <span class="s0">::msgcat::mcset no GREGORIAN_CHANGE_DATE 2342032</span>
    <span class="s0">::msgcat::mcset da GREGORIAN_CHANGE_DATE 2342032</span>

    <span class="s0"># Holland (Brabant, Gelderland, Flanders, Friesland, etc. changed at</span>
    <span class="s0"># various times)</span>

    <span class="s0">::msgcat::mcset nl GREGORIAN_CHANGE_DATE 2342165</span>

    <span class="s0"># Protestant Switzerland (Catholic cantons changed earlier)</span>

    <span class="s0">::msgcat::mcset fr_CH GREGORIAN_CHANGE_DATE 2361342</span>
    <span class="s0">::msgcat::mcset it_CH GREGORIAN_CHANGE_DATE 2361342</span>
    <span class="s0">::msgcat::mcset de_CH GREGORIAN_CHANGE_DATE 2361342</span>

    <span class="s0"># English speaking countries</span>

    <span class="s0">::msgcat::mcset en GREGORIAN_CHANGE_DATE 2361222</span>

    <span class="s0"># Sweden (had several changes onto and off of the Gregorian calendar)</span>

    <span class="s0">::msgcat::mcset sv GREGORIAN_CHANGE_DATE 2361390</span>

    <span class="s0"># Russia</span>

    <span class="s0">::msgcat::mcset ru GREGORIAN_CHANGE_DATE 2421639</span>

    <span class="s0"># Romania (Transylvania changed earler - perhaps de_RO should show the</span>
    <span class="s0"># earlier date?)</span>

    <span class="s0">::msgcat::mcset ro GREGORIAN_CHANGE_DATE 2422063</span>

    <span class="s0"># Greece</span>

    <span class="s0">::msgcat::mcset el GREGORIAN_CHANGE_DATE 2423480</span>

    <span class="s0">#------------------------------------------------------------------</span>
    <span class="s0">#</span>
    <span class="s0">#				CONSTANTS</span>
    <span class="s0">#</span>
    <span class="s0">#------------------------------------------------------------------</span>

    <span class="s0"># Paths at which binary time zone data for the Olson libraries are known</span>
    <span class="s0"># to reside on various operating systems</span>

    <span class="s0">variable ZoneinfoPaths {}</span>
    <span class="s0">foreach path {</span>
	<span class="s0">/usr/share/zoneinfo</span>
	<span class="s0">/usr/share/lib/zoneinfo</span>
	<span class="s0">/usr/lib/zoneinfo</span>
	<span class="s0">/usr/local/etc/zoneinfo</span>
    <span class="s0">} {</span>
	<span class="s0">if { [file isdirectory $path] } {</span>
	    <span class="s0">lappend ZoneinfoPaths $path</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Define the directories for time zone data and message catalogs.</span>

    <span class="s0">variable DataDir [file join $LibDir tzdata]</span>

    <span class="s0"># Number of days in the months, in common years and leap years.</span>

    <span class="s0">variable DaysInRomanMonthInCommonYear \</span>
	<span class="s0">{ 31 28 31 30 31 30 31 31 30 31 30 31 }</span>
    <span class="s0">variable DaysInRomanMonthInLeapYear \</span>
	<span class="s0">{ 31 29 31 30 31 30 31 31 30 31 30 31 }</span>
    <span class="s0">variable DaysInPriorMonthsInCommonYear [list 0]</span>
    <span class="s0">variable DaysInPriorMonthsInLeapYear [list 0]</span>
    <span class="s0">set i 0</span>
    <span class="s0">foreach j $DaysInRomanMonthInCommonYear {</span>
	<span class="s0">lappend DaysInPriorMonthsInCommonYear [incr i $j]</span>
    <span class="s0">}</span>
    <span class="s0">set i 0</span>
    <span class="s0">foreach j $DaysInRomanMonthInLeapYear {</span>
	<span class="s0">lappend DaysInPriorMonthsInLeapYear [incr i $j]</span>
    <span class="s0">}</span>

    <span class="s0"># Another epoch (Hi, Jeff!)</span>

    <span class="s0">variable Roddenberry 1946</span>

    <span class="s0"># Integer ranges</span>

    <span class="s0">variable MINWIDE -9223372036854775808</span>
    <span class="s0">variable MAXWIDE 9223372036854775807</span>

    <span class="s0"># Day before Leap Day</span>

    <span class="s0">variable FEB_28	       58</span>

    <span class="s0"># Translation table to map Windows TZI onto cities, so that the Olson</span>
    <span class="s0"># rules can apply.  In some cases the mapping is ambiguous, so it's wise</span>
    <span class="s0"># to specify $::env(TCL_TZ) rather than simply depending on the system</span>
    <span class="s0"># time zone.</span>

    <span class="s0"># The keys are long lists of values obtained from the time zone</span>
    <span class="s0"># information in the Registry.  In order, the list elements are:</span>
    <span class="s0"># 	Bias StandardBias DaylightBias</span>
    <span class="s0">#   StandardDate.wYear StandardDate.wMonth StandardDate.wDayOfWeek</span>
    <span class="s0">#   StandardDate.wDay StandardDate.wHour StandardDate.wMinute</span>
    <span class="s0">#   StandardDate.wSecond StandardDate.wMilliseconds</span>
    <span class="s0">#   DaylightDate.wYear DaylightDate.wMonth DaylightDate.wDayOfWeek</span>
    <span class="s0">#   DaylightDate.wDay DaylightDate.wHour DaylightDate.wMinute</span>
    <span class="s0">#   DaylightDate.wSecond DaylightDate.wMilliseconds</span>
    <span class="s0"># The values are the names of time zones where those rules apply.  There</span>
    <span class="s0"># is considerable ambiguity in certain zones; an attempt has been made to</span>
    <span class="s0"># make a reasonable guess, but this table needs to be taken with a grain</span>
    <span class="s0"># of salt.</span>

    <span class="s0">variable WinZoneInfo [dict create {*}{</span>
	<span class="s0">{-43200 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}  :Pacific/Kwajalein</span>
	<span class="s0">{-39600 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}	 :Pacific/Midway</span>
	<span class="s0">{-36000 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}  :Pacific/Honolulu</span>
        <span class="s0">{-32400 0 3600 0 11 0 1 2 0 0 0 0 3 0 2 2 0 0 0} :America/Anchorage</span>
        <span class="s0">{-28800 0 3600 0 11 0 1 2 0 0 0 0 3 0 2 2 0 0 0} :America/Los_Angeles</span>
        <span class="s0">{-28800 0 3600 0 10 0 5 2 0 0 0 0 4 0 1 2 0 0 0} :America/Tijuana</span>
        <span class="s0">{-25200 0 3600 0 11 0 1 2 0 0 0 0 3 0 2 2 0 0 0} :America/Denver</span>
        <span class="s0">{-25200 0 3600 0 10 0 5 2 0 0 0 0 4 0 1 2 0 0 0} :America/Chihuahua</span>
	<span class="s0">{-25200 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}  :America/Phoenix</span>
	<span class="s0">{-21600 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}  :America/Regina</span>
	<span class="s0">{-21600 0 3600 0 11 0 1 2 0 0 0 0 3 0 2 2 0 0 0} :America/Chicago</span>
        <span class="s0">{-21600 0 3600 0 10 0 5 2 0 0 0 0 4 0 1 2 0 0 0} :America/Mexico_City</span>
	<span class="s0">{-18000 0 3600 0 11 0 1 2 0 0 0 0 3 0 2 2 0 0 0} :America/New_York</span>
	<span class="s0">{-18000 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}  :America/Indianapolis</span>
	<span class="s0">{-14400 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}  :America/Caracas</span>
        <span class="s0">{-14400 0 3600 0 3 6 2 23 59 59 999 0 10 6 2 23 59 59 999}</span>
							 <span class="s0">:America/Santiago</span>
        <span class="s0">{-14400 0 3600 0 2 0 5 2 0 0 0 0 11 0 1 2 0 0 0} :America/Manaus</span>
        <span class="s0">{-14400 0 3600 0 11 0 1 2 0 0 0 0 3 0 2 2 0 0 0} :America/Halifax</span>
	<span class="s0">{-12600 0 3600 0 10 0 5 2 0 0 0 0 4 0 1 2 0 0 0} :America/St_Johns</span>
	<span class="s0">{-10800 0 3600 0 2 0 2 2 0 0 0 0 10 0 3 2 0 0 0} :America/Sao_Paulo</span>
	<span class="s0">{-10800 0 3600 0 10 0 5 2 0 0 0 0 4 0 1 2 0 0 0} :America/Godthab</span>
	<span class="s0">{-10800 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}  :America/Buenos_Aires</span>
        <span class="s0">{-10800 0 3600 0 2 0 5 2 0 0 0 0 11 0 1 2 0 0 0} :America/Bahia</span>
        <span class="s0">{-10800 0 3600 0 3 0 2 2 0 0 0 0 10 0 1 2 0 0 0} :America/Montevideo</span>
	<span class="s0">{-7200 0 3600 0 9 0 5 2 0 0 0 0 3 0 5 2 0 0 0}   :America/Noronha</span>
	<span class="s0">{-3600 0 3600 0 10 0 5 3 0 0 0 0 3 0 5 2 0 0 0}  :Atlantic/Azores</span>
	<span class="s0">{-3600 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Atlantic/Cape_Verde</span>
	<span class="s0">{0 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}       :UTC</span>
	<span class="s0">{0 0 3600 0 10 0 5 2 0 0 0 0 3 0 5 1 0 0 0}      :Europe/London</span>
	<span class="s0">{3600 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}    :Africa/Kinshasa</span>
	<span class="s0">{3600 0 3600 0 10 0 5 3 0 0 0 0 3 0 5 2 0 0 0}   :CET</span>
        <span class="s0">{7200 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}    :Africa/Harare</span>
        <span class="s0">{7200 0 3600 0 9 4 5 23 59 59 0 0 4 4 5 23 59 59 0}</span>
			      				 <span class="s0">:Africa/Cairo</span>
	<span class="s0">{7200 0 3600 0 10 0 5 4 0 0 0 0 3 0 5 3 0 0 0}   :Europe/Helsinki</span>
        <span class="s0">{7200 0 3600 0 9 0 3 2 0 0 0 0 3 5 5 2 0 0 0}    :Asia/Jerusalem</span>
	<span class="s0">{7200 0 3600 0 9 0 5 1 0 0 0 0 3 0 5 0 0 0 0}    :Europe/Bucharest</span>
	<span class="s0">{7200 0 3600 0 10 0 5 3 0 0 0 0 3 0 5 2 0 0 0}   :Europe/Athens</span>
        <span class="s0">{7200 0 3600 0 9 5 5 1 0 0 0 0 3 4 5 0 0 0 0}    :Asia/Amman</span>
        <span class="s0">{7200 0 3600 0 10 6 5 23 59 59 999 0 3 0 5 0 0 0 0}</span>
							 <span class="s0">:Asia/Beirut</span>
        <span class="s0">{7200 0 -3600 0 4 0 1 2 0 0 0 0 9 0 1 2 0 0 0}   :Africa/Windhoek</span>
	<span class="s0">{10800 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Asia/Riyadh</span>
	<span class="s0">{10800 0 3600 0 10 0 1 4 0 0 0 0 4 0 1 3 0 0 0}  :Asia/Baghdad</span>
	<span class="s0">{10800 0 3600 0 10 0 5 3 0 0 0 0 3 0 5 2 0 0 0}  :Europe/Moscow</span>
	<span class="s0">{12600 0 3600 0 9 2 4 2 0 0 0 0 3 0 1 2 0 0 0}   :Asia/Tehran</span>
        <span class="s0">{14400 0 3600 0 10 0 5 5 0 0 0 0 3 0 5 4 0 0 0}  :Asia/Baku</span>
	<span class="s0">{14400 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Asia/Muscat</span>
	<span class="s0">{14400 0 3600 0 10 0 5 3 0 0 0 0 3 0 5 2 0 0 0}  :Asia/Tbilisi</span>
	<span class="s0">{16200 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Asia/Kabul</span>
	<span class="s0">{18000 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Asia/Karachi</span>
	<span class="s0">{18000 0 3600 0 10 0 5 3 0 0 0 0 3 0 5 2 0 0 0}  :Asia/Yekaterinburg</span>
	<span class="s0">{19800 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Asia/Calcutta</span>
	<span class="s0">{20700 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Asia/Katmandu</span>
	<span class="s0">{21600 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Asia/Dhaka</span>
	<span class="s0">{21600 0 3600 0 10 0 5 3 0 0 0 0 3 0 5 2 0 0 0}  :Asia/Novosibirsk</span>
	<span class="s0">{23400 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Asia/Rangoon</span>
	<span class="s0">{25200 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Asia/Bangkok</span>
	<span class="s0">{25200 0 3600 0 10 0 5 3 0 0 0 0 3 0 5 2 0 0 0}  :Asia/Krasnoyarsk</span>
	<span class="s0">{28800 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Asia/Chongqing</span>
	<span class="s0">{28800 0 3600 0 10 0 5 3 0 0 0 0 3 0 5 2 0 0 0}  :Asia/Irkutsk</span>
	<span class="s0">{32400 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Asia/Tokyo</span>
	<span class="s0">{32400 0 3600 0 10 0 5 3 0 0 0 0 3 0 5 2 0 0 0}  :Asia/Yakutsk</span>
	<span class="s0">{34200 0 3600 0 3 0 5 3 0 0 0 0 10 0 5 2 0 0 0}  :Australia/Adelaide</span>
	<span class="s0">{34200 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Australia/Darwin</span>
	<span class="s0">{36000 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Australia/Brisbane</span>
	<span class="s0">{36000 0 3600 0 10 0 5 3 0 0 0 0 3 0 5 2 0 0 0}  :Asia/Vladivostok</span>
	<span class="s0">{36000 0 3600 0 3 0 5 3 0 0 0 0 10 0 1 2 0 0 0}  :Australia/Hobart</span>
	<span class="s0">{36000 0 3600 0 3 0 5 3 0 0 0 0 10 0 5 2 0 0 0}  :Australia/Sydney</span>
	<span class="s0">{39600 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Pacific/Noumea</span>
	<span class="s0">{43200 0 3600 0 3 0 3 3 0 0 0 0 10 0 1 2 0 0 0}  :Pacific/Auckland</span>
	<span class="s0">{43200 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Pacific/Fiji</span>
	<span class="s0">{46800 0 3600 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}   :Pacific/Tongatapu</span>
    <span class="s0">}]</span>

    <span class="s0"># Groups of fields that specify the date, priorities, and code bursts that</span>
    <span class="s0"># determine Julian Day Number given those groups.  The code in [clock</span>
    <span class="s0"># scan] will choose the highest priority (lowest numbered) set of fields</span>
    <span class="s0"># that determines the date.</span>

    <span class="s0">variable DateParseActions {</span>

	<span class="s0">{ seconds } 0 {}</span>

	<span class="s0">{ julianDay } 1 {}</span>

	<span class="s0">{ era century yearOfCentury month dayOfMonth } 2 {</span>
	    <span class="s0">dict set date year [expr { 100 * [dict get $date century]</span>
				       <span class="s0">+ [dict get $date yearOfCentury] }]</span>
	    <span class="s0">set date [GetJulianDayFromEraYearMonthDay $date[set date {}] \</span>
			  <span class="s0">$changeover]</span>
	<span class="s0">}</span>
	<span class="s0">{ era century yearOfCentury dayOfYear } 2 {</span>
	    <span class="s0">dict set date year [expr { 100 * [dict get $date century]</span>
				       <span class="s0">+ [dict get $date yearOfCentury] }]</span>
	    <span class="s0">set date [GetJulianDayFromEraYearDay $date[set date {}] \</span>
			  <span class="s0">$changeover]</span>
	<span class="s0">}</span>

	<span class="s0">{ century yearOfCentury month dayOfMonth } 3 {</span>
	    <span class="s0">dict set date era CE</span>
	    <span class="s0">dict set date year [expr { 100 * [dict get $date century]</span>
				       <span class="s0">+ [dict get $date yearOfCentury] }]</span>
	    <span class="s0">set date [GetJulianDayFromEraYearMonthDay $date[set date {}] \</span>
			  <span class="s0">$changeover]</span>
	<span class="s0">}</span>
	<span class="s0">{ century yearOfCentury dayOfYear } 3 {</span>
	    <span class="s0">dict set date era CE</span>
	    <span class="s0">dict set date year [expr { 100 * [dict get $date century]</span>
				       <span class="s0">+ [dict get $date yearOfCentury] }]</span>
	    <span class="s0">set date [GetJulianDayFromEraYearDay $date[set date {}] \</span>
			  <span class="s0">$changeover]</span>
	<span class="s0">}</span>
	<span class="s0">{ iso8601Century iso8601YearOfCentury iso8601Week dayOfWeek } 3 {</span>
	    <span class="s0">dict set date era CE</span>
	    <span class="s0">dict set date iso8601Year \</span>
		<span class="s0">[expr { 100 * [dict get $date iso8601Century]</span>
			<span class="s0">+ [dict get $date iso8601YearOfCentury] }]</span>
	    <span class="s0">set date [GetJulianDayFromEraYearWeekDay $date[set date {}] \</span>
			 <span class="s0">$changeover]</span>
	<span class="s0">}</span>

	<span class="s0">{ yearOfCentury month dayOfMonth } 4 {</span>
	    <span class="s0">set date [InterpretTwoDigitYear $date[set date {}] $baseTime]</span>
	    <span class="s0">dict set date era CE</span>
	    <span class="s0">set date [GetJulianDayFromEraYearMonthDay $date[set date {}] \</span>
			  <span class="s0">$changeover]</span>
	<span class="s0">}</span>
	<span class="s0">{ yearOfCentury dayOfYear } 4 {</span>
	    <span class="s0">set date [InterpretTwoDigitYear $date[set date {}] $baseTime]</span>
	    <span class="s0">dict set date era CE</span>
	    <span class="s0">set date [GetJulianDayFromEraYearDay $date[set date {}] \</span>
			  <span class="s0">$changeover]</span>
	<span class="s0">}</span>
	<span class="s0">{ iso8601YearOfCentury iso8601Week dayOfWeek } 4 {</span>
	    <span class="s0">set date [InterpretTwoDigitYear \</span>
			  <span class="s0">$date[set date {}] $baseTime \</span>
			  <span class="s0">iso8601YearOfCentury iso8601Year]</span>
	    <span class="s0">dict set date era CE</span>
	    <span class="s0">set date [GetJulianDayFromEraYearWeekDay $date[set date {}] \</span>
			 <span class="s0">$changeover]</span>
	<span class="s0">}</span>

	<span class="s0">{ month dayOfMonth } 5 {</span>
	    <span class="s0">set date [AssignBaseYear $date[set date {}] \</span>
			  <span class="s0">$baseTime $timeZone $changeover]</span>
	    <span class="s0">set date [GetJulianDayFromEraYearMonthDay $date[set date {}] \</span>
			  <span class="s0">$changeover]</span>
	<span class="s0">}</span>
	<span class="s0">{ dayOfYear } 5 {</span>
	    <span class="s0">set date [AssignBaseYear $date[set date {}] \</span>
			  <span class="s0">$baseTime $timeZone $changeover]</span>
	    <span class="s0">set date [GetJulianDayFromEraYearDay $date[set date {}] \</span>
			 <span class="s0">$changeover]</span>
	<span class="s0">}</span>
	<span class="s0">{ iso8601Week dayOfWeek } 5 {</span>
	    <span class="s0">set date [AssignBaseIso8601Year $date[set date {}] \</span>
			  <span class="s0">$baseTime $timeZone $changeover]</span>
	    <span class="s0">set date [GetJulianDayFromEraYearWeekDay $date[set date {}] \</span>
			 <span class="s0">$changeover]</span>
	<span class="s0">}</span>

	<span class="s0">{ dayOfMonth } 6 {</span>
	    <span class="s0">set date [AssignBaseMonth $date[set date {}] \</span>
			  <span class="s0">$baseTime $timeZone $changeover]</span>
	    <span class="s0">set date [GetJulianDayFromEraYearMonthDay $date[set date {}] \</span>
			  <span class="s0">$changeover]</span>
	<span class="s0">}</span>

	<span class="s0">{ dayOfWeek } 7 {</span>
	    <span class="s0">set date [AssignBaseWeek $date[set date {}] \</span>
			  <span class="s0">$baseTime $timeZone $changeover]</span>
	    <span class="s0">set date [GetJulianDayFromEraYearWeekDay $date[set date {}] \</span>
			 <span class="s0">$changeover]</span>
	<span class="s0">}</span>

	<span class="s0">{} 8 {</span>
	    <span class="s0">set date [AssignBaseJulianDay $date[set date {}] \</span>
			  <span class="s0">$baseTime $timeZone $changeover]</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Groups of fields that specify time of day, priorities, and code that</span>
    <span class="s0"># processes them</span>

    <span class="s0">variable TimeParseActions {</span>

	<span class="s0">seconds 1 {}</span>

	<span class="s0">{ hourAMPM minute second amPmIndicator } 2 {</span>
	    <span class="s0">dict set date secondOfDay [InterpretHMSP $date]</span>
	<span class="s0">}</span>
	<span class="s0">{ hour minute second } 2 {</span>
	    <span class="s0">dict set date secondOfDay [InterpretHMS $date]</span>
	<span class="s0">}</span>

	<span class="s0">{ hourAMPM minute amPmIndicator } 3 {</span>
	    <span class="s0">dict set date second 0</span>
	    <span class="s0">dict set date secondOfDay [InterpretHMSP $date]</span>
	<span class="s0">}</span>
	<span class="s0">{ hour minute } 3 {</span>
	    <span class="s0">dict set date second 0</span>
	    <span class="s0">dict set date secondOfDay [InterpretHMS $date]</span>
	<span class="s0">}</span>

	<span class="s0">{ hourAMPM amPmIndicator } 4 {</span>
	    <span class="s0">dict set date minute 0</span>
	    <span class="s0">dict set date second 0</span>
	    <span class="s0">dict set date secondOfDay [InterpretHMSP $date]</span>
	<span class="s0">}</span>
	<span class="s0">{ hour } 4 {</span>
	    <span class="s0">dict set date minute 0</span>
	    <span class="s0">dict set date second 0</span>
	    <span class="s0">dict set date secondOfDay [InterpretHMS $date]</span>
	<span class="s0">}</span>

	<span class="s0">{ } 5 {</span>
	    <span class="s0">dict set date secondOfDay 0</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Legacy time zones, used primarily for parsing RFC822 dates.</span>

    <span class="s0">variable LegacyTimeZone [dict create \</span>
	<span class="s0">gmt	+0000 \</span>
	<span class="s0">ut	+0000 \</span>
	<span class="s0">utc	+0000 \</span>
	<span class="s0">bst	+0100 \</span>
	<span class="s0">wet	+0000 \</span>
	<span class="s0">wat	-0100 \</span>
	<span class="s0">at	-0200 \</span>
	<span class="s0">nft	-0330 \</span>
	<span class="s0">nst	-0330 \</span>
	<span class="s0">ndt	-0230 \</span>
	<span class="s0">ast	-0400 \</span>
	<span class="s0">adt	-0300 \</span>
	<span class="s0">est	-0500 \</span>
	<span class="s0">edt	-0400 \</span>
	<span class="s0">cst	-0600 \</span>
	<span class="s0">cdt	-0500 \</span>
	<span class="s0">mst	-0700 \</span>
	<span class="s0">mdt	-0600 \</span>
	<span class="s0">pst	-0800 \</span>
	<span class="s0">pdt	-0700 \</span>
	<span class="s0">yst	-0900 \</span>
	<span class="s0">ydt	-0800 \</span>
	<span class="s0">hst	-1000 \</span>
	<span class="s0">hdt	-0900 \</span>
	<span class="s0">cat	-1000 \</span>
	<span class="s0">ahst	-1000 \</span>
	<span class="s0">nt	-1100 \</span>
	<span class="s0">idlw	-1200 \</span>
	<span class="s0">cet	+0100 \</span>
	<span class="s0">cest	+0200 \</span>
	<span class="s0">met	+0100 \</span>
	<span class="s0">mewt	+0100 \</span>
	<span class="s0">mest	+0200 \</span>
	<span class="s0">swt	+0100 \</span>
	<span class="s0">sst	+0200 \</span>
	<span class="s0">fwt	+0100 \</span>
	<span class="s0">fst	+0200 \</span>
	<span class="s0">eet	+0200 \</span>
	<span class="s0">eest	+0300 \</span>
	<span class="s0">bt	+0300 \</span>
	<span class="s0">it	+0330 \</span>
	<span class="s0">zp4	+0400 \</span>
	<span class="s0">zp5	+0500 \</span>
	<span class="s0">ist	+0530 \</span>
	<span class="s0">zp6	+0600 \</span>
	<span class="s0">wast	+0700 \</span>
	<span class="s0">wadt	+0800 \</span>
	<span class="s0">jt	+0730 \</span>
	<span class="s0">cct	+0800 \</span>
	<span class="s0">jst	+0900 \</span>
	<span class="s0">kst     +0900 \</span>
	<span class="s0">cast	+0930 \</span>
        <span class="s0">jdt     +1000 \</span>
        <span class="s0">kdt     +1000 \</span>
	<span class="s0">cadt	+1030 \</span>
	<span class="s0">east	+1000 \</span>
	<span class="s0">eadt	+1030 \</span>
	<span class="s0">gst	+1000 \</span>
	<span class="s0">nzt	+1200 \</span>
	<span class="s0">nzst	+1200 \</span>
	<span class="s0">nzdt	+1300 \</span>
	<span class="s0">idle	+1200 \</span>
	<span class="s0">a	+0100 \</span>
	<span class="s0">b	+0200 \</span>
	<span class="s0">c	+0300 \</span>
	<span class="s0">d	+0400 \</span>
	<span class="s0">e	+0500 \</span>
	<span class="s0">f	+0600 \</span>
	<span class="s0">g	+0700 \</span>
	<span class="s0">h	+0800 \</span>
	<span class="s0">i	+0900 \</span>
	<span class="s0">k	+1000 \</span>
	<span class="s0">l	+1100 \</span>
	<span class="s0">m	+1200 \</span>
	<span class="s0">n	-0100 \</span>
	<span class="s0">o	-0200 \</span>
	<span class="s0">p	-0300 \</span>
	<span class="s0">q	-0400 \</span>
	<span class="s0">r	-0500 \</span>
	<span class="s0">s	-0600 \</span>
	<span class="s0">t	-0700 \</span>
	<span class="s0">u	-0800 \</span>
	<span class="s0">v	-0900 \</span>
	<span class="s0">w	-1000 \</span>
	<span class="s0">x	-1100 \</span>
	<span class="s0">y	-1200 \</span>
	<span class="s0">z	+0000 \</span>
    <span class="s0">]</span>

    <span class="s0"># Caches</span>

    <span class="s0">variable LocaleNumeralCache {};	# Dictionary whose keys are locale</span>
					<span class="s0"># names and whose values are pairs</span>
					<span class="s0"># comprising regexes matching numerals</span>
					<span class="s0"># in the given locales and dictionaries</span>
					<span class="s0"># mapping the numerals to their numeric</span>
					<span class="s0"># values.</span>
    <span class="s0"># variable CachedSystemTimeZone;    # If 'CachedSystemTimeZone' exists,</span>
					<span class="s0"># it contains the value of the</span>
					<span class="s0"># system time zone, as determined from</span>
					<span class="s0"># the environment.</span>
    <span class="s0">variable TimeZoneBad {};	        # Dictionary whose keys are time zone</span>
    					<span class="s0"># names and whose values are 1 if</span>
					<span class="s0"># the time zone is unknown and 0</span>
    					<span class="s0"># if it is known.</span>
    <span class="s0">variable TZData;			# Array whose keys are time zone names</span>
					<span class="s0"># and whose values are lists of quads</span>
					<span class="s0"># comprising start time, UTC offset,</span>
					<span class="s0"># Daylight Saving Time indicator, and</span>
					<span class="s0"># time zone abbreviation.</span>
    <span class="s0">variable FormatProc;		# Array mapping format group</span>
					<span class="s0"># and locale to the name of a procedure</span>
					<span class="s0"># that renders the given format</span>
<span class="s0">}</span>
<span class="s0">::tcl::clock::Initialize</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># clock format --</span>
<span class="s0">#</span>
<span class="s0">#	Formats a count of seconds since the Posix Epoch as a time of day.</span>
<span class="s0">#</span>
<span class="s0"># The 'clock format' command formats times of day for output.  Refer to the</span>
<span class="s0"># user documentation to see what it does.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::format { args } {</span>

    <span class="s0">variable FormatProc</span>
    <span class="s0">variable TZData</span>

    <span class="s0">lassign [ParseFormatArgs {*}$args] format locale timezone</span>
    <span class="s0">set locale [string tolower $locale]</span>
    <span class="s0">set clockval [lindex $args 0]</span>

    <span class="s0"># Get the data for time changes in the given zone</span>

    <span class="s0">if {$timezone eq &quot;&quot;} {</span>
	<span class="s0">set timezone [GetSystemTimeZone]</span>
    <span class="s0">}</span>
    <span class="s0">if {![info exists TZData($timezone)]} {</span>
	<span class="s0">if {[catch {SetupTimeZone $timezone} retval opts]} {</span>
	    <span class="s0">dict unset opts -errorinfo</span>
	    <span class="s0">return -options $opts $retval</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Build a procedure to format the result. Cache the built procedure's name</span>
    <span class="s0"># in the 'FormatProc' array to avoid losing its internal representation,</span>
    <span class="s0"># which contains the name resolution.</span>

    <span class="s0">set procName formatproc'$format'$locale</span>
    <span class="s0">set procName [namespace current]::[string map {: {\:} \\ {\\}} $procName]</span>
    <span class="s0">if {[info exists FormatProc($procName)]} {</span>
	<span class="s0">set procName $FormatProc($procName)</span>
    <span class="s0">} else {</span>
	<span class="s0">set FormatProc($procName) \</span>
	    <span class="s0">[ParseClockFormatFormat $procName $format $locale]</span>
    <span class="s0">}</span>

    <span class="s0">return [$procName $clockval $timezone]</span>

<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># ParseClockFormatFormat --</span>
<span class="s0">#</span>
<span class="s0">#	Builds and caches a procedure that formats a time value.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	format -- Format string to use</span>
<span class="s0">#	locale -- Locale in which the format string is to be interpreted</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the name of the newly-built procedure.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::ParseClockFormatFormat {procName format locale} {</span>

    <span class="s0">if {[namespace which $procName] ne {}} {</span>
	<span class="s0">return $procName</span>
    <span class="s0">}</span>

    <span class="s0"># Map away the locale-dependent composite format groups</span>

    <span class="s0">EnterLocale $locale</span>

    <span class="s0"># Change locale if a fresh locale has been given on the command line.</span>

    <span class="s0">try {</span>
	<span class="s0">return [ParseClockFormatFormat2 $format $locale $procName]</span>
    <span class="s0">} trap CLOCK {result opts} {</span>
	<span class="s0">dict unset opts -errorinfo</span>
	<span class="s0">return -options $opts $result</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">proc ::tcl::clock::ParseClockFormatFormat2 {format locale procName} {</span>
    <span class="s0">set didLocaleEra 0</span>
    <span class="s0">set didLocaleNumerals 0</span>
    <span class="s0">set preFormatCode \</span>
	<span class="s0">[string map [list @GREGORIAN_CHANGE_DATE@ \</span>
				       <span class="s0">[mc GREGORIAN_CHANGE_DATE]] \</span>
	     <span class="s0">{</span>
		 <span class="s0">variable TZData</span>
		 <span class="s0">set date [GetDateFields $clockval \</span>
			       <span class="s0">$TZData($timezone) \</span>
			       <span class="s0">@GREGORIAN_CHANGE_DATE@]</span>
	     <span class="s0">}]</span>
    <span class="s0">set formatString {}</span>
    <span class="s0">set substituents {}</span>
    <span class="s0">set state {}</span>

    <span class="s0">set format [LocalizeFormat $locale $format]</span>

    <span class="s0">foreach char [split $format {}] {</span>
	<span class="s0">switch -exact -- $state {</span>
	    <span class="s0">{} {</span>
		<span class="s0">if { [string equal % $char] } {</span>
		    <span class="s0">set state percent</span>
		<span class="s0">} else {</span>
		    <span class="s0">append formatString $char</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s0">percent {			# Character following a '%' character</span>
		<span class="s0">set state {}</span>
		<span class="s0">switch -exact -- $char {</span>
		    <span class="s0">% {			# A literal character, '%'</span>
			<span class="s0">append formatString %%</span>
		    <span class="s0">}</span>
		    <span class="s0">a {			# Day of week, abbreviated</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">[string map \</span>
				 <span class="s0">[list @DAYS_OF_WEEK_ABBREV@ \</span>
				      <span class="s0">[list [mc DAYS_OF_WEEK_ABBREV]]] \</span>
				 <span class="s0">{ [lindex @DAYS_OF_WEEK_ABBREV@ \</span>
					<span class="s0">[expr {[dict get $date dayOfWeek] \</span>
						   <span class="s0">% 7}]]}]</span>
		    <span class="s0">}</span>
		    <span class="s0">A {			# Day of week, spelt out.</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">[string map \</span>
				 <span class="s0">[list @DAYS_OF_WEEK_FULL@ \</span>
				      <span class="s0">[list [mc DAYS_OF_WEEK_FULL]]] \</span>
				 <span class="s0">{ [lindex @DAYS_OF_WEEK_FULL@ \</span>
					<span class="s0">[expr {[dict get $date dayOfWeek] \</span>
						   <span class="s0">% 7}]]}]</span>
		    <span class="s0">}</span>
		    <span class="s0">b - h {		# Name of month, abbreviated.</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">[string map \</span>
				 <span class="s0">[list @MONTHS_ABBREV@ \</span>
				      <span class="s0">[list [mc MONTHS_ABBREV]]] \</span>
				 <span class="s0">{ [lindex @MONTHS_ABBREV@ \</span>
					<span class="s0">[expr {[dict get $date month]-1}]]}]</span>
		    <span class="s0">}</span>
		    <span class="s0">B {			# Name of month, spelt out</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">[string map \</span>
				 <span class="s0">[list @MONTHS_FULL@ \</span>
				      <span class="s0">[list [mc MONTHS_FULL]]] \</span>
				 <span class="s0">{ [lindex @MONTHS_FULL@ \</span>
					<span class="s0">[expr {[dict get $date month]-1}]]}]</span>
		    <span class="s0">}</span>
		    <span class="s0">C {			# Century number</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [expr {[dict get $date year] / 100}]}</span>
		    <span class="s0">}</span>
		    <span class="s0">d {			# Day of month, with leading zero</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append substituents { [dict get $date dayOfMonth]}</span>
		    <span class="s0">}</span>
		    <span class="s0">e {			# Day of month, without leading zero</span>
			<span class="s0">append formatString %2d</span>
			<span class="s0">append substituents { [dict get $date dayOfMonth]}</span>
		    <span class="s0">}</span>
		    <span class="s0">E {			# Format group in a locale-dependent</span>
					<span class="s0"># alternative era</span>
			<span class="s0">set state percentE</span>
			<span class="s0">if {!$didLocaleEra} {</span>
			    <span class="s0">append preFormatCode \</span>
				<span class="s0">[string map \</span>
				     <span class="s0">[list @LOCALE_ERAS@ \</span>
					  <span class="s0">[list [mc LOCALE_ERAS]]] \</span>
				     <span class="s0">{</span>
					 <span class="s0">set date [GetLocaleEra \</span>
						       <span class="s0">$date[set date {}] \</span>
						       <span class="s0">@LOCALE_ERAS@]}] \n</span>
			    <span class="s0">set didLocaleEra 1</span>
			<span class="s0">}</span>
			<span class="s0">if {!$didLocaleNumerals} {</span>
			    <span class="s0">append preFormatCode \</span>
				<span class="s0">[list set localeNumerals \</span>
				     <span class="s0">[mc LOCALE_NUMERALS]] \n</span>
			    <span class="s0">set didLocaleNumerals 1</span>
			<span class="s0">}</span>
		    <span class="s0">}</span>
		    <span class="s0">g {			# Two-digit year relative to ISO8601</span>
					<span class="s0"># week number</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [expr { [dict get $date iso8601Year] % 100 }]}</span>
		    <span class="s0">}</span>
		    <span class="s0">G {			# Four-digit year relative to ISO8601</span>
					<span class="s0"># week number</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append substituents { [dict get $date iso8601Year]}</span>
		    <span class="s0">}</span>
		    <span class="s0">H {			# Hour in the 24-hour day, leading zero</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [expr { [dict get $date localSeconds] \</span>
					  <span class="s0">/ 3600 % 24}]}</span>
		    <span class="s0">}</span>
		    <span class="s0">I {			# Hour AM/PM, with leading zero</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [expr { ( ( ( [dict get $date localSeconds] \</span>
					    <span class="s0">% 86400 ) \</span>
					  <span class="s0">+ 86400 \</span>
					  <span class="s0">- 3600 ) \</span>
					<span class="s0">/ 3600 ) \</span>
				      <span class="s0">% 12 + 1 }] }</span>
		    <span class="s0">}</span>
		    <span class="s0">j {			# Day of year (001-366)</span>
			<span class="s0">append formatString %03d</span>
			<span class="s0">append substituents { [dict get $date dayOfYear]}</span>
		    <span class="s0">}</span>
		    <span class="s0">J {			# Julian Day Number</span>
			<span class="s0">append formatString %07ld</span>
			<span class="s0">append substituents { [dict get $date julianDay]}</span>
		    <span class="s0">}</span>
		    <span class="s0">k {			# Hour (0-23), no leading zero</span>
			<span class="s0">append formatString %2d</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [expr { [dict get $date localSeconds]</span>
				      <span class="s0">/ 3600</span>
				      <span class="s0">% 24 }]}</span>
		    <span class="s0">}</span>
		    <span class="s0">l {			# Hour (12-11), no leading zero</span>
			<span class="s0">append formatString %2d</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [expr { ( ( ( [dict get $date localSeconds]</span>
					   <span class="s0">% 86400 )</span>
					 <span class="s0">+ 86400</span>
					 <span class="s0">- 3600 )</span>
				       <span class="s0">/ 3600 )</span>
				     <span class="s0">% 12 + 1 }]}</span>
		    <span class="s0">}</span>
		    <span class="s0">m {			# Month number, leading zero</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append substituents { [dict get $date month]}</span>
		    <span class="s0">}</span>
		    <span class="s0">M {			# Minute of the hour, leading zero</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [expr { [dict get $date localSeconds]</span>
				      <span class="s0">/ 60</span>
				      <span class="s0">% 60 }]}</span>
		    <span class="s0">}</span>
		    <span class="s0">n {			# A literal newline</span>
			<span class="s0">append formatString \n</span>
		    <span class="s0">}</span>
		    <span class="s0">N {			# Month number, no leading zero</span>
			<span class="s0">append formatString %2d</span>
			<span class="s0">append substituents { [dict get $date month]}</span>
		    <span class="s0">}</span>
		    <span class="s0">O {			# A format group in the locale's</span>
					<span class="s0"># alternative numerals</span>
			<span class="s0">set state percentO</span>
			<span class="s0">if {!$didLocaleNumerals} {</span>
			    <span class="s0">append preFormatCode \</span>
				<span class="s0">[list set localeNumerals \</span>
				     <span class="s0">[mc LOCALE_NUMERALS]] \n</span>
			    <span class="s0">set didLocaleNumerals 1</span>
			<span class="s0">}</span>
		    <span class="s0">}</span>
		    <span class="s0">p {			# Localized 'AM' or 'PM' indicator</span>
					<span class="s0"># converted to uppercase</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append preFormatCode \</span>
			    <span class="s0">[list set AM [string toupper [mc AM]]] \n \</span>
			    <span class="s0">[list set PM [string toupper [mc PM]]] \n</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [expr {(([dict get $date localSeconds]</span>
				       <span class="s0">% 86400) &lt; 43200) ?</span>
				     <span class="s0">$AM : $PM}]}</span>
		    <span class="s0">}</span>
		    <span class="s0">P {			# Localized 'AM' or 'PM' indicator</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append preFormatCode \</span>
			    <span class="s0">[list set am [mc AM]] \n \</span>
			    <span class="s0">[list set pm [mc PM]] \n</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [expr {(([dict get $date localSeconds]</span>
				       <span class="s0">% 86400) &lt; 43200) ?</span>
				     <span class="s0">$am : $pm}]}</span>

		    <span class="s0">}</span>
		    <span class="s0">Q {			# Hi, Jeff!</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents { [FormatStarDate $date]}</span>
		    <span class="s0">}</span>
		    <span class="s0">s {			# Seconds from the Posix Epoch</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents { [dict get $date seconds]}</span>
		    <span class="s0">}</span>
		    <span class="s0">S {			# Second of the minute, with</span>
			<span class="s0"># leading zero</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [expr { [dict get $date localSeconds]</span>
				      <span class="s0">% 60 }]}</span>
		    <span class="s0">}</span>
		    <span class="s0">t {			# A literal tab character</span>
			<span class="s0">append formatString \t</span>
		    <span class="s0">}</span>
		    <span class="s0">u {			# Day of the week (1-Monday, 7-Sunday)</span>
			<span class="s0">append formatString %1d</span>
			<span class="s0">append substituents { [dict get $date dayOfWeek]}</span>
		    <span class="s0">}</span>
		    <span class="s0">U {			# Week of the year (00-53). The</span>
					<span class="s0"># first Sunday of the year is the</span>
					<span class="s0"># first day of week 01</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append preFormatCode {</span>
			    <span class="s0">set dow [dict get $date dayOfWeek]</span>
			    <span class="s0">if { $dow == 7 } {</span>
				<span class="s0">set dow 0</span>
			    <span class="s0">}</span>
			    <span class="s0">incr dow</span>
			    <span class="s0">set UweekNumber \</span>
				<span class="s0">[expr { ( [dict get $date dayOfYear]</span>
					  <span class="s0">- $dow + 7 )</span>
					<span class="s0">/ 7 }]</span>
			<span class="s0">}</span>
			<span class="s0">append substituents { $UweekNumber}</span>
		    <span class="s0">}</span>
		    <span class="s0">V {			# The ISO8601 week number</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append substituents { [dict get $date iso8601Week]}</span>
		    <span class="s0">}</span>
		    <span class="s0">w {			# Day of the week (0-Sunday,</span>
					<span class="s0"># 6-Saturday)</span>
			<span class="s0">append formatString %1d</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [expr { [dict get $date dayOfWeek] % 7 }]}</span>
		    <span class="s0">}</span>
		    <span class="s0">W {			# Week of the year (00-53). The first</span>
					<span class="s0"># Monday of the year is the first day</span>
					<span class="s0"># of week 01.</span>
			<span class="s0">append preFormatCode {</span>
			    <span class="s0">set WweekNumber \</span>
				<span class="s0">[expr { ( [dict get $date dayOfYear]</span>
					  <span class="s0">- [dict get $date dayOfWeek]</span>
					  <span class="s0">+ 7 )</span>
					<span class="s0">/ 7 }]</span>
			<span class="s0">}</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append substituents { $WweekNumber}</span>
		    <span class="s0">}</span>
		    <span class="s0">y {			# The two-digit year of the century</span>
			<span class="s0">append formatString %02d</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [expr { [dict get $date year] % 100 }]}</span>
		    <span class="s0">}</span>
		    <span class="s0">Y {			# The four-digit year</span>
			<span class="s0">append formatString %04d</span>
			<span class="s0">append substituents { [dict get $date year]}</span>
		    <span class="s0">}</span>
		    <span class="s0">z {			# The time zone as hours and minutes</span>
					<span class="s0"># east (+) or west (-) of Greenwich</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents { [FormatNumericTimeZone \</span>
						   <span class="s0">[dict get $date tzOffset]]}</span>
		    <span class="s0">}</span>
		    <span class="s0">Z {			# The name of the time zone</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents { [dict get $date tzName]}</span>
		    <span class="s0">}</span>
		    <span class="s0">% {			# A literal percent character</span>
			<span class="s0">append formatString %%</span>
		    <span class="s0">}</span>
		    <span class="s0">default {		# An unknown escape sequence</span>
			<span class="s0">append formatString %% $char</span>
		    <span class="s0">}</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s0">percentE {			# Character following %E</span>
		<span class="s0">set state {}</span>
		<span class="s0">switch -exact -- $char {</span>
		    <span class="s0">E {</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents { } \</span>
			    <span class="s0">[string map \</span>
				 <span class="s0">[list @BCE@ [list [mc BCE]] \</span>
				      <span class="s0">@CE@ [list [mc CE]]] \</span>
				      <span class="s0">{[dict get {BCE @BCE@ CE @CE@} \</span>
					    <span class="s0">[dict get $date era]]}]</span>
		    <span class="s0">}</span>
		    <span class="s0">C {			# Locale-dependent era</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents { [dict get $date localeEra]}</span>
		    <span class="s0">}</span>
		    <span class="s0">y {			# Locale-dependent year of the era</span>
			<span class="s0">append preFormatCode {</span>
			    <span class="s0">set y [dict get $date localeYear]</span>
			    <span class="s0">if { $y &gt;= 0 &amp;&amp; $y &lt; 100 } {</span>
				<span class="s0">set Eyear [lindex $localeNumerals $y]</span>
			    <span class="s0">} else {</span>
				<span class="s0">set Eyear $y</span>
			    <span class="s0">}</span>
			<span class="s0">}</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents { $Eyear}</span>
		    <span class="s0">}</span>
		    <span class="s0">default {		# Unknown %E format group</span>
			<span class="s0">append formatString %%E $char</span>
		    <span class="s0">}</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s0">percentO {			# Character following %O</span>
		<span class="s0">set state {}</span>
		<span class="s0">switch -exact -- $char {</span>
		    <span class="s0">d - e {		# Day of the month in alternative</span>
			<span class="s0"># numerals</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [lindex $localeNumerals \</span>
				   <span class="s0">[dict get $date dayOfMonth]]}</span>
		    <span class="s0">}</span>
		    <span class="s0">H - k {		# Hour of the day in alternative</span>
					<span class="s0"># numerals</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [lindex $localeNumerals \</span>
				   <span class="s0">[expr { [dict get $date localSeconds]</span>
					   <span class="s0">/ 3600</span>
					   <span class="s0">% 24 }]]}</span>
		    <span class="s0">}</span>
		    <span class="s0">I - l {		# Hour (12-11) AM/PM in alternative</span>
					<span class="s0"># numerals</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [lindex $localeNumerals \</span>
				   <span class="s0">[expr { ( ( ( [dict get $date localSeconds]</span>
						 <span class="s0">% 86400 )</span>
					       <span class="s0">+ 86400</span>
					       <span class="s0">- 3600 )</span>
					     <span class="s0">/ 3600 )</span>
					   <span class="s0">% 12 + 1 }]]}</span>
		    <span class="s0">}</span>
		    <span class="s0">m {			# Month number in alternative numerals</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [lindex $localeNumerals [dict get $date month]]}</span>
		    <span class="s0">}</span>
		    <span class="s0">M {			# Minute of the hour in alternative</span>
					<span class="s0"># numerals</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [lindex $localeNumerals \</span>
				   <span class="s0">[expr { [dict get $date localSeconds]</span>
					   <span class="s0">/ 60</span>
					   <span class="s0">% 60 }]]}</span>
		    <span class="s0">}</span>
		    <span class="s0">S {			# Second of the minute in alternative</span>
					<span class="s0"># numerals</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [lindex $localeNumerals \</span>
				   <span class="s0">[expr { [dict get $date localSeconds]</span>
					   <span class="s0">% 60 }]]}</span>
		    <span class="s0">}</span>
		    <span class="s0">u {			# Day of the week (Monday=1,Sunday=7)</span>
					<span class="s0"># in alternative numerals</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [lindex $localeNumerals \</span>
				   <span class="s0">[dict get $date dayOfWeek]]}</span>
			<span class="s0">}</span>
		    <span class="s0">w {			# Day of the week (Sunday=0,Saturday=6)</span>
					<span class="s0"># in alternative numerals</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [lindex $localeNumerals \</span>
				   <span class="s0">[expr { [dict get $date dayOfWeek] % 7 }]]}</span>
		    <span class="s0">}</span>
		    <span class="s0">y {			# Year of the century in alternative</span>
					<span class="s0"># numerals</span>
			<span class="s0">append formatString %s</span>
			<span class="s0">append substituents \</span>
			    <span class="s0">{ [lindex $localeNumerals \</span>
				   <span class="s0">[expr { [dict get $date year] % 100 }]]}</span>
		    <span class="s0">}</span>
		    <span class="s0">default {	# Unknown format group</span>
			<span class="s0">append formatString %%O $char</span>
		    <span class="s0">}</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Clean up any improperly terminated groups</span>

    <span class="s0">switch -exact -- $state {</span>
	<span class="s0">percent {</span>
	    <span class="s0">append formatString %%</span>
	<span class="s0">}</span>
	<span class="s0">percentE {</span>
	    <span class="s0">append retval %%E</span>
	<span class="s0">}</span>
	<span class="s0">percentO {</span>
	    <span class="s0">append retval %%O</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">proc $procName {clockval timezone} &quot;</span>
        <span class="s0">$preFormatCode</span>
        <span class="s0">return \[::format [list $formatString] $substituents\]</span>
    <span class="s0">&quot;</span>

    <span class="s0">#    puts [list $procName [info args $procName] [info body $procName]]</span>

    <span class="s0">return $procName</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># clock scan --</span>
<span class="s0">#</span>
<span class="s0">#	Inputs a count of seconds since the Posix Epoch as a time of day.</span>
<span class="s0">#</span>
<span class="s0"># The 'clock format' command scans times of day on input.  Refer to the user</span>
<span class="s0"># documentation to see what it does.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::scan { args } {</span>

    <span class="s0">set format {}</span>

    <span class="s0"># Check the count of args</span>

    <span class="s0">if { [llength $args] &lt; 1 || [llength $args] % 2 != 1 } {</span>
	<span class="s0">set cmdName &quot;clock scan&quot;</span>
	<span class="s0">return -code error \</span>
	    <span class="s0">-errorcode [list CLOCK wrongNumArgs] \</span>
	    <span class="s0">&quot;wrong \# args: should be\</span>
             <span class="s0">\&quot;$cmdName string\</span>
             <span class="s0">?-base seconds?\</span>
             <span class="s0">?-format string? ?-gmt boolean?\</span>
             <span class="s0">?-locale LOCALE? ?-timezone ZONE?\&quot;&quot;</span>
    <span class="s0">}</span>

    <span class="s0"># Set defaults</span>

    <span class="s0">set base [clock seconds]</span>
    <span class="s0">set string [lindex $args 0]</span>
    <span class="s0">set format {}</span>
    <span class="s0">set gmt 0</span>
    <span class="s0">set locale c</span>
    <span class="s0">set timezone [GetSystemTimeZone]</span>

    <span class="s0"># Pick up command line options.</span>

    <span class="s0">foreach { flag value } [lreplace $args 0 0] {</span>
	<span class="s0">set saw($flag) {}</span>
	<span class="s0">switch -exact -- $flag {</span>
	    <span class="s0">-b - -ba - -bas - -base {</span>
		<span class="s0">set base $value</span>
	    <span class="s0">}</span>
	    <span class="s0">-f - -fo - -for - -form - -forma - -format {</span>
		<span class="s0">set format $value</span>
	    <span class="s0">}</span>
	    <span class="s0">-g - -gm - -gmt {</span>
		<span class="s0">set gmt $value</span>
	    <span class="s0">}</span>
	    <span class="s0">-l - -lo - -loc - -loca - -local - -locale {</span>
		<span class="s0">set locale [string tolower $value]</span>
	    <span class="s0">}</span>
	    <span class="s0">-t - -ti - -tim - -time - -timez - -timezo - -timezon - -timezone {</span>
		<span class="s0">set timezone $value</span>
	    <span class="s0">}</span>
	    <span class="s0">default {</span>
		<span class="s0">return -code error \</span>
		    <span class="s0">-errorcode [list CLOCK badOption $flag] \</span>
		    <span class="s0">&quot;bad option \&quot;$flag\&quot;,\</span>
                     <span class="s0">must be -base, -format, -gmt, -locale or -timezone&quot;</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Check options for validity</span>

    <span class="s0">if { [info exists saw(-gmt)] &amp;&amp; [info exists saw(-timezone)] } {</span>
	<span class="s0">return -code error \</span>
	    <span class="s0">-errorcode [list CLOCK gmtWithTimezone] \</span>
	    <span class="s0">&quot;cannot use -gmt and -timezone in same call&quot;</span>
    <span class="s0">}</span>
    <span class="s0">if { [catch { expr { wide($base) } } result] } {</span>
	<span class="s0">return -code error &quot;expected integer but got \&quot;$base\&quot;&quot;</span>
    <span class="s0">}</span>
    <span class="s0">if { ![string is boolean -strict $gmt] } {</span>
	<span class="s0">return -code error &quot;expected boolean value but got \&quot;$gmt\&quot;&quot;</span>
    <span class="s0">} elseif { $gmt } {</span>
	<span class="s0">set timezone :GMT</span>
    <span class="s0">}</span>

    <span class="s0">if { ![info exists saw(-format)] } {</span>
	<span class="s0"># Perhaps someday we'll localize the legacy code. Right now, it's not</span>
	<span class="s0"># localized.</span>
	<span class="s0">if { [info exists saw(-locale)] } {</span>
	    <span class="s0">return -code error \</span>
		<span class="s0">-errorcode [list CLOCK flagWithLegacyFormat] \</span>
		<span class="s0">&quot;legacy \[clock scan\] does not support -locale&quot;</span>

	<span class="s0">}</span>
	<span class="s0">return [FreeScan $string $base $timezone $locale]</span>
    <span class="s0">}</span>

    <span class="s0"># Change locale if a fresh locale has been given on the command line.</span>

    <span class="s0">EnterLocale $locale</span>

    <span class="s0">try {</span>
	<span class="s0"># Map away the locale-dependent composite format groups</span>

	<span class="s0">set scanner [ParseClockScanFormat $format $locale]</span>
	<span class="s0">return [$scanner $string $base $timezone]</span>
    <span class="s0">} trap CLOCK {result opts} {</span>
	<span class="s0"># Conceal location of generation of expected errors</span>
	<span class="s0">dict unset opts -errorinfo</span>
	<span class="s0">return -options $opts $result</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># FreeScan --</span>
<span class="s0">#</span>
<span class="s0">#	Scans a time in free format</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	string - String containing the time to scan</span>
<span class="s0">#	base - Base time, expressed in seconds from the Epoch</span>
<span class="s0">#	timezone - Default time zone in which the time will be expressed</span>
<span class="s0">#	locale - (Unused) Name of the locale where the time will be scanned.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the date and time extracted from the string in seconds from</span>
<span class="s0">#	the epoch</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::FreeScan { string base timezone locale } {</span>

    <span class="s0">variable TZData</span>

    <span class="s0"># Get the data for time changes in the given zone</span>

    <span class="s0">try {</span>
	<span class="s0">SetupTimeZone $timezone</span>
    <span class="s0">} on error {retval opts} {</span>
	<span class="s0">dict unset opts -errorinfo</span>
	<span class="s0">return -options $opts $retval</span>
    <span class="s0">}</span>

    <span class="s0"># Extract year, month and day from the base time for the parser to use as</span>
    <span class="s0"># defaults</span>

    <span class="s0">set date [GetDateFields $base $TZData($timezone) 2361222]</span>
    <span class="s0">dict set date secondOfDay [expr {</span>
	<span class="s0">[dict get $date localSeconds] % 86400</span>
    <span class="s0">}]</span>

    <span class="s0"># Parse the date.  The parser will return a list comprising date, time,</span>
    <span class="s0"># time zone, relative month/day/seconds, relative weekday, ordinal month.</span>

    <span class="s0">try {</span>
	<span class="s0">set scanned [Oldscan $string \</span>
		     <span class="s0">[dict get $date year] \</span>
		     <span class="s0">[dict get $date month] \</span>
		     <span class="s0">[dict get $date dayOfMonth]]</span>
	<span class="s0">lassign $scanned \</span>
	    <span class="s0">parseDate parseTime parseZone parseRel \</span>
	    <span class="s0">parseWeekday parseOrdinalMonth</span>
    <span class="s0">} on error message {</span>
	<span class="s0">return -code error \</span>
	    <span class="s0">&quot;unable to convert date-time string \&quot;$string\&quot;: $message&quot;</span>
    <span class="s0">}</span>

    <span class="s0"># If the caller supplied a date in the string, update the 'date' dict with</span>
    <span class="s0"># the value. If the caller didn't specify a time with the date, default to</span>
    <span class="s0"># midnight.</span>

    <span class="s0">if { [llength $parseDate] &gt; 0 } {</span>
	<span class="s0">lassign $parseDate y m d</span>
	<span class="s0">if { $y &lt; 100 } {</span>
	    <span class="s0">if { $y &gt;= 39 } {</span>
		<span class="s0">incr y 1900</span>
	    <span class="s0">} else {</span>
		<span class="s0">incr y 2000</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">dict set date era CE</span>
	<span class="s0">dict set date year $y</span>
	<span class="s0">dict set date month $m</span>
	<span class="s0">dict set date dayOfMonth $d</span>
	<span class="s0">if { $parseTime eq {} } {</span>
	    <span class="s0">set parseTime 0</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># If the caller supplied a time zone in the string, it comes back as a</span>
    <span class="s0"># two-element list; the first element is the number of minutes east of</span>
    <span class="s0"># Greenwich, and the second is a Daylight Saving Time indicator (1 == yes,</span>
    <span class="s0"># 0 == no, -1 == unknown). We make it into a time zone indicator of</span>
    <span class="s0"># +-hhmm.</span>

    <span class="s0">if { [llength $parseZone] &gt; 0 } {</span>
	<span class="s0">lassign $parseZone minEast dstFlag</span>
	<span class="s0">set timezone [FormatNumericTimeZone \</span>
			  <span class="s0">[expr { 60 * $minEast + 3600 * $dstFlag }]]</span>
	<span class="s0">SetupTimeZone $timezone</span>
    <span class="s0">}</span>
    <span class="s0">dict set date tzName $timezone</span>

    <span class="s0"># Assemble date, time, zone into seconds-from-epoch</span>

    <span class="s0">set date [GetJulianDayFromEraYearMonthDay $date[set date {}] 2361222]</span>
    <span class="s0">if { $parseTime ne {} } {</span>
	<span class="s0">dict set date secondOfDay $parseTime</span>
    <span class="s0">} elseif { [llength $parseWeekday] != 0</span>
	       <span class="s0">|| [llength $parseOrdinalMonth] != 0</span>
	       <span class="s0">|| ( [llength $parseRel] != 0</span>
		    <span class="s0">&amp;&amp; ( [lindex $parseRel 0] != 0</span>
			 <span class="s0">|| [lindex $parseRel 1] != 0 ) ) } {</span>
	<span class="s0">dict set date secondOfDay 0</span>
    <span class="s0">}</span>

    <span class="s0">dict set date localSeconds [expr {</span>
	<span class="s0">-210866803200</span>
	<span class="s0">+ ( 86400 * wide([dict get $date julianDay]) )</span>
	<span class="s0">+ [dict get $date secondOfDay]</span>
    <span class="s0">}]</span>
    <span class="s0">dict set date tzName $timezone</span>
    <span class="s0">set date [ConvertLocalToUTC $date[set date {}] $TZData($timezone) 2361222]</span>
    <span class="s0">set seconds [dict get $date seconds]</span>

    <span class="s0"># Do relative times</span>

    <span class="s0">if { [llength $parseRel] &gt; 0 } {</span>
	<span class="s0">lassign $parseRel relMonth relDay relSecond</span>
	<span class="s0">set seconds [add $seconds \</span>
			 <span class="s0">$relMonth months $relDay days $relSecond seconds \</span>
			 <span class="s0">-timezone $timezone -locale $locale]</span>
    <span class="s0">}</span>

    <span class="s0"># Do relative weekday</span>

    <span class="s0">if { [llength $parseWeekday] &gt; 0 } {</span>
	<span class="s0">lassign $parseWeekday dayOrdinal dayOfWeek</span>
	<span class="s0">set date2 [GetDateFields $seconds $TZData($timezone) 2361222]</span>
	<span class="s0">dict set date2 era CE</span>
	<span class="s0">set jdwkday [WeekdayOnOrBefore $dayOfWeek [expr {</span>
	    <span class="s0">[dict get $date2 julianDay] + 6</span>
	<span class="s0">}]]</span>
	<span class="s0">incr jdwkday [expr { 7 * $dayOrdinal }]</span>
	<span class="s0">if { $dayOrdinal &gt; 0 } {</span>
	    <span class="s0">incr jdwkday -7</span>
	<span class="s0">}</span>
	<span class="s0">dict set date2 secondOfDay \</span>
	    <span class="s0">[expr { [dict get $date2 localSeconds] % 86400 }]</span>
	<span class="s0">dict set date2 julianDay $jdwkday</span>
	<span class="s0">dict set date2 localSeconds [expr {</span>
	    <span class="s0">-210866803200</span>
	    <span class="s0">+ ( 86400 * wide([dict get $date2 julianDay]) )</span>
	    <span class="s0">+ [dict get $date secondOfDay]</span>
	<span class="s0">}]</span>
	<span class="s0">dict set date2 tzName $timezone</span>
	<span class="s0">set date2 [ConvertLocalToUTC $date2[set date2 {}] $TZData($timezone) \</span>
		       <span class="s0">2361222]</span>
	<span class="s0">set seconds [dict get $date2 seconds]</span>

    <span class="s0">}</span>

    <span class="s0"># Do relative month</span>

    <span class="s0">if { [llength $parseOrdinalMonth] &gt; 0 } {</span>
	<span class="s0">lassign $parseOrdinalMonth monthOrdinal monthNumber</span>
	<span class="s0">if { $monthOrdinal &gt; 0 } {</span>
	    <span class="s0">set monthDiff [expr { $monthNumber - [dict get $date month] }]</span>
	    <span class="s0">if { $monthDiff &lt;= 0 } {</span>
		<span class="s0">incr monthDiff 12</span>
	    <span class="s0">}</span>
	    <span class="s0">incr monthOrdinal -1</span>
	<span class="s0">} else {</span>
	    <span class="s0">set monthDiff [expr { [dict get $date month] - $monthNumber }]</span>
	    <span class="s0">if { $monthDiff &gt;= 0 } {</span>
		<span class="s0">incr monthDiff -12</span>
	    <span class="s0">}</span>
	    <span class="s0">incr monthOrdinal</span>
	<span class="s0">}</span>
	<span class="s0">set seconds [add $seconds $monthOrdinal years $monthDiff months \</span>
			 <span class="s0">-timezone $timezone -locale $locale]</span>
    <span class="s0">}</span>

    <span class="s0">return $seconds</span>
<span class="s0">}</span>


<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># ParseClockScanFormat --</span>
<span class="s0">#</span>
<span class="s0">#	Parses a format string given to [clock scan -format]</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	formatString - The format being parsed</span>
<span class="s0">#	locale - The current locale</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Constructs and returns a procedure that accepts the string being</span>
<span class="s0">#	scanned, the base time, and the time zone.  The procedure will either</span>
<span class="s0">#	return the scanned time or else throw an error that should be rethrown</span>
<span class="s0">#	to the caller of [clock scan]</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	The given procedure is defined in the ::tcl::clock namespace.  Scan</span>
<span class="s0">#	procedures are not deleted once installed.</span>
<span class="s0">#</span>
<span class="s0"># Why do we parse dates by defining a procedure to parse them?  The reason is</span>
<span class="s0"># that by doing so, we have one convenient place to cache all the information:</span>
<span class="s0"># the regular expressions that match the patterns (which will be compiled),</span>
<span class="s0"># the code that assembles the date information, everything lands in one place.</span>
<span class="s0"># In this way, when a given format is reused at run time, all the information</span>
<span class="s0"># of how to apply it is available in a single place.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::ParseClockScanFormat {formatString locale} {</span>
    <span class="s0"># Check whether the format has been parsed previously, and return the</span>
    <span class="s0"># existing recognizer if it has.</span>

    <span class="s0">set procName scanproc'$formatString'$locale</span>
    <span class="s0">set procName [namespace current]::[string map {: {\:} \\ {\\}} $procName]</span>
    <span class="s0">if { [namespace which $procName] != {} } {</span>
	<span class="s0">return $procName</span>
    <span class="s0">}</span>

    <span class="s0">variable DateParseActions</span>
    <span class="s0">variable TimeParseActions</span>

    <span class="s0"># Localize the %x, %X, etc. groups</span>

    <span class="s0">set formatString [LocalizeFormat $locale $formatString]</span>

    <span class="s0"># Condense whitespace</span>

    <span class="s0">regsub -all {[[:space:]]+} $formatString { } formatString</span>

    <span class="s0"># Walk through the groups of the format string.  In this loop, we</span>
    <span class="s0"># accumulate:</span>
    <span class="s0">#	- a regular expression that matches the string,</span>
    <span class="s0">#   - the count of capturing brackets in the regexp</span>
    <span class="s0">#   - a set of code that post-processes the fields captured by the regexp,</span>
    <span class="s0">#   - a dictionary whose keys are the names of fields that are present</span>
    <span class="s0">#     in the format string.</span>

    <span class="s0">set re {^[[:space:]]*}</span>
    <span class="s0">set captureCount 0</span>
    <span class="s0">set postcode {}</span>
    <span class="s0">set fieldSet [dict create]</span>
    <span class="s0">set fieldCount 0</span>
    <span class="s0">set postSep {}</span>
    <span class="s0">set state {}</span>

    <span class="s0">foreach c [split $formatString {}] {</span>
	<span class="s0">switch -exact -- $state {</span>
	    <span class="s0">{} {</span>
		<span class="s0">if { $c eq &quot;%&quot; } {</span>
		    <span class="s0">set state %</span>
		<span class="s0">} elseif { $c eq &quot; &quot; } {</span>
		    <span class="s0">append re {[[:space:]]+}</span>
		<span class="s0">} else {</span>
		    <span class="s0">if { ! [string is alnum $c] } {</span>
			<span class="s0">append re &quot;\\&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">append re $c</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s0">% {</span>
		<span class="s0">set state {}</span>
		<span class="s0">switch -exact -- $c {</span>
		    <span class="s0">% {</span>
			<span class="s0">append re %</span>
		    <span class="s0">}</span>
		    <span class="s0">{ } {</span>
			<span class="s0">append re &quot;\[\[:space:\]\]*&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">a - A { 		# Day of week, in words</span>
			<span class="s0">set l {}</span>
			<span class="s0">foreach \</span>
			    <span class="s0">i {7 1 2 3 4 5 6} \</span>
			    <span class="s0">abr [mc DAYS_OF_WEEK_ABBREV] \</span>
			    <span class="s0">full [mc DAYS_OF_WEEK_FULL] {</span>
				<span class="s0">dict set l [string tolower $abr] $i</span>
				<span class="s0">dict set l [string tolower $full] $i</span>
				<span class="s0">incr i</span>
			    <span class="s0">}</span>
			<span class="s0">lassign [UniquePrefixRegexp $l] regex lookup</span>
			<span class="s0">append re ( $regex )</span>
			<span class="s0">dict set fieldSet dayOfWeek [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date dayOfWeek \[&quot; \</span>
			    <span class="s0">&quot;dict get &quot; [list $lookup] &quot; &quot; \</span>
			    <span class="s0">\[ {string tolower $field} [incr captureCount] \] \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">b - B - h {		# Name of month</span>
			<span class="s0">set i 0</span>
			<span class="s0">set l {}</span>
			<span class="s0">foreach \</span>
			    <span class="s0">abr [mc MONTHS_ABBREV] \</span>
			    <span class="s0">full [mc MONTHS_FULL] {</span>
				<span class="s0">incr i</span>
				<span class="s0">dict set l [string tolower $abr] $i</span>
				<span class="s0">dict set l [string tolower $full] $i</span>
			    <span class="s0">}</span>
			<span class="s0">lassign [UniquePrefixRegexp $l] regex lookup</span>
			<span class="s0">append re ( $regex )</span>
			<span class="s0">dict set fieldSet month [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date month \[&quot; \</span>
			    <span class="s0">&quot;dict get &quot; [list $lookup] \</span>
			    <span class="s0">&quot; &quot; \[ {string tolower $field} \</span>
			    <span class="s0">[incr captureCount] \] \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">C {			# Gregorian century</span>
			<span class="s0">append re \\s*(\\d\\d?)</span>
			<span class="s0">dict set fieldSet century [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date century \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">d - e {		# Day of month</span>
			<span class="s0">append re \\s*(\\d\\d?)</span>
			<span class="s0">dict set fieldSet dayOfMonth [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date dayOfMonth \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">E {			# Prefix for locale-specific codes</span>
			<span class="s0">set state %E</span>
		    <span class="s0">}</span>
		    <span class="s0">g {			# ISO8601 2-digit year</span>
			<span class="s0">append re \\s*(\\d\\d)</span>
			<span class="s0">dict set fieldSet iso8601YearOfCentury \</span>
			    <span class="s0">[incr fieldCount]</span>
			<span class="s0">append postcode \</span>
			    <span class="s0">&quot;dict set date iso8601YearOfCentury \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">G {			# ISO8601 4-digit year</span>
			<span class="s0">append re \\s*(\\d\\d)(\\d\\d)</span>
			<span class="s0">dict set fieldSet iso8601Century [incr fieldCount]</span>
			<span class="s0">dict set fieldSet iso8601YearOfCentury \</span>
			    <span class="s0">[incr fieldCount]</span>
			<span class="s0">append postcode \</span>
			    <span class="s0">&quot;dict set date iso8601Century \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot; \</span>
			    <span class="s0">&quot;dict set date iso8601YearOfCentury \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">H - k {		# Hour of day</span>
			<span class="s0">append re \\s*(\\d\\d?)</span>
			<span class="s0">dict set fieldSet hour [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date hour \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">I - l {		# Hour, AM/PM</span>
			<span class="s0">append re \\s*(\\d\\d?)</span>
			<span class="s0">dict set fieldSet hourAMPM [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date hourAMPM \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">j {			# Day of year</span>
			<span class="s0">append re \\s*(\\d\\d?\\d?)</span>
			<span class="s0">dict set fieldSet dayOfYear [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date dayOfYear \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">J {			# Julian Day Number</span>
			<span class="s0">append re \\s*(\\d+)</span>
			<span class="s0">dict set fieldSet julianDay [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date julianDay \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %ld&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">m - N {		# Month number</span>
			<span class="s0">append re \\s*(\\d\\d?)</span>
			<span class="s0">dict set fieldSet month [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date month \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">M {			# Minute</span>
			<span class="s0">append re \\s*(\\d\\d?)</span>
			<span class="s0">dict set fieldSet minute [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date minute \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">n {			# Literal newline</span>
			<span class="s0">append re \\n</span>
		    <span class="s0">}</span>
		    <span class="s0">O {			# Prefix for locale numerics</span>
			<span class="s0">set state %O</span>
		    <span class="s0">}</span>
		    <span class="s0">p - P { 		# AM/PM indicator</span>
			<span class="s0">set l [list [string tolower [mc AM]] 0 \</span>
				   <span class="s0">[string tolower [mc PM]] 1]</span>
			<span class="s0">lassign [UniquePrefixRegexp $l] regex lookup</span>
			<span class="s0">append re ( $regex )</span>
			<span class="s0">dict set fieldSet amPmIndicator [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date amPmIndicator \[&quot; \</span>
			    <span class="s0">&quot;dict get &quot; [list $lookup] &quot; \[string tolower &quot; \</span>
			    <span class="s0">&quot;\$field&quot; \</span>
			    <span class="s0">[incr captureCount] \</span>
			    <span class="s0">&quot;\]\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">Q {			# Hi, Jeff!</span>
			<span class="s0">append re {Stardate\s+([-+]?\d+)(\d\d\d)[.](\d)}</span>
			<span class="s0">incr captureCount</span>
			<span class="s0">dict set fieldSet seconds [incr fieldCount]</span>
			<span class="s0">append postcode {dict set date seconds } \[ \</span>
			    <span class="s0">{ParseStarDate $field} [incr captureCount] \</span>
			    <span class="s0">{ $field} [incr captureCount] \</span>
			    <span class="s0">{ $field} [incr captureCount] \</span>
			    <span class="s0">\] \n</span>
		    <span class="s0">}</span>
		    <span class="s0">s {			# Seconds from Posix Epoch</span>
			<span class="s0"># This next case is insanely difficult, because it's</span>
			<span class="s0"># problematic to determine whether the field is</span>
			<span class="s0"># actually within the range of a wide integer.</span>
			<span class="s0">append re {\s*([-+]?\d+)}</span>
			<span class="s0">dict set fieldSet seconds [incr fieldCount]</span>
			<span class="s0">append postcode {dict set date seconds } \[ \</span>
			    <span class="s0">{ScanWide $field} [incr captureCount] \] \n</span>
		    <span class="s0">}</span>
		    <span class="s0">S {			# Second</span>
			<span class="s0">append re \\s*(\\d\\d?)</span>
			<span class="s0">dict set fieldSet second [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date second \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">t {			# Literal tab character</span>
			<span class="s0">append re \\t</span>
		    <span class="s0">}</span>
		    <span class="s0">u - w {		# Day number within week, 0 or 7 == Sun</span>
					<span class="s0"># 1=Mon, 6=Sat</span>
			<span class="s0">append re \\s*(\\d)</span>
			<span class="s0">dict set fieldSet dayOfWeek [incr fieldCount]</span>
			<span class="s0">append postcode {::scan $field} [incr captureCount] \</span>
			    <span class="s0">{ %d dow} \n \</span>
			    <span class="s0">{</span>
				<span class="s0">if { $dow == 0 } {</span>
				    <span class="s0">set dow 7</span>
				<span class="s0">} elseif { $dow &gt; 7 } {</span>
				    <span class="s0">return -code error \</span>
					<span class="s0">-errorcode [list CLOCK badDayOfWeek] \</span>
					<span class="s0">&quot;day of week is greater than 7&quot;</span>
				<span class="s0">}</span>
				<span class="s0">dict set date dayOfWeek $dow</span>
			    <span class="s0">}</span>
		    <span class="s0">}</span>
		    <span class="s0">U {			# Week of year. The first Sunday of</span>
					<span class="s0"># the year is the first day of week</span>
					<span class="s0"># 01. No scan rule uses this group.</span>
			<span class="s0">append re \\s*\\d\\d?</span>
		    <span class="s0">}</span>
		    <span class="s0">V {			# Week of ISO8601 year</span>

			<span class="s0">append re \\s*(\\d\\d?)</span>
			<span class="s0">dict set fieldSet iso8601Week [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date iso8601Week \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">W {			# Week of the year (00-53). The first</span>
					<span class="s0"># Monday of the year is the first day</span>
					<span class="s0"># of week 01. No scan rule uses this</span>
					<span class="s0"># group.</span>
			<span class="s0">append re \\s*\\d\\d?</span>
		    <span class="s0">}</span>
		    <span class="s0">y {			# Two-digit Gregorian year</span>
			<span class="s0">append re \\s*(\\d\\d?)</span>
			<span class="s0">dict set fieldSet yearOfCentury [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date yearOfCentury \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">Y {			# 4-digit Gregorian year</span>
			<span class="s0">append re \\s*(\\d\\d)(\\d\\d)</span>
			<span class="s0">dict set fieldSet century [incr fieldCount]</span>
			<span class="s0">dict set fieldSet yearOfCentury [incr fieldCount]</span>
			<span class="s0">append postcode \</span>
			    <span class="s0">&quot;dict set date century \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot; \</span>
			    <span class="s0">&quot;dict set date yearOfCentury \[&quot; \</span>
			    <span class="s0">&quot;::scan \$field&quot; [incr captureCount] &quot; %d&quot; \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">z - Z {			# Time zone name</span>
			<span class="s0">append re {(?:([-+]\d\d(?::?\d\d(?::?\d\d)?)?)|([[:alnum:]]{1,4}))}</span>
			<span class="s0">dict set fieldSet tzName [incr fieldCount]</span>
			<span class="s0">append postcode \</span>
			    <span class="s0">{if } \{ { $field} [incr captureCount] \</span>
			    <span class="s0">{ ne &quot;&quot; } \} { } \{ \n \</span>
			    <span class="s0">{dict set date tzName $field} \</span>
			    <span class="s0">$captureCount \n \</span>
			    <span class="s0">\} { else } \{ \n \</span>
			    <span class="s0">{dict set date tzName } \[ \</span>
			    <span class="s0">{ConvertLegacyTimeZone $field} \</span>
			    <span class="s0">[incr captureCount] \] \n \</span>
			    <span class="s0">\} \n \</span>
		    <span class="s0">}</span>
		    <span class="s0">% {			# Literal percent character</span>
			<span class="s0">append re %</span>
		    <span class="s0">}</span>
		    <span class="s0">default {</span>
			<span class="s0">append re %</span>
			<span class="s0">if { ! [string is alnum $c] } {</span>
			    <span class="s0">append re \\</span>
			    <span class="s0">}</span>
			<span class="s0">append re $c</span>
		    <span class="s0">}</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s0">%E {</span>
		<span class="s0">switch -exact -- $c {</span>
		    <span class="s0">C {			# Locale-dependent era</span>
			<span class="s0">set d {}</span>
			<span class="s0">foreach triple [mc LOCALE_ERAS] {</span>
			    <span class="s0">lassign $triple t symbol year</span>
			    <span class="s0">dict set d [string tolower $symbol] $year</span>
			<span class="s0">}</span>
			<span class="s0">lassign [UniquePrefixRegexp $d] regex lookup</span>
			<span class="s0">append re (?: $regex )</span>
		    <span class="s0">}</span>
		    <span class="s0">E {</span>
			<span class="s0">set l {}</span>
			<span class="s0">dict set l [string tolower [mc BCE]] BCE</span>
			<span class="s0">dict set l [string tolower [mc CE]] CE</span>
			<span class="s0">dict set l b.c.e. BCE</span>
			<span class="s0">dict set l c.e. CE</span>
			<span class="s0">dict set l b.c. BCE</span>
			<span class="s0">dict set l a.d. CE</span>
			<span class="s0">lassign [UniquePrefixRegexp $l] regex lookup</span>
			<span class="s0">append re ( $regex )</span>
			<span class="s0">dict set fieldSet era [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date era \[&quot;\</span>
			    <span class="s0">&quot;dict get &quot; [list $lookup] \</span>
			    <span class="s0">{ } \[ {string tolower $field} \</span>
			    <span class="s0">[incr captureCount] \] \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">y {			# Locale-dependent year of the era</span>
			<span class="s0">lassign [LocaleNumeralMatcher $locale] regex lookup</span>
			<span class="s0">append re $regex</span>
			<span class="s0">incr captureCount</span>
		    <span class="s0">}</span>
		    <span class="s0">default {</span>
			<span class="s0">append re %E</span>
			<span class="s0">if { ! [string is alnum $c] } {</span>
			    <span class="s0">append re \\</span>
			    <span class="s0">}</span>
			<span class="s0">append re $c</span>
		    <span class="s0">}</span>
		<span class="s0">}</span>
		<span class="s0">set state {}</span>
	    <span class="s0">}</span>
	    <span class="s0">%O {</span>
		<span class="s0">switch -exact -- $c {</span>
		    <span class="s0">d - e {</span>
			<span class="s0">lassign [LocaleNumeralMatcher $locale] regex lookup</span>
			<span class="s0">append re $regex</span>
			<span class="s0">dict set fieldSet dayOfMonth [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date dayOfMonth \[&quot; \</span>
			    <span class="s0">&quot;dict get &quot; [list $lookup] &quot; \$field&quot; \</span>
			    <span class="s0">[incr captureCount] \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">H - k {</span>
			<span class="s0">lassign [LocaleNumeralMatcher $locale] regex lookup</span>
			<span class="s0">append re $regex</span>
			<span class="s0">dict set fieldSet hour [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date hour \[&quot; \</span>
			    <span class="s0">&quot;dict get &quot; [list $lookup] &quot; \$field&quot; \</span>
			    <span class="s0">[incr captureCount] \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">I - l {</span>
			<span class="s0">lassign [LocaleNumeralMatcher $locale] regex lookup</span>
			<span class="s0">append re $regex</span>
			<span class="s0">dict set fieldSet hourAMPM [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date hourAMPM \[&quot; \</span>
			    <span class="s0">&quot;dict get &quot; [list $lookup] &quot; \$field&quot; \</span>
			    <span class="s0">[incr captureCount] \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">m {</span>
			<span class="s0">lassign [LocaleNumeralMatcher $locale] regex lookup</span>
			<span class="s0">append re $regex</span>
			<span class="s0">dict set fieldSet month [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date month \[&quot; \</span>
			    <span class="s0">&quot;dict get &quot; [list $lookup] &quot; \$field&quot; \</span>
			    <span class="s0">[incr captureCount] \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">M {</span>
			<span class="s0">lassign [LocaleNumeralMatcher $locale] regex lookup</span>
			<span class="s0">append re $regex</span>
			<span class="s0">dict set fieldSet minute [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date minute \[&quot; \</span>
			    <span class="s0">&quot;dict get &quot; [list $lookup] &quot; \$field&quot; \</span>
			    <span class="s0">[incr captureCount] \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">S {</span>
			<span class="s0">lassign [LocaleNumeralMatcher $locale] regex lookup</span>
			<span class="s0">append re $regex</span>
			<span class="s0">dict set fieldSet second [incr fieldCount]</span>
			<span class="s0">append postcode &quot;dict set date second \[&quot; \</span>
			    <span class="s0">&quot;dict get &quot; [list $lookup] &quot; \$field&quot; \</span>
			    <span class="s0">[incr captureCount] \</span>
			    <span class="s0">&quot;\]\n&quot;</span>
		    <span class="s0">}</span>
		    <span class="s0">u - w {</span>
			<span class="s0">lassign [LocaleNumeralMatcher $locale] regex lookup</span>
			<span class="s0">append re $regex</span>
			<span class="s0">dict set fieldSet dayOfWeek [incr fieldCount]</span>
			<span class="s0">append postcode &quot;set dow \[dict get &quot; [list $lookup] \</span>
			    <span class="s0">{ $field} [incr captureCount] \] \n \</span>
			    <span class="s0">{</span>
				<span class="s0">if { $dow == 0 } {</span>
				    <span class="s0">set dow 7</span>
				<span class="s0">} elseif { $dow &gt; 7 } {</span>
				    <span class="s0">return -code error \</span>
					<span class="s0">-errorcode [list CLOCK badDayOfWeek] \</span>
					<span class="s0">&quot;day of week is greater than 7&quot;</span>
				<span class="s0">}</span>
				<span class="s0">dict set date dayOfWeek $dow</span>
			    <span class="s0">}</span>
		    <span class="s0">}</span>
		    <span class="s0">y {</span>
			<span class="s0">lassign [LocaleNumeralMatcher $locale] regex lookup</span>
			<span class="s0">append re $regex</span>
			<span class="s0">dict set fieldSet yearOfCentury [incr fieldCount]</span>
			<span class="s0">append postcode {dict set date yearOfCentury } \[ \</span>
			    <span class="s0">{dict get } [list $lookup] { $field} \</span>
			    <span class="s0">[incr captureCount] \] \n</span>
		    <span class="s0">}</span>
		    <span class="s0">default {</span>
			<span class="s0">append re %O</span>
			<span class="s0">if { ! [string is alnum $c] } {</span>
			    <span class="s0">append re \\</span>
			    <span class="s0">}</span>
			<span class="s0">append re $c</span>
		    <span class="s0">}</span>
		<span class="s0">}</span>
		<span class="s0">set state {}</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Clean up any unfinished format groups</span>

    <span class="s0">append re $state \\s*\$</span>

    <span class="s0"># Build the procedure</span>

    <span class="s0">set procBody {}</span>
    <span class="s0">append procBody &quot;variable ::tcl::clock::TZData&quot; \n</span>
    <span class="s0">append procBody &quot;if \{ !\[ regexp -nocase [list $re] \$string -&gt;&quot;</span>
    <span class="s0">for { set i 1 } { $i &lt;= $captureCount } { incr i } {</span>
	<span class="s0">append procBody &quot; &quot; field $i</span>
    <span class="s0">}</span>
    <span class="s0">append procBody &quot;\] \} \{&quot; \n</span>
    <span class="s0">append procBody {</span>
	<span class="s0">return -code error -errorcode [list CLOCK badInputString] \</span>
	    <span class="s0">{input string does not match supplied format}</span>
    <span class="s0">}</span>
    <span class="s0">append procBody \}\n</span>
    <span class="s0">append procBody &quot;set date \[dict create\]&quot; \n</span>
    <span class="s0">append procBody {dict set date tzName $timeZone} \n</span>
    <span class="s0">append procBody $postcode</span>
    <span class="s0">append procBody [list set changeover [mc GREGORIAN_CHANGE_DATE]] \n</span>

    <span class="s0"># Set up the time zone before doing anything with a default base date</span>
    <span class="s0"># that might need a timezone to interpret it.</span>

    <span class="s0">if { ![dict exists $fieldSet seconds]</span>
	    <span class="s0">&amp;&amp; ![dict exists $fieldSet starDate] } {</span>
	<span class="s0">if { [dict exists $fieldSet tzName] } {</span>
	    <span class="s0">append procBody {</span>
		<span class="s0">set timeZone [dict get $date tzName]</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">append procBody {</span>
	    <span class="s0">::tcl::clock::SetupTimeZone $timeZone</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Add code that gets Julian Day Number from the fields.</span>

    <span class="s0">append procBody [MakeParseCodeFromFields $fieldSet $DateParseActions]</span>

    <span class="s0"># Get time of day</span>

    <span class="s0">append procBody [MakeParseCodeFromFields $fieldSet $TimeParseActions]</span>

    <span class="s0"># Assemble seconds from the Julian day and second of the day.</span>
    <span class="s0"># Convert to local time unless epoch seconds or stardate are</span>
    <span class="s0"># being processed - they're always absolute</span>

    <span class="s0">if { ![dict exists $fieldSet seconds]</span>
         <span class="s0">&amp;&amp; ![dict exists $fieldSet starDate] } {</span>
	<span class="s0">append procBody {</span>
	    <span class="s0">if { [dict get $date julianDay] &gt; 5373484 } {</span>
		<span class="s0">return -code error -errorcode [list CLOCK dateTooLarge] \</span>
		    <span class="s0">&quot;requested date too large to represent&quot;</span>
	    <span class="s0">}</span>
	    <span class="s0">dict set date localSeconds [expr {</span>
		<span class="s0">-210866803200</span>
		<span class="s0">+ ( 86400 * wide([dict get $date julianDay]) )</span>
		<span class="s0">+ [dict get $date secondOfDay]</span>
	    <span class="s0">}]</span>
	<span class="s0">}</span>

	<span class="s0"># Finally, convert the date to local time</span>

	<span class="s0">append procBody {</span>
	    <span class="s0">set date [::tcl::clock::ConvertLocalToUTC $date[set date {}] \</span>
			  <span class="s0">$TZData($timeZone) $changeover]</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Return result</span>

    <span class="s0">append procBody {return [dict get $date seconds]} \n</span>

    <span class="s0">proc $procName { string baseTime timeZone } $procBody</span>

    <span class="s0"># puts [list proc $procName [list string baseTime timeZone] $procBody]</span>

    <span class="s0">return $procName</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># LocaleNumeralMatcher --</span>
<span class="s0">#</span>
<span class="s0">#	Composes a regexp that captures the numerals in the given locale, and</span>
<span class="s0">#	a dictionary to map them to conventional numerals.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	locale - Name of the current locale</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns a two-element list comprising the regexp and the dictionary.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	Caches the result.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::LocaleNumeralMatcher {l} {</span>
    <span class="s0">variable LocaleNumeralCache</span>

    <span class="s0">if { ![dict exists $LocaleNumeralCache $l] } {</span>
	<span class="s0">set d {}</span>
	<span class="s0">set i 0</span>
	<span class="s0">set sep \(</span>
	<span class="s0">foreach n [mc LOCALE_NUMERALS] {</span>
	    <span class="s0">dict set d $n $i</span>
	    <span class="s0">regsub -all {[^[:alnum:]]} $n \\\\&amp; subex</span>
	    <span class="s0">append re $sep $subex</span>
	    <span class="s0">set sep |</span>
	    <span class="s0">incr i</span>
	<span class="s0">}</span>
	<span class="s0">append re \)</span>
	<span class="s0">dict set LocaleNumeralCache $l [list $re $d]</span>
    <span class="s0">}</span>
    <span class="s0">return [dict get $LocaleNumeralCache $l]</span>
<span class="s0">}</span>



<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># UniquePrefixRegexp --</span>
<span class="s0">#</span>
<span class="s0">#	Composes a regexp that performs unique-prefix matching.  The RE</span>
<span class="s0">#	matches one of a supplied set of strings, or any unique prefix</span>
<span class="s0">#	thereof.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	data - List of alternating match-strings and values.</span>
<span class="s0">#	       Match-strings with distinct values are considered</span>
<span class="s0">#	       distinct.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns a two-element list.  The first is a regexp that matches any</span>
<span class="s0">#	unique prefix of any of the strings.  The second is a dictionary whose</span>
<span class="s0">#	keys are match values from the regexp and whose values are the</span>
<span class="s0">#	corresponding values from 'data'.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::UniquePrefixRegexp { data } {</span>
    <span class="s0"># The 'successors' dictionary will contain, for each string that is a</span>
    <span class="s0"># prefix of any key, all characters that may follow that prefix.  The</span>
    <span class="s0"># 'prefixMapping' dictionary will have keys that are prefixes of keys and</span>
    <span class="s0"># values that correspond to the keys.</span>

    <span class="s0">set prefixMapping [dict create]</span>
    <span class="s0">set successors [dict create {} {}]</span>

    <span class="s0"># Walk the key-value pairs</span>

    <span class="s0">foreach { key value } $data {</span>
	<span class="s0"># Construct all prefixes of the key;</span>

	<span class="s0">set prefix {}</span>
	<span class="s0">foreach char [split $key {}] {</span>
	    <span class="s0">set oldPrefix $prefix</span>
	    <span class="s0">dict set successors $oldPrefix $char {}</span>
	    <span class="s0">append prefix $char</span>

	    <span class="s0"># Put the prefixes in the 'prefixMapping' and 'successors'</span>
	    <span class="s0"># dictionaries</span>

	    <span class="s0">dict lappend prefixMapping $prefix $value</span>
	    <span class="s0">if { ![dict exists $successors $prefix] } {</span>
		<span class="s0">dict set successors $prefix {}</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Identify those prefixes that designate unique values, and those that are</span>
    <span class="s0"># the full keys</span>

    <span class="s0">set uniquePrefixMapping {}</span>
    <span class="s0">dict for { key valueList } $prefixMapping {</span>
	<span class="s0">if { [llength $valueList] == 1 } {</span>
	    <span class="s0">dict set uniquePrefixMapping $key [lindex $valueList 0]</span>
	<span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">foreach { key value } $data {</span>
	<span class="s0">dict set uniquePrefixMapping $key $value</span>
    <span class="s0">}</span>

    <span class="s0"># Construct the re.</span>

    <span class="s0">return [list \</span>
		<span class="s0">[MakeUniquePrefixRegexp $successors $uniquePrefixMapping {}] \</span>
		<span class="s0">$uniquePrefixMapping]</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># MakeUniquePrefixRegexp --</span>
<span class="s0">#</span>
<span class="s0">#	Service procedure for 'UniquePrefixRegexp' that constructs a regular</span>
<span class="s0">#	expresison that matches the unique prefixes.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	successors - Dictionary whose keys are all prefixes</span>
<span class="s0">#		     of keys passed to 'UniquePrefixRegexp' and whose</span>
<span class="s0">#		     values are dictionaries whose keys are the characters</span>
<span class="s0">#		     that may follow those prefixes.</span>
<span class="s0">#	uniquePrefixMapping - Dictionary whose keys are the unique</span>
<span class="s0">#			      prefixes and whose values are not examined.</span>
<span class="s0">#	prefixString - Current prefix being processed.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns a constructed regular expression that matches the set of</span>
<span class="s0">#	unique prefixes beginning with the 'prefixString'.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::MakeUniquePrefixRegexp { successors</span>
					  <span class="s0">uniquePrefixMapping</span>
					  <span class="s0">prefixString } {</span>

    <span class="s0"># Get the characters that may follow the current prefix string</span>

    <span class="s0">set schars [lsort -ascii [dict keys [dict get $successors $prefixString]]]</span>
    <span class="s0">if { [llength $schars] == 0 } {</span>
	<span class="s0">return {}</span>
    <span class="s0">}</span>

    <span class="s0"># If there is more than one successor character, or if the current prefix</span>
    <span class="s0"># is a unique prefix, surround the generated re with non-capturing</span>
    <span class="s0"># parentheses.</span>

    <span class="s0">set re {}</span>
    <span class="s0">if {</span>
	<span class="s0">[dict exists $uniquePrefixMapping $prefixString]</span>
	<span class="s0">|| [llength $schars] &gt; 1</span>
    <span class="s0">} then {</span>
	<span class="s0">append re &quot;(?:&quot;</span>
    <span class="s0">}</span>

    <span class="s0"># Generate a regexp that matches the successors.</span>

    <span class="s0">set sep &quot;&quot;</span>
    <span class="s0">foreach { c } $schars {</span>
	<span class="s0">set nextPrefix $prefixString$c</span>
	<span class="s0">regsub -all {[^[:alnum:]]} $c \\\\&amp; rechar</span>
	<span class="s0">append re $sep $rechar \</span>
	    <span class="s0">[MakeUniquePrefixRegexp \</span>
		 <span class="s0">$successors $uniquePrefixMapping $nextPrefix]</span>
	<span class="s0">set sep |</span>
    <span class="s0">}</span>

    <span class="s0"># If the current prefix is a unique prefix, make all following text</span>
    <span class="s0"># optional. Otherwise, if there is more than one successor character,</span>
    <span class="s0"># close the non-capturing parentheses.</span>

    <span class="s0">if { [dict exists $uniquePrefixMapping $prefixString] } {</span>
	<span class="s0">append re &quot;)?&quot;</span>
    <span class="s0">} elseif { [llength $schars] &gt; 1 } {</span>
	<span class="s0">append re &quot;)&quot;</span>
    <span class="s0">}</span>

    <span class="s0">return $re</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># MakeParseCodeFromFields --</span>
<span class="s0">#</span>
<span class="s0">#	Composes Tcl code to extract the Julian Day Number from a dictionary</span>
<span class="s0">#	containing date fields.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	dateFields -- Dictionary whose keys are fields of the date,</span>
<span class="s0">#	              and whose values are the rightmost positions</span>
<span class="s0">#		      at which those fields appear.</span>
<span class="s0">#	parseActions -- List of triples: field set, priority, and</span>
<span class="s0">#			code to emit.  Smaller priorities are better, and</span>
<span class="s0">#			the list must be in ascending order by priority</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns a burst of code that extracts the day number from the given</span>
<span class="s0">#	date.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::MakeParseCodeFromFields { dateFields parseActions } {</span>

    <span class="s0">set currPrio 999</span>
    <span class="s0">set currFieldPos [list]</span>
    <span class="s0">set currCodeBurst {</span>
	<span class="s0">error &quot;in ::tcl::clock::MakeParseCodeFromFields: can't happen&quot;</span>
    <span class="s0">}</span>

    <span class="s0">foreach { fieldSet prio parseAction } $parseActions {</span>
	<span class="s0"># If we've found an answer that's better than any that follow, quit</span>
	<span class="s0"># now.</span>

	<span class="s0">if { $prio &gt; $currPrio } {</span>
	    <span class="s0">break</span>
	<span class="s0">}</span>

	<span class="s0"># Accumulate the field positions that are used in the current field</span>
	<span class="s0"># grouping.</span>

	<span class="s0">set fieldPos [list]</span>
	<span class="s0">set ok true</span>
	<span class="s0">foreach field $fieldSet {</span>
	    <span class="s0">if { ! [dict exists $dateFields $field] } {</span>
		<span class="s0">set ok 0</span>
		<span class="s0">break</span>
	    <span class="s0">}</span>
	    <span class="s0">lappend fieldPos [dict get $dateFields $field]</span>
	<span class="s0">}</span>

	<span class="s0"># Quit if we don't have a complete set of fields</span>
	<span class="s0">if { !$ok } {</span>
	    <span class="s0">continue</span>
	<span class="s0">}</span>

	<span class="s0"># Determine whether the current answer is better than the last.</span>

	<span class="s0">set fPos [lsort -integer -decreasing $fieldPos]</span>

	<span class="s0">if { $prio ==  $currPrio } {</span>
	    <span class="s0">foreach currPos $currFieldPos newPos $fPos {</span>
		<span class="s0">if {</span>
		    <span class="s0">![string is integer $newPos]</span>
		    <span class="s0">|| ![string is integer $currPos]</span>
		    <span class="s0">|| $newPos &gt; $currPos</span>
		<span class="s0">} then {</span>
		    <span class="s0">break</span>
		<span class="s0">}</span>
		<span class="s0">if { $newPos &lt; $currPos } {</span>
		    <span class="s0">set ok 0</span>
		    <span class="s0">break</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">if { !$ok } {</span>
	    <span class="s0">continue</span>
	<span class="s0">}</span>

	<span class="s0"># Remember the best possibility for extracting date information</span>

	<span class="s0">set currPrio $prio</span>
	<span class="s0">set currFieldPos $fPos</span>
	<span class="s0">set currCodeBurst $parseAction</span>
    <span class="s0">}</span>

    <span class="s0">return $currCodeBurst</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># EnterLocale --</span>
<span class="s0">#</span>
<span class="s0">#	Switch [mclocale] to a given locale if necessary</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	locale -- Desired locale</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the locale that was previously current.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	Does [mclocale].  If necessary, loades the designated locale's files.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::EnterLocale { locale } {</span>
    <span class="s0">if { $locale eq {system} } {</span>
	<span class="s0">if { $::tcl_platform(platform) ne {windows} } {</span>
	    <span class="s0"># On a non-windows platform, the 'system' locale is the same as</span>
	    <span class="s0"># the 'current' locale</span>

	    <span class="s0">set locale current</span>
	<span class="s0">} else {</span>
	    <span class="s0"># On a windows platform, the 'system' locale is adapted from the</span>
	    <span class="s0"># 'current' locale by applying the date and time formats from the</span>
	    <span class="s0"># Control Panel.  First, load the 'current' locale if it's not yet</span>
	    <span class="s0"># loaded</span>

	    <span class="s0">mcpackagelocale set [mclocale]</span>

	    <span class="s0"># Make a new locale string for the system locale, and get the</span>
	    <span class="s0"># Control Panel information</span>

	    <span class="s0">set locale [mclocale]_windows</span>
	    <span class="s0">if { ! [mcpackagelocale present $locale] } {</span>
		<span class="s0">LoadWindowsDateTimeFormats $locale</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">if { $locale eq {current}} {</span>
	<span class="s0">set locale [mclocale]</span>
    <span class="s0">}</span>
    <span class="s0"># Eventually load the locale</span>
    <span class="s0">mcpackagelocale set $locale</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># LoadWindowsDateTimeFormats --</span>
<span class="s0">#</span>
<span class="s0">#	Load the date/time formats from the Control Panel in Windows and</span>
<span class="s0">#	convert them so that they're usable by Tcl.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	locale - Name of the locale in whose message catalog</span>
<span class="s0">#	         the converted formats are to be stored.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	Updates the given message catalog with the locale strings.</span>
<span class="s0">#</span>
<span class="s0"># Presumes that on entry, [mclocale] is set to the current locale, so that</span>
<span class="s0"># default strings can be obtained if the Registry query fails.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::LoadWindowsDateTimeFormats { locale } {</span>
    <span class="s0"># Bail out if we can't find the Registry</span>

    <span class="s0">variable NoRegistry</span>
    <span class="s0">if { [info exists NoRegistry] } return</span>

    <span class="s0">if { ![catch {</span>
	<span class="s0">registry get &quot;HKEY_CURRENT_USER\\Control Panel\\International&quot; \</span>
	    <span class="s0">sShortDate</span>
    <span class="s0">} string] } {</span>
	<span class="s0">set quote {}</span>
	<span class="s0">set datefmt {}</span>
	<span class="s0">foreach { unquoted quoted } [split $string '] {</span>
	    <span class="s0">append datefmt $quote [string map {</span>
		<span class="s0">dddd %A</span>
		<span class="s0">ddd  %a</span>
		<span class="s0">dd   %d</span>
		<span class="s0">d    %e</span>
		<span class="s0">MMMM %B</span>
		<span class="s0">MMM  %b</span>
		<span class="s0">MM   %m</span>
		<span class="s0">M    %N</span>
		<span class="s0">yyyy %Y</span>
		<span class="s0">yy   %y</span>
                <span class="s0">y    %y</span>
                <span class="s0">gg   {}</span>
	    <span class="s0">} $unquoted]</span>
	    <span class="s0">if { $quoted eq {} } {</span>
		<span class="s0">set quote '</span>
	    <span class="s0">} else {</span>
		<span class="s0">set quote $quoted</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">::msgcat::mcset $locale DATE_FORMAT $datefmt</span>
    <span class="s0">}</span>

    <span class="s0">if { ![catch {</span>
	<span class="s0">registry get &quot;HKEY_CURRENT_USER\\Control Panel\\International&quot; \</span>
	    <span class="s0">sLongDate</span>
    <span class="s0">} string] } {</span>
	<span class="s0">set quote {}</span>
	<span class="s0">set ldatefmt {}</span>
	<span class="s0">foreach { unquoted quoted } [split $string '] {</span>
	    <span class="s0">append ldatefmt $quote [string map {</span>
		<span class="s0">dddd %A</span>
		<span class="s0">ddd  %a</span>
		<span class="s0">dd   %d</span>
		<span class="s0">d    %e</span>
		<span class="s0">MMMM %B</span>
		<span class="s0">MMM  %b</span>
		<span class="s0">MM   %m</span>
		<span class="s0">M    %N</span>
		<span class="s0">yyyy %Y</span>
		<span class="s0">yy   %y</span>
                <span class="s0">y    %y</span>
                <span class="s0">gg   {}</span>
	    <span class="s0">} $unquoted]</span>
	    <span class="s0">if { $quoted eq {} } {</span>
		<span class="s0">set quote '</span>
	    <span class="s0">} else {</span>
		<span class="s0">set quote $quoted</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">::msgcat::mcset $locale LOCALE_DATE_FORMAT $ldatefmt</span>
    <span class="s0">}</span>

    <span class="s0">if { ![catch {</span>
	<span class="s0">registry get &quot;HKEY_CURRENT_USER\\Control Panel\\International&quot; \</span>
	    <span class="s0">sTimeFormat</span>
    <span class="s0">} string] } {</span>
	<span class="s0">set quote {}</span>
	<span class="s0">set timefmt {}</span>
	<span class="s0">foreach { unquoted quoted } [split $string '] {</span>
	    <span class="s0">append timefmt $quote [string map {</span>
		<span class="s0">HH    %H</span>
		<span class="s0">H     %k</span>
		<span class="s0">hh    %I</span>
		<span class="s0">h     %l</span>
		<span class="s0">mm    %M</span>
		<span class="s0">m     %M</span>
		<span class="s0">ss    %S</span>
		<span class="s0">s     %S</span>
		<span class="s0">tt    %p</span>
		<span class="s0">t     %p</span>
	    <span class="s0">} $unquoted]</span>
	    <span class="s0">if { $quoted eq {} } {</span>
		<span class="s0">set quote '</span>
	    <span class="s0">} else {</span>
		<span class="s0">set quote $quoted</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">::msgcat::mcset $locale TIME_FORMAT $timefmt</span>
    <span class="s0">}</span>

    <span class="s0">catch {</span>
	<span class="s0">::msgcat::mcset $locale DATE_TIME_FORMAT &quot;$datefmt $timefmt&quot;</span>
    <span class="s0">}</span>
    <span class="s0">catch {</span>
	<span class="s0">::msgcat::mcset $locale LOCALE_DATE_TIME_FORMAT &quot;$ldatefmt $timefmt&quot;</span>
    <span class="s0">}</span>

    <span class="s0">return</span>

<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># LocalizeFormat --</span>
<span class="s0">#</span>
<span class="s0">#	Map away locale-dependent format groups in a clock format.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	locale -- Current [mclocale] locale, supplied to avoid</span>
<span class="s0">#		  an extra call</span>
<span class="s0">#	format -- Format supplied to [clock scan] or [clock format]</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the string with locale-dependent composite format groups</span>
<span class="s0">#	substituted out.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::LocalizeFormat { locale format } {</span>

    <span class="s0"># message catalog key to cache this format</span>
    <span class="s0">set key FORMAT_$format</span>

    <span class="s0">if { [::msgcat::mcexists -exactlocale -exactnamespace $key] } {</span>
	<span class="s0">return [mc $key]</span>
    <span class="s0">}</span>
    <span class="s0"># Handle locale-dependent format groups by mapping them out of the format</span>
    <span class="s0"># string.  Note that the order of the [string map] operations is</span>
    <span class="s0"># significant because later formats can refer to later ones; for example</span>
    <span class="s0"># %c can refer to %X, which in turn can refer to %T.</span>

    <span class="s0">set list {</span>
	<span class="s0">%% %%</span>
	<span class="s0">%D %m/%d/%Y</span>
	<span class="s0">%+ {%a %b %e %H:%M:%S %Z %Y}</span>
    <span class="s0">}</span>
    <span class="s0">lappend list %EY [string map $list [mc LOCALE_YEAR_FORMAT]]</span>
    <span class="s0">lappend list %T  [string map $list [mc TIME_FORMAT_24_SECS]]</span>
    <span class="s0">lappend list %R  [string map $list [mc TIME_FORMAT_24]]</span>
    <span class="s0">lappend list %r  [string map $list [mc TIME_FORMAT_12]]</span>
    <span class="s0">lappend list %X  [string map $list [mc TIME_FORMAT]]</span>
    <span class="s0">lappend list %EX [string map $list [mc LOCALE_TIME_FORMAT]]</span>
    <span class="s0">lappend list %x  [string map $list [mc DATE_FORMAT]]</span>
    <span class="s0">lappend list %Ex [string map $list [mc LOCALE_DATE_FORMAT]]</span>
    <span class="s0">lappend list %c  [string map $list [mc DATE_TIME_FORMAT]]</span>
    <span class="s0">lappend list %Ec [string map $list [mc LOCALE_DATE_TIME_FORMAT]]</span>
    <span class="s0">set format [string map $list $format]</span>

    <span class="s0">::msgcat::mcset $locale $key $format</span>
    <span class="s0">return $format</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># FormatNumericTimeZone --</span>
<span class="s0">#</span>
<span class="s0">#	Formats a time zone as +hhmmss</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	z - Time zone in seconds east of Greenwich</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the time zone formatted in a numeric form</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::FormatNumericTimeZone { z } {</span>
    <span class="s0">if { $z &lt; 0 } {</span>
	<span class="s0">set z [expr { - $z }]</span>
	<span class="s0">set retval -</span>
    <span class="s0">} else {</span>
	<span class="s0">set retval +</span>
    <span class="s0">}</span>
    <span class="s0">append retval [::format %02d [expr { $z / 3600 }]]</span>
    <span class="s0">set z [expr { $z % 3600 }]</span>
    <span class="s0">append retval [::format %02d [expr { $z / 60 }]]</span>
    <span class="s0">set z [expr { $z % 60 }]</span>
    <span class="s0">if { $z != 0 } {</span>
	<span class="s0">append retval [::format %02d $z]</span>
    <span class="s0">}</span>
    <span class="s0">return $retval</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># FormatStarDate --</span>
<span class="s0">#</span>
<span class="s0">#	Formats a date as a StarDate.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date - Dictionary containing 'year', 'dayOfYear', and</span>
<span class="s0">#	       'localSeconds' fields.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the given date formatted as a StarDate.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># Jeff Hobbs put this in to support an atrocious pun about Tcl being</span>
<span class="s0"># &quot;Enterprise ready.&quot;  Now we're stuck with it.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::FormatStarDate { date } {</span>
    <span class="s0">variable Roddenberry</span>

    <span class="s0"># Get day of year, zero based</span>

    <span class="s0">set doy [expr { [dict get $date dayOfYear] - 1 }]</span>

    <span class="s0"># Determine whether the year is a leap year</span>

    <span class="s0">set lp [IsGregorianLeapYear $date]</span>

    <span class="s0"># Convert day of year to a fractional year</span>

    <span class="s0">if { $lp } {</span>
	<span class="s0">set fractYear [expr { 1000 * $doy / 366 }]</span>
    <span class="s0">} else {</span>
	<span class="s0">set fractYear [expr { 1000 * $doy / 365 }]</span>
    <span class="s0">}</span>

    <span class="s0"># Put together the StarDate</span>

    <span class="s0">return [::format &quot;Stardate %02d%03d.%1d&quot; \</span>
		<span class="s0">[expr { [dict get $date year] - $Roddenberry }] \</span>
		<span class="s0">$fractYear \</span>
		<span class="s0">[expr { [dict get $date localSeconds] % 86400</span>
			<span class="s0">/ ( 86400 / 10 ) }]]</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># ParseStarDate --</span>
<span class="s0">#</span>
<span class="s0">#	Parses a StarDate</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	year - Year from the Roddenberry epoch</span>
<span class="s0">#	fractYear - Fraction of a year specifiying the day of year.</span>
<span class="s0">#	fractDay - Fraction of a day</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns a count of seconds from the Posix epoch.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># Jeff Hobbs put this in to support an atrocious pun about Tcl being</span>
<span class="s0"># &quot;Enterprise ready.&quot;  Now we're stuck with it.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::ParseStarDate { year fractYear fractDay } {</span>
    <span class="s0">variable Roddenberry</span>

    <span class="s0"># Build a tentative date from year and fraction.</span>

    <span class="s0">set date [dict create \</span>
		  <span class="s0">gregorian 1 \</span>
		  <span class="s0">era CE \</span>
		  <span class="s0">year [expr { $year + $Roddenberry }] \</span>
		  <span class="s0">dayOfYear [expr { $fractYear * 365 / 1000 + 1 }]]</span>
    <span class="s0">set date [GetJulianDayFromGregorianEraYearDay $date[set date {}]]</span>

    <span class="s0"># Determine whether the given year is a leap year</span>

    <span class="s0">set lp [IsGregorianLeapYear $date]</span>

    <span class="s0"># Reconvert the fractional year according to whether the given year is a</span>
    <span class="s0"># leap year</span>

    <span class="s0">if { $lp } {</span>
	<span class="s0">dict set date dayOfYear \</span>
	    <span class="s0">[expr { $fractYear * 366 / 1000 + 1 }]</span>
    <span class="s0">} else {</span>
	<span class="s0">dict set date dayOfYear \</span>
	    <span class="s0">[expr { $fractYear * 365 / 1000 + 1 }]</span>
    <span class="s0">}</span>
    <span class="s0">dict unset date julianDay</span>
    <span class="s0">dict unset date gregorian</span>
    <span class="s0">set date [GetJulianDayFromGregorianEraYearDay $date[set date {}]]</span>

    <span class="s0">return [expr {</span>
	<span class="s0">86400 * [dict get $date julianDay]</span>
	<span class="s0">- 210866803200</span>
	<span class="s0">+ ( 86400 / 10 ) * $fractDay</span>
    <span class="s0">}]</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># ScanWide --</span>
<span class="s0">#</span>
<span class="s0">#	Scans a wide integer from an input</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	str - String containing a decimal wide integer</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the string as a pure wide integer.  Throws an error if the</span>
<span class="s0">#	string is misformatted or out of range.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::ScanWide { str } {</span>
    <span class="s0">set count [::scan $str {%ld %c} result junk]</span>
    <span class="s0">if { $count != 1 } {</span>
	<span class="s0">return -code error -errorcode [list CLOCK notAnInteger $str] \</span>
	    <span class="s0">&quot;\&quot;$str\&quot; is not an integer&quot;</span>
    <span class="s0">}</span>
    <span class="s0">if { [incr result 0] != $str } {</span>
	<span class="s0">return -code error -errorcode [list CLOCK integervalueTooLarge] \</span>
	    <span class="s0">&quot;integer value too large to represent&quot;</span>
    <span class="s0">}</span>
    <span class="s0">return $result</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># InterpretTwoDigitYear --</span>
<span class="s0">#</span>
<span class="s0">#	Given a date that contains only the year of the century, determines</span>
<span class="s0">#	the target value of a two-digit year.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date - Dictionary containing fields of the date.</span>
<span class="s0">#	baseTime - Base time relative to which the date is expressed.</span>
<span class="s0">#	twoDigitField - Name of the field that stores the two-digit year.</span>
<span class="s0">#			Default is 'yearOfCentury'</span>
<span class="s0">#	fourDigitField - Name of the field that will receive the four-digit</span>
<span class="s0">#	                 year.  Default is 'year'</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the dictionary augmented with the four-digit year, stored in</span>
<span class="s0">#	the given key.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># The current rule for interpreting a two-digit year is that the year shall be</span>
<span class="s0"># between 1937 and 2037, thus staying within the range of a 32-bit signed</span>
<span class="s0"># value for time.  This rule may change to a sliding window in future</span>
<span class="s0"># versions, so the 'baseTime' parameter (which is currently ignored) is</span>
<span class="s0"># provided in the procedure signature.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::InterpretTwoDigitYear { date baseTime</span>
					   <span class="s0">{ twoDigitField yearOfCentury }</span>
					   <span class="s0">{ fourDigitField year } } {</span>
    <span class="s0">set yr [dict get $date $twoDigitField]</span>
    <span class="s0">if { $yr &lt;= 37 } {</span>
	<span class="s0">dict set date $fourDigitField [expr { $yr + 2000 }]</span>
    <span class="s0">} else {</span>
	<span class="s0">dict set date $fourDigitField [expr { $yr + 1900 }]</span>
    <span class="s0">}</span>
    <span class="s0">return $date</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># AssignBaseYear --</span>
<span class="s0">#</span>
<span class="s0">#	Places the number of the current year into a dictionary.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date - Dictionary value to update</span>
<span class="s0">#	baseTime - Base time from which to extract the year, expressed</span>
<span class="s0">#		   in seconds from the Posix epoch</span>
<span class="s0">#	timezone - the time zone in which the date is being scanned</span>
<span class="s0">#	changeover - the Julian Day on which the Gregorian calendar</span>
<span class="s0">#		     was adopted in the target locale.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the dictionary with the current year assigned.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::AssignBaseYear { date baseTime timezone changeover } {</span>
    <span class="s0">variable TZData</span>

    <span class="s0"># Find the Julian Day Number corresponding to the base time, and</span>
    <span class="s0"># find the Gregorian year corresponding to that Julian Day.</span>

    <span class="s0">set date2 [GetDateFields $baseTime $TZData($timezone) $changeover]</span>

    <span class="s0"># Store the converted year</span>

    <span class="s0">dict set date era [dict get $date2 era]</span>
    <span class="s0">dict set date year [dict get $date2 year]</span>

    <span class="s0">return $date</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># AssignBaseIso8601Year --</span>
<span class="s0">#</span>
<span class="s0">#	Determines the base year in the ISO8601 fiscal calendar.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date - Dictionary containing the fields of the date that</span>
<span class="s0">#	       is to be augmented with the base year.</span>
<span class="s0">#	baseTime - Base time expressed in seconds from the Posix epoch.</span>
<span class="s0">#	timeZone - Target time zone</span>
<span class="s0">#	changeover - Julian Day of adoption of the Gregorian calendar in</span>
<span class="s0">#		     the target locale.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the given date with &quot;iso8601Year&quot; set to the</span>
<span class="s0">#	base year.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::AssignBaseIso8601Year {date baseTime timeZone changeover} {</span>
    <span class="s0">variable TZData</span>

    <span class="s0"># Find the Julian Day Number corresponding to the base time</span>

    <span class="s0">set date2 [GetDateFields $baseTime $TZData($timeZone) $changeover]</span>

    <span class="s0"># Calculate the ISO8601 date and transfer the year</span>

    <span class="s0">dict set date era CE</span>
    <span class="s0">dict set date iso8601Year [dict get $date2 iso8601Year]</span>
    <span class="s0">return $date</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># AssignBaseMonth --</span>
<span class="s0">#</span>
<span class="s0">#	Places the number of the current year and month into a</span>
<span class="s0">#	dictionary.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date - Dictionary value to update</span>
<span class="s0">#	baseTime - Time from which the year and month are to be</span>
<span class="s0">#	           obtained, expressed in seconds from the Posix epoch.</span>
<span class="s0">#	timezone - Name of the desired time zone</span>
<span class="s0">#	changeover - Julian Day on which the Gregorian calendar was adopted.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the dictionary with the base year and month assigned.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::AssignBaseMonth {date baseTime timezone changeover} {</span>
    <span class="s0">variable TZData</span>

    <span class="s0"># Find the year and month corresponding to the base time</span>

    <span class="s0">set date2 [GetDateFields $baseTime $TZData($timezone) $changeover]</span>
    <span class="s0">dict set date era [dict get $date2 era]</span>
    <span class="s0">dict set date year [dict get $date2 year]</span>
    <span class="s0">dict set date month [dict get $date2 month]</span>
    <span class="s0">return $date</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># AssignBaseWeek --</span>
<span class="s0">#</span>
<span class="s0">#	Determines the base year and week in the ISO8601 fiscal calendar.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date - Dictionary containing the fields of the date that</span>
<span class="s0">#	       is to be augmented with the base year and week.</span>
<span class="s0">#	baseTime - Base time expressed in seconds from the Posix epoch.</span>
<span class="s0">#	changeover - Julian Day on which the Gregorian calendar was adopted</span>
<span class="s0">#		     in the target locale.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the given date with &quot;iso8601Year&quot; set to the</span>
<span class="s0">#	base year and &quot;iso8601Week&quot; to the week number.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::AssignBaseWeek {date baseTime timeZone changeover} {</span>
    <span class="s0">variable TZData</span>

    <span class="s0"># Find the Julian Day Number corresponding to the base time</span>

    <span class="s0">set date2 [GetDateFields $baseTime $TZData($timeZone) $changeover]</span>

    <span class="s0"># Calculate the ISO8601 date and transfer the year</span>

    <span class="s0">dict set date era CE</span>
    <span class="s0">dict set date iso8601Year [dict get $date2 iso8601Year]</span>
    <span class="s0">dict set date iso8601Week [dict get $date2 iso8601Week]</span>
    <span class="s0">return $date</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># AssignBaseJulianDay --</span>
<span class="s0">#</span>
<span class="s0">#	Determines the base day for a time-of-day conversion.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date - Dictionary that is to get the base day</span>
<span class="s0">#	baseTime - Base time expressed in seconds from the Posix epoch</span>
<span class="s0">#	changeover - Julian day on which the Gregorian calendar was</span>
<span class="s0">#		     adpoted in the target locale.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the given dictionary augmented with a 'julianDay' field</span>
<span class="s0">#	that contains the base day.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::AssignBaseJulianDay { date baseTime timeZone changeover } {</span>
    <span class="s0">variable TZData</span>

    <span class="s0"># Find the Julian Day Number corresponding to the base time</span>

    <span class="s0">set date2 [GetDateFields $baseTime $TZData($timeZone) $changeover]</span>
    <span class="s0">dict set date julianDay [dict get $date2 julianDay]</span>

    <span class="s0">return $date</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># InterpretHMSP --</span>
<span class="s0">#</span>
<span class="s0">#	Interprets a time in the form &quot;hh:mm:ss am&quot;.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date -- Dictionary containing &quot;hourAMPM&quot;, &quot;minute&quot;, &quot;second&quot;</span>
<span class="s0">#	        and &quot;amPmIndicator&quot; fields.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the number of seconds from local midnight.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::InterpretHMSP { date } {</span>
    <span class="s0">set hr [dict get $date hourAMPM]</span>
    <span class="s0">if { $hr == 12 } {</span>
	<span class="s0">set hr 0</span>
    <span class="s0">}</span>
    <span class="s0">if { [dict get $date amPmIndicator] } {</span>
	<span class="s0">incr hr 12</span>
    <span class="s0">}</span>
    <span class="s0">dict set date hour $hr</span>
    <span class="s0">return [InterpretHMS $date[set date {}]]</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># InterpretHMS --</span>
<span class="s0">#</span>
<span class="s0">#	Interprets a 24-hour time &quot;hh:mm:ss&quot;</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date -- Dictionary containing the &quot;hour&quot;, &quot;minute&quot; and &quot;second&quot;</span>
<span class="s0">#	        fields.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the given dictionary augmented with a &quot;secondOfDay&quot;</span>
<span class="s0">#	field containing the number of seconds from local midnight.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::InterpretHMS { date } {</span>
    <span class="s0">return [expr {</span>
	<span class="s0">( [dict get $date hour] * 60</span>
	  <span class="s0">+ [dict get $date minute] ) * 60</span>
	<span class="s0">+ [dict get $date second]</span>
    <span class="s0">}]</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># GetSystemTimeZone --</span>
<span class="s0">#</span>
<span class="s0">#	Determines the system time zone, which is the default for the</span>
<span class="s0">#	'clock' command if no other zone is supplied.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the system time zone.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	Stores the sustem time zone in the 'CachedSystemTimeZone'</span>
<span class="s0">#	variable, since determining it may be an expensive process.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::GetSystemTimeZone {} {</span>
    <span class="s0">variable CachedSystemTimeZone</span>
    <span class="s0">variable TimeZoneBad</span>

    <span class="s0">if {[set result [getenv TCL_TZ]] ne {}} {</span>
	<span class="s0">set timezone $result</span>
    <span class="s0">} elseif {[set result [getenv TZ]] ne {}} {</span>
	<span class="s0">set timezone $result</span>
    <span class="s0">}</span>
    <span class="s0">if {![info exists timezone]} {</span>
        <span class="s0"># Cache the time zone only if it was detected by one of the</span>
        <span class="s0"># expensive methods.</span>
        <span class="s0">if { [info exists CachedSystemTimeZone] } {</span>
            <span class="s0">set timezone $CachedSystemTimeZone</span>
        <span class="s0">} elseif { $::tcl_platform(platform) eq {windows} } {</span>
            <span class="s0">set timezone [GuessWindowsTimeZone]</span>
        <span class="s0">} elseif { [file exists /etc/localtime]</span>
                   <span class="s0">&amp;&amp; ![catch {ReadZoneinfoFile \</span>
                                   <span class="s0">Tcl/Localtime /etc/localtime}] } {</span>
            <span class="s0">set timezone :Tcl/Localtime</span>
        <span class="s0">} else {</span>
            <span class="s0">set timezone :localtime</span>
        <span class="s0">}</span>
	<span class="s0">set CachedSystemTimeZone $timezone</span>
    <span class="s0">}</span>
    <span class="s0">if { ![dict exists $TimeZoneBad $timezone] } {</span>
	<span class="s0">dict set TimeZoneBad $timezone [catch {SetupTimeZone $timezone}]</span>
    <span class="s0">}</span>
    <span class="s0">if { [dict get $TimeZoneBad $timezone] } {</span>
	<span class="s0">return :localtime</span>
    <span class="s0">} else {</span>
	<span class="s0">return $timezone</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># ConvertLegacyTimeZone --</span>
<span class="s0">#</span>
<span class="s0">#	Given an alphanumeric time zone identifier and the system time zone,</span>
<span class="s0">#	convert the alphanumeric identifier to an unambiguous time zone.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	tzname - Name of the time zone to convert</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns a time zone name corresponding to tzname, but in an</span>
<span class="s0">#	unambiguous form, generally +hhmm.</span>
<span class="s0">#</span>
<span class="s0"># This procedure is implemented primarily to allow the parsing of RFC822</span>
<span class="s0"># date/time strings.  Processing a time zone name on input is not recommended</span>
<span class="s0"># practice, because there is considerable room for ambiguity; for instance, is</span>
<span class="s0"># BST Brazilian Standard Time, or British Summer Time?</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::ConvertLegacyTimeZone { tzname } {</span>
    <span class="s0">variable LegacyTimeZone</span>

    <span class="s0">set tzname [string tolower $tzname]</span>
    <span class="s0">if { ![dict exists $LegacyTimeZone $tzname] } {</span>
	<span class="s0">return -code error -errorcode [list CLOCK badTZName $tzname] \</span>
	    <span class="s0">&quot;time zone \&quot;$tzname\&quot; not found&quot;</span>
    <span class="s0">}</span>
    <span class="s0">return [dict get $LegacyTimeZone $tzname]</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># SetupTimeZone --</span>
<span class="s0">#</span>
<span class="s0">#	Given the name or specification of a time zone, sets up its in-memory</span>
<span class="s0">#	data.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	tzname - Name of a time zone</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Unless the time zone is ':localtime', sets the TZData array to contain</span>
<span class="s0">#	the lookup table for local&lt;-&gt;UTC conversion.  Returns an error if the</span>
<span class="s0">#	time zone cannot be parsed.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::SetupTimeZone { timezone } {</span>
    <span class="s0">variable TZData</span>

    <span class="s0">if {! [info exists TZData($timezone)] } {</span>
	<span class="s0">variable MINWIDE</span>
	<span class="s0">if { $timezone eq {:localtime} } {</span>
	    <span class="s0"># Nothing to do, we'll convert using the localtime function</span>

	<span class="s0">} elseif {</span>
	    <span class="s0">[regexp {^([-+])(\d\d)(?::?(\d\d)(?::?(\d\d))?)?} $timezone \</span>
		    <span class="s0">-&gt; s hh mm ss]</span>
	<span class="s0">} then {</span>
	    <span class="s0"># Make a fixed offset</span>

	    <span class="s0">::scan $hh %d hh</span>
	    <span class="s0">if { $mm eq {} } {</span>
		<span class="s0">set mm 0</span>
	    <span class="s0">} else {</span>
		<span class="s0">::scan $mm %d mm</span>
	    <span class="s0">}</span>
	    <span class="s0">if { $ss eq {} } {</span>
		<span class="s0">set ss 0</span>
	    <span class="s0">} else {</span>
		<span class="s0">::scan $ss %d ss</span>
	    <span class="s0">}</span>
	    <span class="s0">set offset [expr { ( $hh * 60 + $mm ) * 60 + $ss }]</span>
	    <span class="s0">if { $s eq {-} } {</span>
		<span class="s0">set offset [expr { - $offset }]</span>
	    <span class="s0">}</span>
	    <span class="s0">set TZData($timezone) [list [list $MINWIDE $offset -1 $timezone]]</span>

	<span class="s0">} elseif { [string index $timezone 0] eq {:} } {</span>
	    <span class="s0"># Convert using a time zone file</span>

	    <span class="s0">if {</span>
		<span class="s0">[catch {</span>
		    <span class="s0">LoadTimeZoneFile [string range $timezone 1 end]</span>
		<span class="s0">}] &amp;&amp; [catch {</span>
		    <span class="s0">LoadZoneinfoFile [string range $timezone 1 end]</span>
		<span class="s0">}]</span>
	    <span class="s0">} then {</span>
		<span class="s0">return -code error \</span>
		    <span class="s0">-errorcode [list CLOCK badTimeZone $timezone] \</span>
		    <span class="s0">&quot;time zone \&quot;$timezone\&quot; not found&quot;</span>
	    <span class="s0">}</span>
	<span class="s0">} elseif { ![catch {ParsePosixTimeZone $timezone} tzfields] } {</span>
	    <span class="s0"># This looks like a POSIX time zone - try to process it</span>

	    <span class="s0">if { [catch {ProcessPosixTimeZone $tzfields} data opts] } {</span>
		<span class="s0">if { [lindex [dict get $opts -errorcode] 0] eq {CLOCK} } {</span>
		    <span class="s0">dict unset opts -errorinfo</span>
		<span class="s0">}</span>
		<span class="s0">return -options $opts $data</span>
	    <span class="s0">} else {</span>
		<span class="s0">set TZData($timezone) $data</span>
	    <span class="s0">}</span>

	<span class="s0">} else {</span>
	    <span class="s0"># We couldn't parse this as a POSIX time zone.  Try again with a</span>
	    <span class="s0"># time zone file - this time without a colon</span>

	    <span class="s0">if { [catch { LoadTimeZoneFile $timezone }]</span>
		 <span class="s0">&amp;&amp; [catch { LoadZoneinfoFile $timezone } - opts] } {</span>
		<span class="s0">dict unset opts -errorinfo</span>
		<span class="s0">return -options $opts &quot;time zone $timezone not found&quot;</span>
	    <span class="s0">}</span>
	    <span class="s0">set TZData($timezone) $TZData(:$timezone)</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">return</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># GuessWindowsTimeZone --</span>
<span class="s0">#</span>
<span class="s0">#	Determines the system time zone on windows.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns a time zone specifier that corresponds to the system time zone</span>
<span class="s0">#	information found in the Registry.</span>
<span class="s0">#</span>
<span class="s0"># Bugs:</span>
<span class="s0">#	Fixed dates for DST change are unimplemented at present, because no</span>
<span class="s0">#	time zone information supplied with Windows actually uses them!</span>
<span class="s0">#</span>
<span class="s0"># On a Windows system where neither $env(TCL_TZ) nor $env(TZ) is specified,</span>
<span class="s0"># GuessWindowsTimeZone looks in the Registry for the system time zone</span>
<span class="s0"># information.  It then attempts to find an entry in WinZoneInfo for a time</span>
<span class="s0"># zone that uses the same rules.  If it finds one, it returns it; otherwise,</span>
<span class="s0"># it constructs a Posix-style time zone string and returns that.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::GuessWindowsTimeZone {} {</span>
    <span class="s0">variable WinZoneInfo</span>
    <span class="s0">variable NoRegistry</span>
    <span class="s0">variable TimeZoneBad</span>

    <span class="s0">if { [info exists NoRegistry] } {</span>
	<span class="s0">return :localtime</span>
    <span class="s0">}</span>

    <span class="s0"># Dredge time zone information out of the registry</span>

    <span class="s0">if { [catch {</span>
	<span class="s0">set rpath HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation</span>
	<span class="s0">set data [list \</span>
		      <span class="s0">[expr { -60</span>
			      <span class="s0">* [registry get $rpath Bias] }] \</span>
		      <span class="s0">[expr { -60</span>
				  <span class="s0">* [registry get $rpath StandardBias] }] \</span>
		      <span class="s0">[expr { -60 \</span>
				  <span class="s0">* [registry get $rpath DaylightBias] }]]</span>
	<span class="s0">set stdtzi [registry get $rpath StandardStart]</span>
	<span class="s0">foreach ind {0 2 14 4 6 8 10 12} {</span>
	    <span class="s0">binary scan $stdtzi @${ind}s val</span>
	    <span class="s0">lappend data $val</span>
	<span class="s0">}</span>
	<span class="s0">set daytzi [registry get $rpath DaylightStart]</span>
	<span class="s0">foreach ind {0 2 14 4 6 8 10 12} {</span>
	    <span class="s0">binary scan $daytzi @${ind}s val</span>
	    <span class="s0">lappend data $val</span>
	<span class="s0">}</span>
    <span class="s0">}] } {</span>
	<span class="s0"># Missing values in the Registry - bail out</span>

	<span class="s0">return :localtime</span>
    <span class="s0">}</span>

    <span class="s0"># Make up a Posix time zone specifier if we can't find one.  Check here</span>
    <span class="s0"># that the tzdata file exists, in case we're running in an environment</span>
    <span class="s0"># (e.g. starpack) where tzdata is incomplete.  (Bug 1237907)</span>

    <span class="s0">if { [dict exists $WinZoneInfo $data] } {</span>
	<span class="s0">set tzname [dict get $WinZoneInfo $data]</span>
	<span class="s0">if { ! [dict exists $TimeZoneBad $tzname] } {</span>
	    <span class="s0">dict set TimeZoneBad $tzname [catch {SetupTimeZone $tzname}]</span>
	<span class="s0">}</span>
    <span class="s0">} else {</span>
	<span class="s0">set tzname {}</span>
    <span class="s0">}</span>
    <span class="s0">if { $tzname eq {} || [dict get $TimeZoneBad $tzname] } {</span>
	<span class="s0">lassign $data \</span>
	    <span class="s0">bias stdBias dstBias \</span>
	    <span class="s0">stdYear stdMonth stdDayOfWeek stdDayOfMonth \</span>
	    <span class="s0">stdHour stdMinute stdSecond stdMillisec \</span>
	    <span class="s0">dstYear dstMonth dstDayOfWeek dstDayOfMonth \</span>
	    <span class="s0">dstHour dstMinute dstSecond dstMillisec</span>
	<span class="s0">set stdDelta [expr { $bias + $stdBias }]</span>
	<span class="s0">set dstDelta [expr { $bias + $dstBias }]</span>
	<span class="s0">if { $stdDelta &lt;= 0 } {</span>
	    <span class="s0">set stdSignum +</span>
	    <span class="s0">set stdDelta [expr { - $stdDelta }]</span>
	    <span class="s0">set dispStdSignum -</span>
	<span class="s0">} else {</span>
	    <span class="s0">set stdSignum -</span>
	    <span class="s0">set dispStdSignum +</span>
	<span class="s0">}</span>
	<span class="s0">set hh [::format %02d [expr { $stdDelta / 3600 }]]</span>
	<span class="s0">set mm [::format %02d [expr { ($stdDelta / 60 ) % 60 }]]</span>
	<span class="s0">set ss [::format %02d [expr { $stdDelta % 60 }]]</span>
	<span class="s0">set tzname {}</span>
	<span class="s0">append tzname &lt; $dispStdSignum $hh $mm &gt; $stdSignum $hh : $mm : $ss</span>
	<span class="s0">if { $stdMonth &gt;= 0 } {</span>
	    <span class="s0">if { $dstDelta &lt;= 0 } {</span>
		<span class="s0">set dstSignum +</span>
		<span class="s0">set dstDelta [expr { - $dstDelta }]</span>
		<span class="s0">set dispDstSignum -</span>
	    <span class="s0">} else {</span>
		<span class="s0">set dstSignum -</span>
		<span class="s0">set dispDstSignum +</span>
	    <span class="s0">}</span>
	    <span class="s0">set hh [::format %02d [expr { $dstDelta / 3600 }]]</span>
	    <span class="s0">set mm [::format %02d [expr { ($dstDelta / 60 ) % 60 }]]</span>
	    <span class="s0">set ss [::format %02d [expr { $dstDelta % 60 }]]</span>
	    <span class="s0">append tzname &lt; $dispDstSignum $hh $mm &gt; $dstSignum $hh : $mm : $ss</span>
	    <span class="s0">if { $dstYear == 0 } {</span>
		<span class="s0">append tzname ,M $dstMonth . $dstDayOfMonth . $dstDayOfWeek</span>
	    <span class="s0">} else {</span>
		<span class="s0"># I have not been able to find any locale on which Windows</span>
		<span class="s0"># converts time zone on a fixed day of the year, hence don't</span>
		<span class="s0"># know how to interpret the fields.  If someone can inform me,</span>
		<span class="s0"># I'd be glad to code it up.  For right now, we bail out in</span>
		<span class="s0"># such a case.</span>
		<span class="s0">return :localtime</span>
	    <span class="s0">}</span>
	    <span class="s0">append tzname / [::format %02d $dstHour] \</span>
		<span class="s0">: [::format %02d $dstMinute] \</span>
		<span class="s0">: [::format %02d $dstSecond]</span>
	    <span class="s0">if { $stdYear == 0 } {</span>
		<span class="s0">append tzname ,M $stdMonth . $stdDayOfMonth . $stdDayOfWeek</span>
	    <span class="s0">} else {</span>
		<span class="s0"># I have not been able to find any locale on which Windows</span>
		<span class="s0"># converts time zone on a fixed day of the year, hence don't</span>
		<span class="s0"># know how to interpret the fields.  If someone can inform me,</span>
		<span class="s0"># I'd be glad to code it up.  For right now, we bail out in</span>
		<span class="s0"># such a case.</span>
		<span class="s0">return :localtime</span>
	    <span class="s0">}</span>
	    <span class="s0">append tzname / [::format %02d $stdHour] \</span>
		<span class="s0">: [::format %02d $stdMinute] \</span>
		<span class="s0">: [::format %02d $stdSecond]</span>
	<span class="s0">}</span>
	<span class="s0">dict set WinZoneInfo $data $tzname</span>
    <span class="s0">}</span>

    <span class="s0">return [dict get $WinZoneInfo $data]</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># LoadTimeZoneFile --</span>
<span class="s0">#</span>
<span class="s0">#	Load the data file that specifies the conversion between a</span>
<span class="s0">#	given time zone and Greenwich.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	fileName -- Name of the file to load</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	TZData(:fileName) contains the time zone data</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::LoadTimeZoneFile { fileName } {</span>
    <span class="s0">variable DataDir</span>
    <span class="s0">variable TZData</span>

    <span class="s0">if { [info exists TZData($fileName)] } {</span>
	<span class="s0">return</span>
    <span class="s0">}</span>

    <span class="s0"># Since an unsafe interp uses the [clock] command in the master, this code</span>
    <span class="s0"># is security sensitive.  Make sure that the path name cannot escape the</span>
    <span class="s0"># given directory.</span>

    <span class="s0">if { ![regexp {^[[.-.][:alpha:]_]+(?:/[[.-.][:alpha:]_]+)*$} $fileName] } {</span>
	<span class="s0">return -code error \</span>
	    <span class="s0">-errorcode [list CLOCK badTimeZone $:fileName] \</span>
	    <span class="s0">&quot;time zone \&quot;:$fileName\&quot; not valid&quot;</span>
    <span class="s0">}</span>
    <span class="s0">try {</span>
	<span class="s0">source -encoding utf-8 [file join $DataDir $fileName]</span>
    <span class="s0">} on error {} {</span>
	<span class="s0">return -code error \</span>
	    <span class="s0">-errorcode [list CLOCK badTimeZone :$fileName] \</span>
	    <span class="s0">&quot;time zone \&quot;:$fileName\&quot; not found&quot;</span>
    <span class="s0">}</span>
    <span class="s0">return</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># LoadZoneinfoFile --</span>
<span class="s0">#</span>
<span class="s0">#	Loads a binary time zone information file in Olson format.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	fileName - Relative path name of the file to load.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns an empty result normally; returns an error if no Olson file</span>
<span class="s0">#	was found or the file was malformed in some way.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	TZData(:fileName) contains the time zone data</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::LoadZoneinfoFile { fileName } {</span>
    <span class="s0">variable ZoneinfoPaths</span>

    <span class="s0"># Since an unsafe interp uses the [clock] command in the master, this code</span>
    <span class="s0"># is security sensitive.  Make sure that the path name cannot escape the</span>
    <span class="s0"># given directory.</span>

    <span class="s0">if { ![regexp {^[[.-.][:alpha:]_]+(?:/[[.-.][:alpha:]_]+)*$} $fileName] } {</span>
	<span class="s0">return -code error \</span>
	    <span class="s0">-errorcode [list CLOCK badTimeZone $:fileName] \</span>
	    <span class="s0">&quot;time zone \&quot;:$fileName\&quot; not valid&quot;</span>
    <span class="s0">}</span>
    <span class="s0">foreach d $ZoneinfoPaths {</span>
	<span class="s0">set fname [file join $d $fileName]</span>
	<span class="s0">if { [file readable $fname] &amp;&amp; [file isfile $fname] } {</span>
	    <span class="s0">break</span>
	<span class="s0">}</span>
	<span class="s0">unset fname</span>
    <span class="s0">}</span>
    <span class="s0">ReadZoneinfoFile $fileName $fname</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># ReadZoneinfoFile --</span>
<span class="s0">#</span>
<span class="s0">#	Loads a binary time zone information file in Olson format.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	fileName - Name of the time zone (relative path name of the</span>
<span class="s0">#		   file).</span>
<span class="s0">#	fname - Absolute path name of the file.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns an empty result normally; returns an error if no Olson file</span>
<span class="s0">#	was found or the file was malformed in some way.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	TZData(:fileName) contains the time zone data</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::ReadZoneinfoFile {fileName fname} {</span>
    <span class="s0">variable MINWIDE</span>
    <span class="s0">variable TZData</span>
    <span class="s0">if { ![file exists $fname] } {</span>
	<span class="s0">return -code error &quot;$fileName not found&quot;</span>
    <span class="s0">}</span>

    <span class="s0">if { [file size $fname] &gt; 262144 } {</span>
	<span class="s0">return -code error &quot;$fileName too big&quot;</span>
    <span class="s0">}</span>

    <span class="s0"># Suck in all the data from the file</span>

    <span class="s0">set f [open $fname r]</span>
    <span class="s0">fconfigure $f -translation binary</span>
    <span class="s0">set d [read $f]</span>
    <span class="s0">close $f</span>

    <span class="s0"># The file begins with a magic number, sixteen reserved bytes, and then</span>
    <span class="s0"># six 4-byte integers giving counts of fileds in the file.</span>

    <span class="s0">binary scan $d a4a1x15IIIIII \</span>
	<span class="s0">magic version nIsGMT nIsStd nLeap nTime nType nChar</span>
    <span class="s0">set seek 44</span>
    <span class="s0">set ilen 4</span>
    <span class="s0">set iformat I</span>
    <span class="s0">if { $magic != {TZif} } {</span>
	<span class="s0">return -code error &quot;$fileName not a time zone information file&quot;</span>
    <span class="s0">}</span>
    <span class="s0">if { $nType &gt; 255 } {</span>
	<span class="s0">return -code error &quot;$fileName contains too many time types&quot;</span>
    <span class="s0">}</span>
    <span class="s0"># Accept only Posix-style zoneinfo.  Sorry, 'leaps' bigots.</span>
    <span class="s0">if { $nLeap != 0 } {</span>
	<span class="s0">return -code error &quot;$fileName contains leap seconds&quot;</span>
    <span class="s0">}</span>

    <span class="s0"># In a version 2 file, we use the second part of the file, which contains</span>
    <span class="s0"># 64-bit transition times.</span>

    <span class="s0">if {$version eq &quot;2&quot;} {</span>
	<span class="s0">set seek [expr {</span>
	    <span class="s0">44</span>
	    <span class="s0">+ 5 * $nTime</span>
	    <span class="s0">+ 6 * $nType</span>
	    <span class="s0">+ 4 * $nLeap</span>
	    <span class="s0">+ $nIsStd</span>
	    <span class="s0">+ $nIsGMT</span>
	    <span class="s0">+ $nChar</span>
	<span class="s0">}]</span>
	<span class="s0">binary scan $d @${seek}a4a1x15IIIIII \</span>
	    <span class="s0">magic version nIsGMT nIsStd nLeap nTime nType nChar</span>
	<span class="s0">if {$magic ne {TZif}} {</span>
	    <span class="s0">return -code error &quot;seek address $seek miscomputed, magic = $magic&quot;</span>
	<span class="s0">}</span>
	<span class="s0">set iformat W</span>
	<span class="s0">set ilen 8</span>
	<span class="s0">incr seek 44</span>
    <span class="s0">}</span>

    <span class="s0"># Next come ${nTime} transition times, followed by ${nTime} time type</span>
    <span class="s0"># codes.  The type codes are unsigned 1-byte quantities.  We insert an</span>
    <span class="s0"># arbitrary start time in front of the transitions.</span>

    <span class="s0">binary scan $d @${seek}${iformat}${nTime}c${nTime} times tempCodes</span>
    <span class="s0">incr seek [expr { ($ilen + 1) * $nTime }]</span>
    <span class="s0">set times [linsert $times 0 $MINWIDE]</span>
    <span class="s0">set codes {}</span>
    <span class="s0">foreach c $tempCodes {</span>
	<span class="s0">lappend codes [expr { $c &amp; 0xff }]</span>
    <span class="s0">}</span>
    <span class="s0">set codes [linsert $codes 0 0]</span>

    <span class="s0"># Next come ${nType} time type descriptions, each of which has an offset</span>
    <span class="s0"># (seconds east of GMT), a DST indicator, and an index into the</span>
    <span class="s0"># abbreviation text.</span>

    <span class="s0">for { set i 0 } { $i &lt; $nType } { incr i } {</span>
	<span class="s0">binary scan $d @${seek}Icc gmtOff isDst abbrInd</span>
	<span class="s0">lappend types [list $gmtOff $isDst $abbrInd]</span>
	<span class="s0">incr seek 6</span>
    <span class="s0">}</span>

    <span class="s0"># Next come $nChar characters of time zone name abbreviations, which are</span>
    <span class="s0"># null-terminated.</span>
    <span class="s0"># We build them up into a dictionary indexed by character index, because</span>
    <span class="s0"># that's what's in the indices above.</span>

    <span class="s0">binary scan $d @${seek}a${nChar} abbrs</span>
    <span class="s0">incr seek ${nChar}</span>
    <span class="s0">set abbrList [split $abbrs \0]</span>
    <span class="s0">set i 0</span>
    <span class="s0">set abbrevs {}</span>
    <span class="s0">foreach a $abbrList {</span>
	<span class="s0">for {set j 0} {$j &lt;= [string length $a]} {incr j} {</span>
	    <span class="s0">dict set abbrevs $i [string range $a $j end]</span>
	    <span class="s0">incr i</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Package up a list of tuples, each of which contains transition time,</span>
    <span class="s0"># seconds east of Greenwich, DST flag and time zone abbreviation.</span>

    <span class="s0">set r {}</span>
    <span class="s0">set lastTime $MINWIDE</span>
    <span class="s0">foreach t $times c $codes {</span>
	<span class="s0">if { $t &lt; $lastTime } {</span>
	    <span class="s0">return -code error &quot;$fileName has times out of order&quot;</span>
	<span class="s0">}</span>
	<span class="s0">set lastTime $t</span>
	<span class="s0">lassign [lindex $types $c] gmtoff isDst abbrInd</span>
	<span class="s0">set abbrev [dict get $abbrevs $abbrInd]</span>
	<span class="s0">lappend r [list $t $gmtoff $isDst $abbrev]</span>
    <span class="s0">}</span>

    <span class="s0"># In a version 2 file, there is also a POSIX-style time zone description</span>
    <span class="s0"># at the very end of the file.  To get to it, skip over nLeap leap second</span>
    <span class="s0"># values (8 bytes each),</span>
    <span class="s0"># nIsStd standard/DST indicators and nIsGMT UTC/local indicators.</span>

    <span class="s0">if {$version eq {2}} {</span>
	<span class="s0">set seek [expr {$seek + 8 * $nLeap + $nIsStd + $nIsGMT + 1}]</span>
	<span class="s0">set last [string first \n $d $seek]</span>
	<span class="s0">set posix [string range $d $seek [expr {$last-1}]]</span>
	<span class="s0">if {[llength $posix] &gt; 0} {</span>
	    <span class="s0">set posixFields [ParsePosixTimeZone $posix]</span>
	    <span class="s0">foreach tuple [ProcessPosixTimeZone $posixFields] {</span>
		<span class="s0">lassign $tuple t gmtoff isDst abbrev</span>
		<span class="s0">if {$t &gt; $lastTime} {</span>
		    <span class="s0">lappend r $tuple</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">set TZData(:$fileName) $r</span>

    <span class="s0">return</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># ParsePosixTimeZone --</span>
<span class="s0">#</span>
<span class="s0">#	Parses the TZ environment variable in Posix form</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	tz	Time zone specifier to be interpreted</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns a dictionary whose values contain the various pieces of the</span>
<span class="s0">#	time zone specification.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># Errors:</span>
<span class="s0">#	Throws an error if the syntax of the time zone is incorrect.</span>
<span class="s0">#</span>
<span class="s0"># The following keys are present in the dictionary:</span>
<span class="s0">#	stdName - Name of the time zone when Daylight Saving Time</span>
<span class="s0">#		  is not in effect.</span>
<span class="s0">#	stdSignum - Sign (+, -, or empty) of the offset from Greenwich</span>
<span class="s0">#		    to the given (non-DST) time zone.  + and the empty</span>
<span class="s0">#		    string denote zones west of Greenwich, - denotes east</span>
<span class="s0">#		    of Greenwich; this is contrary to the ISO convention</span>
<span class="s0">#		    but follows Posix.</span>
<span class="s0">#	stdHours - Hours part of the offset from Greenwich to the given</span>
<span class="s0">#		   (non-DST) time zone.</span>
<span class="s0">#	stdMinutes - Minutes part of the offset from Greenwich to the</span>
<span class="s0">#		     given (non-DST) time zone. Empty denotes zero.</span>
<span class="s0">#	stdSeconds - Seconds part of the offset from Greenwich to the</span>
<span class="s0">#		     given (non-DST) time zone. Empty denotes zero.</span>
<span class="s0">#	dstName - Name of the time zone when DST is in effect, or the</span>
<span class="s0">#		  empty string if the time zone does not observe Daylight</span>
<span class="s0">#		  Saving Time.</span>
<span class="s0">#	dstSignum, dstHours, dstMinutes, dstSeconds -</span>
<span class="s0">#		Fields corresponding to stdSignum, stdHours, stdMinutes,</span>
<span class="s0">#		stdSeconds for the Daylight Saving Time version of the</span>
<span class="s0">#		time zone.  If dstHours is empty, it is presumed to be 1.</span>
<span class="s0">#	startDayOfYear - The ordinal number of the day of the year on which</span>
<span class="s0">#			 Daylight Saving Time begins.  If this field is</span>
<span class="s0">#			 empty, then DST begins on a given month-week-day,</span>
<span class="s0">#			 as below.</span>
<span class="s0">#	startJ - The letter J, or an empty string.  If a J is present in</span>
<span class="s0">#		 this field, then startDayOfYear does not count February 29</span>
<span class="s0">#		 even in leap years.</span>
<span class="s0">#	startMonth - The number of the month in which Daylight Saving Time</span>
<span class="s0">#		     begins, supplied if startDayOfYear is empty.  If both</span>
<span class="s0">#		     startDayOfYear and startMonth are empty, then US rules</span>
<span class="s0">#		     are presumed.</span>
<span class="s0">#	startWeekOfMonth - The number of the week in the month in which</span>
<span class="s0">#			   Daylight Saving Time begins, in the range 1-5.</span>
<span class="s0">#			   5 denotes the last week of the month even in a</span>
<span class="s0">#			   4-week month.</span>
<span class="s0">#	startDayOfWeek - The number of the day of the week (Sunday=0,</span>
<span class="s0">#			 Saturday=6) on which Daylight Saving Time begins.</span>
<span class="s0">#	startHours - The hours part of the time of day at which Daylight</span>
<span class="s0">#		     Saving Time begins. An empty string is presumed to be 2.</span>
<span class="s0">#	startMinutes - The minutes part of the time of day at which DST begins.</span>
<span class="s0">#		       An empty string is presumed zero.</span>
<span class="s0">#	startSeconds - The seconds part of the time of day at which DST begins.</span>
<span class="s0">#		       An empty string is presumed zero.</span>
<span class="s0">#	endDayOfYear, endJ, endMonth, endWeekOfMonth, endDayOfWeek,</span>
<span class="s0">#	endHours, endMinutes, endSeconds -</span>
<span class="s0">#		Specify the end of DST in the same way that the start* fields</span>
<span class="s0">#		specify the beginning of DST.</span>
<span class="s0">#</span>
<span class="s0"># This procedure serves only to break the time specifier into fields.  No</span>
<span class="s0"># attempt is made to canonicalize the fields or supply default values.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::ParsePosixTimeZone { tz } {</span>
    <span class="s0">if {[regexp -expanded -nocase -- {</span>
	<span class="s0">^</span>
	<span class="s0"># 1 - Standard time zone name</span>
	<span class="s0">([[:alpha:]]+ | &lt;[-+[:alnum:]]+&gt;)</span>
	<span class="s0"># 2 - Standard time zone offset, signum</span>
	<span class="s0">([-+]?)</span>
	<span class="s0"># 3 - Standard time zone offset, hours</span>
	<span class="s0">([[:digit:]]{1,2})</span>
	<span class="s0">(?:</span>
	    <span class="s0"># 4 - Standard time zone offset, minutes</span>
	    <span class="s0">: ([[:digit:]]{1,2})</span>
	    <span class="s0">(?:</span>
	        <span class="s0"># 5 - Standard time zone offset, seconds</span>
		<span class="s0">: ([[:digit:]]{1,2} )</span>
	    <span class="s0">)?</span>
	<span class="s0">)?</span>
	<span class="s0">(?:</span>
	    <span class="s0"># 6 - DST time zone name</span>
	    <span class="s0">([[:alpha:]]+ | &lt;[-+[:alnum:]]+&gt;)</span>
	    <span class="s0">(?:</span>
	        <span class="s0">(?:</span>
		    <span class="s0"># 7 - DST time zone offset, signum</span>
		    <span class="s0">([-+]?)</span>
		    <span class="s0"># 8 - DST time zone offset, hours</span>
		    <span class="s0">([[:digit:]]{1,2})</span>
		    <span class="s0">(?:</span>
			<span class="s0"># 9 - DST time zone offset, minutes</span>
			<span class="s0">: ([[:digit:]]{1,2})</span>
			<span class="s0">(?:</span>
		            <span class="s0"># 10 - DST time zone offset, seconds</span>
			    <span class="s0">: ([[:digit:]]{1,2})</span>
			<span class="s0">)?</span>
		    <span class="s0">)?</span>
		<span class="s0">)?</span>
	        <span class="s0">(?:</span>
		    <span class="s0">,</span>
		    <span class="s0">(?:</span>
			<span class="s0"># 11 - Optional J in n and Jn form 12 - Day of year</span>
		        <span class="s0">( J ? )	( [[:digit:]]+ )</span>
                        <span class="s0">| M</span>
			<span class="s0"># 13 - Month number 14 - Week of month 15 - Day of week</span>
			<span class="s0">( [[:digit:]] + )</span>
			<span class="s0">[.] ( [[:digit:]] + )</span>
			<span class="s0">[.] ( [[:digit:]] + )</span>
		    <span class="s0">)</span>
		    <span class="s0">(?:</span>
			<span class="s0"># 16 - Start time of DST - hours</span>
			<span class="s0">/ ( [[:digit:]]{1,2} )</span>
		        <span class="s0">(?:</span>
			    <span class="s0"># 17 - Start time of DST - minutes</span>
			    <span class="s0">: ( [[:digit:]]{1,2} )</span>
			    <span class="s0">(?:</span>
				<span class="s0"># 18 - Start time of DST - seconds</span>
				<span class="s0">: ( [[:digit:]]{1,2} )</span>
			    <span class="s0">)?</span>
			<span class="s0">)?</span>
		    <span class="s0">)?</span>
		    <span class="s0">,</span>
		    <span class="s0">(?:</span>
			<span class="s0"># 19 - Optional J in n and Jn form 20 - Day of year</span>
		        <span class="s0">( J ? )	( [[:digit:]]+ )</span>
                        <span class="s0">| M</span>
			<span class="s0"># 21 - Month number 22 - Week of month 23 - Day of week</span>
			<span class="s0">( [[:digit:]] + )</span>
			<span class="s0">[.] ( [[:digit:]] + )</span>
			<span class="s0">[.] ( [[:digit:]] + )</span>
		    <span class="s0">)</span>
		    <span class="s0">(?:</span>
			<span class="s0"># 24 - End time of DST - hours</span>
			<span class="s0">/ ( [[:digit:]]{1,2} )</span>
		        <span class="s0">(?:</span>
			    <span class="s0"># 25 - End time of DST - minutes</span>
			    <span class="s0">: ( [[:digit:]]{1,2} )</span>
			    <span class="s0">(?:</span>
				<span class="s0"># 26 - End time of DST - seconds</span>
				<span class="s0">: ( [[:digit:]]{1,2} )</span>
			    <span class="s0">)?</span>
			<span class="s0">)?</span>
		    <span class="s0">)?</span>
                <span class="s0">)?</span>
	    <span class="s0">)?</span>
        <span class="s0">)?</span>
	<span class="s0">$</span>
    <span class="s0">} $tz -&gt; x(stdName) x(stdSignum) x(stdHours) x(stdMinutes) x(stdSeconds) \</span>
	     <span class="s0">x(dstName) x(dstSignum) x(dstHours) x(dstMinutes) x(dstSeconds) \</span>
	     <span class="s0">x(startJ) x(startDayOfYear) \</span>
	     <span class="s0">x(startMonth) x(startWeekOfMonth) x(startDayOfWeek) \</span>
	     <span class="s0">x(startHours) x(startMinutes) x(startSeconds) \</span>
	     <span class="s0">x(endJ) x(endDayOfYear) \</span>
	     <span class="s0">x(endMonth) x(endWeekOfMonth) x(endDayOfWeek) \</span>
	     <span class="s0">x(endHours) x(endMinutes) x(endSeconds)] } {</span>
	<span class="s0"># it's a good timezone</span>

	<span class="s0">return [array get x]</span>
    <span class="s0">}</span>

    <span class="s0">return -code error\</span>
	<span class="s0">-errorcode [list CLOCK badTimeZone $tz] \</span>
	<span class="s0">&quot;unable to parse time zone specification \&quot;$tz\&quot;&quot;</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># ProcessPosixTimeZone --</span>
<span class="s0">#</span>
<span class="s0">#	Handle a Posix time zone after it's been broken out into fields.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	z - Dictionary returned from 'ParsePosixTimeZone'</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns time zone information for the 'TZData' array.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::ProcessPosixTimeZone { z } {</span>
    <span class="s0">variable MINWIDE</span>
    <span class="s0">variable TZData</span>

    <span class="s0"># Determine the standard time zone name and seconds east of Greenwich</span>

    <span class="s0">set stdName [dict get $z stdName]</span>
    <span class="s0">if { [string index $stdName 0] eq {&lt;} } {</span>
	<span class="s0">set stdName [string range $stdName 1 end-1]</span>
    <span class="s0">}</span>
    <span class="s0">if { [dict get $z stdSignum] eq {-} } {</span>
	<span class="s0">set stdSignum +1</span>
    <span class="s0">} else {</span>
	<span class="s0">set stdSignum -1</span>
    <span class="s0">}</span>
    <span class="s0">set stdHours [lindex [::scan [dict get $z stdHours] %d] 0]</span>
    <span class="s0">if { [dict get $z stdMinutes] ne {} } {</span>
	<span class="s0">set stdMinutes [lindex [::scan [dict get $z stdMinutes] %d] 0]</span>
    <span class="s0">} else {</span>
	<span class="s0">set stdMinutes 0</span>
    <span class="s0">}</span>
    <span class="s0">if { [dict get $z stdSeconds] ne {} } {</span>
	<span class="s0">set stdSeconds [lindex [::scan [dict get $z stdSeconds] %d] 0]</span>
    <span class="s0">} else {</span>
	<span class="s0">set stdSeconds 0</span>
    <span class="s0">}</span>
    <span class="s0">set stdOffset [expr {</span>
	<span class="s0">(($stdHours * 60 + $stdMinutes) * 60 + $stdSeconds) * $stdSignum</span>
    <span class="s0">}]</span>
    <span class="s0">set data [list [list $MINWIDE $stdOffset 0 $stdName]]</span>

    <span class="s0"># If there's no daylight zone, we're done</span>

    <span class="s0">set dstName [dict get $z dstName]</span>
    <span class="s0">if { $dstName eq {} } {</span>
	<span class="s0">return $data</span>
    <span class="s0">}</span>
    <span class="s0">if { [string index $dstName 0] eq {&lt;} } {</span>
	<span class="s0">set dstName [string range $dstName 1 end-1]</span>
    <span class="s0">}</span>

    <span class="s0"># Determine the daylight name</span>

    <span class="s0">if { [dict get $z dstSignum] eq {-} } {</span>
	<span class="s0">set dstSignum +1</span>
    <span class="s0">} else {</span>
	<span class="s0">set dstSignum -1</span>
    <span class="s0">}</span>
    <span class="s0">if { [dict get $z dstHours] eq {} } {</span>
	<span class="s0">set dstOffset [expr { 3600 + $stdOffset }]</span>
    <span class="s0">} else {</span>
	<span class="s0">set dstHours [lindex [::scan [dict get $z dstHours] %d] 0]</span>
	<span class="s0">if { [dict get $z dstMinutes] ne {} } {</span>
	    <span class="s0">set dstMinutes [lindex [::scan [dict get $z dstMinutes] %d] 0]</span>
	<span class="s0">} else {</span>
	    <span class="s0">set dstMinutes 0</span>
	<span class="s0">}</span>
	<span class="s0">if { [dict get $z dstSeconds] ne {} } {</span>
	    <span class="s0">set dstSeconds [lindex [::scan [dict get $z dstSeconds] %d] 0]</span>
	<span class="s0">} else {</span>
	    <span class="s0">set dstSeconds 0</span>
	<span class="s0">}</span>
	<span class="s0">set dstOffset [expr {</span>
	    <span class="s0">(($dstHours*60 + $dstMinutes) * 60 + $dstSeconds) * $dstSignum</span>
	<span class="s0">}]</span>
    <span class="s0">}</span>

    <span class="s0"># Fill in defaults for European or US DST rules</span>
    <span class="s0"># US start time is the second Sunday in March</span>
    <span class="s0"># EU start time is the last Sunday in March</span>
    <span class="s0"># US end time is the first Sunday in November.</span>
    <span class="s0"># EU end time is the last Sunday in October</span>

    <span class="s0">if {</span>
	<span class="s0">[dict get $z startDayOfYear] eq {}</span>
	<span class="s0">&amp;&amp; [dict get $z startMonth] eq {}</span>
    <span class="s0">} then {</span>
	<span class="s0">if {($stdSignum * $stdHours&gt;=0) &amp;&amp; ($stdSignum * $stdHours&lt;=12)} {</span>
	    <span class="s0"># EU</span>
	    <span class="s0">dict set z startWeekOfMonth 5</span>
	    <span class="s0">if {$stdHours&gt;2} {</span>
		<span class="s0">dict set z startHours 2</span>
	    <span class="s0">} else {</span>
		<span class="s0">dict set z startHours [expr {$stdHours+1}]</span>
	    <span class="s0">}</span>
	<span class="s0">} else {</span>
	    <span class="s0"># US</span>
	    <span class="s0">dict set z startWeekOfMonth 2</span>
	    <span class="s0">dict set z startHours 2</span>
	<span class="s0">}</span>
	<span class="s0">dict set z startMonth 3</span>
	<span class="s0">dict set z startDayOfWeek 0</span>
	<span class="s0">dict set z startMinutes 0</span>
	<span class="s0">dict set z startSeconds 0</span>
    <span class="s0">}</span>
    <span class="s0">if {</span>
	<span class="s0">[dict get $z endDayOfYear] eq {}</span>
	<span class="s0">&amp;&amp; [dict get $z endMonth] eq {}</span>
    <span class="s0">} then {</span>
	<span class="s0">if {($stdSignum * $stdHours&gt;=0) &amp;&amp; ($stdSignum * $stdHours&lt;=12)} {</span>
	    <span class="s0"># EU</span>
	    <span class="s0">dict set z endMonth 10</span>
	    <span class="s0">dict set z endWeekOfMonth 5</span>
	    <span class="s0">if {$stdHours&gt;2} {</span>
		<span class="s0">dict set z endHours 3</span>
	    <span class="s0">} else {</span>
		<span class="s0">dict set z endHours [expr {$stdHours+2}]</span>
	    <span class="s0">}</span>
	<span class="s0">} else {</span>
	    <span class="s0"># US</span>
	    <span class="s0">dict set z endMonth 11</span>
	    <span class="s0">dict set z endWeekOfMonth 1</span>
	    <span class="s0">dict set z endHours 2</span>
	<span class="s0">}</span>
	<span class="s0">dict set z endDayOfWeek 0</span>
	<span class="s0">dict set z endMinutes 0</span>
	<span class="s0">dict set z endSeconds 0</span>
    <span class="s0">}</span>

    <span class="s0"># Put DST in effect in all years from 1916 to 2099.</span>

    <span class="s0">for { set y 1916 } { $y &lt; 2100 } { incr y } {</span>
	<span class="s0">set startTime [DeterminePosixDSTTime $z start $y]</span>
	<span class="s0">incr startTime [expr { - wide($stdOffset) }]</span>
	<span class="s0">set endTime [DeterminePosixDSTTime $z end $y]</span>
	<span class="s0">incr endTime [expr { - wide($dstOffset) }]</span>
	<span class="s0">if { $startTime &lt; $endTime } {</span>
	    <span class="s0">lappend data \</span>
		<span class="s0">[list $startTime $dstOffset 1 $dstName] \</span>
		<span class="s0">[list $endTime $stdOffset 0 $stdName]</span>
	<span class="s0">} else {</span>
	    <span class="s0">lappend data \</span>
		<span class="s0">[list $endTime $stdOffset 0 $stdName] \</span>
		<span class="s0">[list $startTime $dstOffset 1 $dstName]</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">return $data</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># DeterminePosixDSTTime --</span>
<span class="s0">#</span>
<span class="s0">#	Determines the time that Daylight Saving Time starts or ends from a</span>
<span class="s0">#	Posix time zone specification.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	z - Time zone data returned from ParsePosixTimeZone.</span>
<span class="s0">#	    Missing fields are expected to be filled in with</span>
<span class="s0">#	    default values.</span>
<span class="s0">#	bound - The word 'start' or 'end'</span>
<span class="s0">#	y - The year for which the transition time is to be determined.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the transition time as a count of seconds from the epoch.  The</span>
<span class="s0">#	time is relative to the wall clock, not UTC.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::DeterminePosixDSTTime { z bound y } {</span>

    <span class="s0">variable FEB_28</span>

    <span class="s0"># Determine the start or end day of DST</span>

    <span class="s0">set date [dict create era CE year $y]</span>
    <span class="s0">set doy [dict get $z ${bound}DayOfYear]</span>
    <span class="s0">if { $doy ne {} } {</span>

	<span class="s0"># Time was specified as a day of the year</span>

	<span class="s0">if { [dict get $z ${bound}J] ne {}</span>
	     <span class="s0">&amp;&amp; [IsGregorianLeapYear $y]</span>
	     <span class="s0">&amp;&amp; ( $doy &gt; $FEB_28 ) } {</span>
	    <span class="s0">incr doy</span>
	<span class="s0">}</span>
	<span class="s0">dict set date dayOfYear $doy</span>
	<span class="s0">set date [GetJulianDayFromEraYearDay $date[set date {}] 2361222]</span>
    <span class="s0">} else {</span>
	<span class="s0"># Time was specified as a day of the week within a month</span>

	<span class="s0">dict set date month [dict get $z ${bound}Month]</span>
	<span class="s0">dict set date dayOfWeek [dict get $z ${bound}DayOfWeek]</span>
	<span class="s0">set dowim [dict get $z ${bound}WeekOfMonth]</span>
	<span class="s0">if { $dowim &gt;= 5 } {</span>
	    <span class="s0">set dowim -1</span>
	<span class="s0">}</span>
	<span class="s0">dict set date dayOfWeekInMonth $dowim</span>
	<span class="s0">set date [GetJulianDayFromEraYearMonthWeekDay $date[set date {}] 2361222]</span>

    <span class="s0">}</span>

    <span class="s0">set jd [dict get $date julianDay]</span>
    <span class="s0">set seconds [expr {</span>
	<span class="s0">wide($jd) * wide(86400) - wide(210866803200)</span>
    <span class="s0">}]</span>

    <span class="s0">set h [dict get $z ${bound}Hours]</span>
    <span class="s0">if { $h eq {} } {</span>
	<span class="s0">set h 2</span>
    <span class="s0">} else {</span>
	<span class="s0">set h [lindex [::scan $h %d] 0]</span>
    <span class="s0">}</span>
    <span class="s0">set m [dict get $z ${bound}Minutes]</span>
    <span class="s0">if { $m eq {} } {</span>
	<span class="s0">set m 0</span>
    <span class="s0">} else {</span>
	<span class="s0">set m [lindex [::scan $m %d] 0]</span>
    <span class="s0">}</span>
    <span class="s0">set s [dict get $z ${bound}Seconds]</span>
    <span class="s0">if { $s eq {} } {</span>
	<span class="s0">set s 0</span>
    <span class="s0">} else {</span>
	<span class="s0">set s [lindex [::scan $s %d] 0]</span>
    <span class="s0">}</span>
    <span class="s0">set tod [expr { ( $h * 60 + $m ) * 60 + $s }]</span>
    <span class="s0">return [expr { $seconds + $tod }]</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># GetLocaleEra --</span>
<span class="s0">#</span>
<span class="s0">#	Given local time expressed in seconds from the Posix epoch,</span>
<span class="s0">#	determine localized era and year within the era.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date - Dictionary that must contain the keys, 'localSeconds',</span>
<span class="s0">#	       whose value is expressed as the appropriate local time;</span>
<span class="s0">#	       and 'year', whose value is the Gregorian year.</span>
<span class="s0">#	etable - Value of the LOCALE_ERAS key in the message catalogue</span>
<span class="s0">#	         for the target locale.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the dictionary, augmented with the keys, 'localeEra' and</span>
<span class="s0">#	'localeYear'.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::GetLocaleEra { date etable } {</span>
    <span class="s0">set index [BSearch $etable [dict get $date localSeconds]]</span>
    <span class="s0">if { $index &lt; 0} {</span>
	<span class="s0">dict set date localeEra \</span>
	    <span class="s0">[::format %02d [expr { [dict get $date year] / 100 }]]</span>
	<span class="s0">dict set date localeYear [expr {</span>
	    <span class="s0">[dict get $date year] % 100</span>
	<span class="s0">}]</span>
    <span class="s0">} else {</span>
	<span class="s0">dict set date localeEra [lindex $etable $index 1]</span>
	<span class="s0">dict set date localeYear [expr {</span>
	    <span class="s0">[dict get $date year] - [lindex $etable $index 2]</span>
	<span class="s0">}]</span>
    <span class="s0">}</span>
    <span class="s0">return $date</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># GetJulianDayFromEraYearDay --</span>
<span class="s0">#</span>
<span class="s0">#	Given a year, month and day on the Gregorian calendar, determines</span>
<span class="s0">#	the Julian Day Number beginning at noon on that date.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date -- A dictionary in which the 'era', 'year', and</span>
<span class="s0">#		'dayOfYear' slots are populated. The calendar in use</span>
<span class="s0">#		is determined by the date itself relative to:</span>
<span class="s0">#       changeover -- Julian day on which the Gregorian calendar was</span>
<span class="s0">#		adopted in the current locale.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the given dictionary augmented with a 'julianDay' key whose</span>
<span class="s0">#	value is the desired Julian Day Number, and a 'gregorian' key that</span>
<span class="s0">#	specifies whether the calendar is Gregorian (1) or Julian (0).</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># Bugs:</span>
<span class="s0">#	This code needs to be moved to the C layer.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::GetJulianDayFromEraYearDay {date changeover} {</span>
    <span class="s0"># Get absolute year number from the civil year</span>

    <span class="s0">switch -exact -- [dict get $date era] {</span>
	<span class="s0">BCE {</span>
	    <span class="s0">set year [expr { 1 - [dict get $date year] }]</span>
	<span class="s0">}</span>
	<span class="s0">CE {</span>
	    <span class="s0">set year [dict get $date year]</span>
	<span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">set ym1 [expr { $year - 1 }]</span>

    <span class="s0"># Try the Gregorian calendar first.</span>

    <span class="s0">dict set date gregorian 1</span>
    <span class="s0">set jd [expr {</span>
	<span class="s0">1721425</span>
	<span class="s0">+ [dict get $date dayOfYear]</span>
	<span class="s0">+ ( 365 * $ym1 )</span>
	<span class="s0">+ ( $ym1 / 4 )</span>
	<span class="s0">- ( $ym1 / 100 )</span>
	<span class="s0">+ ( $ym1 / 400 )</span>
    <span class="s0">}]</span>

    <span class="s0"># If the date is before the Gregorian change, use the Julian calendar.</span>

    <span class="s0">if { $jd &lt; $changeover } {</span>
	<span class="s0">dict set date gregorian 0</span>
	<span class="s0">set jd [expr {</span>
	    <span class="s0">1721423</span>
	    <span class="s0">+ [dict get $date dayOfYear]</span>
	    <span class="s0">+ ( 365 * $ym1 )</span>
	    <span class="s0">+ ( $ym1 / 4 )</span>
	<span class="s0">}]</span>
    <span class="s0">}</span>

    <span class="s0">dict set date julianDay $jd</span>
    <span class="s0">return $date</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># GetJulianDayFromEraYearMonthWeekDay --</span>
<span class="s0">#</span>
<span class="s0">#	Determines the Julian Day number corresponding to the nth given</span>
<span class="s0">#	day-of-the-week in a given month.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date - Dictionary containing the keys, 'era', 'year', 'month'</span>
<span class="s0">#	       'weekOfMonth', 'dayOfWeek', and 'dayOfWeekInMonth'.</span>
<span class="s0">#	changeover - Julian Day of adoption of the Gregorian calendar</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the given dictionary, augmented with a 'julianDay' key.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># Bugs:</span>
<span class="s0">#	This code needs to be moved to the C layer.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::GetJulianDayFromEraYearMonthWeekDay {date changeover} {</span>
    <span class="s0"># Come up with a reference day; either the zeroeth day of the given month</span>
    <span class="s0"># (dayOfWeekInMonth &gt;= 0) or the seventh day of the following month</span>
    <span class="s0"># (dayOfWeekInMonth &lt; 0)</span>

    <span class="s0">set date2 $date</span>
    <span class="s0">set week [dict get $date dayOfWeekInMonth]</span>
    <span class="s0">if { $week &gt;= 0 } {</span>
	<span class="s0">dict set date2 dayOfMonth 0</span>
    <span class="s0">} else {</span>
	<span class="s0">dict incr date2 month</span>
	<span class="s0">dict set date2 dayOfMonth 7</span>
    <span class="s0">}</span>
    <span class="s0">set date2 [GetJulianDayFromEraYearMonthDay $date2[set date2 {}] \</span>
		   <span class="s0">$changeover]</span>
    <span class="s0">set wd0 [WeekdayOnOrBefore [dict get $date dayOfWeek] \</span>
		 <span class="s0">[dict get $date2 julianDay]]</span>
    <span class="s0">dict set date julianDay [expr { $wd0 + 7 * $week }]</span>
    <span class="s0">return $date</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># IsGregorianLeapYear --</span>
<span class="s0">#</span>
<span class="s0">#	Determines whether a given date represents a leap year in the</span>
<span class="s0">#	Gregorian calendar.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	date -- The date to test.  The fields, 'era', 'year' and 'gregorian'</span>
<span class="s0">#	        must be set.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns 1 if the year is a leap year, 0 otherwise.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::IsGregorianLeapYear { date } {</span>
    <span class="s0">switch -exact -- [dict get $date era] {</span>
	<span class="s0">BCE {</span>
	    <span class="s0">set year [expr { 1 - [dict get $date year]}]</span>
	<span class="s0">}</span>
	<span class="s0">CE {</span>
	    <span class="s0">set year [dict get $date year]</span>
	<span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">if { $year % 4 != 0 } {</span>
	<span class="s0">return 0</span>
    <span class="s0">} elseif { ![dict get $date gregorian] } {</span>
	<span class="s0">return 1</span>
    <span class="s0">} elseif { $year % 400 == 0 } {</span>
	<span class="s0">return 1</span>
    <span class="s0">} elseif { $year % 100 == 0 } {</span>
	<span class="s0">return 0</span>
    <span class="s0">} else {</span>
	<span class="s0">return 1</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># WeekdayOnOrBefore --</span>
<span class="s0">#</span>
<span class="s0">#	Determine the nearest day of week (given by the 'weekday' parameter,</span>
<span class="s0">#	Sunday==0) on or before a given Julian Day.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	weekday -- Day of the week</span>
<span class="s0">#	j -- Julian Day number</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the Julian Day Number of the desired date.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::WeekdayOnOrBefore { weekday j } {</span>
    <span class="s0">set k [expr { ( $weekday + 6 )  % 7 }]</span>
    <span class="s0">return [expr { $j - ( $j - $k ) % 7 }]</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># BSearch --</span>
<span class="s0">#</span>
<span class="s0">#	Service procedure that does binary search in several places inside the</span>
<span class="s0">#	'clock' command.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	list - List of lists, sorted in ascending order by the</span>
<span class="s0">#	       first elements</span>
<span class="s0">#	key - Value to search for</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the index of the greatest element in $list that is less than</span>
<span class="s0">#	or equal to $key.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::BSearch { list key } {</span>
    <span class="s0">if {[llength $list] == 0} {</span>
	<span class="s0">return -1</span>
    <span class="s0">}</span>
    <span class="s0">if { $key &lt; [lindex $list 0 0] } {</span>
	<span class="s0">return -1</span>
    <span class="s0">}</span>

    <span class="s0">set l 0</span>
    <span class="s0">set u [expr { [llength $list] - 1 }]</span>

    <span class="s0">while { $l &lt; $u } {</span>
	<span class="s0"># At this point, we know that</span>
	<span class="s0">#   $k &gt;= [lindex $list $l 0]</span>
	<span class="s0">#   Either $u == [llength $list] or else $k &lt; [lindex $list $u+1 0]</span>
	<span class="s0"># We find the midpoint of the interval {l,u} rounded UP, compare</span>
	<span class="s0"># against it, and set l or u to maintain the invariant.  Note that the</span>
	<span class="s0"># interval shrinks at each step, guaranteeing convergence.</span>

	<span class="s0">set m [expr { ( $l + $u + 1 ) / 2 }]</span>
	<span class="s0">if { $key &gt;= [lindex $list $m 0] } {</span>
	    <span class="s0">set l $m</span>
	<span class="s0">} else {</span>
	    <span class="s0">set u [expr { $m - 1 }]</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">return $l</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># clock add --</span>
<span class="s0">#</span>
<span class="s0">#	Adds an offset to a given time.</span>
<span class="s0">#</span>
<span class="s0"># Syntax:</span>
<span class="s0">#	clock add clockval ?count unit?... ?-option value?</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	clockval -- Starting time value</span>
<span class="s0">#	count -- Amount of a unit of time to add</span>
<span class="s0">#	unit -- Unit of time to add, must be one of:</span>
<span class="s0">#			years year months month weeks week</span>
<span class="s0">#			days day hours hour minutes minute</span>
<span class="s0">#			seconds second</span>
<span class="s0">#</span>
<span class="s0"># Options:</span>
<span class="s0">#	-gmt BOOLEAN</span>
<span class="s0">#		(Deprecated) Flag synonymous with '-timezone :GMT'</span>
<span class="s0">#	-timezone ZONE</span>
<span class="s0">#		Name of the time zone in which calculations are to be done.</span>
<span class="s0">#	-locale NAME</span>
<span class="s0">#		Name of the locale in which calculations are to be done.</span>
<span class="s0">#		Used to determine the Gregorian change date.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the given time adjusted by the given offset(s) in</span>
<span class="s0">#	order.</span>
<span class="s0">#</span>
<span class="s0"># Notes:</span>
<span class="s0">#	It is possible that adding a number of months or years will adjust the</span>
<span class="s0">#	day of the month as well.  For instance, the time at one month after</span>
<span class="s0">#	31 January is either 28 or 29 February, because February has fewer</span>
<span class="s0">#	than 31 days.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::add { clockval args } {</span>
    <span class="s0">if { [llength $args] % 2 != 0 } {</span>
	<span class="s0">set cmdName &quot;clock add&quot;</span>
	<span class="s0">return -code error \</span>
	    <span class="s0">-errorcode [list CLOCK wrongNumArgs] \</span>
	    <span class="s0">&quot;wrong \# args: should be\</span>
             <span class="s0">\&quot;$cmdName clockval ?number units?...\</span>
             <span class="s0">?-gmt boolean? ?-locale LOCALE? ?-timezone ZONE?\&quot;&quot;</span>
    <span class="s0">}</span>
    <span class="s0">if { [catch { expr {wide($clockval)} } result] } {</span>
	<span class="s0">return -code error $result</span>
    <span class="s0">}</span>

    <span class="s0">set offsets {}</span>
    <span class="s0">set gmt 0</span>
    <span class="s0">set locale c</span>
    <span class="s0">set timezone [GetSystemTimeZone]</span>

    <span class="s0">foreach { a b } $args {</span>
	<span class="s0">if { [string is integer -strict $a] } {</span>
	    <span class="s0">lappend offsets $a $b</span>
	<span class="s0">} else {</span>
	    <span class="s0">switch -exact -- $a {</span>
		<span class="s0">-g - -gm - -gmt {</span>
		    <span class="s0">set gmt $b</span>
		<span class="s0">}</span>
		<span class="s0">-l - -lo - -loc - -loca - -local - -locale {</span>
		    <span class="s0">set locale [string tolower $b]</span>
		<span class="s0">}</span>
		<span class="s0">-t - -ti - -tim - -time - -timez - -timezo - -timezon -</span>
		<span class="s0">-timezone {</span>
		    <span class="s0">set timezone $b</span>
		<span class="s0">}</span>
		<span class="s0">default {</span>
		    <span class="s0">throw [list CLOCK badOption $a] \</span>
			<span class="s0">&quot;bad option \&quot;$a\&quot;,\</span>
                         <span class="s0">must be -gmt, -locale or -timezone&quot;</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Check options for validity</span>

    <span class="s0">if { [info exists saw(-gmt)] &amp;&amp; [info exists saw(-timezone)] } {</span>
	<span class="s0">return -code error \</span>
	    <span class="s0">-errorcode [list CLOCK gmtWithTimezone] \</span>
	    <span class="s0">&quot;cannot use -gmt and -timezone in same call&quot;</span>
    <span class="s0">}</span>
    <span class="s0">if { [catch { expr { wide($clockval) } } result] } {</span>
	<span class="s0">return -code error &quot;expected integer but got \&quot;$clockval\&quot;&quot;</span>
    <span class="s0">}</span>
    <span class="s0">if { ![string is boolean -strict $gmt] } {</span>
	<span class="s0">return -code error &quot;expected boolean value but got \&quot;$gmt\&quot;&quot;</span>
    <span class="s0">} elseif { $gmt } {</span>
	<span class="s0">set timezone :GMT</span>
    <span class="s0">}</span>

    <span class="s0">EnterLocale $locale</span>

    <span class="s0">set changeover [mc GREGORIAN_CHANGE_DATE]</span>

    <span class="s0">if {[catch {SetupTimeZone $timezone} retval opts]} {</span>
	<span class="s0">dict unset opts -errorinfo</span>
	<span class="s0">return -options $opts $retval</span>
    <span class="s0">}</span>

    <span class="s0">try {</span>
	<span class="s0">foreach { quantity unit } $offsets {</span>
	    <span class="s0">switch -exact -- $unit {</span>
		<span class="s0">years - year {</span>
		    <span class="s0">set clockval [AddMonths [expr { 12 * $quantity }] \</span>
			    <span class="s0">$clockval $timezone $changeover]</span>
		<span class="s0">}</span>
		<span class="s0">months - month {</span>
		    <span class="s0">set clockval [AddMonths $quantity $clockval $timezone \</span>
			    <span class="s0">$changeover]</span>
		<span class="s0">}</span>

		<span class="s0">weeks - week {</span>
		    <span class="s0">set clockval [AddDays [expr { 7 * $quantity }] \</span>
			    <span class="s0">$clockval $timezone $changeover]</span>
		<span class="s0">}</span>
		<span class="s0">days - day {</span>
		    <span class="s0">set clockval [AddDays $quantity $clockval $timezone \</span>
			    <span class="s0">$changeover]</span>
		<span class="s0">}</span>

		<span class="s0">hours - hour {</span>
		    <span class="s0">set clockval [expr { 3600 * $quantity + $clockval }]</span>
		<span class="s0">}</span>
		<span class="s0">minutes - minute {</span>
		    <span class="s0">set clockval [expr { 60 * $quantity + $clockval }]</span>
		<span class="s0">}</span>
		<span class="s0">seconds - second {</span>
		    <span class="s0">set clockval [expr { $quantity + $clockval }]</span>
		<span class="s0">}</span>

		<span class="s0">default {</span>
		    <span class="s0">throw [list CLOCK badUnit $unit] \</span>
			<span class="s0">&quot;unknown unit \&quot;$unit\&quot;, must be \</span>
                        <span class="s0">years, months, weeks, days, hours, minutes or seconds&quot;</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">return $clockval</span>
    <span class="s0">} trap CLOCK {result opts} {</span>
	<span class="s0"># Conceal the innards of [clock] when it's an expected error</span>
	<span class="s0">dict unset opts -errorinfo</span>
	<span class="s0">return -options $opts $result</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># AddMonths --</span>
<span class="s0">#</span>
<span class="s0">#	Add a given number of months to a given clock value in a given</span>
<span class="s0">#	time zone.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	months - Number of months to add (may be negative)</span>
<span class="s0">#	clockval - Seconds since the epoch before the operation</span>
<span class="s0">#	timezone - Time zone in which the operation is to be performed</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the new clock value as a number of seconds since</span>
<span class="s0">#	the epoch.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::AddMonths { months clockval timezone changeover } {</span>
    <span class="s0">variable DaysInRomanMonthInCommonYear</span>
    <span class="s0">variable DaysInRomanMonthInLeapYear</span>
    <span class="s0">variable TZData</span>

    <span class="s0"># Convert the time to year, month, day, and fraction of day.</span>

    <span class="s0">set date [GetDateFields $clockval $TZData($timezone) $changeover]</span>
    <span class="s0">dict set date secondOfDay [expr {</span>
	<span class="s0">[dict get $date localSeconds] % 86400</span>
    <span class="s0">}]</span>
    <span class="s0">dict set date tzName $timezone</span>

    <span class="s0"># Add the requisite number of months</span>

    <span class="s0">set m [dict get $date month]</span>
    <span class="s0">incr m $months</span>
    <span class="s0">incr m -1</span>
    <span class="s0">set delta [expr { $m / 12 }]</span>
    <span class="s0">set mm [expr { $m % 12 }]</span>
    <span class="s0">dict set date month [expr { $mm + 1 }]</span>
    <span class="s0">dict incr date year $delta</span>

    <span class="s0"># If the date doesn't exist in the current month, repair it</span>

    <span class="s0">if { [IsGregorianLeapYear $date] } {</span>
	<span class="s0">set hath [lindex $DaysInRomanMonthInLeapYear $mm]</span>
    <span class="s0">} else {</span>
	<span class="s0">set hath [lindex $DaysInRomanMonthInCommonYear $mm]</span>
    <span class="s0">}</span>
    <span class="s0">if { [dict get $date dayOfMonth] &gt; $hath } {</span>
	<span class="s0">dict set date dayOfMonth $hath</span>
    <span class="s0">}</span>

    <span class="s0"># Reconvert to a number of seconds</span>

    <span class="s0">set date [GetJulianDayFromEraYearMonthDay \</span>
		  <span class="s0">$date[set date {}]\</span>
		  <span class="s0">$changeover]</span>
    <span class="s0">dict set date localSeconds [expr {</span>
	<span class="s0">-210866803200</span>
	<span class="s0">+ ( 86400 * wide([dict get $date julianDay]) )</span>
	<span class="s0">+ [dict get $date secondOfDay]</span>
    <span class="s0">}]</span>
    <span class="s0">set date [ConvertLocalToUTC $date[set date {}] $TZData($timezone) \</span>
		 <span class="s0">$changeover]</span>

    <span class="s0">return [dict get $date seconds]</span>

<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># AddDays --</span>
<span class="s0">#</span>
<span class="s0">#	Add a given number of days to a given clock value in a given time</span>
<span class="s0">#	zone.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	days - Number of days to add (may be negative)</span>
<span class="s0">#	clockval - Seconds since the epoch before the operation</span>
<span class="s0">#	timezone - Time zone in which the operation is to be performed</span>
<span class="s0">#	changeover - Julian Day on which the Gregorian calendar was adopted</span>
<span class="s0">#		     in the target locale.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	Returns the new clock value as a number of seconds since the epoch.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::AddDays { days clockval timezone changeover } {</span>
    <span class="s0">variable TZData</span>

    <span class="s0"># Convert the time to Julian Day</span>

    <span class="s0">set date [GetDateFields $clockval $TZData($timezone) $changeover]</span>
    <span class="s0">dict set date secondOfDay [expr {</span>
	<span class="s0">[dict get $date localSeconds] % 86400</span>
    <span class="s0">}]</span>
    <span class="s0">dict set date tzName $timezone</span>

    <span class="s0"># Add the requisite number of days</span>

    <span class="s0">dict incr date julianDay $days</span>

    <span class="s0"># Reconvert to a number of seconds</span>

    <span class="s0">dict set date localSeconds [expr {</span>
	<span class="s0">-210866803200</span>
	<span class="s0">+ ( 86400 * wide([dict get $date julianDay]) )</span>
	<span class="s0">+ [dict get $date secondOfDay]</span>
    <span class="s0">}]</span>
    <span class="s0">set date [ConvertLocalToUTC $date[set date {}] $TZData($timezone) \</span>
		  <span class="s0">$changeover]</span>

    <span class="s0">return [dict get $date seconds]</span>

<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># ChangeCurrentLocale --</span>
<span class="s0">#</span>
<span class="s0">#        The global locale was changed within msgcat.</span>
<span class="s0">#        Clears the buffered parse functions of the current locale.</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#        loclist (ignored)</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#        None.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#        Buffered parse functions are cleared.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::ChangeCurrentLocale {args} {</span>
    <span class="s0">variable FormatProc</span>
    <span class="s0">variable LocaleNumeralCache</span>
    <span class="s0">variable CachedSystemTimeZone</span>
    <span class="s0">variable TimeZoneBad</span>

    <span class="s0">foreach p [info procs [namespace current]::scanproc'*'current] {</span>
        <span class="s0">rename $p {}</span>
    <span class="s0">}</span>
    <span class="s0">foreach p [info procs [namespace current]::formatproc'*'current] {</span>
        <span class="s0">rename $p {}</span>
    <span class="s0">}</span>

    <span class="s0">catch {array unset FormatProc *'current}</span>
    <span class="s0">set LocaleNumeralCache {}</span>
<span class="s0">}</span>

<span class="s0">#----------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># ClearCaches --</span>
<span class="s0">#</span>
<span class="s0">#	Clears all caches to reclaim the memory used in [clock]</span>
<span class="s0">#</span>
<span class="s0"># Parameters:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># Results:</span>
<span class="s0">#	None.</span>
<span class="s0">#</span>
<span class="s0"># Side effects:</span>
<span class="s0">#	Caches are cleared.</span>
<span class="s0">#</span>
<span class="s0">#----------------------------------------------------------------------</span>

<span class="s0">proc ::tcl::clock::ClearCaches {} {</span>
    <span class="s0">variable FormatProc</span>
    <span class="s0">variable LocaleNumeralCache</span>
    <span class="s0">variable CachedSystemTimeZone</span>
    <span class="s0">variable TimeZoneBad</span>

    <span class="s0">foreach p [info procs [namespace current]::scanproc'*] {</span>
	<span class="s0">rename $p {}</span>
    <span class="s0">}</span>
    <span class="s0">foreach p [info procs [namespace current]::formatproc'*] {</span>
	<span class="s0">rename $p {}</span>
    <span class="s0">}</span>

    <span class="s0">catch {unset FormatProc}</span>
    <span class="s0">set LocaleNumeralCache {}</span>
    <span class="s0">catch {unset CachedSystemTimeZone}</span>
    <span class="s0">set TimeZoneBad {}</span>
    <span class="s0">InitTZData</span>
<span class="s0">}</span>
</pre>
</body>
</html>