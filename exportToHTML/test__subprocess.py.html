<html>
<head>
<title>test__subprocess.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #a5c261;}
.s6 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test__subprocess.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">errno</span>
<span class="s0">import </span><span class="s1">unittest</span>

<span class="s0">import </span><span class="s1">time</span>
<span class="s0">import </span><span class="s1">tempfile</span>

<span class="s0">import </span><span class="s1">gevent.testing </span><span class="s0">as </span><span class="s1">greentest</span>
<span class="s0">import </span><span class="s1">gevent</span>
<span class="s0">from </span><span class="s1">gevent.testing </span><span class="s0">import </span><span class="s1">mock</span>
<span class="s0">from </span><span class="s1">gevent </span><span class="s0">import </span><span class="s1">subprocess</span>

<span class="s0">if not </span><span class="s1">hasattr(subprocess</span><span class="s0">, </span><span class="s2">'mswindows'</span><span class="s1">):</span>
    <span class="s3"># PyPy3, native python subprocess</span>
    <span class="s1">subprocess.mswindows = </span><span class="s0">False</span>


<span class="s1">PYPY = hasattr(sys</span><span class="s0">, </span><span class="s2">'pypy_version_info'</span><span class="s1">)</span>
<span class="s1">PY3 = sys.version_info[</span><span class="s4">0</span><span class="s1">] &gt;= </span><span class="s4">3</span>


<span class="s0">if </span><span class="s1">subprocess.mswindows:</span>
    <span class="s1">SETBINARY = </span><span class="s2">'import msvcrt; msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY);'</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">SETBINARY = </span><span class="s2">''</span>


<span class="s1">python_universal_newlines = hasattr(sys.stdout</span><span class="s0">, </span><span class="s2">'newlines'</span><span class="s1">)</span>
<span class="s3"># The stdlib of Python 3 on Windows doesn't properly handle universal newlines</span>
<span class="s3"># (it produces broken results compared to Python 2)</span>
<span class="s3"># See gevent.subprocess for more details.</span>
<span class="s1">python_universal_newlines_broken = PY3 </span><span class="s0">and </span><span class="s1">subprocess.mswindows</span>

<span class="s1">@greentest.skipWithoutResource(</span><span class="s2">'subprocess'</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">TestPopen(greentest.TestCase):</span>

    <span class="s3"># Use the normal error handling. Make sure that any background greenlets</span>
    <span class="s3"># subprocess spawns propagate errors as expected.</span>
    <span class="s1">error_fatal = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">test_exit(self):</span>
        <span class="s1">popen = subprocess.Popen([sys.executable</span><span class="s0">, </span><span class="s2">'-c'</span><span class="s0">, </span><span class="s2">'import sys; sys.exit(10)'</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(popen.wait()</span><span class="s0">, </span><span class="s4">10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_wait(self):</span>
        <span class="s1">popen = subprocess.Popen([sys.executable</span><span class="s0">, </span><span class="s2">'-c'</span><span class="s0">, </span><span class="s2">'import sys; sys.exit(11)'</span><span class="s1">])</span>
        <span class="s1">gevent.wait([popen])</span>
        <span class="s1">self.assertEqual(popen.poll()</span><span class="s0">, </span><span class="s4">11</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_child_exception(self):</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(OSError) </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s1">subprocess.Popen([</span><span class="s2">'*'</span><span class="s1">]).wait()</span>

        <span class="s1">self.assertEqual(exc.exception.errno</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_leak(self):</span>
        <span class="s1">num_before = greentest.get_number_open_files()</span>
        <span class="s1">p = subprocess.Popen([sys.executable</span><span class="s0">, </span><span class="s2">&quot;-c&quot;</span><span class="s0">, </span><span class="s2">&quot;print()&quot;</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s1">stdout=subprocess.PIPE)</span>
        <span class="s1">p.wait()</span>
        <span class="s1">p.stdout.close()</span>
        <span class="s0">del </span><span class="s1">p</span>

        <span class="s1">num_after = greentest.get_number_open_files()</span>
        <span class="s1">self.assertEqual(num_before</span><span class="s0">, </span><span class="s1">num_after)</span>

    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s2">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_communicate(self):</span>
        <span class="s1">p = subprocess.Popen([sys.executable</span><span class="s0">, </span><span class="s2">&quot;-W&quot;</span><span class="s0">, </span><span class="s2">&quot;ignore&quot;</span><span class="s0">,</span>
                              <span class="s2">&quot;-c&quot;</span><span class="s0">,</span>
                              <span class="s2">'import sys,os;'</span>
                              <span class="s2">'sys.stderr.write(&quot;pineapple&quot;);'</span>
                              <span class="s2">'sys.stdout.write(sys.stdin.read())'</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s1">stdin=subprocess.PIPE</span><span class="s0">,</span>
                             <span class="s1">stdout=subprocess.PIPE</span><span class="s0">,</span>
                             <span class="s1">stderr=subprocess.PIPE)</span>
        <span class="s1">(stdout</span><span class="s0">, </span><span class="s1">stderr) = p.communicate(</span><span class="s5">b&quot;banana&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(stdout</span><span class="s0">, </span><span class="s5">b&quot;banana&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">sys.executable.endswith(</span><span class="s2">'-dbg'</span><span class="s1">):</span>
            <span class="s0">assert </span><span class="s1">stderr.startswith(</span><span class="s5">b'pineapple'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.assertEqual(stderr</span><span class="s0">, </span><span class="s5">b&quot;pineapple&quot;</span><span class="s1">)</span>

    <span class="s1">@greentest.skipIf(subprocess.mswindows</span><span class="s0">,</span>
                      <span class="s2">&quot;Windows does weird things here&quot;</span><span class="s1">)</span>
    <span class="s1">@greentest.skipOnLibuvOnCIOnPyPy(</span><span class="s2">&quot;Sometimes segfaults&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_communicate_universal(self):</span>
        <span class="s3"># Native string all the things. See https://github.com/gevent/gevent/issues/1039</span>
        <span class="s1">p = subprocess.Popen(</span>
            <span class="s1">[</span>
                <span class="s1">sys.executable</span><span class="s0">,</span>
                <span class="s2">&quot;-W&quot;</span><span class="s0">, </span><span class="s2">&quot;ignore&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;-c&quot;</span><span class="s0">,</span>
                <span class="s2">'import sys,os;'</span>
                <span class="s2">'sys.stderr.write(&quot;pineapple</span><span class="s0">\\</span><span class="s2">r</span><span class="s0">\\</span><span class="s2">n</span><span class="s0">\\</span><span class="s2">xff</span><span class="s0">\\</span><span class="s2">xff</span><span class="s0">\\</span><span class="s2">xf2</span><span class="s0">\\</span><span class="s2">xf9</span><span class="s0">\\</span><span class="s2">r</span><span class="s0">\\</span><span class="s2">n&quot;);'</span>
                <span class="s2">'sys.stdout.write(sys.stdin.read())'</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">stdin=subprocess.PIPE</span><span class="s0">,</span>
            <span class="s1">stdout=subprocess.PIPE</span><span class="s0">,</span>
            <span class="s1">stderr=subprocess.PIPE</span><span class="s0">,</span>
            <span class="s1">universal_newlines=</span><span class="s0">True</span>
        <span class="s1">)</span>
        <span class="s1">(stdout</span><span class="s0">, </span><span class="s1">stderr) = p.communicate(</span><span class="s2">'banana</span><span class="s0">\r\n\xff\xff\xf2\xf9\r\n</span><span class="s2">'</span><span class="s1">)</span>
        <span class="s1">self.assertIsInstance(stdout</span><span class="s0">, </span><span class="s1">str)</span>
        <span class="s1">self.assertIsInstance(stderr</span><span class="s0">, </span><span class="s1">str)</span>
        <span class="s1">self.assertEqual(stdout</span><span class="s0">,</span>
                         <span class="s2">'banana</span><span class="s0">\n\xff\xff\xf2\xf9\n</span><span class="s2">'</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(stderr</span><span class="s0">,</span>
                         <span class="s2">'pineapple</span><span class="s0">\n\xff\xff\xf2\xf9\n</span><span class="s2">'</span><span class="s1">)</span>

    <span class="s1">@greentest.skipOnWindows(</span><span class="s2">&quot;Windows IO is weird; this doesn't raise&quot;</span><span class="s1">)</span>
    <span class="s1">@greentest.skipOnPy2(</span><span class="s2">&quot;Only Python 2 decodes&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_communicate_undecodable(self):</span>
        <span class="s3"># If the subprocess writes non-decodable data, `communicate` raises the</span>
        <span class="s3"># same UnicodeDecodeError that the stdlib does, instead of</span>
        <span class="s3"># printing it to the hub. This only applies to Python 3, because only it</span>
        <span class="s3"># will actually use text mode.</span>
        <span class="s3"># See https://github.com/gevent/gevent/issues/1510</span>
        <span class="s0">with </span><span class="s1">subprocess.Popen(</span>
                <span class="s1">[</span>
                    <span class="s1">sys.executable</span><span class="s0">,</span>
                    <span class="s2">'-W'</span><span class="s0">, </span><span class="s2">'ignore'</span><span class="s0">,</span>
                    <span class="s2">'-c'</span><span class="s0">,</span>
                    <span class="s2">&quot;import os, sys; &quot;</span>
                    <span class="s2">r'os.write(sys.stdout.fileno(), b&quot;\xff&quot;)'</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s1">stdin=subprocess.PIPE</span><span class="s0">, </span><span class="s1">stdout=subprocess.PIPE</span><span class="s0">,</span>
                <span class="s1">stderr=subprocess.PIPE</span><span class="s0">,</span>
                <span class="s1">text=</span><span class="s0">True, </span><span class="s1">universal_newlines=</span><span class="s0">True</span>
        <span class="s1">) </span><span class="s0">as </span><span class="s1">p:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(UnicodeDecodeError):</span>
                <span class="s1">p.communicate()</span>

    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s2">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_universal1(self):</span>
        <span class="s0">with </span><span class="s1">subprocess.Popen(</span>
                <span class="s1">[</span>
                    <span class="s1">sys.executable</span><span class="s0">, </span><span class="s2">&quot;-c&quot;</span><span class="s0">,</span>
                    <span class="s2">'import sys,os;' </span><span class="s1">+ SETBINARY +</span>
                    <span class="s2">'sys.stdout.write(&quot;line1</span><span class="s0">\\</span><span class="s2">n&quot;);'</span>
                    <span class="s2">'sys.stdout.flush();'</span>
                    <span class="s2">'sys.stdout.write(&quot;line2</span><span class="s0">\\</span><span class="s2">r&quot;);'</span>
                    <span class="s2">'sys.stdout.flush();'</span>
                    <span class="s2">'sys.stdout.write(&quot;line3</span><span class="s0">\\</span><span class="s2">r</span><span class="s0">\\</span><span class="s2">n&quot;);'</span>
                    <span class="s2">'sys.stdout.flush();'</span>
                    <span class="s2">'sys.stdout.write(&quot;line4</span><span class="s0">\\</span><span class="s2">r&quot;);'</span>
                    <span class="s2">'sys.stdout.flush();'</span>
                    <span class="s2">'sys.stdout.write(&quot;</span><span class="s0">\\</span><span class="s2">nline5&quot;);'</span>
                    <span class="s2">'sys.stdout.flush();'</span>
                    <span class="s2">'sys.stdout.write(&quot;</span><span class="s0">\\</span><span class="s2">nline6&quot;);'</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s1">stdout=subprocess.PIPE</span><span class="s0">,</span>
                <span class="s1">universal_newlines=</span><span class="s4">1</span><span class="s0">,</span>
                <span class="s1">bufsize=</span><span class="s4">1</span>
        <span class="s1">) </span><span class="s0">as </span><span class="s1">p:</span>
            <span class="s1">stdout = p.stdout.read()</span>
            <span class="s0">if </span><span class="s1">python_universal_newlines:</span>
                <span class="s3"># Interpreter with universal newline support</span>
                <span class="s0">if not </span><span class="s1">python_universal_newlines_broken:</span>
                    <span class="s1">self.assertEqual(stdout</span><span class="s0">,</span>
                                     <span class="s2">&quot;line1</span><span class="s0">\n</span><span class="s2">line2</span><span class="s0">\n</span><span class="s2">line3</span><span class="s0">\n</span><span class="s2">line4</span><span class="s0">\n</span><span class="s2">line5</span><span class="s0">\n</span><span class="s2">line6&quot;</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s3"># Note the extra newline after line 3</span>
                    <span class="s1">self.assertEqual(stdout</span><span class="s0">,</span>
                                     <span class="s2">'line1</span><span class="s0">\n</span><span class="s2">line2</span><span class="s0">\n</span><span class="s2">line3</span><span class="s0">\n\n</span><span class="s2">line4</span><span class="s0">\n\n</span><span class="s2">line5</span><span class="s0">\n</span><span class="s2">line6'</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># Interpreter without universal newline support</span>
                <span class="s1">self.assertEqual(stdout</span><span class="s0">,</span>
                                 <span class="s2">&quot;line1</span><span class="s0">\n</span><span class="s2">line2</span><span class="s0">\r</span><span class="s2">line3</span><span class="s0">\r\n</span><span class="s2">line4</span><span class="s0">\r\n</span><span class="s2">line5</span><span class="s0">\n</span><span class="s2">line6&quot;</span><span class="s1">)</span>

    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s2">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_universal2(self):</span>
        <span class="s0">with </span><span class="s1">subprocess.Popen(</span>
                <span class="s1">[</span>
                    <span class="s1">sys.executable</span><span class="s0">, </span><span class="s2">&quot;-c&quot;</span><span class="s0">,</span>
                    <span class="s2">'import sys,os;' </span><span class="s1">+ SETBINARY +</span>
                    <span class="s2">'sys.stdout.write(&quot;line1</span><span class="s0">\\</span><span class="s2">n&quot;);'</span>
                    <span class="s2">'sys.stdout.flush();'</span>
                    <span class="s2">'sys.stdout.write(&quot;line2</span><span class="s0">\\</span><span class="s2">r&quot;);'</span>
                    <span class="s2">'sys.stdout.flush();'</span>
                    <span class="s2">'sys.stdout.write(&quot;line3</span><span class="s0">\\</span><span class="s2">r</span><span class="s0">\\</span><span class="s2">n&quot;);'</span>
                    <span class="s2">'sys.stdout.flush();'</span>
                    <span class="s2">'sys.stdout.write(&quot;line4</span><span class="s0">\\</span><span class="s2">r</span><span class="s0">\\</span><span class="s2">nline5&quot;);'</span>
                    <span class="s2">'sys.stdout.flush();'</span>
                    <span class="s2">'sys.stdout.write(&quot;</span><span class="s0">\\</span><span class="s2">nline6&quot;);'</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s1">stdout=subprocess.PIPE</span><span class="s0">,</span>
                <span class="s1">universal_newlines=</span><span class="s4">1</span><span class="s0">,</span>
                <span class="s1">bufsize=</span><span class="s4">1</span>
        <span class="s1">) </span><span class="s0">as </span><span class="s1">p:</span>
            <span class="s1">stdout = p.stdout.read()</span>
            <span class="s0">if </span><span class="s1">python_universal_newlines:</span>
                <span class="s3"># Interpreter with universal newline support</span>
                <span class="s0">if not </span><span class="s1">python_universal_newlines_broken:</span>
                    <span class="s1">self.assertEqual(stdout</span><span class="s0">,</span>
                                     <span class="s2">&quot;line1</span><span class="s0">\n</span><span class="s2">line2</span><span class="s0">\n</span><span class="s2">line3</span><span class="s0">\n</span><span class="s2">line4</span><span class="s0">\n</span><span class="s2">line5</span><span class="s0">\n</span><span class="s2">line6&quot;</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s3"># Note the extra newline after line 3</span>
                    <span class="s1">self.assertEqual(stdout</span><span class="s0">,</span>
                                     <span class="s2">'line1</span><span class="s0">\n</span><span class="s2">line2</span><span class="s0">\n</span><span class="s2">line3</span><span class="s0">\n\n</span><span class="s2">line4</span><span class="s0">\n\n</span><span class="s2">line5</span><span class="s0">\n</span><span class="s2">line6'</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># Interpreter without universal newline support</span>
                <span class="s1">self.assertEqual(stdout</span><span class="s0">,</span>
                                 <span class="s2">&quot;line1</span><span class="s0">\n</span><span class="s2">line2</span><span class="s0">\r</span><span class="s2">line3</span><span class="s0">\r\n</span><span class="s2">line4</span><span class="s0">\r\n</span><span class="s2">line5</span><span class="s0">\n</span><span class="s2">line6&quot;</span><span class="s1">)</span>

    <span class="s1">@greentest.skipOnWindows(</span><span class="s2">&quot;Uses 'grep' command&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_nonblock_removed(self):</span>
        <span class="s3"># see issue #134</span>
        <span class="s1">r</span><span class="s0">, </span><span class="s1">w = os.pipe()</span>
        <span class="s1">stdin = subprocess.FileObject(r)</span>
        <span class="s0">with </span><span class="s1">subprocess.Popen([</span><span class="s2">'grep'</span><span class="s0">, </span><span class="s2">'text'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">stdin=stdin) </span><span class="s0">as </span><span class="s1">p:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s3"># Closing one half of the pipe causes Python 3 on OS X to terminate the</span>
                <span class="s3"># child process; it exits with code 1 and the assert that p.poll is None</span>
                <span class="s3"># fails. Removing the close lets it pass under both Python 3 and 2.7.</span>
                <span class="s3"># If subprocess.Popen._remove_nonblock_flag is changed to a noop, then</span>
                <span class="s3"># the test fails (as expected) even with the close removed</span>
                <span class="s3">#os.close(w)</span>
                <span class="s1">time.sleep(</span><span class="s4">0.1</span><span class="s1">)</span>
                <span class="s1">self.assertEqual(p.poll()</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">p.poll() </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">p.kill()</span>
                <span class="s1">stdin.close()</span>
                <span class="s1">os.close(w)</span>

    <span class="s0">def </span><span class="s1">test_issue148(self):</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">7</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(OSError) </span><span class="s0">as </span><span class="s1">exc:</span>
                <span class="s0">with </span><span class="s1">subprocess.Popen(</span><span class="s2">'this_name_must_not_exist'</span><span class="s1">):</span>
                    <span class="s0">pass</span>

            <span class="s1">self.assertEqual(exc.exception.errno</span><span class="s0">, </span><span class="s1">errno.ENOENT)</span>

    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s2">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_check_output_keyword_error(self):</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(subprocess.CalledProcessError) </span><span class="s0">as </span><span class="s1">exc: </span><span class="s3"># pylint:disable=no-member</span>
            <span class="s1">subprocess.check_output([sys.executable</span><span class="s0">, </span><span class="s2">'-c'</span><span class="s0">, </span><span class="s2">'import sys; sys.exit(44)'</span><span class="s1">])</span>

        <span class="s1">self.assertEqual(exc.exception.returncode</span><span class="s0">, </span><span class="s4">44</span><span class="s1">)</span>

    <span class="s1">@greentest.skipOnPy3(</span><span class="s2">&quot;The default buffer changed in Py3&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_popen_bufsize(self):</span>
        <span class="s3"># Test that subprocess has unbuffered output by default</span>
        <span class="s3"># (as the vanilla subprocess module)</span>
        <span class="s0">with </span><span class="s1">subprocess.Popen(</span>
                <span class="s1">[sys.executable</span><span class="s0">, </span><span class="s2">'-u'</span><span class="s0">, </span><span class="s2">'-c'</span><span class="s0">,</span>
                 <span class="s2">'import sys; sys.stdout.write(sys.stdin.readline())'</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">stdin=subprocess.PIPE</span><span class="s0">, </span><span class="s1">stdout=subprocess.PIPE</span>
        <span class="s1">) </span><span class="s0">as </span><span class="s1">p:</span>
            <span class="s1">p.stdin.write(</span><span class="s5">b'foobar</span><span class="s0">\n</span><span class="s5">'</span><span class="s1">)</span>
            <span class="s1">r = p.stdout.readline()</span>
        <span class="s1">self.assertEqual(r</span><span class="s0">, </span><span class="s5">b'foobar</span><span class="s0">\n</span><span class="s5">'</span><span class="s1">)</span>

    <span class="s1">@greentest.ignores_leakcheck</span>
    <span class="s1">@greentest.skipOnWindows(</span><span class="s2">&quot;Not sure why?&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_subprocess_in_native_thread(self):</span>
        <span class="s3"># gevent.subprocess doesn't work from a background</span>
        <span class="s3"># native thread. See #688</span>
        <span class="s0">from </span><span class="s1">gevent </span><span class="s0">import </span><span class="s1">monkey</span>

        <span class="s3"># must be a native thread; defend against monkey-patching</span>
        <span class="s1">ex = []</span>
        <span class="s1">Thread = monkey.get_original(</span><span class="s2">'threading'</span><span class="s0">, </span><span class="s2">'Thread'</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">fn():</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError) </span><span class="s0">as </span><span class="s1">exc:</span>
                <span class="s1">gevent.subprocess.Popen(</span><span class="s2">'echo 123'</span><span class="s0">, </span><span class="s1">shell=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">ex.append(exc.exception)</span>

        <span class="s1">thread = Thread(target=fn)</span>
        <span class="s1">thread.start()</span>
        <span class="s1">thread.join()</span>

        <span class="s1">self.assertEqual(len(ex)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(isinstance(ex[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">TypeError)</span><span class="s0">, </span><span class="s1">ex)</span>
        <span class="s1">self.assertEqual(ex[</span><span class="s4">0</span><span class="s1">].args[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'child watchers are only available on the default loop'</span><span class="s1">)</span>


    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s2">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">__test_no_output(self</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">kind):</span>
        <span class="s0">with </span><span class="s1">subprocess.Popen(</span>
                <span class="s1">[sys.executable</span><span class="s0">, </span><span class="s2">'-c'</span><span class="s0">, </span><span class="s2">'pass'</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">stdout=subprocess.PIPE</span><span class="s0">,</span>
                <span class="s1">**kwargs</span>
        <span class="s1">) </span><span class="s0">as </span><span class="s1">proc:</span>
            <span class="s1">stdout</span><span class="s0">, </span><span class="s1">stderr = proc.communicate()</span>

        <span class="s1">self.assertIsInstance(stdout</span><span class="s0">, </span><span class="s1">kind)</span>
        <span class="s1">self.assertIsNone(stderr)</span>

    <span class="s1">@greentest.skipOnLibuvOnCIOnPyPy(</span><span class="s2">&quot;Sometimes segfaults; &quot;</span>
                                     <span class="s2">&quot;https://travis-ci.org/gevent/gevent/jobs/327357682&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_universal_newlines_text_mode_no_output_is_always_str(self):</span>
        <span class="s3"># If the file is in universal_newlines mode, we should always get a str when</span>
        <span class="s3"># there is no output.</span>
        <span class="s3"># https://github.com/gevent/gevent/pull/939</span>
        <span class="s1">self.__test_no_output({</span><span class="s2">'universal_newlines'</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span><span class="s0">, </span><span class="s1">str)</span>

    <span class="s1">@greentest.skipIf(sys.version_info[:</span><span class="s4">2</span><span class="s1">] &lt; (</span><span class="s4">3</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;Need encoding argument&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_encoded_text_mode_no_output_is_str(self):</span>
        <span class="s3"># If the file is in universal_newlines mode, we should always get a str when</span>
        <span class="s3"># there is no output.</span>
        <span class="s3"># https://github.com/gevent/gevent/pull/939</span>
        <span class="s1">self.__test_no_output({</span><span class="s2">'encoding'</span><span class="s1">: </span><span class="s2">'utf-8'</span><span class="s1">}</span><span class="s0">, </span><span class="s1">str)</span>

    <span class="s0">def </span><span class="s1">test_default_mode_no_output_is_always_str(self):</span>
        <span class="s3"># If the file is in default mode, we should always get a str when</span>
        <span class="s3"># there is no output.</span>
        <span class="s3"># https://github.com/gevent/gevent/pull/939</span>
        <span class="s1">self.__test_no_output({}</span><span class="s0">, </span><span class="s1">bytes)</span>

<span class="s1">@greentest.skipOnWindows(</span><span class="s2">&quot;Testing POSIX fd closing&quot;</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">TestFDs(unittest.TestCase):</span>

    <span class="s1">@mock.patch(</span><span class="s2">'os.closerange'</span><span class="s1">)</span>
    <span class="s1">@mock.patch(</span><span class="s2">'gevent.subprocess._set_inheritable'</span><span class="s1">)</span>
    <span class="s1">@mock.patch(</span><span class="s2">'os.close'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_close_fds_brute_force(self</span><span class="s0">, </span><span class="s1">close</span><span class="s0">, </span><span class="s1">set_inheritable</span><span class="s0">, </span><span class="s1">closerange):</span>
        <span class="s1">keep = (</span>
            <span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">,</span>
            <span class="s3"># Leave a hole</span>
            <span class="s3"># 6,</span>
            <span class="s4">7</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">subprocess.Popen._close_fds_brute_force(keep</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s1">closerange.assert_has_calls([</span>
            <span class="s1">mock.call(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">mock.call(</span><span class="s4">8</span><span class="s0">, </span><span class="s1">subprocess.MAXFD)</span><span class="s0">,</span>
        <span class="s1">])</span>

        <span class="s1">set_inheritable.assert_has_calls([</span>
            <span class="s1">mock.call(</span><span class="s4">4</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">mock.call(</span><span class="s4">5</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">])</span>

        <span class="s1">close.assert_called_once_with(</span><span class="s4">6</span><span class="s1">)</span>

    <span class="s1">@mock.patch(</span><span class="s2">'gevent.subprocess.Popen._close_fds_brute_force'</span><span class="s1">)</span>
    <span class="s1">@mock.patch(</span><span class="s2">'os.listdir'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_close_fds_from_path_bad_values(self</span><span class="s0">, </span><span class="s1">listdir</span><span class="s0">, </span><span class="s1">brute_force):</span>
        <span class="s1">listdir.return_value = </span><span class="s2">'Not an Integer'</span>

        <span class="s1">subprocess.Popen._close_fds_from_path(</span><span class="s2">'path'</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s4">42</span><span class="s1">)</span>
        <span class="s1">brute_force.assert_called_once_with([]</span><span class="s0">, </span><span class="s4">42</span><span class="s1">)</span>

    <span class="s1">@mock.patch(</span><span class="s2">'os.listdir'</span><span class="s1">)</span>
    <span class="s1">@mock.patch(</span><span class="s2">'os.closerange'</span><span class="s1">)</span>
    <span class="s1">@mock.patch(</span><span class="s2">'gevent.subprocess._set_inheritable'</span><span class="s1">)</span>
    <span class="s1">@mock.patch(</span><span class="s2">'os.close'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_close_fds_from_path(self</span><span class="s0">, </span><span class="s1">close</span><span class="s0">, </span><span class="s1">set_inheritable</span><span class="s0">, </span><span class="s1">closerange</span><span class="s0">, </span><span class="s1">listdir):</span>
        <span class="s1">keep = (</span>
            <span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">,</span>
            <span class="s3"># Leave a hole</span>
            <span class="s3"># 6,</span>
            <span class="s4">7</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">listdir.return_value = [</span><span class="s2">'1'</span><span class="s0">, </span><span class="s2">'6'</span><span class="s0">, </span><span class="s2">'37'</span><span class="s1">]</span>

        <span class="s1">subprocess.Popen._close_fds_from_path(</span><span class="s2">'path'</span><span class="s0">, </span><span class="s1">keep</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span>

        <span class="s1">self.assertEqual([]</span><span class="s0">, </span><span class="s1">closerange.mock_calls)</span>

        <span class="s1">set_inheritable.assert_has_calls([</span>
            <span class="s1">mock.call(</span><span class="s4">4</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">mock.call(</span><span class="s4">7</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">])</span>

        <span class="s1">close.assert_has_calls([</span>
            <span class="s1">mock.call(</span><span class="s4">6</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">mock.call(</span><span class="s4">37</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">])</span>

    <span class="s1">@mock.patch(</span><span class="s2">'gevent.subprocess.Popen._close_fds_brute_force'</span><span class="s1">)</span>
    <span class="s1">@mock.patch(</span><span class="s2">'os.path.isdir'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_close_fds_no_dir(self</span><span class="s0">, </span><span class="s1">isdir</span><span class="s0">, </span><span class="s1">brute_force):</span>
        <span class="s1">isdir.return_value = </span><span class="s0">False</span>

        <span class="s1">subprocess.Popen._close_fds([]</span><span class="s0">, </span><span class="s4">42</span><span class="s1">)</span>
        <span class="s1">brute_force.assert_called_once_with([]</span><span class="s0">, </span><span class="s4">42</span><span class="s1">)</span>
        <span class="s1">isdir.assert_has_calls([</span>
            <span class="s1">mock.call(</span><span class="s2">'/proc/self/fd'</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">mock.call(</span><span class="s2">'/dev/fd'</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">])</span>

    <span class="s1">@mock.patch(</span><span class="s2">'gevent.subprocess.Popen._close_fds_from_path'</span><span class="s1">)</span>
    <span class="s1">@mock.patch(</span><span class="s2">'gevent.subprocess.Popen._close_fds_brute_force'</span><span class="s1">)</span>
    <span class="s1">@mock.patch(</span><span class="s2">'os.path.isdir'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_close_fds_with_dir(self</span><span class="s0">, </span><span class="s1">isdir</span><span class="s0">, </span><span class="s1">brute_force</span><span class="s0">, </span><span class="s1">from_path):</span>
        <span class="s1">isdir.return_value = </span><span class="s0">True</span>

        <span class="s1">subprocess.Popen._close_fds([</span><span class="s4">7</span><span class="s1">]</span><span class="s0">, </span><span class="s4">42</span><span class="s1">)</span>

        <span class="s1">self.assertEqual([]</span><span class="s0">, </span><span class="s1">brute_force.mock_calls)</span>
        <span class="s1">from_path.assert_called_once_with(</span><span class="s2">'/proc/self/fd'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">7</span><span class="s1">]</span><span class="s0">, </span><span class="s4">42</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">RunFuncTestCase(greentest.TestCase):</span>
    <span class="s3"># Based on code from python 3.6+</span>

    <span class="s1">__timeout__ = greentest.LARGE_TIMEOUT</span>

    <span class="s1">@greentest.skipWithoutResource(</span><span class="s2">'subprocess'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">run_python(self</span><span class="s0">, </span><span class="s1">code</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s6">&quot;&quot;&quot;Run Python code in a subprocess using subprocess.run&quot;&quot;&quot;</span>
        <span class="s1">argv = [sys.executable</span><span class="s0">, </span><span class="s2">&quot;-c&quot;</span><span class="s0">, </span><span class="s1">code]</span>
        <span class="s0">return </span><span class="s1">subprocess.run(argv</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_returncode(self):</span>
        <span class="s3"># call() function with sequence argument</span>
        <span class="s1">cp = self.run_python(</span><span class="s2">&quot;import sys; sys.exit(47)&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(cp.returncode</span><span class="s0">, </span><span class="s4">47</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(subprocess.CalledProcessError): </span><span class="s3"># pylint:disable=no-member</span>
            <span class="s1">cp.check_returncode()</span>

    <span class="s0">def </span><span class="s1">test_check(self):</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(subprocess.CalledProcessError) </span><span class="s0">as </span><span class="s1">c: </span><span class="s3"># pylint:disable=no-member</span>
            <span class="s1">self.run_python(</span><span class="s2">&quot;import sys; sys.exit(47)&quot;</span><span class="s0">, </span><span class="s1">check=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(c.exception.returncode</span><span class="s0">, </span><span class="s4">47</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_check_zero(self):</span>
        <span class="s3"># check_returncode shouldn't raise when returncode is zero</span>
        <span class="s1">cp = self.run_python(</span><span class="s2">&quot;import sys; sys.exit(0)&quot;</span><span class="s0">, </span><span class="s1">check=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(cp.returncode</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_timeout(self):</span>
        <span class="s3"># run() function with timeout argument; we want to test that the child</span>
        <span class="s3"># process gets killed when the timeout expires.  If the child isn't</span>
        <span class="s3"># killed, this call will deadlock since subprocess.run waits for the</span>
        <span class="s3"># child.</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(subprocess.TimeoutExpired):</span>
            <span class="s1">self.run_python(</span><span class="s2">&quot;while True: pass&quot;</span><span class="s0">, </span><span class="s1">timeout=</span><span class="s4">0.0001</span><span class="s1">)</span>

    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s2">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_capture_stdout(self):</span>
        <span class="s3"># capture stdout with zero return code</span>
        <span class="s1">cp = self.run_python(</span><span class="s2">&quot;print('BDFL')&quot;</span><span class="s0">, </span><span class="s1">stdout=subprocess.PIPE)</span>
        <span class="s1">self.assertIn(</span><span class="s5">b'BDFL'</span><span class="s0">, </span><span class="s1">cp.stdout)</span>

    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s2">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_capture_stderr(self):</span>
        <span class="s1">cp = self.run_python(</span><span class="s2">&quot;import sys; sys.stderr.write('BDFL')&quot;</span><span class="s0">,</span>
                             <span class="s1">stderr=subprocess.PIPE)</span>
        <span class="s1">self.assertIn(</span><span class="s5">b'BDFL'</span><span class="s0">, </span><span class="s1">cp.stderr)</span>

    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s2">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_check_output_stdin_arg(self):</span>
        <span class="s3"># run() can be called with stdin set to a file</span>
        <span class="s0">with </span><span class="s1">tempfile.TemporaryFile() </span><span class="s0">as </span><span class="s1">tf:</span>
            <span class="s1">tf.write(</span><span class="s5">b'pear'</span><span class="s1">)</span>
            <span class="s1">tf.seek(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">cp = self.run_python(</span>
                <span class="s2">&quot;import sys; sys.stdout.write(sys.stdin.read().upper())&quot;</span><span class="s0">,</span>
                <span class="s1">stdin=tf</span><span class="s0">, </span><span class="s1">stdout=subprocess.PIPE)</span>
            <span class="s1">self.assertIn(</span><span class="s5">b'PEAR'</span><span class="s0">, </span><span class="s1">cp.stdout)</span>

    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s2">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_check_output_input_arg(self):</span>
        <span class="s3"># check_output() can be called with input set to a string</span>
        <span class="s1">cp = self.run_python(</span>
            <span class="s2">&quot;import sys; sys.stdout.write(sys.stdin.read().upper())&quot;</span><span class="s0">,</span>
            <span class="s1">input=</span><span class="s5">b'pear'</span><span class="s0">, </span><span class="s1">stdout=subprocess.PIPE)</span>
        <span class="s1">self.assertIn(</span><span class="s5">b'PEAR'</span><span class="s0">, </span><span class="s1">cp.stdout)</span>

    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s2">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_check_output_stdin_with_input_arg(self):</span>
        <span class="s3"># run() refuses to accept 'stdin' with 'input'</span>
        <span class="s0">with </span><span class="s1">tempfile.TemporaryFile() </span><span class="s0">as </span><span class="s1">tf:</span>
            <span class="s1">tf.write(</span><span class="s5">b'pear'</span><span class="s1">)</span>
            <span class="s1">tf.seek(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(ValueError</span><span class="s0">,</span>
                                   <span class="s1">msg=</span><span class="s2">&quot;Expected ValueError when stdin and input args supplied.&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">c:</span>
                <span class="s1">self.run_python(</span><span class="s2">&quot;print('will not be run')&quot;</span><span class="s0">,</span>
                                <span class="s1">stdin=tf</span><span class="s0">, </span><span class="s1">input=</span><span class="s5">b'hare'</span><span class="s1">)</span>
            <span class="s1">self.assertIn(</span><span class="s2">'stdin'</span><span class="s0">, </span><span class="s1">c.exception.args[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">self.assertIn(</span><span class="s2">'input'</span><span class="s0">, </span><span class="s1">c.exception.args[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s2">&quot;hangs&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_check_output_timeout(self):</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(subprocess.TimeoutExpired) </span><span class="s0">as </span><span class="s1">c:</span>
            <span class="s1">self.run_python(</span>
                <span class="s1">(</span>
                    <span class="s2">&quot;import sys, time</span><span class="s0">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;sys.stdout.write('BDFL')</span><span class="s0">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;sys.stdout.flush()</span><span class="s0">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;time.sleep(3600)&quot;</span>
                <span class="s1">)</span><span class="s0">,</span>
                <span class="s3"># Some heavily loaded buildbots (sparc Debian 3.x) require</span>
                <span class="s3"># this much time to start and print.</span>
                <span class="s1">timeout=</span><span class="s4">3</span><span class="s0">, </span><span class="s1">stdout=subprocess.PIPE)</span>
        <span class="s1">self.assertEqual(c.exception.output</span><span class="s0">, </span><span class="s5">b'BDFL'</span><span class="s1">)</span>
        <span class="s3"># output is aliased to stdout</span>
        <span class="s1">self.assertEqual(c.exception.stdout</span><span class="s0">, </span><span class="s5">b'BDFL'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_run_kwargs(self):</span>
        <span class="s1">newenv = os.environ.copy()</span>
        <span class="s1">newenv[</span><span class="s2">&quot;FRUIT&quot;</span><span class="s1">] = </span><span class="s2">&quot;banana&quot;</span>
        <span class="s1">cp = self.run_python((</span><span class="s2">'import sys, os;'</span>
                              <span class="s2">'sys.exit(33 if os.getenv(&quot;FRUIT&quot;)==&quot;banana&quot; else 31)'</span><span class="s1">)</span><span class="s0">,</span>
                             <span class="s1">env=newenv)</span>
        <span class="s1">self.assertEqual(cp.returncode</span><span class="s0">, </span><span class="s4">33</span><span class="s1">)</span>

    <span class="s3"># This test _might_ wind up a bit fragile on loaded build+test machines</span>
    <span class="s3"># as it depends on the timing with wide enough margins for normal situations</span>
    <span class="s3"># but does assert that it happened &quot;soon enough&quot; to believe the right thing</span>
    <span class="s3"># happened.</span>
    <span class="s1">@greentest.skipOnWindows(</span><span class="s2">&quot;requires posix like 'sleep' shell command&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_run_with_shell_timeout_and_capture_output(self):</span>
        <span class="s3">#Output capturing after a timeout mustn't hang forever on open filehandles</span>
        <span class="s0">with </span><span class="s1">self.runs_in_given_time(</span><span class="s4">0.1</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(subprocess.TimeoutExpired):</span>
                <span class="s1">subprocess.run(</span><span class="s2">'sleep 3'</span><span class="s0">, </span><span class="s1">shell=</span><span class="s0">True, </span><span class="s1">timeout=</span><span class="s4">0.1</span><span class="s0">,</span>
                               <span class="s1">capture_output=</span><span class="s0">True</span><span class="s1">)  </span><span class="s3"># New session unspecified.</span>

<span class="s0">if </span><span class="s1">__name__ == </span><span class="s2">'__main__'</span><span class="s1">:</span>
    <span class="s1">greentest.main()</span>
</pre>
</body>
</html>