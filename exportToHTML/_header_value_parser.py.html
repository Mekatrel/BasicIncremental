<html>
<head>
<title>_header_value_parser.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_header_value_parser.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Header value parser implementing various email-related RFC parsing rules. 
 
The parsing methods defined in this module implement various email related 
parsing rules.  Principal among them is RFC 5322, which is the followon 
to RFC 2822 and primarily a clarification of the former.  It also implements 
RFC 2047 encoded word decoding. 
 
RFC 5322 goes to considerable trouble to maintain backward compatibility with 
RFC 822 in the parse phase, while cleaning up the structure on the generation 
phase.  This parser supports correct RFC 5322 generation by tagging white space 
as folding white space only when folding is allowed in the non-obsolete rule 
sets.  Actually, the parser is even more generous when accepting input than RFC 
5322 mandates, following the spirit of Postel's Law, which RFC 5322 encourages. 
Where possible deviations from the standard are annotated on the 'defects' 
attribute of tokens that deviate. 
 
The general structure of the parser follows RFC 5322, and uses its terminology 
where there is a direct correspondence.  Where the implementation requires a 
somewhat different structure than that used by the formal grammar, new terms 
that mimic the closest existing terms are used.  Thus, it really helps to have 
a copy of RFC 5322 handy when studying this code. 
 
Input to the parser is a string that has already been unfolded according to 
RFC 5322 rules.  According to the RFC this unfolding is the very first step, and 
this parser leaves the unfolding step to a higher level message parser, which 
will have already detected the line breaks that need unfolding while 
determining the beginning and end of each header. 
 
The output of the parser is a TokenList object, which is a list subclass.  A 
TokenList is a recursive data structure.  The terminal nodes of the structure 
are Terminal objects, which are subclasses of str.  These do not correspond 
directly to terminal objects in the formal grammar, but are instead more 
practical higher level combinations of true terminals. 
 
All TokenList and Terminal objects have a 'value' attribute, which produces the 
semantically meaningful value of that part of the parse subtree.  The value of 
all whitespace tokens (no matter how many sub-tokens they may contain) is a 
single space, as per the RFC rules.  This includes 'CFWS', which is herein 
included in the general class of whitespace tokens.  There is one exception to 
the rule that whitespace tokens are collapsed into single spaces in values: in 
the value of a 'bare-quoted-string' (a quoted-string with no leading or 
trailing whitespace), any whitespace that appeared between the quotation marks 
is preserved in the returned value.  Note that in all Terminal strings quoted 
pairs are turned into their unquoted values. 
 
All TokenList and Terminal objects also have a string value, which attempts to 
be a &quot;canonical&quot; representation of the RFC-compliant form of the substring that 
produced the parsed subtree, including minimal use of quoted pair quoting. 
Whitespace runs are not collapsed. 
 
Comment tokens also have a 'content' attribute providing the string found 
between the parens (including any nested comments) with whitespace preserved. 
 
All TokenList and Terminal objects have a 'defects' attribute which is a 
possibly empty list all of the defects found while creating the token.  Defects 
may appear on any token in the tree, and a composite list of all defects in the 
subtree is available through the 'all_defects' attribute of any node.  (For 
Terminal notes x.defects == x.all_defects.) 
 
Each object in a parse tree is called a 'token', and each has a 'token_type' 
attribute that gives the name from the RFC 5322 grammar that it represents. 
Not all RFC 5322 nodes are produced, and there is one non-RFC 5322 node that 
may be produced: 'ptext'.  A 'ptext' is a string of printable ascii characters. 
It is returned in place of lists of (ctext/quoted-pair) and 
(qtext/quoted-pair). 
 
XXX: provide complete list of token types. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">print_function</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">unicode_literals</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">division</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">absolute_import</span>
<span class="s2">from </span><span class="s1">future.builtins </span><span class="s2">import </span><span class="s1">int</span><span class="s2">, </span><span class="s1">range</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">super</span><span class="s2">, </span><span class="s1">list</span>

<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">namedtuple</span><span class="s2">, </span><span class="s1">OrderedDict</span>

<span class="s2">from </span><span class="s1">future.backports.urllib.parse </span><span class="s2">import </span><span class="s1">(unquote</span><span class="s2">, </span><span class="s1">unquote_to_bytes)</span>
<span class="s2">from </span><span class="s1">future.backports.email </span><span class="s2">import </span><span class="s1">_encoded_words </span><span class="s2">as </span><span class="s1">_ew</span>
<span class="s2">from </span><span class="s1">future.backports.email </span><span class="s2">import </span><span class="s1">errors</span>
<span class="s2">from </span><span class="s1">future.backports.email </span><span class="s2">import </span><span class="s1">utils</span>

<span class="s3">#</span>
<span class="s3"># Useful constants and functions</span>
<span class="s3">#</span>

<span class="s1">WSP = set(</span><span class="s4">' </span><span class="s2">\t</span><span class="s4">'</span><span class="s1">)</span>
<span class="s1">CFWS_LEADER = WSP | set(</span><span class="s4">'('</span><span class="s1">)</span>
<span class="s1">SPECIALS = set(</span><span class="s4">r'()&lt;&gt;@,:;.\&quot;[]'</span><span class="s1">)</span>
<span class="s1">ATOM_ENDS = SPECIALS | WSP</span>
<span class="s1">DOT_ATOM_ENDS = ATOM_ENDS - set(</span><span class="s4">'.'</span><span class="s1">)</span>
<span class="s3"># '.', '&quot;', and '(' do not end phrases in order to support obs-phrase</span>
<span class="s1">PHRASE_ENDS = SPECIALS - set(</span><span class="s4">'.&quot;('</span><span class="s1">)</span>
<span class="s1">TSPECIALS = (SPECIALS | set(</span><span class="s4">'/?='</span><span class="s1">)) - set(</span><span class="s4">'.'</span><span class="s1">)</span>
<span class="s1">TOKEN_ENDS = TSPECIALS | WSP</span>
<span class="s1">ASPECIALS = TSPECIALS | set(</span><span class="s4">&quot;*'%&quot;</span><span class="s1">)</span>
<span class="s1">ATTRIBUTE_ENDS = ASPECIALS | WSP</span>
<span class="s1">EXTENDED_ATTRIBUTE_ENDS = ATTRIBUTE_ENDS - set(</span><span class="s4">'%'</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">quote_string(value):</span>
    <span class="s2">return </span><span class="s4">'&quot;'</span><span class="s1">+str(value).replace(</span><span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\\\\</span><span class="s4">'</span><span class="s1">).replace(</span><span class="s4">'&quot;'</span><span class="s2">, </span><span class="s4">r'\&quot;'</span><span class="s1">)+</span><span class="s4">'&quot;'</span>

<span class="s3">#</span>
<span class="s3"># Accumulator for header folding</span>
<span class="s3">#</span>

<span class="s2">class </span><span class="s1">_Folded(object):</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">maxlen</span><span class="s2">, </span><span class="s1">policy):</span>
        <span class="s1">self.maxlen = maxlen</span>
        <span class="s1">self.policy = policy</span>
        <span class="s1">self.lastlen = </span><span class="s5">0</span>
        <span class="s1">self.stickyspace = </span><span class="s2">None</span>
        <span class="s1">self.firstline = </span><span class="s2">True</span>
        <span class="s1">self.done = []</span>
        <span class="s1">self.current = list()    </span><span class="s3"># uses l.clear()</span>

    <span class="s2">def </span><span class="s1">newline(self):</span>
        <span class="s1">self.done.extend(self.current)</span>
        <span class="s1">self.done.append(self.policy.linesep)</span>
        <span class="s1">self.current.clear()</span>
        <span class="s1">self.lastlen = </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">finalize(self):</span>
        <span class="s2">if </span><span class="s1">self.current:</span>
            <span class="s1">self.newline()</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(self.done)</span>

    <span class="s2">def </span><span class="s1">append(self</span><span class="s2">, </span><span class="s1">stoken):</span>
        <span class="s1">self.current.append(stoken)</span>

    <span class="s2">def </span><span class="s1">append_if_fits(self</span><span class="s2">, </span><span class="s1">token</span><span class="s2">, </span><span class="s1">stoken=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">stoken </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">stoken = str(token)</span>
        <span class="s1">l = len(stoken)</span>
        <span class="s2">if </span><span class="s1">self.stickyspace </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">stickyspace_len = len(self.stickyspace)</span>
            <span class="s2">if </span><span class="s1">self.lastlen + stickyspace_len + l &lt;= self.maxlen:</span>
                <span class="s1">self.current.append(self.stickyspace)</span>
                <span class="s1">self.lastlen += stickyspace_len</span>
                <span class="s1">self.current.append(stoken)</span>
                <span class="s1">self.lastlen += l</span>
                <span class="s1">self.stickyspace = </span><span class="s2">None</span>
                <span class="s1">self.firstline = </span><span class="s2">False</span>
                <span class="s2">return True</span>
            <span class="s2">if </span><span class="s1">token.has_fws:</span>
                <span class="s1">ws = token.pop_leading_fws()</span>
                <span class="s2">if </span><span class="s1">ws </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">self.stickyspace += str(ws)</span>
                    <span class="s1">stickyspace_len += len(ws)</span>
                <span class="s1">token._fold(self)</span>
                <span class="s2">return True</span>
            <span class="s2">if </span><span class="s1">stickyspace_len </span><span class="s2">and </span><span class="s1">l + </span><span class="s5">1 </span><span class="s1">&lt;= self.maxlen:</span>
                <span class="s1">margin = self.maxlen - l</span>
                <span class="s2">if </span><span class="s5">0 </span><span class="s1">&lt; margin &lt; stickyspace_len:</span>
                    <span class="s1">trim = stickyspace_len - margin</span>
                    <span class="s1">self.current.append(self.stickyspace[:trim])</span>
                    <span class="s1">self.stickyspace = self.stickyspace[trim:]</span>
                    <span class="s1">stickyspace_len = trim</span>
                <span class="s1">self.newline()</span>
                <span class="s1">self.current.append(self.stickyspace)</span>
                <span class="s1">self.current.append(stoken)</span>
                <span class="s1">self.lastlen = l + stickyspace_len</span>
                <span class="s1">self.stickyspace = </span><span class="s2">None</span>
                <span class="s1">self.firstline = </span><span class="s2">False</span>
                <span class="s2">return True</span>
            <span class="s2">if not </span><span class="s1">self.firstline:</span>
                <span class="s1">self.newline()</span>
            <span class="s1">self.current.append(self.stickyspace)</span>
            <span class="s1">self.current.append(stoken)</span>
            <span class="s1">self.stickyspace = </span><span class="s2">None</span>
            <span class="s1">self.firstline = </span><span class="s2">False</span>
            <span class="s2">return True</span>
        <span class="s2">if </span><span class="s1">self.lastlen + l &lt;= self.maxlen:</span>
            <span class="s1">self.current.append(stoken)</span>
            <span class="s1">self.lastlen += l</span>
            <span class="s2">return True</span>
        <span class="s2">if </span><span class="s1">l &lt; self.maxlen:</span>
            <span class="s1">self.newline()</span>
            <span class="s1">self.current.append(stoken)</span>
            <span class="s1">self.lastlen = l</span>
            <span class="s2">return True</span>
        <span class="s2">return False</span>

<span class="s3">#</span>
<span class="s3"># TokenList and its subclasses</span>
<span class="s3">#</span>

<span class="s2">class </span><span class="s1">TokenList(list):</span>

    <span class="s1">token_type = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kw):</span>
        <span class="s1">super(TokenList</span><span class="s2">, </span><span class="s1">self).__init__(*args</span><span class="s2">, </span><span class="s1">**kw)</span>
        <span class="s1">self.defects = []</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'{}({})'</span><span class="s1">.format(self.__class__.__name__</span><span class="s2">,</span>
                               <span class="s1">super(TokenList</span><span class="s2">, </span><span class="s1">self).__repr__())</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">value(self):</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(x.value </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self </span><span class="s2">if </span><span class="s1">x.value)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">all_defects(self):</span>
        <span class="s2">return </span><span class="s1">sum((x.all_defects </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self)</span><span class="s2">, </span><span class="s1">self.defects)</span>

    <span class="s3">#</span>
    <span class="s3"># Folding API</span>
    <span class="s3">#</span>
    <span class="s3"># parts():</span>
    <span class="s3">#</span>
    <span class="s3"># return a list of objects that constitute the &quot;higher level syntactic</span>
    <span class="s3"># objects&quot; specified by the RFC as the best places to fold a header line.</span>
    <span class="s3"># The returned objects must include leading folding white space, even if</span>
    <span class="s3"># this means mutating the underlying parse tree of the object.  Each object</span>
    <span class="s3"># is only responsible for returning *its* parts, and should not drill down</span>
    <span class="s3"># to any lower level except as required to meet the leading folding white</span>
    <span class="s3"># space constraint.</span>
    <span class="s3">#</span>
    <span class="s3"># _fold(folded):</span>
    <span class="s3">#</span>
    <span class="s3">#   folded: the result accumulator.  This is an instance of _Folded.</span>
    <span class="s3">#       (XXX: I haven't finished factoring this out yet, the folding code</span>
    <span class="s3">#       pretty much uses this as a state object.) When the folded.current</span>
    <span class="s3">#       contains as much text as will fit, the _fold method should call</span>
    <span class="s3">#       folded.newline.</span>
    <span class="s3">#  folded.lastlen: the current length of the test stored in folded.current.</span>
    <span class="s3">#  folded.maxlen: The maximum number of characters that may appear on a</span>
    <span class="s3">#       folded line.  Differs from the policy setting in that &quot;no limit&quot; is</span>
    <span class="s3">#       represented by +inf, which means it can be used in the trivially</span>
    <span class="s3">#       logical fashion in comparisons.</span>
    <span class="s3">#</span>
    <span class="s3"># Currently no subclasses implement parts, and I think this will remain</span>
    <span class="s3"># true.  A subclass only needs to implement _fold when the generic version</span>
    <span class="s3"># isn't sufficient.  _fold will need to be implemented primarily when it is</span>
    <span class="s3"># possible for encoded words to appear in the specialized token-list, since</span>
    <span class="s3"># there is no generic algorithm that can know where exactly the encoded</span>
    <span class="s3"># words are allowed.  A _fold implementation is responsible for filling</span>
    <span class="s3"># lines in the same general way that the top level _fold does. It may, and</span>
    <span class="s3"># should, call the _fold method of sub-objects in a similar fashion to that</span>
    <span class="s3"># of the top level _fold.</span>
    <span class="s3">#</span>
    <span class="s3"># XXX: I'm hoping it will be possible to factor the existing code further</span>
    <span class="s3"># to reduce redundancy and make the logic clearer.</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">parts(self):</span>
        <span class="s1">klass = self.__class__</span>
        <span class="s1">this = list()</span>
        <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">token.startswith_fws():</span>
                <span class="s2">if </span><span class="s1">this:</span>
                    <span class="s2">yield </span><span class="s1">this[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">len(this)==</span><span class="s5">1 </span><span class="s2">else </span><span class="s1">klass(this)</span>
                    <span class="s1">this.clear()</span>
            <span class="s1">end_ws = token.pop_trailing_ws()</span>
            <span class="s1">this.append(token)</span>
            <span class="s2">if </span><span class="s1">end_ws:</span>
                <span class="s2">yield </span><span class="s1">klass(this)</span>
                <span class="s1">this = [end_ws]</span>
        <span class="s2">if </span><span class="s1">this:</span>
            <span class="s2">yield </span><span class="s1">this[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">len(this)==</span><span class="s5">1 </span><span class="s2">else </span><span class="s1">klass(this)</span>

    <span class="s2">def </span><span class="s1">startswith_fws(self):</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].startswith_fws()</span>

    <span class="s2">def </span><span class="s1">pop_leading_fws(self):</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'fws'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.pop(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].pop_leading_fws()</span>

    <span class="s2">def </span><span class="s1">pop_trailing_ws(self):</span>
        <span class="s2">if </span><span class="s1">self[-</span><span class="s5">1</span><span class="s1">].token_type == </span><span class="s4">'cfws'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.pop(-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self[-</span><span class="s5">1</span><span class="s1">].pop_trailing_ws()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">has_fws(self):</span>
        <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">part.has_fws:</span>
                <span class="s2">return True</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">has_leading_comment(self):</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].has_leading_comment()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">comments(self):</span>
        <span class="s1">comments = []</span>
        <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s1">comments.extend(token.comments)</span>
        <span class="s2">return </span><span class="s1">comments</span>

    <span class="s2">def </span><span class="s1">fold(self</span><span class="s2">, </span><span class="s1">**_3to2kwargs):</span>
        <span class="s3"># max_line_length 0/None means no limit, ie: infinitely long.</span>
        <span class="s1">policy = _3to2kwargs[</span><span class="s4">'policy'</span><span class="s1">]; </span><span class="s2">del </span><span class="s1">_3to2kwargs[</span><span class="s4">'policy'</span><span class="s1">]</span>
        <span class="s1">maxlen = policy.max_line_length </span><span class="s2">or </span><span class="s1">float(</span><span class="s4">&quot;+inf&quot;</span><span class="s1">)</span>
        <span class="s1">folded = _Folded(maxlen</span><span class="s2">, </span><span class="s1">policy)</span>
        <span class="s1">self._fold(folded)</span>
        <span class="s1">folded.finalize()</span>
        <span class="s2">return </span><span class="s1">str(folded)</span>

    <span class="s2">def </span><span class="s1">as_encoded_word(self</span><span class="s2">, </span><span class="s1">charset):</span>
        <span class="s3"># This works only for things returned by 'parts', which include</span>
        <span class="s3"># the leading fws, if any, that should be used.</span>
        <span class="s1">res = []</span>
        <span class="s1">ws = self.pop_leading_fws()</span>
        <span class="s2">if </span><span class="s1">ws:</span>
            <span class="s1">res.append(ws)</span>
        <span class="s1">trailer = self.pop(-</span><span class="s5">1</span><span class="s1">) </span><span class="s2">if </span><span class="s1">self[-</span><span class="s5">1</span><span class="s1">].token_type==</span><span class="s4">'fws' </span><span class="s2">else </span><span class="s4">''</span>
        <span class="s1">res.append(_ew.encode(str(self)</span><span class="s2">, </span><span class="s1">charset))</span>
        <span class="s1">res.append(trailer)</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(res)</span>

    <span class="s2">def </span><span class="s1">cte_encode(self</span><span class="s2">, </span><span class="s1">charset</span><span class="s2">, </span><span class="s1">policy):</span>
        <span class="s1">res = []</span>
        <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s1">res.append(part.cte_encode(charset</span><span class="s2">, </span><span class="s1">policy))</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(res)</span>

    <span class="s2">def </span><span class="s1">_fold(self</span><span class="s2">, </span><span class="s1">folded):</span>
        <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">self.parts:</span>
            <span class="s1">tstr = str(part)</span>
            <span class="s1">tlen = len(tstr)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">str(part).encode(</span><span class="s4">'us-ascii'</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">UnicodeEncodeError:</span>
                <span class="s2">if </span><span class="s1">any(isinstance(x</span><span class="s2">, </span><span class="s1">errors.UndecodableBytesDefect)</span>
                        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">part.all_defects):</span>
                    <span class="s1">charset = </span><span class="s4">'unknown-8bit'</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s3"># XXX: this should be a policy setting</span>
                    <span class="s1">charset = </span><span class="s4">'utf-8'</span>
                <span class="s1">tstr = part.cte_encode(charset</span><span class="s2">, </span><span class="s1">folded.policy)</span>
                <span class="s1">tlen = len(tstr)</span>
            <span class="s2">if </span><span class="s1">folded.append_if_fits(part</span><span class="s2">, </span><span class="s1">tstr):</span>
                <span class="s2">continue</span>
            <span class="s3"># Peel off the leading whitespace if any and make it sticky, to</span>
            <span class="s3"># avoid infinite recursion.</span>
            <span class="s1">ws = part.pop_leading_fws()</span>
            <span class="s2">if </span><span class="s1">ws </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s3"># Peel off the leading whitespace and make it sticky, to</span>
                <span class="s3"># avoid infinite recursion.</span>
                <span class="s1">folded.stickyspace = str(part.pop(</span><span class="s5">0</span><span class="s1">))</span>
                <span class="s2">if </span><span class="s1">folded.append_if_fits(part):</span>
                    <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">part.has_fws:</span>
                <span class="s1">part._fold(folded)</span>
                <span class="s2">continue</span>
            <span class="s3"># There are no fold points in this one; it is too long for a single</span>
            <span class="s3"># line and can't be split...we just have to put it on its own line.</span>
            <span class="s1">folded.append(tstr)</span>
            <span class="s1">folded.newline()</span>

    <span class="s2">def </span><span class="s1">pprint(self</span><span class="s2">, </span><span class="s1">indent=</span><span class="s4">''</span><span class="s1">):</span>
        <span class="s1">print(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(self._pp(indent=</span><span class="s4">''</span><span class="s1">)))</span>

    <span class="s2">def </span><span class="s1">ppstr(self</span><span class="s2">, </span><span class="s1">indent=</span><span class="s4">''</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(self._pp(indent=</span><span class="s4">''</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_pp(self</span><span class="s2">, </span><span class="s1">indent=</span><span class="s4">''</span><span class="s1">):</span>
        <span class="s2">yield </span><span class="s4">'{}{}/{}('</span><span class="s1">.format(</span>
            <span class="s1">indent</span><span class="s2">,</span>
            <span class="s1">self.__class__.__name__</span><span class="s2">,</span>
            <span class="s1">self.token_type)</span>
        <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if not </span><span class="s1">hasattr(token</span><span class="s2">, </span><span class="s4">'_pp'</span><span class="s1">):</span>
                <span class="s2">yield </span><span class="s1">(indent + </span><span class="s4">'    !! invalid element in token '</span>
                                        <span class="s4">'list: {!r}'</span><span class="s1">.format(token))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">token._pp(indent+</span><span class="s4">'    '</span><span class="s1">):</span>
                    <span class="s2">yield </span><span class="s1">line</span>
        <span class="s2">if </span><span class="s1">self.defects:</span>
            <span class="s1">extra = </span><span class="s4">' Defects: {}'</span><span class="s1">.format(self.defects)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">extra = </span><span class="s4">''</span>
        <span class="s2">yield </span><span class="s4">'{}){}'</span><span class="s1">.format(indent</span><span class="s2">, </span><span class="s1">extra)</span>


<span class="s2">class </span><span class="s1">WhiteSpaceTokenList(TokenList):</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">value(self):</span>
        <span class="s2">return </span><span class="s4">' '</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">comments(self):</span>
        <span class="s2">return </span><span class="s1">[x.content </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self </span><span class="s2">if </span><span class="s1">x.token_type==</span><span class="s4">'comment'</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">UnstructuredTokenList(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'unstructured'</span>

    <span class="s2">def </span><span class="s1">_fold(self</span><span class="s2">, </span><span class="s1">folded):</span>
        <span class="s2">if </span><span class="s1">any(x.token_type==</span><span class="s4">'encoded-word' </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self):</span>
            <span class="s2">return </span><span class="s1">self._fold_encoded(folded)</span>
        <span class="s3"># Here we can have either a pure ASCII string that may or may not</span>
        <span class="s3"># have surrogateescape encoded bytes, or a unicode string.</span>
        <span class="s1">last_ew = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">self.parts:</span>
            <span class="s1">tstr = str(part)</span>
            <span class="s1">is_ew = </span><span class="s2">False</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">str(part).encode(</span><span class="s4">'us-ascii'</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">UnicodeEncodeError:</span>
                <span class="s2">if </span><span class="s1">any(isinstance(x</span><span class="s2">, </span><span class="s1">errors.UndecodableBytesDefect)</span>
                       <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">part.all_defects):</span>
                    <span class="s1">charset = </span><span class="s4">'unknown-8bit'</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">charset = </span><span class="s4">'utf-8'</span>
                <span class="s2">if </span><span class="s1">last_ew </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s3"># We've already done an EW, combine this one with it</span>
                    <span class="s3"># if there's room.</span>
                    <span class="s1">chunk = get_unstructured(</span>
                        <span class="s4">''</span><span class="s1">.join(folded.current[last_ew:]+[tstr])).as_encoded_word(charset)</span>
                    <span class="s1">oldlastlen = sum(len(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">folded.current[:last_ew])</span>
                    <span class="s1">schunk = str(chunk)</span>
                    <span class="s1">lchunk = len(schunk)</span>
                    <span class="s2">if </span><span class="s1">oldlastlen + lchunk &lt;= folded.maxlen:</span>
                        <span class="s2">del </span><span class="s1">folded.current[last_ew:]</span>
                        <span class="s1">folded.append(schunk)</span>
                        <span class="s1">folded.lastlen = oldlastlen + lchunk</span>
                        <span class="s2">continue</span>
                <span class="s1">tstr = part.as_encoded_word(charset)</span>
                <span class="s1">is_ew = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">folded.append_if_fits(part</span><span class="s2">, </span><span class="s1">tstr):</span>
                <span class="s2">if </span><span class="s1">is_ew:</span>
                    <span class="s1">last_ew = len(folded.current) - </span><span class="s5">1</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">is_ew </span><span class="s2">or </span><span class="s1">last_ew:</span>
                <span class="s3"># It's too big to fit on the line, but since we've</span>
                <span class="s3"># got encoded words we can use encoded word folding.</span>
                <span class="s1">part._fold_as_ew(folded)</span>
                <span class="s2">continue</span>
            <span class="s3"># Peel off the leading whitespace if any and make it sticky, to</span>
            <span class="s3"># avoid infinite recursion.</span>
            <span class="s1">ws = part.pop_leading_fws()</span>
            <span class="s2">if </span><span class="s1">ws </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">folded.stickyspace = str(ws)</span>
                <span class="s2">if </span><span class="s1">folded.append_if_fits(part):</span>
                    <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">part.has_fws:</span>
                <span class="s1">part.fold(folded)</span>
                <span class="s2">continue</span>
            <span class="s3"># It can't be split...we just have to put it on its own line.</span>
            <span class="s1">folded.append(tstr)</span>
            <span class="s1">folded.newline()</span>
            <span class="s1">last_ew = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">cte_encode(self</span><span class="s2">, </span><span class="s1">charset</span><span class="s2">, </span><span class="s1">policy):</span>
        <span class="s1">res = []</span>
        <span class="s1">last_ew = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s1">spart = str(part)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">spart.encode(</span><span class="s4">'us-ascii'</span><span class="s1">)</span>
                <span class="s1">res.append(spart)</span>
            <span class="s2">except </span><span class="s1">UnicodeEncodeError:</span>
                <span class="s2">if </span><span class="s1">last_ew </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">res.append(part.cte_encode(charset</span><span class="s2">, </span><span class="s1">policy))</span>
                    <span class="s1">last_ew = len(res)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">tl = get_unstructured(</span><span class="s4">''</span><span class="s1">.join(res[last_ew:] + [spart]))</span>
                    <span class="s1">res.append(tl.as_encoded_word())</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(res)</span>


<span class="s2">class </span><span class="s1">Phrase(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'phrase'</span>

    <span class="s2">def </span><span class="s1">_fold(self</span><span class="s2">, </span><span class="s1">folded):</span>
        <span class="s3"># As with Unstructured, we can have pure ASCII with or without</span>
        <span class="s3"># surrogateescape encoded bytes, or we could have unicode.  But this</span>
        <span class="s3"># case is more complicated, since we have to deal with the various</span>
        <span class="s3"># sub-token types and how they can be composed in the face of</span>
        <span class="s3"># unicode-that-needs-CTE-encoding, and the fact that if a token a</span>
        <span class="s3"># comment that becomes a barrier across which we can't compose encoded</span>
        <span class="s3"># words.</span>
        <span class="s1">last_ew = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">self.parts:</span>
            <span class="s1">tstr = str(part)</span>
            <span class="s1">tlen = len(tstr)</span>
            <span class="s1">has_ew = </span><span class="s2">False</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">str(part).encode(</span><span class="s4">'us-ascii'</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">UnicodeEncodeError:</span>
                <span class="s2">if </span><span class="s1">any(isinstance(x</span><span class="s2">, </span><span class="s1">errors.UndecodableBytesDefect)</span>
                        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">part.all_defects):</span>
                    <span class="s1">charset = </span><span class="s4">'unknown-8bit'</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">charset = </span><span class="s4">'utf-8'</span>
                <span class="s2">if </span><span class="s1">last_ew </span><span class="s2">is not None and not </span><span class="s1">part.has_leading_comment():</span>
                    <span class="s3"># We've already done an EW, let's see if we can combine</span>
                    <span class="s3"># this one with it.  The last_ew logic ensures that all we</span>
                    <span class="s3"># have at this point is atoms, no comments or quoted</span>
                    <span class="s3"># strings.  So we can treat the text between the last</span>
                    <span class="s3"># encoded word and the content of this token as</span>
                    <span class="s3"># unstructured text, and things will work correctly.  But</span>
                    <span class="s3"># we have to strip off any trailing comment on this token</span>
                    <span class="s3"># first, and if it is a quoted string we have to pull out</span>
                    <span class="s3"># the content (we're encoding it, so it no longer needs to</span>
                    <span class="s3"># be quoted).</span>
                    <span class="s2">if </span><span class="s1">part[-</span><span class="s5">1</span><span class="s1">].token_type == </span><span class="s4">'cfws' </span><span class="s2">and </span><span class="s1">part.comments:</span>
                        <span class="s1">remainder = part.pop(-</span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">remainder = </span><span class="s4">''</span>
                    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">token </span><span class="s2">in </span><span class="s1">enumerate(part):</span>
                        <span class="s2">if </span><span class="s1">token.token_type == </span><span class="s4">'bare-quoted-string'</span><span class="s1">:</span>
                            <span class="s1">part[i] = UnstructuredTokenList(token[:])</span>
                    <span class="s1">chunk = get_unstructured(</span>
                        <span class="s4">''</span><span class="s1">.join(folded.current[last_ew:]+[tstr])).as_encoded_word(charset)</span>
                    <span class="s1">schunk = str(chunk)</span>
                    <span class="s1">lchunk = len(schunk)</span>
                    <span class="s2">if </span><span class="s1">last_ew + lchunk &lt;= folded.maxlen:</span>
                        <span class="s2">del </span><span class="s1">folded.current[last_ew:]</span>
                        <span class="s1">folded.append(schunk)</span>
                        <span class="s1">folded.lastlen = sum(len(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">folded.current)</span>
                        <span class="s2">continue</span>
                <span class="s1">tstr = part.as_encoded_word(charset)</span>
                <span class="s1">tlen = len(tstr)</span>
                <span class="s1">has_ew = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">folded.append_if_fits(part</span><span class="s2">, </span><span class="s1">tstr):</span>
                <span class="s2">if </span><span class="s1">has_ew </span><span class="s2">and not </span><span class="s1">part.comments:</span>
                    <span class="s1">last_ew = len(folded.current) - </span><span class="s5">1</span>
                <span class="s2">elif </span><span class="s1">part.comments </span><span class="s2">or </span><span class="s1">part.token_type == </span><span class="s4">'quoted-string'</span><span class="s1">:</span>
                    <span class="s3"># If a comment is involved we can't combine EWs.  And if a</span>
                    <span class="s3"># quoted string is involved, it's not worth the effort to</span>
                    <span class="s3"># try to combine them.</span>
                    <span class="s1">last_ew = </span><span class="s2">None</span>
                <span class="s2">continue</span>
            <span class="s1">part._fold(folded)</span>

    <span class="s2">def </span><span class="s1">cte_encode(self</span><span class="s2">, </span><span class="s1">charset</span><span class="s2">, </span><span class="s1">policy):</span>
        <span class="s1">res = []</span>
        <span class="s1">last_ew = </span><span class="s2">None</span>
        <span class="s1">is_ew = </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s1">spart = str(part)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">spart.encode(</span><span class="s4">'us-ascii'</span><span class="s1">)</span>
                <span class="s1">res.append(spart)</span>
            <span class="s2">except </span><span class="s1">UnicodeEncodeError:</span>
                <span class="s1">is_ew = </span><span class="s2">True</span>
                <span class="s2">if </span><span class="s1">last_ew </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">if not </span><span class="s1">part.comments:</span>
                        <span class="s1">last_ew = len(res)</span>
                    <span class="s1">res.append(part.cte_encode(charset</span><span class="s2">, </span><span class="s1">policy))</span>
                <span class="s2">elif not </span><span class="s1">part.has_leading_comment():</span>
                    <span class="s2">if </span><span class="s1">part[-</span><span class="s5">1</span><span class="s1">].token_type == </span><span class="s4">'cfws' </span><span class="s2">and </span><span class="s1">part.comments:</span>
                        <span class="s1">remainder = part.pop(-</span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">remainder = </span><span class="s4">''</span>
                    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">token </span><span class="s2">in </span><span class="s1">enumerate(part):</span>
                        <span class="s2">if </span><span class="s1">token.token_type == </span><span class="s4">'bare-quoted-string'</span><span class="s1">:</span>
                            <span class="s1">part[i] = UnstructuredTokenList(token[:])</span>
                    <span class="s1">tl = get_unstructured(</span><span class="s4">''</span><span class="s1">.join(res[last_ew:] + [spart]))</span>
                    <span class="s1">res[last_ew:] = [tl.as_encoded_word(charset)]</span>
            <span class="s2">if </span><span class="s1">part.comments </span><span class="s2">or </span><span class="s1">(</span><span class="s2">not </span><span class="s1">is_ew </span><span class="s2">and </span><span class="s1">part.token_type == </span><span class="s4">'quoted-string'</span><span class="s1">):</span>
                <span class="s1">last_ew = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(res)</span>

<span class="s2">class </span><span class="s1">Word(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'word'</span>


<span class="s2">class </span><span class="s1">CFWSList(WhiteSpaceTokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'cfws'</span>

    <span class="s2">def </span><span class="s1">has_leading_comment(self):</span>
        <span class="s2">return </span><span class="s1">bool(self.comments)</span>


<span class="s2">class </span><span class="s1">Atom(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'atom'</span>


<span class="s2">class </span><span class="s1">Token(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'token'</span>


<span class="s2">class </span><span class="s1">EncodedWord(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'encoded-word'</span>
    <span class="s1">cte = </span><span class="s2">None</span>
    <span class="s1">charset = </span><span class="s2">None</span>
    <span class="s1">lang = </span><span class="s2">None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">encoded(self):</span>
        <span class="s2">if </span><span class="s1">self.cte </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.cte</span>
        <span class="s1">_ew.encode(str(self)</span><span class="s2">, </span><span class="s1">self.charset)</span>



<span class="s2">class </span><span class="s1">QuotedString(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'quoted-string'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">content(self):</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">x.token_type == </span><span class="s4">'bare-quoted-string'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">x.value</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">quoted_value(self):</span>
        <span class="s1">res = []</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">x.token_type == </span><span class="s4">'bare-quoted-string'</span><span class="s1">:</span>
                <span class="s1">res.append(str(x))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">res.append(x.value)</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(res)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">stripped_value(self):</span>
        <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">token.token_type == </span><span class="s4">'bare-quoted-string'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">token.value</span>


<span class="s2">class </span><span class="s1">BareQuotedString(QuotedString):</span>

    <span class="s1">token_type = </span><span class="s4">'bare-quoted-string'</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">quote_string(</span><span class="s4">''</span><span class="s1">.join(str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">value(self):</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self)</span>


<span class="s2">class </span><span class="s1">Comment(WhiteSpaceTokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'comment'</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(sum([</span>
                            <span class="s1">[</span><span class="s4">&quot;(&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">[self.quote(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self]</span><span class="s2">,</span>
                            <span class="s1">[</span><span class="s4">&quot;)&quot;</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">]</span><span class="s2">, </span><span class="s1">[]))</span>

    <span class="s2">def </span><span class="s1">quote(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">value.token_type == </span><span class="s4">'comment'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">str(value)</span>
        <span class="s2">return </span><span class="s1">str(value).replace(</span><span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\\\\</span><span class="s4">'</span><span class="s1">).replace(</span>
                                  <span class="s4">'('</span><span class="s2">, </span><span class="s4">'\('</span><span class="s1">).replace(</span>
                                  <span class="s4">')'</span><span class="s2">, </span><span class="s4">'\)'</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">content(self):</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">comments(self):</span>
        <span class="s2">return </span><span class="s1">[self.content]</span>

<span class="s2">class </span><span class="s1">AddressList(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'address-list'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">addresses(self):</span>
        <span class="s2">return </span><span class="s1">[x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self </span><span class="s2">if </span><span class="s1">x.token_type==</span><span class="s4">'address'</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">mailboxes(self):</span>
        <span class="s2">return </span><span class="s1">sum((x.mailboxes</span>
                    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self </span><span class="s2">if </span><span class="s1">x.token_type==</span><span class="s4">'address'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[])</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">all_mailboxes(self):</span>
        <span class="s2">return </span><span class="s1">sum((x.all_mailboxes</span>
                    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self </span><span class="s2">if </span><span class="s1">x.token_type==</span><span class="s4">'address'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[])</span>


<span class="s2">class </span><span class="s1">Address(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'address'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">display_name(self):</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'group'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].display_name</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">mailboxes(self):</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'mailbox'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[self[</span><span class="s5">0</span><span class="s1">]]</span>
        <span class="s2">elif </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'invalid-mailbox'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].mailboxes</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">all_mailboxes(self):</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'mailbox'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[self[</span><span class="s5">0</span><span class="s1">]]</span>
        <span class="s2">elif </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'invalid-mailbox'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[self[</span><span class="s5">0</span><span class="s1">]]</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].all_mailboxes</span>

<span class="s2">class </span><span class="s1">MailboxList(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'mailbox-list'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">mailboxes(self):</span>
        <span class="s2">return </span><span class="s1">[x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self </span><span class="s2">if </span><span class="s1">x.token_type==</span><span class="s4">'mailbox'</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">all_mailboxes(self):</span>
        <span class="s2">return </span><span class="s1">[x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self</span>
            <span class="s2">if </span><span class="s1">x.token_type </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'mailbox'</span><span class="s2">, </span><span class="s4">'invalid-mailbox'</span><span class="s1">)]</span>


<span class="s2">class </span><span class="s1">GroupList(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'group-list'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">mailboxes(self):</span>
        <span class="s2">if not </span><span class="s1">self </span><span class="s2">or </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type != </span><span class="s4">'mailbox-list'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].mailboxes</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">all_mailboxes(self):</span>
        <span class="s2">if not </span><span class="s1">self </span><span class="s2">or </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type != </span><span class="s4">'mailbox-list'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].all_mailboxes</span>


<span class="s2">class </span><span class="s1">Group(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">&quot;group&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">mailboxes(self):</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s5">2</span><span class="s1">].token_type != </span><span class="s4">'group-list'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">2</span><span class="s1">].mailboxes</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">all_mailboxes(self):</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s5">2</span><span class="s1">].token_type != </span><span class="s4">'group-list'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">2</span><span class="s1">].all_mailboxes</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">display_name(self):</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].display_name</span>


<span class="s2">class </span><span class="s1">NameAddr(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'name-addr'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">display_name(self):</span>
        <span class="s2">if </span><span class="s1">len(self) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].display_name</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">local_part(self):</span>
        <span class="s2">return </span><span class="s1">self[-</span><span class="s5">1</span><span class="s1">].local_part</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">domain(self):</span>
        <span class="s2">return </span><span class="s1">self[-</span><span class="s5">1</span><span class="s1">].domain</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">route(self):</span>
        <span class="s2">return </span><span class="s1">self[-</span><span class="s5">1</span><span class="s1">].route</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">addr_spec(self):</span>
        <span class="s2">return </span><span class="s1">self[-</span><span class="s5">1</span><span class="s1">].addr_spec</span>


<span class="s2">class </span><span class="s1">AngleAddr(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'angle-addr'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">local_part(self):</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">x.token_type == </span><span class="s4">'addr-spec'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">x.local_part</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">domain(self):</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">x.token_type == </span><span class="s4">'addr-spec'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">x.domain</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">route(self):</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">x.token_type == </span><span class="s4">'obs-route'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">x.domains</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">addr_spec(self):</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">x.token_type == </span><span class="s4">'addr-spec'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">x.addr_spec</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">'&lt;&gt;'</span>


<span class="s2">class </span><span class="s1">ObsRoute(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'obs-route'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">domains(self):</span>
        <span class="s2">return </span><span class="s1">[x.domain </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self </span><span class="s2">if </span><span class="s1">x.token_type == </span><span class="s4">'domain'</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">Mailbox(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'mailbox'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">display_name(self):</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'name-addr'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].display_name</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">local_part(self):</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].local_part</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">domain(self):</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].domain</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">route(self):</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'name-addr'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].route</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">addr_spec(self):</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].addr_spec</span>


<span class="s2">class </span><span class="s1">InvalidMailbox(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'invalid-mailbox'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">display_name(self):</span>
        <span class="s2">return None</span>

    <span class="s1">local_part = domain = route = addr_spec = display_name</span>


<span class="s2">class </span><span class="s1">Domain(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'domain'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">domain(self):</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(super(Domain</span><span class="s2">, </span><span class="s1">self).value.split())</span>


<span class="s2">class </span><span class="s1">DotAtom(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'dot-atom'</span>


<span class="s2">class </span><span class="s1">DotAtomText(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'dot-atom-text'</span>


<span class="s2">class </span><span class="s1">AddrSpec(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'addr-spec'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">local_part(self):</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].local_part</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">domain(self):</span>
        <span class="s2">if </span><span class="s1">len(self) &lt; </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">self[-</span><span class="s5">1</span><span class="s1">].domain</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">value(self):</span>
        <span class="s2">if </span><span class="s1">len(self) &lt; </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].value</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].value.rstrip()+self[</span><span class="s5">1</span><span class="s1">].value+self[</span><span class="s5">2</span><span class="s1">].value.lstrip()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">addr_spec(self):</span>
        <span class="s1">nameset = set(self.local_part)</span>
        <span class="s2">if </span><span class="s1">len(nameset) &gt; len(nameset-DOT_ATOM_ENDS):</span>
            <span class="s1">lp = quote_string(self.local_part)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lp = self.local_part</span>
        <span class="s2">if </span><span class="s1">self.domain </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lp + </span><span class="s4">'@' </span><span class="s1">+ self.domain</span>
        <span class="s2">return </span><span class="s1">lp</span>


<span class="s2">class </span><span class="s1">ObsLocalPart(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'obs-local-part'</span>


<span class="s2">class </span><span class="s1">DisplayName(Phrase):</span>

    <span class="s1">token_type = </span><span class="s4">'display-name'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">display_name(self):</span>
        <span class="s1">res = TokenList(self)</span>
        <span class="s2">if </span><span class="s1">res[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'cfws'</span><span class="s1">:</span>
            <span class="s1">res.pop(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">res[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'cfws'</span><span class="s1">:</span>
                <span class="s1">res[</span><span class="s5">0</span><span class="s1">] = TokenList(res[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">:])</span>
        <span class="s2">if </span><span class="s1">res[-</span><span class="s5">1</span><span class="s1">].token_type == </span><span class="s4">'cfws'</span><span class="s1">:</span>
            <span class="s1">res.pop()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">res[-</span><span class="s5">1</span><span class="s1">][-</span><span class="s5">1</span><span class="s1">].token_type == </span><span class="s4">'cfws'</span><span class="s1">:</span>
                <span class="s1">res[-</span><span class="s5">1</span><span class="s1">] = TokenList(res[-</span><span class="s5">1</span><span class="s1">][:-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">res.value</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">value(self):</span>
        <span class="s1">quote = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">self.defects:</span>
            <span class="s1">quote = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self:</span>
                <span class="s2">if </span><span class="s1">x.token_type == </span><span class="s4">'quoted-string'</span><span class="s1">:</span>
                    <span class="s1">quote = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">quote:</span>
            <span class="s1">pre = post = </span><span class="s4">''</span>
            <span class="s2">if </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type==</span><span class="s4">'cfws' </span><span class="s2">or </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">].token_type==</span><span class="s4">'cfws'</span><span class="s1">:</span>
                <span class="s1">pre = </span><span class="s4">' '</span>
            <span class="s2">if </span><span class="s1">self[-</span><span class="s5">1</span><span class="s1">].token_type==</span><span class="s4">'cfws' </span><span class="s2">or </span><span class="s1">self[-</span><span class="s5">1</span><span class="s1">][-</span><span class="s5">1</span><span class="s1">].token_type==</span><span class="s4">'cfws'</span><span class="s1">:</span>
                <span class="s1">post = </span><span class="s4">' '</span>
            <span class="s2">return </span><span class="s1">pre+quote_string(self.display_name)+post</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super(DisplayName</span><span class="s2">, </span><span class="s1">self).value</span>


<span class="s2">class </span><span class="s1">LocalPart(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'local-part'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">value(self):</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">&quot;quoted-string&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].quoted_value</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].value</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">local_part(self):</span>
        <span class="s3"># Strip whitespace from front, back, and around dots.</span>
        <span class="s1">res = [DOT]</span>
        <span class="s1">last = DOT</span>
        <span class="s1">last_is_tl = </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">tok </span><span class="s2">in </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">] + [DOT]:</span>
            <span class="s2">if </span><span class="s1">tok.token_type == </span><span class="s4">'cfws'</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">(last_is_tl </span><span class="s2">and </span><span class="s1">tok.token_type == </span><span class="s4">'dot' </span><span class="s2">and</span>
                    <span class="s1">last[-</span><span class="s5">1</span><span class="s1">].token_type == </span><span class="s4">'cfws'</span><span class="s1">):</span>
                <span class="s1">res[-</span><span class="s5">1</span><span class="s1">] = TokenList(last[:-</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">is_tl = isinstance(tok</span><span class="s2">, </span><span class="s1">TokenList)</span>
            <span class="s2">if </span><span class="s1">(is_tl </span><span class="s2">and </span><span class="s1">last.token_type == </span><span class="s4">'dot' </span><span class="s2">and</span>
                    <span class="s1">tok[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'cfws'</span><span class="s1">):</span>
                <span class="s1">res.append(TokenList(tok[</span><span class="s5">1</span><span class="s1">:]))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">res.append(tok)</span>
            <span class="s1">last = res[-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">last_is_tl = is_tl</span>
        <span class="s1">res = TokenList(res[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">res.value</span>


<span class="s2">class </span><span class="s1">DomainLiteral(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'domain-literal'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">domain(self):</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(super(DomainLiteral</span><span class="s2">, </span><span class="s1">self).value.split())</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ip(self):</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">x.token_type == </span><span class="s4">'ptext'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">x.value</span>


<span class="s2">class </span><span class="s1">MIMEVersion(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'mime-version'</span>
    <span class="s1">major = </span><span class="s2">None</span>
    <span class="s1">minor = </span><span class="s2">None</span>


<span class="s2">class </span><span class="s1">Parameter(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'parameter'</span>
    <span class="s1">sectioned = </span><span class="s2">False</span>
    <span class="s1">extended = </span><span class="s2">False</span>
    <span class="s1">charset = </span><span class="s4">'us-ascii'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">section_number(self):</span>
        <span class="s3"># Because the first token, the attribute (name) eats CFWS, the second</span>
        <span class="s3"># token is always the section if there is one.</span>
        <span class="s2">return </span><span class="s1">self[</span><span class="s5">1</span><span class="s1">].number </span><span class="s2">if </span><span class="s1">self.sectioned </span><span class="s2">else </span><span class="s5">0</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">param_value(self):</span>
        <span class="s3"># This is part of the &quot;handle quoted extended parameters&quot; hack.</span>
        <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">token.token_type == </span><span class="s4">'value'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">token.stripped_value</span>
            <span class="s2">if </span><span class="s1">token.token_type == </span><span class="s4">'quoted-string'</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">token:</span>
                    <span class="s2">if </span><span class="s1">token.token_type == </span><span class="s4">'bare-quoted-string'</span><span class="s1">:</span>
                        <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">token:</span>
                            <span class="s2">if </span><span class="s1">token.token_type == </span><span class="s4">'value'</span><span class="s1">:</span>
                                <span class="s2">return </span><span class="s1">token.stripped_value</span>
        <span class="s2">return </span><span class="s4">''</span>


<span class="s2">class </span><span class="s1">InvalidParameter(Parameter):</span>

    <span class="s1">token_type = </span><span class="s4">'invalid-parameter'</span>


<span class="s2">class </span><span class="s1">Attribute(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'attribute'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">stripped_value(self):</span>
        <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">token.token_type.endswith(</span><span class="s4">'attrtext'</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s1">token.value</span>

<span class="s2">class </span><span class="s1">Section(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'section'</span>
    <span class="s1">number = </span><span class="s2">None</span>


<span class="s2">class </span><span class="s1">Value(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'value'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">stripped_value(self):</span>
        <span class="s1">token = self[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">token.token_type == </span><span class="s4">'cfws'</span><span class="s1">:</span>
            <span class="s1">token = self[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">token.token_type.endswith(</span>
                <span class="s1">(</span><span class="s4">'quoted-string'</span><span class="s2">, </span><span class="s4">'attribute'</span><span class="s2">, </span><span class="s4">'extended-attribute'</span><span class="s1">)):</span>
            <span class="s2">return </span><span class="s1">token.stripped_value</span>
        <span class="s2">return </span><span class="s1">self.value</span>


<span class="s2">class </span><span class="s1">MimeParameters(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'mime-parameters'</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">params(self):</span>
        <span class="s3"># The RFC specifically states that the ordering of parameters is not</span>
        <span class="s3"># guaranteed and may be reordered by the transport layer.  So we have</span>
        <span class="s3"># to assume the RFC 2231 pieces can come in any order.  However, we</span>
        <span class="s3"># output them in the order that we first see a given name, which gives</span>
        <span class="s3"># us a stable __str__.</span>
        <span class="s1">params = OrderedDict()</span>
        <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if not </span><span class="s1">token.token_type.endswith(</span><span class="s4">'parameter'</span><span class="s1">):</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">token[</span><span class="s5">0</span><span class="s1">].token_type != </span><span class="s4">'attribute'</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s1">name = token[</span><span class="s5">0</span><span class="s1">].value.strip()</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">params:</span>
                <span class="s1">params[name] = []</span>
            <span class="s1">params[name].append((token.section_number</span><span class="s2">, </span><span class="s1">token))</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">parts </span><span class="s2">in </span><span class="s1">params.items():</span>
            <span class="s1">parts = sorted(parts)</span>
            <span class="s3"># XXX: there might be more recovery we could do here if, for</span>
            <span class="s3"># example, this is really a case of a duplicate attribute name.</span>
            <span class="s1">value_parts = []</span>
            <span class="s1">charset = parts[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">].charset</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(section_number</span><span class="s2">, </span><span class="s1">param) </span><span class="s2">in </span><span class="s1">enumerate(parts):</span>
                <span class="s2">if </span><span class="s1">section_number != i:</span>
                    <span class="s1">param.defects.append(errors.InvalidHeaderDefect(</span>
                        <span class="s4">&quot;inconsistent multipart parameter numbering&quot;</span><span class="s1">))</span>
                <span class="s1">value = param.param_value</span>
                <span class="s2">if </span><span class="s1">param.extended:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">value = unquote_to_bytes(value)</span>
                    <span class="s2">except </span><span class="s1">UnicodeEncodeError:</span>
                        <span class="s3"># source had surrogate escaped bytes.  What we do now</span>
                        <span class="s3"># is a bit of an open question.  I'm not sure this is</span>
                        <span class="s3"># the best choice, but it is what the old algorithm did</span>
                        <span class="s1">value = unquote(value</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s4">'latin-1'</span><span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s1">value = value.decode(charset</span><span class="s2">, </span><span class="s4">'surrogateescape'</span><span class="s1">)</span>
                        <span class="s2">except </span><span class="s1">LookupError:</span>
                            <span class="s3"># XXX: there should really be a custom defect for</span>
                            <span class="s3"># unknown character set to make it easy to find,</span>
                            <span class="s3"># because otherwise unknown charset is a silent</span>
                            <span class="s3"># failure.</span>
                            <span class="s1">value = value.decode(</span><span class="s4">'us-ascii'</span><span class="s2">, </span><span class="s4">'surrogateescape'</span><span class="s1">)</span>
                        <span class="s2">if </span><span class="s1">utils._has_surrogates(value):</span>
                            <span class="s1">param.defects.append(errors.UndecodableBytesDefect())</span>
                <span class="s1">value_parts.append(value)</span>
            <span class="s1">value = </span><span class="s4">''</span><span class="s1">.join(value_parts)</span>
            <span class="s2">yield </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">params = []</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self.params:</span>
            <span class="s2">if </span><span class="s1">value:</span>
                <span class="s1">params.append(</span><span class="s4">'{}={}'</span><span class="s1">.format(name</span><span class="s2">, </span><span class="s1">quote_string(value)))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">params.append(name)</span>
        <span class="s1">params = </span><span class="s4">'; '</span><span class="s1">.join(params)</span>
        <span class="s2">return </span><span class="s4">' ' </span><span class="s1">+ params </span><span class="s2">if </span><span class="s1">params </span><span class="s2">else </span><span class="s4">''</span>


<span class="s2">class </span><span class="s1">ParameterizedHeaderValue(TokenList):</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">params(self):</span>
        <span class="s2">for </span><span class="s1">token </span><span class="s2">in </span><span class="s1">reversed(self):</span>
            <span class="s2">if </span><span class="s1">token.token_type == </span><span class="s4">'mime-parameters'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">token.params</span>
        <span class="s2">return </span><span class="s1">{}</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">parts(self):</span>
        <span class="s2">if </span><span class="s1">self </span><span class="s2">and </span><span class="s1">self[-</span><span class="s5">1</span><span class="s1">].token_type == </span><span class="s4">'mime-parameters'</span><span class="s1">:</span>
            <span class="s3"># We don't want to start a new line if all of the params don't fit</span>
            <span class="s3"># after the value, so unwrap the parameter list.</span>
            <span class="s2">return </span><span class="s1">TokenList(self[:-</span><span class="s5">1</span><span class="s1">] + self[-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">TokenList(self).parts</span>


<span class="s2">class </span><span class="s1">ContentType(ParameterizedHeaderValue):</span>

    <span class="s1">token_type = </span><span class="s4">'content-type'</span>
    <span class="s1">maintype = </span><span class="s4">'text'</span>
    <span class="s1">subtype = </span><span class="s4">'plain'</span>


<span class="s2">class </span><span class="s1">ContentDisposition(ParameterizedHeaderValue):</span>

    <span class="s1">token_type = </span><span class="s4">'content-disposition'</span>
    <span class="s1">content_disposition = </span><span class="s2">None</span>


<span class="s2">class </span><span class="s1">ContentTransferEncoding(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'content-transfer-encoding'</span>
    <span class="s1">cte = </span><span class="s4">'7bit'</span>


<span class="s2">class </span><span class="s1">HeaderLabel(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'header-label'</span>


<span class="s2">class </span><span class="s1">Header(TokenList):</span>

    <span class="s1">token_type = </span><span class="s4">'header'</span>

    <span class="s2">def </span><span class="s1">_fold(self</span><span class="s2">, </span><span class="s1">folded):</span>
        <span class="s1">folded.append(str(self.pop(</span><span class="s5">0</span><span class="s1">)))</span>
        <span class="s1">folded.lastlen = len(folded.current[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s3"># The first line of the header is different from all others: we don't</span>
        <span class="s3"># want to start a new object on a new line if it has any fold points in</span>
        <span class="s3"># it that would allow part of it to be on the first header line.</span>
        <span class="s3"># Further, if the first fold point would fit on the new line, we want</span>
        <span class="s3"># to do that, but if it doesn't we want to put it on the first line.</span>
        <span class="s3"># Folded supports this via the stickyspace attribute.  If this</span>
        <span class="s3"># attribute is not None, it does the special handling.</span>
        <span class="s1">folded.stickyspace = str(self.pop(</span><span class="s5">0</span><span class="s1">)) </span><span class="s2">if </span><span class="s1">self[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'cfws' </span><span class="s2">else </span><span class="s4">''</span>
        <span class="s1">rest = self.pop(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Malformed Header token list&quot;</span><span class="s1">)</span>
        <span class="s1">rest._fold(folded)</span>


<span class="s3">#</span>
<span class="s3"># Terminal classes and instances</span>
<span class="s3">#</span>

<span class="s2">class </span><span class="s1">Terminal(str):</span>

    <span class="s2">def </span><span class="s1">__new__(cls</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">token_type):</span>
        <span class="s1">self = super(Terminal</span><span class="s2">, </span><span class="s1">cls).__new__(cls</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s1">self.token_type = token_type</span>
        <span class="s1">self.defects = []</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;{}({})&quot;</span><span class="s1">.format(self.__class__.__name__</span><span class="s2">, </span><span class="s1">super(Terminal</span><span class="s2">, </span><span class="s1">self).__repr__())</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">all_defects(self):</span>
        <span class="s2">return </span><span class="s1">list(self.defects)</span>

    <span class="s2">def </span><span class="s1">_pp(self</span><span class="s2">, </span><span class="s1">indent=</span><span class="s4">''</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s4">&quot;{}{}/{}({}){}&quot;</span><span class="s1">.format(</span>
            <span class="s1">indent</span><span class="s2">,</span>
            <span class="s1">self.__class__.__name__</span><span class="s2">,</span>
            <span class="s1">self.token_type</span><span class="s2">,</span>
            <span class="s1">super(Terminal</span><span class="s2">, </span><span class="s1">self).__repr__()</span><span class="s2">,</span>
            <span class="s4">'' </span><span class="s2">if not </span><span class="s1">self.defects </span><span class="s2">else </span><span class="s4">' {}'</span><span class="s1">.format(self.defects)</span><span class="s2">,</span>
            <span class="s1">)]</span>

    <span class="s2">def </span><span class="s1">cte_encode(self</span><span class="s2">, </span><span class="s1">charset</span><span class="s2">, </span><span class="s1">policy):</span>
        <span class="s1">value = str(self)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">value.encode(</span><span class="s4">'us-ascii'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">value</span>
        <span class="s2">except </span><span class="s1">UnicodeEncodeError:</span>
            <span class="s2">return </span><span class="s1">_ew.encode(value</span><span class="s2">, </span><span class="s1">charset)</span>

    <span class="s2">def </span><span class="s1">pop_trailing_ws(self):</span>
        <span class="s3"># This terminates the recursion.</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">pop_leading_fws(self):</span>
        <span class="s3"># This terminates the recursion.</span>
        <span class="s2">return None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">comments(self):</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">has_leading_comment(self):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">__getnewargs__(self):</span>
        <span class="s2">return</span><span class="s1">(str(self)</span><span class="s2">, </span><span class="s1">self.token_type)</span>


<span class="s2">class </span><span class="s1">WhiteSpaceTerminal(Terminal):</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">value(self):</span>
        <span class="s2">return </span><span class="s4">' '</span>

    <span class="s2">def </span><span class="s1">startswith_fws(self):</span>
        <span class="s2">return True</span>

    <span class="s1">has_fws = </span><span class="s2">True</span>


<span class="s2">class </span><span class="s1">ValueTerminal(Terminal):</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">value(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">startswith_fws(self):</span>
        <span class="s2">return False</span>

    <span class="s1">has_fws = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">as_encoded_word(self</span><span class="s2">, </span><span class="s1">charset):</span>
        <span class="s2">return </span><span class="s1">_ew.encode(str(self)</span><span class="s2">, </span><span class="s1">charset)</span>


<span class="s2">class </span><span class="s1">EWWhiteSpaceTerminal(WhiteSpaceTerminal):</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">value(self):</span>
        <span class="s2">return </span><span class="s4">''</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">encoded(self):</span>
        <span class="s2">return </span><span class="s1">self[:]</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s4">''</span>

    <span class="s1">has_fws = </span><span class="s2">True</span>


<span class="s3"># XXX these need to become classes and used as instances so</span>
<span class="s3"># that a program can't change them in a parse tree and screw</span>
<span class="s3"># up other parse trees.  Maybe should have  tests for that, too.</span>
<span class="s1">DOT = ValueTerminal(</span><span class="s4">'.'</span><span class="s2">, </span><span class="s4">'dot'</span><span class="s1">)</span>
<span class="s1">ListSeparator = ValueTerminal(</span><span class="s4">','</span><span class="s2">, </span><span class="s4">'list-separator'</span><span class="s1">)</span>
<span class="s1">RouteComponentMarker = ValueTerminal(</span><span class="s4">'@'</span><span class="s2">, </span><span class="s4">'route-component-marker'</span><span class="s1">)</span>

<span class="s3">#</span>
<span class="s3"># Parser</span>
<span class="s3">#</span>

<span class="s4">&quot;&quot;&quot;Parse strings according to RFC822/2047/2822/5322 rules. 
 
This is a stateless parser.  Each get_XXX function accepts a string and 
returns either a Terminal or a TokenList representing the RFC object named 
by the method and a string containing the remaining unparsed characters 
from the input.  Thus a parser method consumes the next syntactic construct 
of a given type and returns a token representing the construct plus the 
unparsed remainder of the input string. 
 
For example, if the first element of a structured header is a 'phrase', 
then: 
 
    phrase, value = get_phrase(value) 
 
returns the complete phrase from the start of the string value, plus any 
characters left in the string after the phrase is removed. 
 
&quot;&quot;&quot;</span>

<span class="s1">_wsp_splitter = re.compile(</span><span class="s4">r'([{}]+)'</span><span class="s1">.format(</span><span class="s4">''</span><span class="s1">.join(WSP))).split</span>
<span class="s1">_non_atom_end_matcher = re.compile(</span><span class="s4">r&quot;[^{}]+&quot;</span><span class="s1">.format(</span>
    <span class="s4">''</span><span class="s1">.join(ATOM_ENDS).replace(</span><span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s2">,</span><span class="s4">'</span><span class="s2">\\\\</span><span class="s4">'</span><span class="s1">).replace(</span><span class="s4">']'</span><span class="s2">,</span><span class="s4">'\]'</span><span class="s1">))).match</span>
<span class="s1">_non_printable_finder = re.compile(</span><span class="s4">r&quot;[\x00-\x20\x7F]&quot;</span><span class="s1">).findall</span>
<span class="s1">_non_token_end_matcher = re.compile(</span><span class="s4">r&quot;[^{}]+&quot;</span><span class="s1">.format(</span>
    <span class="s4">''</span><span class="s1">.join(TOKEN_ENDS).replace(</span><span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s2">,</span><span class="s4">'</span><span class="s2">\\\\</span><span class="s4">'</span><span class="s1">).replace(</span><span class="s4">']'</span><span class="s2">,</span><span class="s4">'\]'</span><span class="s1">))).match</span>
<span class="s1">_non_attribute_end_matcher = re.compile(</span><span class="s4">r&quot;[^{}]+&quot;</span><span class="s1">.format(</span>
    <span class="s4">''</span><span class="s1">.join(ATTRIBUTE_ENDS).replace(</span><span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s2">,</span><span class="s4">'</span><span class="s2">\\\\</span><span class="s4">'</span><span class="s1">).replace(</span><span class="s4">']'</span><span class="s2">,</span><span class="s4">'\]'</span><span class="s1">))).match</span>
<span class="s1">_non_extended_attribute_end_matcher = re.compile(</span><span class="s4">r&quot;[^{}]+&quot;</span><span class="s1">.format(</span>
    <span class="s4">''</span><span class="s1">.join(EXTENDED_ATTRIBUTE_ENDS).replace(</span>
                                    <span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s2">,</span><span class="s4">'</span><span class="s2">\\\\</span><span class="s4">'</span><span class="s1">).replace(</span><span class="s4">']'</span><span class="s2">,</span><span class="s4">'\]'</span><span class="s1">))).match</span>

<span class="s2">def </span><span class="s1">_validate_xtext(xtext):</span>
    <span class="s0">&quot;&quot;&quot;If input token contains ASCII non-printables, register a defect.&quot;&quot;&quot;</span>

    <span class="s1">non_printables = _non_printable_finder(xtext)</span>
    <span class="s2">if </span><span class="s1">non_printables:</span>
        <span class="s1">xtext.defects.append(errors.NonPrintableDefect(non_printables))</span>
    <span class="s2">if </span><span class="s1">utils._has_surrogates(xtext):</span>
        <span class="s1">xtext.defects.append(errors.UndecodableBytesDefect(</span>
            <span class="s4">&quot;Non-ASCII characters found in header token&quot;</span><span class="s1">))</span>

<span class="s2">def </span><span class="s1">_get_ptext_to_endchars(value</span><span class="s2">, </span><span class="s1">endchars):</span>
    <span class="s0">&quot;&quot;&quot;Scan printables/quoted-pairs until endchars and return unquoted ptext. 
 
    This function turns a run of qcontent, ccontent-without-comments, or 
    dtext-with-quoted-printables into a single string by unquoting any 
    quoted printables.  It returns the string, the remaining value, and 
    a flag that is True iff there were any quoted printables decoded. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_3to2list = list(_wsp_splitter(value</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">fragment</span><span class="s2">, </span><span class="s1">remainder</span><span class="s2">, </span><span class="s1">= _3to2list[:</span><span class="s5">1</span><span class="s1">] + [_3to2list[</span><span class="s5">1</span><span class="s1">:]]</span>
    <span class="s1">vchars = []</span>
    <span class="s1">escape = </span><span class="s2">False</span>
    <span class="s1">had_qp = </span><span class="s2">False</span>
    <span class="s2">for </span><span class="s1">pos </span><span class="s2">in </span><span class="s1">range(len(fragment)):</span>
        <span class="s2">if </span><span class="s1">fragment[pos] == </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">escape:</span>
                <span class="s1">escape = </span><span class="s2">False</span>
                <span class="s1">had_qp = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">escape = </span><span class="s2">True</span>
                <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">escape:</span>
            <span class="s1">escape = </span><span class="s2">False</span>
        <span class="s2">elif </span><span class="s1">fragment[pos] </span><span class="s2">in </span><span class="s1">endchars:</span>
            <span class="s2">break</span>
        <span class="s1">vchars.append(fragment[pos])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">pos = pos + </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(vchars)</span><span class="s2">, </span><span class="s4">''</span><span class="s1">.join([fragment[pos:]] + remainder)</span><span class="s2">, </span><span class="s1">had_qp</span>

<span class="s2">def </span><span class="s1">_decode_ew_run(value):</span>
    <span class="s0">&quot;&quot;&quot; Decode a run of RFC2047 encoded words. 
 
        _decode_ew_run(value) -&gt; (text, value, defects) 
 
    Scans the supplied value for a run of tokens that look like they are RFC 
    2047 encoded words, decodes those words into text according to RFC 2047 
    rules (whitespace between encoded words is discarded), and returns the text 
    and the remaining value (including any leading whitespace on the remaining 
    value), as well as a list of any defects encountered while decoding.  The 
    input value may not have any leading whitespace. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">res = []</span>
    <span class="s1">defects = []</span>
    <span class="s1">last_ws = </span><span class="s4">''</span>
    <span class="s2">while </span><span class="s1">value:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">tok</span><span class="s2">, </span><span class="s1">ws</span><span class="s2">, </span><span class="s1">value = _wsp_splitter(value</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s1">tok</span><span class="s2">, </span><span class="s1">ws</span><span class="s2">, </span><span class="s1">value = value</span><span class="s2">, </span><span class="s4">''</span><span class="s2">, </span><span class="s4">''</span>
        <span class="s2">if not </span><span class="s1">(tok.startswith(</span><span class="s4">'=?'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">tok.endswith(</span><span class="s4">'?='</span><span class="s1">)):</span>
            <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(res)</span><span class="s2">, </span><span class="s1">last_ws + tok + ws + value</span><span class="s2">, </span><span class="s1">defects</span>
        <span class="s1">text</span><span class="s2">, </span><span class="s1">charset</span><span class="s2">, </span><span class="s1">lang</span><span class="s2">, </span><span class="s1">new_defects = _ew.decode(tok)</span>
        <span class="s1">res.append(text)</span>
        <span class="s1">defects.extend(new_defects)</span>
        <span class="s1">last_ws = ws</span>
    <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(res)</span><span class="s2">, </span><span class="s1">last_ws</span><span class="s2">, </span><span class="s1">defects</span>

<span class="s2">def </span><span class="s1">get_fws(value):</span>
    <span class="s0">&quot;&quot;&quot;FWS = 1*WSP 
 
    This isn't the RFC definition.  We're using fws to represent tokens where 
    folding can be done, but when we are parsing the *un*folding has already 
    been done so we don't need to watch out for CRLF. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">newvalue = value.lstrip()</span>
    <span class="s1">fws = WhiteSpaceTerminal(value[:len(value)-len(newvalue)]</span><span class="s2">, </span><span class="s4">'fws'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">fws</span><span class="s2">, </span><span class="s1">newvalue</span>

<span class="s2">def </span><span class="s1">get_encoded_word(value):</span>
    <span class="s0">&quot;&quot;&quot; encoded-word = &quot;=?&quot; charset &quot;?&quot; encoding &quot;?&quot; encoded-text &quot;?=&quot; 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ew = EncodedWord()</span>
    <span class="s2">if not </span><span class="s1">value.startswith(</span><span class="s4">'=?'</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected encoded word but found {}&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">_3to2list1 = list(value[</span><span class="s5">2</span><span class="s1">:].split(</span><span class="s4">'?='</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">tok</span><span class="s2">, </span><span class="s1">remainder</span><span class="s2">, </span><span class="s1">= _3to2list1[:</span><span class="s5">1</span><span class="s1">] + [_3to2list1[</span><span class="s5">1</span><span class="s1">:]]</span>
    <span class="s2">if </span><span class="s1">tok == value[</span><span class="s5">2</span><span class="s1">:]:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected encoded word but found {}&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">remstr = </span><span class="s4">''</span><span class="s1">.join(remainder)</span>
    <span class="s2">if </span><span class="s1">remstr[:</span><span class="s5">2</span><span class="s1">].isdigit():</span>
        <span class="s1">_3to2list3 = list(remstr.split(</span><span class="s4">'?='</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">rest</span><span class="s2">, </span><span class="s1">remainder</span><span class="s2">, </span><span class="s1">= _3to2list3[:</span><span class="s5">1</span><span class="s1">] + [_3to2list3[</span><span class="s5">1</span><span class="s1">:]]</span>
        <span class="s1">tok = tok + </span><span class="s4">'?=' </span><span class="s1">+ rest</span>
    <span class="s2">if </span><span class="s1">len(tok.split()) &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">ew.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;whitespace inside encoded word&quot;</span><span class="s1">))</span>
    <span class="s1">ew.cte = value</span>
    <span class="s1">value = </span><span class="s4">''</span><span class="s1">.join(remainder)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">text</span><span class="s2">, </span><span class="s1">charset</span><span class="s2">, </span><span class="s1">lang</span><span class="s2">, </span><span class="s1">defects = _ew.decode(</span><span class="s4">'=?' </span><span class="s1">+ tok + </span><span class="s4">'?='</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">ValueError:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;encoded word format invalid: '{}'&quot;</span><span class="s1">.format(ew.cte))</span>
    <span class="s1">ew.charset = charset</span>
    <span class="s1">ew.lang = lang</span>
    <span class="s1">ew.defects.extend(defects)</span>
    <span class="s2">while </span><span class="s1">text:</span>
        <span class="s2">if </span><span class="s1">text[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">WSP:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">text = get_fws(text)</span>
            <span class="s1">ew.append(token)</span>
            <span class="s2">continue</span>
        <span class="s1">_3to2list5 = list(_wsp_splitter(text</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">chars</span><span class="s2">, </span><span class="s1">remainder</span><span class="s2">, </span><span class="s1">= _3to2list5[:</span><span class="s5">1</span><span class="s1">] + [_3to2list5[</span><span class="s5">1</span><span class="s1">:]]</span>
        <span class="s1">vtext = ValueTerminal(chars</span><span class="s2">, </span><span class="s4">'vtext'</span><span class="s1">)</span>
        <span class="s1">_validate_xtext(vtext)</span>
        <span class="s1">ew.append(vtext)</span>
        <span class="s1">text = </span><span class="s4">''</span><span class="s1">.join(remainder)</span>
    <span class="s2">return </span><span class="s1">ew</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_unstructured(value):</span>
    <span class="s0">&quot;&quot;&quot;unstructured = (*([FWS] vchar) *WSP) / obs-unstruct 
       obs-unstruct = *((*LF *CR *(obs-utext) *LF *CR)) / FWS) 
       obs-utext = %d0 / obs-NO-WS-CTL / LF / CR 
 
       obs-NO-WS-CTL is control characters except WSP/CR/LF. 
 
    So, basically, we have printable runs, plus control characters or nulls in 
    the obsolete syntax, separated by whitespace.  Since RFC 2047 uses the 
    obsolete syntax in its specification, but requires whitespace on either 
    side of the encoded words, I can see no reason to need to separate the 
    non-printable-non-whitespace from the printable runs if they occur, so we 
    parse this into xtext tokens separated by WSP tokens. 
 
    Because an 'unstructured' value must by definition constitute the entire 
    value, this 'get' routine does not return a remaining value, only the 
    parsed TokenList. 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># XXX: but what about bare CR and LF?  They might signal the start or</span>
    <span class="s3"># end of an encoded word.  YAGNI for now, since out current parsers</span>
    <span class="s3"># will never send us strings with bard CR or LF.</span>

    <span class="s1">unstructured = UnstructuredTokenList()</span>
    <span class="s2">while </span><span class="s1">value:</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">WSP:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_fws(value)</span>
            <span class="s1">unstructured.append(token)</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">value.startswith(</span><span class="s4">'=?'</span><span class="s1">):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_encoded_word(value)</span>
            <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">have_ws = </span><span class="s2">True</span>
                <span class="s2">if </span><span class="s1">len(unstructured) &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">unstructured[-</span><span class="s5">1</span><span class="s1">].token_type != </span><span class="s4">'fws'</span><span class="s1">:</span>
                        <span class="s1">unstructured.defects.append(errors.InvalidHeaderDefect(</span>
                            <span class="s4">&quot;missing whitespace before encoded word&quot;</span><span class="s1">))</span>
                        <span class="s1">have_ws = </span><span class="s2">False</span>
                <span class="s2">if </span><span class="s1">have_ws </span><span class="s2">and </span><span class="s1">len(unstructured) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">unstructured[-</span><span class="s5">2</span><span class="s1">].token_type == </span><span class="s4">'encoded-word'</span><span class="s1">:</span>
                        <span class="s1">unstructured[-</span><span class="s5">1</span><span class="s1">] = EWWhiteSpaceTerminal(</span>
                            <span class="s1">unstructured[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'fws'</span><span class="s1">)</span>
                <span class="s1">unstructured.append(token)</span>
                <span class="s2">continue</span>
        <span class="s1">_3to2list7 = list(_wsp_splitter(value</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">tok</span><span class="s2">, </span><span class="s1">remainder</span><span class="s2">, </span><span class="s1">= _3to2list7[:</span><span class="s5">1</span><span class="s1">] + [_3to2list7[</span><span class="s5">1</span><span class="s1">:]]</span>
        <span class="s1">vtext = ValueTerminal(tok</span><span class="s2">, </span><span class="s4">'vtext'</span><span class="s1">)</span>
        <span class="s1">_validate_xtext(vtext)</span>
        <span class="s1">unstructured.append(vtext)</span>
        <span class="s1">value = </span><span class="s4">''</span><span class="s1">.join(remainder)</span>
    <span class="s2">return </span><span class="s1">unstructured</span>

<span class="s2">def </span><span class="s1">get_qp_ctext(value):</span>
    <span class="s0">&quot;&quot;&quot;ctext = &lt;printable ascii except \ ( )&gt; 
 
    This is not the RFC ctext, since we are handling nested comments in comment 
    and unquoting quoted-pairs here.  We allow anything except the '()' 
    characters, but if we find any ASCII other than the RFC defined printable 
    ASCII an NonPrintableDefect is added to the token's defects list.  Since 
    quoted pairs are converted to their unquoted values, what is returned is 
    a 'ptext' token.  In this case it is a WhiteSpaceTerminal, so it's value 
    is ' '. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ptext</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">_ = _get_ptext_to_endchars(value</span><span class="s2">, </span><span class="s4">'()'</span><span class="s1">)</span>
    <span class="s1">ptext = WhiteSpaceTerminal(ptext</span><span class="s2">, </span><span class="s4">'ptext'</span><span class="s1">)</span>
    <span class="s1">_validate_xtext(ptext)</span>
    <span class="s2">return </span><span class="s1">ptext</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_qcontent(value):</span>
    <span class="s0">&quot;&quot;&quot;qcontent = qtext / quoted-pair 
 
    We allow anything except the DQUOTE character, but if we find any ASCII 
    other than the RFC defined printable ASCII an NonPrintableDefect is 
    added to the token's defects list.  Any quoted pairs are converted to their 
    unquoted values, so what is returned is a 'ptext' token.  In this case it 
    is a ValueTerminal. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ptext</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">_ = _get_ptext_to_endchars(value</span><span class="s2">, </span><span class="s4">'&quot;'</span><span class="s1">)</span>
    <span class="s1">ptext = ValueTerminal(ptext</span><span class="s2">, </span><span class="s4">'ptext'</span><span class="s1">)</span>
    <span class="s1">_validate_xtext(ptext)</span>
    <span class="s2">return </span><span class="s1">ptext</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_atext(value):</span>
    <span class="s0">&quot;&quot;&quot;atext = &lt;matches _atext_matcher&gt; 
 
    We allow any non-ATOM_ENDS in atext, but add an InvalidATextDefect to 
    the token's defects list if we find non-atext characters. 
    &quot;&quot;&quot;</span>
    <span class="s1">m = _non_atom_end_matcher(value)</span>
    <span class="s2">if not </span><span class="s1">m:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected atext but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">atext = m.group()</span>
    <span class="s1">value = value[len(atext):]</span>
    <span class="s1">atext = ValueTerminal(atext</span><span class="s2">, </span><span class="s4">'atext'</span><span class="s1">)</span>
    <span class="s1">_validate_xtext(atext)</span>
    <span class="s2">return </span><span class="s1">atext</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_bare_quoted_string(value):</span>
    <span class="s0">&quot;&quot;&quot;bare-quoted-string = DQUOTE *([FWS] qcontent) [FWS] DQUOTE 
 
    A quoted-string without the leading or trailing white space.  Its 
    value is the text between the quote marks, with whitespace 
    preserved and quoted pairs decoded. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'&quot;'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected '</span><span class="s2">\&quot;</span><span class="s4">' but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">bare_quoted_string = BareQuotedString()</span>
    <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'&quot;'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">WSP:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_fws(value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_qcontent(value)</span>
        <span class="s1">bare_quoted_string.append(token)</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s1">bare_quoted_string.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;end of header inside quoted string&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">bare_quoted_string</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">return </span><span class="s1">bare_quoted_string</span><span class="s2">, </span><span class="s1">value[</span><span class="s5">1</span><span class="s1">:]</span>

<span class="s2">def </span><span class="s1">get_comment(value):</span>
    <span class="s0">&quot;&quot;&quot;comment = &quot;(&quot; *([FWS] ccontent) [FWS] &quot;)&quot; 
       ccontent = ctext / quoted-pair / comment 
 
    We handle nested comments here, and quoted-pair in our qp-ctext routine. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'('</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected '(' but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">comment = Comment()</span>
    <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">&quot;)&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">WSP:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_fws(value)</span>
        <span class="s2">elif </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'('</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_comment(value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_qp_ctext(value)</span>
        <span class="s1">comment.append(token)</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s1">comment.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;end of header inside comment&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">comment</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">return </span><span class="s1">comment</span><span class="s2">, </span><span class="s1">value[</span><span class="s5">1</span><span class="s1">:]</span>

<span class="s2">def </span><span class="s1">get_cfws(value):</span>
    <span class="s0">&quot;&quot;&quot;CFWS = (1*([FWS] comment) [FWS]) / FWS 
 
    &quot;&quot;&quot;</span>
    <span class="s1">cfws = CFWSList()</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">WSP:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_fws(value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_comment(value)</span>
        <span class="s1">cfws.append(token)</span>
    <span class="s2">return </span><span class="s1">cfws</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_quoted_string(value):</span>
    <span class="s0">&quot;&quot;&quot;quoted-string = [CFWS] &lt;bare-quoted-string&gt; [CFWS] 
 
    'bare-quoted-string' is an intermediate class defined by this 
    parser and not by the RFC grammar.  It is the quoted string 
    without any attached CFWS. 
    &quot;&quot;&quot;</span>
    <span class="s1">quoted_string = QuotedString()</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">quoted_string.append(token)</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_bare_quoted_string(value)</span>
    <span class="s1">quoted_string.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">quoted_string.append(token)</span>
    <span class="s2">return </span><span class="s1">quoted_string</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_atom(value):</span>
    <span class="s0">&quot;&quot;&quot;atom = [CFWS] 1*atext [CFWS] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">atom = Atom()</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">atom.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">ATOM_ENDS:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected atom but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_atext(value)</span>
    <span class="s1">atom.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">atom.append(token)</span>
    <span class="s2">return </span><span class="s1">atom</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_dot_atom_text(value):</span>
    <span class="s0">&quot;&quot;&quot; dot-text = 1*atext *(&quot;.&quot; 1*atext) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">dot_atom_text = DotAtomText()</span>
    <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">ATOM_ENDS:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;expected atom at a start of &quot;</span>
            <span class="s4">&quot;dot-atom-text but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">ATOM_ENDS:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_atext(value)</span>
        <span class="s1">dot_atom_text.append(token)</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'.'</span><span class="s1">:</span>
            <span class="s1">dot_atom_text.append(DOT)</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">if </span><span class="s1">dot_atom_text[-</span><span class="s5">1</span><span class="s1">] </span><span class="s2">is </span><span class="s1">DOT:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;expected atom at end of dot-atom-text &quot;</span>
            <span class="s4">&quot;but found '{}'&quot;</span><span class="s1">.format(</span><span class="s4">'.'</span><span class="s1">+value))</span>
    <span class="s2">return </span><span class="s1">dot_atom_text</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_dot_atom(value):</span>
    <span class="s0">&quot;&quot;&quot; dot-atom = [CFWS] dot-atom-text [CFWS] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">dot_atom = DotAtom()</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">dot_atom.append(token)</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_dot_atom_text(value)</span>
    <span class="s1">dot_atom.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">dot_atom.append(token)</span>
    <span class="s2">return </span><span class="s1">dot_atom</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_word(value):</span>
    <span class="s0">&quot;&quot;&quot;word = atom / quoted-string 
 
    Either atom or quoted-string may start with CFWS.  We have to peel off this 
    CFWS first to determine which type of word to parse.  Afterward we splice 
    the leading CFWS, if any, into the parsed sub-token. 
 
    If neither an atom or a quoted-string is found before the next special, a 
    HeaderParseError is raised. 
 
    The token returned is either an Atom or a QuotedString, as appropriate. 
    This means the 'word' level of the formal grammar is not represented in the 
    parse tree; this is because having that extra layer when manipulating the 
    parse tree is more confusing than it is helpful. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">leader</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">leader = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">]==</span><span class="s4">'&quot;'</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_quoted_string(value)</span>
    <span class="s2">elif </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">SPECIALS:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;Expected 'atom' or 'quoted-string' &quot;</span>
                                      <span class="s4">&quot;but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_atom(value)</span>
    <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">token[:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
    <span class="s2">return </span><span class="s1">token</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_phrase(value):</span>
    <span class="s0">&quot;&quot;&quot; phrase = 1*word / obs-phrase 
        obs-phrase = word *(word / &quot;.&quot; / CFWS) 
 
    This means a phrase can be a sequence of words, periods, and CFWS in any 
    order as long as it starts with at least one word.  If anything other than 
    words is detected, an ObsoleteHeaderDefect is added to the token's defect 
    list.  We also accept a phrase that starts with CFWS followed by a dot; 
    this is registered as an InvalidHeaderDefect, since it is not supported by 
    even the obsolete grammar. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">phrase = Phrase()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_word(value)</span>
        <span class="s1">phrase.append(token)</span>
    <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
        <span class="s1">phrase.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;phrase does not start with word&quot;</span><span class="s1">))</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">PHRASE_ENDS:</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">]==</span><span class="s4">'.'</span><span class="s1">:</span>
            <span class="s1">phrase.append(DOT)</span>
            <span class="s1">phrase.defects.append(errors.ObsoleteHeaderDefect(</span>
                <span class="s4">&quot;period in 'phrase'&quot;</span><span class="s1">))</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_word(value)</span>
            <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
                <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
                    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
                    <span class="s1">phrase.defects.append(errors.ObsoleteHeaderDefect(</span>
                        <span class="s4">&quot;comment found without atom&quot;</span><span class="s1">))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise</span>
            <span class="s1">phrase.append(token)</span>
    <span class="s2">return </span><span class="s1">phrase</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_local_part(value):</span>
    <span class="s0">&quot;&quot;&quot; local-part = dot-atom / quoted-string / obs-local-part 
 
    &quot;&quot;&quot;</span>
    <span class="s1">local_part = LocalPart()</span>
    <span class="s1">leader = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">leader</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected local-part but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_dot_atom(value)</span>
    <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_word(value)</span>
        <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
            <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">' </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">PHRASE_ENDS:</span>
                <span class="s2">raise</span>
            <span class="s1">token = TokenList()</span>
    <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">token[:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
    <span class="s1">local_part.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">(value[</span><span class="s5">0</span><span class="s1">]==</span><span class="s4">'</span><span class="s2">\\</span><span class="s4">' </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">PHRASE_ENDS):</span>
        <span class="s1">obs_local_part</span><span class="s2">, </span><span class="s1">value = get_obs_local_part(str(local_part) + value)</span>
        <span class="s2">if </span><span class="s1">obs_local_part.token_type == </span><span class="s4">'invalid-obs-local-part'</span><span class="s1">:</span>
            <span class="s1">local_part.defects.append(errors.InvalidHeaderDefect(</span>
                <span class="s4">&quot;local-part is not dot-atom, quoted-string, or obs-local-part&quot;</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">local_part.defects.append(errors.ObsoleteHeaderDefect(</span>
                <span class="s4">&quot;local-part is not a dot-atom (contains CFWS)&quot;</span><span class="s1">))</span>
        <span class="s1">local_part[</span><span class="s5">0</span><span class="s1">] = obs_local_part</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">local_part.value.encode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">UnicodeEncodeError:</span>
        <span class="s1">local_part.defects.append(errors.NonASCIILocalPartDefect(</span>
                <span class="s4">&quot;local-part contains non-ASCII characters)&quot;</span><span class="s1">))</span>
    <span class="s2">return </span><span class="s1">local_part</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_obs_local_part(value):</span>
    <span class="s0">&quot;&quot;&quot; obs-local-part = word *(&quot;.&quot; word) 
    &quot;&quot;&quot;</span>
    <span class="s1">obs_local_part = ObsLocalPart()</span>
    <span class="s1">last_non_ws_was_dot = </span><span class="s2">False</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">(value[</span><span class="s5">0</span><span class="s1">]==</span><span class="s4">'</span><span class="s2">\\</span><span class="s4">' </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">PHRASE_ENDS):</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'.'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">last_non_ws_was_dot:</span>
                <span class="s1">obs_local_part.defects.append(errors.InvalidHeaderDefect(</span>
                    <span class="s4">&quot;invalid repeated '.'&quot;</span><span class="s1">))</span>
            <span class="s1">obs_local_part.append(DOT)</span>
            <span class="s1">last_non_ws_was_dot = </span><span class="s2">True</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s2">continue</span>
        <span class="s2">elif </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">]==</span><span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s1">:</span>
            <span class="s1">obs_local_part.append(ValueTerminal(value[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                                                <span class="s4">'misplaced-special'</span><span class="s1">))</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s1">obs_local_part.defects.append(errors.InvalidHeaderDefect(</span>
                <span class="s4">&quot;'</span><span class="s2">\\</span><span class="s4">' character outside of quoted-string/ccontent&quot;</span><span class="s1">))</span>
            <span class="s1">last_non_ws_was_dot = </span><span class="s2">False</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">obs_local_part </span><span class="s2">and </span><span class="s1">obs_local_part[-</span><span class="s5">1</span><span class="s1">].token_type != </span><span class="s4">'dot'</span><span class="s1">:</span>
            <span class="s1">obs_local_part.defects.append(errors.InvalidHeaderDefect(</span>
                <span class="s4">&quot;missing '.' between words&quot;</span><span class="s1">))</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_word(value)</span>
            <span class="s1">last_non_ws_was_dot = </span><span class="s2">False</span>
        <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
            <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">CFWS_LEADER:</span>
                <span class="s2">raise</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">obs_local_part.append(token)</span>
    <span class="s2">if </span><span class="s1">(obs_local_part[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'dot' </span><span class="s2">or</span>
            <span class="s1">obs_local_part[</span><span class="s5">0</span><span class="s1">].token_type==</span><span class="s4">'cfws' </span><span class="s2">and</span>
            <span class="s1">obs_local_part[</span><span class="s5">1</span><span class="s1">].token_type==</span><span class="s4">'dot'</span><span class="s1">):</span>
        <span class="s1">obs_local_part.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Invalid leading '.' in local part&quot;</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">(obs_local_part[-</span><span class="s5">1</span><span class="s1">].token_type == </span><span class="s4">'dot' </span><span class="s2">or</span>
            <span class="s1">obs_local_part[-</span><span class="s5">1</span><span class="s1">].token_type==</span><span class="s4">'cfws' </span><span class="s2">and</span>
            <span class="s1">obs_local_part[-</span><span class="s5">2</span><span class="s1">].token_type==</span><span class="s4">'dot'</span><span class="s1">):</span>
        <span class="s1">obs_local_part.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Invalid trailing '.' in local part&quot;</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">obs_local_part.defects:</span>
        <span class="s1">obs_local_part.token_type = </span><span class="s4">'invalid-obs-local-part'</span>
    <span class="s2">return </span><span class="s1">obs_local_part</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_dtext(value):</span>
    <span class="s0">&quot;&quot;&quot; dtext = &lt;printable ascii except \ [ ]&gt; / obs-dtext 
        obs-dtext = obs-NO-WS-CTL / quoted-pair 
 
    We allow anything except the excluded characters, but if we find any 
    ASCII other than the RFC defined printable ASCII an NonPrintableDefect is 
    added to the token's defects list.  Quoted pairs are converted to their 
    unquoted values, so what is returned is a ptext token, in this case a 
    ValueTerminal.  If there were quoted-printables, an ObsoleteHeaderDefect is 
    added to the returned token's defect list. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ptext</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">had_qp = _get_ptext_to_endchars(value</span><span class="s2">, </span><span class="s4">'[]'</span><span class="s1">)</span>
    <span class="s1">ptext = ValueTerminal(ptext</span><span class="s2">, </span><span class="s4">'ptext'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">had_qp:</span>
        <span class="s1">ptext.defects.append(errors.ObsoleteHeaderDefect(</span>
            <span class="s4">&quot;quoted printable found in domain-literal&quot;</span><span class="s1">))</span>
    <span class="s1">_validate_xtext(ptext)</span>
    <span class="s2">return </span><span class="s1">ptext</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">_check_for_early_dl_end(value</span><span class="s2">, </span><span class="s1">domain_literal):</span>
    <span class="s2">if </span><span class="s1">value:</span>
        <span class="s2">return False</span>
    <span class="s1">domain_literal.append(errors.InvalidHeaderDefect(</span>
        <span class="s4">&quot;end of input inside domain-literal&quot;</span><span class="s1">))</span>
    <span class="s1">domain_literal.append(ValueTerminal(</span><span class="s4">']'</span><span class="s2">, </span><span class="s4">'domain-literal-end'</span><span class="s1">))</span>
    <span class="s2">return True</span>

<span class="s2">def </span><span class="s1">get_domain_literal(value):</span>
    <span class="s0">&quot;&quot;&quot; domain-literal = [CFWS] &quot;[&quot; *([FWS] dtext) [FWS] &quot;]&quot; [CFWS] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">domain_literal = DomainLiteral()</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">domain_literal.append(token)</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;expected domain-literal&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'['</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;expected '[' at start of domain-literal &quot;</span>
                <span class="s4">&quot;but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">if </span><span class="s1">_check_for_early_dl_end(value</span><span class="s2">, </span><span class="s1">domain_literal):</span>
        <span class="s2">return </span><span class="s1">domain_literal</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s1">domain_literal.append(ValueTerminal(</span><span class="s4">'['</span><span class="s2">, </span><span class="s4">'domain-literal-start'</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">WSP:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_fws(value)</span>
        <span class="s1">domain_literal.append(token)</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_dtext(value)</span>
    <span class="s1">domain_literal.append(token)</span>
    <span class="s2">if </span><span class="s1">_check_for_early_dl_end(value</span><span class="s2">, </span><span class="s1">domain_literal):</span>
        <span class="s2">return </span><span class="s1">domain_literal</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">WSP:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_fws(value)</span>
        <span class="s1">domain_literal.append(token)</span>
    <span class="s2">if </span><span class="s1">_check_for_early_dl_end(value</span><span class="s2">, </span><span class="s1">domain_literal):</span>
        <span class="s2">return </span><span class="s1">domain_literal</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">']'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;expected ']' at end of domain-literal &quot;</span>
                <span class="s4">&quot;but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">domain_literal.append(ValueTerminal(</span><span class="s4">']'</span><span class="s2">, </span><span class="s4">'domain-literal-end'</span><span class="s1">))</span>
    <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">domain_literal.append(token)</span>
    <span class="s2">return </span><span class="s1">domain_literal</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_domain(value):</span>
    <span class="s0">&quot;&quot;&quot; domain = dot-atom / domain-literal / obs-domain 
        obs-domain = atom *(&quot;.&quot; atom)) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">domain = Domain()</span>
    <span class="s1">leader = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">leader</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected domain but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'['</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_domain_literal(value)</span>
        <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">token[:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
        <span class="s1">domain.append(token)</span>
        <span class="s2">return </span><span class="s1">domain</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_dot_atom(value)</span>
    <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_atom(value)</span>
    <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">token[:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
    <span class="s1">domain.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'.'</span><span class="s1">:</span>
        <span class="s1">domain.defects.append(errors.ObsoleteHeaderDefect(</span>
            <span class="s4">&quot;domain is not a dot-atom (contains CFWS)&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">domain[</span><span class="s5">0</span><span class="s1">].token_type == </span><span class="s4">'dot-atom'</span><span class="s1">:</span>
            <span class="s1">domain[:] = domain[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'.'</span><span class="s1">:</span>
            <span class="s1">domain.append(DOT)</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_atom(value[</span><span class="s5">1</span><span class="s1">:])</span>
            <span class="s1">domain.append(token)</span>
    <span class="s2">return </span><span class="s1">domain</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_addr_spec(value):</span>
    <span class="s0">&quot;&quot;&quot; addr-spec = local-part &quot;@&quot; domain 
 
    &quot;&quot;&quot;</span>
    <span class="s1">addr_spec = AddrSpec()</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_local_part(value)</span>
    <span class="s1">addr_spec.append(token)</span>
    <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'@'</span><span class="s1">:</span>
        <span class="s1">addr_spec.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;add-spec local part with no domain&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">addr_spec</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s1">addr_spec.append(ValueTerminal(</span><span class="s4">'@'</span><span class="s2">, </span><span class="s4">'address-at-symbol'</span><span class="s1">))</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_domain(value[</span><span class="s5">1</span><span class="s1">:])</span>
    <span class="s1">addr_spec.append(token)</span>
    <span class="s2">return </span><span class="s1">addr_spec</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_obs_route(value):</span>
    <span class="s0">&quot;&quot;&quot; obs-route = obs-domain-list &quot;:&quot; 
        obs-domain-list = *(CFWS / &quot;,&quot;) &quot;@&quot; domain *(&quot;,&quot; [CFWS] [&quot;@&quot; domain]) 
 
        Returns an obs-route token with the appropriate sub-tokens (that is, 
        there is no obs-domain-list in the parse tree). 
    &quot;&quot;&quot;</span>
    <span class="s1">obs_route = ObsRoute()</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">(value[</span><span class="s5">0</span><span class="s1">]==</span><span class="s4">',' </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER):</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
            <span class="s1">obs_route.append(token)</span>
        <span class="s2">elif </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">','</span><span class="s1">:</span>
            <span class="s1">obs_route.append(ListSeparator)</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'@'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected obs-route domain but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">obs_route.append(RouteComponentMarker)</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_domain(value[</span><span class="s5">1</span><span class="s1">:])</span>
    <span class="s1">obs_route.append(token)</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">]==</span><span class="s4">','</span><span class="s1">:</span>
        <span class="s1">obs_route.append(ListSeparator)</span>
        <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">if not </span><span class="s1">value:</span>
            <span class="s2">break</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
            <span class="s1">obs_route.append(token)</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'@'</span><span class="s1">:</span>
            <span class="s1">obs_route.append(RouteComponentMarker)</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_domain(value[</span><span class="s5">1</span><span class="s1">:])</span>
            <span class="s1">obs_route.append(token)</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;end of header while parsing obs-route&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">':'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError( </span><span class="s4">&quot;expected ':' marking end of &quot;</span>
            <span class="s4">&quot;obs-route but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">obs_route.append(ValueTerminal(</span><span class="s4">':'</span><span class="s2">, </span><span class="s4">'end-of-obs-route-marker'</span><span class="s1">))</span>
    <span class="s2">return </span><span class="s1">obs_route</span><span class="s2">, </span><span class="s1">value[</span><span class="s5">1</span><span class="s1">:]</span>

<span class="s2">def </span><span class="s1">get_angle_addr(value):</span>
    <span class="s0">&quot;&quot;&quot; angle-addr = [CFWS] &quot;&lt;&quot; addr-spec &quot;&gt;&quot; [CFWS] / obs-angle-addr 
        obs-angle-addr = [CFWS] &quot;&lt;&quot; obs-route addr-spec &quot;&gt;&quot; [CFWS] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">angle_addr = AngleAddr()</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">angle_addr.append(token)</span>
    <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'&lt;'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected angle-addr but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">angle_addr.append(ValueTerminal(</span><span class="s4">'&lt;'</span><span class="s2">, </span><span class="s4">'angle-addr-start'</span><span class="s1">))</span>
    <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s3"># Although it is not legal per RFC5322, SMTP uses '&lt;&gt;' in certain</span>
    <span class="s3"># circumstances.</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'&gt;'</span><span class="s1">:</span>
        <span class="s1">angle_addr.append(ValueTerminal(</span><span class="s4">'&gt;'</span><span class="s2">, </span><span class="s4">'angle-addr-end'</span><span class="s1">))</span>
        <span class="s1">angle_addr.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;null addr-spec in angle-addr&quot;</span><span class="s1">))</span>
        <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">return </span><span class="s1">angle_addr</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_addr_spec(value)</span>
    <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_obs_route(value)</span>
            <span class="s1">angle_addr.defects.append(errors.ObsoleteHeaderDefect(</span>
                <span class="s4">&quot;obsolete route specification in angle-addr&quot;</span><span class="s1">))</span>
        <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
            <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
                <span class="s4">&quot;expected addr-spec or obs-route but found '{}'&quot;</span><span class="s1">.format(value))</span>
        <span class="s1">angle_addr.append(token)</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_addr_spec(value)</span>
    <span class="s1">angle_addr.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'&gt;'</span><span class="s1">:</span>
        <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">angle_addr.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;missing trailing '&gt;' on angle-addr&quot;</span><span class="s1">))</span>
    <span class="s1">angle_addr.append(ValueTerminal(</span><span class="s4">'&gt;'</span><span class="s2">, </span><span class="s4">'angle-addr-end'</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">angle_addr.append(token)</span>
    <span class="s2">return </span><span class="s1">angle_addr</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_display_name(value):</span>
    <span class="s0">&quot;&quot;&quot; display-name = phrase 
 
    Because this is simply a name-rule, we don't return a display-name 
    token containing a phrase, but rather a display-name token with 
    the content of the phrase. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">display_name = DisplayName()</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_phrase(value)</span>
    <span class="s1">display_name.extend(token[:])</span>
    <span class="s1">display_name.defects = token.defects[:]</span>
    <span class="s2">return </span><span class="s1">display_name</span><span class="s2">, </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">get_name_addr(value):</span>
    <span class="s0">&quot;&quot;&quot; name-addr = [display-name] angle-addr 
 
    &quot;&quot;&quot;</span>
    <span class="s1">name_addr = NameAddr()</span>
    <span class="s3"># Both the optional display name and the angle-addr can start with cfws.</span>
    <span class="s1">leader = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">leader</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s2">if not </span><span class="s1">value:</span>
            <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
                <span class="s4">&quot;expected name-addr but found '{}'&quot;</span><span class="s1">.format(leader))</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'&lt;'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">PHRASE_ENDS:</span>
            <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
                <span class="s4">&quot;expected name-addr but found '{}'&quot;</span><span class="s1">.format(value))</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_display_name(value)</span>
        <span class="s2">if not </span><span class="s1">value:</span>
            <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
                <span class="s4">&quot;expected name-addr but found '{}'&quot;</span><span class="s1">.format(token))</span>
        <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">token[</span><span class="s5">0</span><span class="s1">][:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
            <span class="s1">leader = </span><span class="s2">None</span>
        <span class="s1">name_addr.append(token)</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_angle_addr(value)</span>
    <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">token[:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
    <span class="s1">name_addr.append(token)</span>
    <span class="s2">return </span><span class="s1">name_addr</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_mailbox(value):</span>
    <span class="s0">&quot;&quot;&quot; mailbox = name-addr / addr-spec 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># The only way to figure out if we are dealing with a name-addr or an</span>
    <span class="s3"># addr-spec is to try parsing each one.</span>
    <span class="s1">mailbox = Mailbox()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_name_addr(value)</span>
    <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_addr_spec(value)</span>
        <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
            <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
                <span class="s4">&quot;expected mailbox but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s2">if </span><span class="s1">any(isinstance(x</span><span class="s2">, </span><span class="s1">errors.InvalidHeaderDefect)</span>
                       <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">token.all_defects):</span>
        <span class="s1">mailbox.token_type = </span><span class="s4">'invalid-mailbox'</span>
    <span class="s1">mailbox.append(token)</span>
    <span class="s2">return </span><span class="s1">mailbox</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_invalid_mailbox(value</span><span class="s2">, </span><span class="s1">endchars):</span>
    <span class="s0">&quot;&quot;&quot; Read everything up to one of the chars in endchars. 
 
    This is outside the formal grammar.  The InvalidMailbox TokenList that is 
    returned acts like a Mailbox, but the data attributes are None. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">invalid_mailbox = InvalidMailbox()</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">endchars:</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">PHRASE_ENDS:</span>
            <span class="s1">invalid_mailbox.append(ValueTerminal(value[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                                                 <span class="s4">'misplaced-special'</span><span class="s1">))</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_phrase(value)</span>
            <span class="s1">invalid_mailbox.append(token)</span>
    <span class="s2">return </span><span class="s1">invalid_mailbox</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_mailbox_list(value):</span>
    <span class="s0">&quot;&quot;&quot; mailbox-list = (mailbox *(&quot;,&quot; mailbox)) / obs-mbox-list 
        obs-mbox-list = *([CFWS] &quot;,&quot;) mailbox *(&quot;,&quot; [mailbox / CFWS]) 
 
    For this routine we go outside the formal grammar in order to improve error 
    handling.  We recognize the end of the mailbox list only at the end of the 
    value or at a ';' (the group terminator).  This is so that we can turn 
    invalid mailboxes into InvalidMailbox tokens and continue parsing any 
    remaining valid mailboxes.  We also allow all mailbox entries to be null, 
    and this condition is handled appropriately at a higher level. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mailbox_list = MailboxList()</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">';'</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_mailbox(value)</span>
            <span class="s1">mailbox_list.append(token)</span>
        <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
            <span class="s1">leader = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
                <span class="s1">leader</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
                <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s4">',;'</span><span class="s1">:</span>
                    <span class="s1">mailbox_list.append(leader)</span>
                    <span class="s1">mailbox_list.defects.append(errors.ObsoleteHeaderDefect(</span>
                        <span class="s4">&quot;empty element in mailbox-list&quot;</span><span class="s1">))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_invalid_mailbox(value</span><span class="s2">, </span><span class="s4">',;'</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">token[:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
                    <span class="s1">mailbox_list.append(token)</span>
                    <span class="s1">mailbox_list.defects.append(errors.InvalidHeaderDefect(</span>
                        <span class="s4">&quot;invalid mailbox in mailbox-list&quot;</span><span class="s1">))</span>
            <span class="s2">elif </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">','</span><span class="s1">:</span>
                <span class="s1">mailbox_list.defects.append(errors.ObsoleteHeaderDefect(</span>
                    <span class="s4">&quot;empty element in mailbox-list&quot;</span><span class="s1">))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_invalid_mailbox(value</span><span class="s2">, </span><span class="s4">',;'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">token[:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
                <span class="s1">mailbox_list.append(token)</span>
                <span class="s1">mailbox_list.defects.append(errors.InvalidHeaderDefect(</span>
                    <span class="s4">&quot;invalid mailbox in mailbox-list&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s4">',;'</span><span class="s1">:</span>
            <span class="s3"># Crap after mailbox; treat it as an invalid mailbox.</span>
            <span class="s3"># The mailbox info will still be available.</span>
            <span class="s1">mailbox = mailbox_list[-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">mailbox.token_type = </span><span class="s4">'invalid-mailbox'</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_invalid_mailbox(value</span><span class="s2">, </span><span class="s4">',;'</span><span class="s1">)</span>
            <span class="s1">mailbox.extend(token)</span>
            <span class="s1">mailbox_list.defects.append(errors.InvalidHeaderDefect(</span>
                <span class="s4">&quot;invalid mailbox in mailbox-list&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">','</span><span class="s1">:</span>
            <span class="s1">mailbox_list.append(ListSeparator)</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">return </span><span class="s1">mailbox_list</span><span class="s2">, </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">get_group_list(value):</span>
    <span class="s0">&quot;&quot;&quot; group-list = mailbox-list / CFWS / obs-group-list 
        obs-group-list = 1*([CFWS] &quot;,&quot;) [CFWS] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">group_list = GroupList()</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s1">group_list.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;end of header before group-list&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">group_list</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s1">leader = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">leader</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s2">if not </span><span class="s1">value:</span>
            <span class="s3"># This should never happen in email parsing, since CFWS-only is a</span>
            <span class="s3"># legal alternative to group-list in a group, which is the only</span>
            <span class="s3"># place group-list appears.</span>
            <span class="s1">group_list.defects.append(errors.InvalidHeaderDefect(</span>
                <span class="s4">&quot;end of header in group-list&quot;</span><span class="s1">))</span>
            <span class="s1">group_list.append(leader)</span>
            <span class="s2">return </span><span class="s1">group_list</span><span class="s2">, </span><span class="s1">value</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">';'</span><span class="s1">:</span>
            <span class="s1">group_list.append(leader)</span>
            <span class="s2">return </span><span class="s1">group_list</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_mailbox_list(value)</span>
    <span class="s2">if </span><span class="s1">len(token.all_mailboxes)==</span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">group_list.append(leader)</span>
        <span class="s1">group_list.extend(token)</span>
        <span class="s1">group_list.defects.append(errors.ObsoleteHeaderDefect(</span>
            <span class="s4">&quot;group-list with empty entries&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">group_list</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">token[:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
    <span class="s1">group_list.append(token)</span>
    <span class="s2">return </span><span class="s1">group_list</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_group(value):</span>
    <span class="s0">&quot;&quot;&quot; group = display-name &quot;:&quot; [group-list] &quot;;&quot; [CFWS] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">group = Group()</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_display_name(value)</span>
    <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">':'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;expected ':' at end of group &quot;</span>
            <span class="s4">&quot;display name but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">group.append(token)</span>
    <span class="s1">group.append(ValueTerminal(</span><span class="s4">':'</span><span class="s2">, </span><span class="s4">'group-display-name-terminator'</span><span class="s1">))</span>
    <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">';'</span><span class="s1">:</span>
        <span class="s1">group.append(ValueTerminal(</span><span class="s4">';'</span><span class="s2">, </span><span class="s4">'group-terminator'</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">group</span><span class="s2">, </span><span class="s1">value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_group_list(value)</span>
    <span class="s1">group.append(token)</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s1">group.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;end of header in group&quot;</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">';'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected ';' at end of group but found {}&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">group.append(ValueTerminal(</span><span class="s4">';'</span><span class="s2">, </span><span class="s4">'group-terminator'</span><span class="s1">))</span>
    <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">group.append(token)</span>
    <span class="s2">return </span><span class="s1">group</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_address(value):</span>
    <span class="s0">&quot;&quot;&quot; address = mailbox / group 
 
    Note that counter-intuitively, an address can be either a single address or 
    a list of addresses (a group).  This is why the returned Address object has 
    a 'mailboxes' attribute which treats a single address as a list of length 
    one.  When you need to differentiate between to two cases, extract the single 
    element, which is either a mailbox or a group token. 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># The formal grammar isn't very helpful when parsing an address.  mailbox</span>
    <span class="s3"># and group, especially when allowing for obsolete forms, start off very</span>
    <span class="s3"># similarly.  It is only when you reach one of @, &lt;, or : that you know</span>
    <span class="s3"># what you've got.  So, we try each one in turn, starting with the more</span>
    <span class="s3"># likely of the two.  We could perhaps make this more efficient by looking</span>
    <span class="s3"># for a phrase and then branching based on the next character, but that</span>
    <span class="s3"># would be a premature optimization.</span>
    <span class="s1">address = Address()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_group(value)</span>
    <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_mailbox(value)</span>
        <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
            <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
                <span class="s4">&quot;expected address but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">address.append(token)</span>
    <span class="s2">return </span><span class="s1">address</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_address_list(value):</span>
    <span class="s0">&quot;&quot;&quot; address_list = (address *(&quot;,&quot; address)) / obs-addr-list 
        obs-addr-list = *([CFWS] &quot;,&quot;) address *(&quot;,&quot; [address / CFWS]) 
 
    We depart from the formal grammar here by continuing to parse until the end 
    of the input, assuming the input to be entirely composed of an 
    address-list.  This is always true in email parsing, and allows us 
    to skip invalid addresses to parse additional valid ones. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">address_list = AddressList()</span>
    <span class="s2">while </span><span class="s1">value:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_address(value)</span>
            <span class="s1">address_list.append(token)</span>
        <span class="s2">except </span><span class="s1">errors.HeaderParseError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s1">leader = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
                <span class="s1">leader</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
                <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">','</span><span class="s1">:</span>
                    <span class="s1">address_list.append(leader)</span>
                    <span class="s1">address_list.defects.append(errors.ObsoleteHeaderDefect(</span>
                        <span class="s4">&quot;address-list entry with no content&quot;</span><span class="s1">))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_invalid_mailbox(value</span><span class="s2">, </span><span class="s4">','</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">token[:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
                    <span class="s1">address_list.append(Address([token]))</span>
                    <span class="s1">address_list.defects.append(errors.InvalidHeaderDefect(</span>
                        <span class="s4">&quot;invalid address in address-list&quot;</span><span class="s1">))</span>
            <span class="s2">elif </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">','</span><span class="s1">:</span>
                <span class="s1">address_list.defects.append(errors.ObsoleteHeaderDefect(</span>
                    <span class="s4">&quot;empty element in address-list&quot;</span><span class="s1">))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_invalid_mailbox(value</span><span class="s2">, </span><span class="s4">','</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">token[:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
                <span class="s1">address_list.append(Address([token]))</span>
                <span class="s1">address_list.defects.append(errors.InvalidHeaderDefect(</span>
                    <span class="s4">&quot;invalid address in address-list&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">','</span><span class="s1">:</span>
            <span class="s3"># Crap after address; treat it as an invalid mailbox.</span>
            <span class="s3"># The mailbox info will still be available.</span>
            <span class="s1">mailbox = address_list[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">mailbox.token_type = </span><span class="s4">'invalid-mailbox'</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_invalid_mailbox(value</span><span class="s2">, </span><span class="s4">','</span><span class="s1">)</span>
            <span class="s1">mailbox.extend(token)</span>
            <span class="s1">address_list.defects.append(errors.InvalidHeaderDefect(</span>
                <span class="s4">&quot;invalid address in address-list&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">value:  </span><span class="s3"># Must be a , at this point.</span>
            <span class="s1">address_list.append(ValueTerminal(</span><span class="s4">','</span><span class="s2">, </span><span class="s4">'list-separator'</span><span class="s1">))</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">return </span><span class="s1">address_list</span><span class="s2">, </span><span class="s1">value</span>

<span class="s3">#</span>
<span class="s3"># XXX: As I begin to add additional header parsers, I'm realizing we probably</span>
<span class="s3"># have two level of parser routines: the get_XXX methods that get a token in</span>
<span class="s3"># the grammar, and parse_XXX methods that parse an entire field value.  So</span>
<span class="s3"># get_address_list above should really be a parse_ method, as probably should</span>
<span class="s3"># be get_unstructured.</span>
<span class="s3">#</span>

<span class="s2">def </span><span class="s1">parse_mime_version(value):</span>
    <span class="s0">&quot;&quot;&quot; mime-version = [CFWS] 1*digit [CFWS] &quot;.&quot; [CFWS] 1*digit [CFWS] 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># The [CFWS] is implicit in the RFC 2045 BNF.</span>
    <span class="s3"># XXX: This routine is a bit verbose, should factor out a get_int method.</span>
    <span class="s1">mime_version = MIMEVersion()</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s1">mime_version.defects.append(errors.HeaderMissingRequiredValue(</span>
            <span class="s4">&quot;Missing MIME version number (eg: 1.0)&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">mime_version</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">mime_version.append(token)</span>
        <span class="s2">if not </span><span class="s1">value:</span>
            <span class="s1">mime_version.defects.append(errors.HeaderMissingRequiredValue(</span>
                <span class="s4">&quot;Expected MIME version number but found only CFWS&quot;</span><span class="s1">))</span>
    <span class="s1">digits = </span><span class="s4">''</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'.' </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">digits += value[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">if not </span><span class="s1">digits.isdigit():</span>
        <span class="s1">mime_version.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Expected MIME major version number but found {!r}&quot;</span><span class="s1">.format(digits)))</span>
        <span class="s1">mime_version.append(ValueTerminal(digits</span><span class="s2">, </span><span class="s4">'xtext'</span><span class="s1">))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">mime_version.major = int(digits)</span>
        <span class="s1">mime_version.append(ValueTerminal(digits</span><span class="s2">, </span><span class="s4">'digits'</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">mime_version.append(token)</span>
    <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'.'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">mime_version.major </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">mime_version.defects.append(errors.InvalidHeaderDefect(</span>
                <span class="s4">&quot;Incomplete MIME version; found only major number&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">value:</span>
            <span class="s1">mime_version.append(ValueTerminal(value</span><span class="s2">, </span><span class="s4">'xtext'</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">mime_version</span>
    <span class="s1">mime_version.append(ValueTerminal(</span><span class="s4">'.'</span><span class="s2">, </span><span class="s4">'version-separator'</span><span class="s1">))</span>
    <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">mime_version.append(token)</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s2">if </span><span class="s1">mime_version.major </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">mime_version.defects.append(errors.InvalidHeaderDefect(</span>
                <span class="s4">&quot;Incomplete MIME version; found only major number&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">mime_version</span>
    <span class="s1">digits = </span><span class="s4">''</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">digits += value[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">if not </span><span class="s1">digits.isdigit():</span>
        <span class="s1">mime_version.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Expected MIME minor version number but found {!r}&quot;</span><span class="s1">.format(digits)))</span>
        <span class="s1">mime_version.append(ValueTerminal(digits</span><span class="s2">, </span><span class="s4">'xtext'</span><span class="s1">))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">mime_version.minor = int(digits)</span>
        <span class="s1">mime_version.append(ValueTerminal(digits</span><span class="s2">, </span><span class="s4">'digits'</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">mime_version.append(token)</span>
    <span class="s2">if </span><span class="s1">value:</span>
        <span class="s1">mime_version.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Excess non-CFWS text after MIME version&quot;</span><span class="s1">))</span>
        <span class="s1">mime_version.append(ValueTerminal(value</span><span class="s2">, </span><span class="s4">'xtext'</span><span class="s1">))</span>
    <span class="s2">return </span><span class="s1">mime_version</span>

<span class="s2">def </span><span class="s1">get_invalid_parameter(value):</span>
    <span class="s0">&quot;&quot;&quot; Read everything up to the next ';'. 
 
    This is outside the formal grammar.  The InvalidParameter TokenList that is 
    returned acts like a Parameter, but the data attributes are None. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">invalid_parameter = InvalidParameter()</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">';'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">PHRASE_ENDS:</span>
            <span class="s1">invalid_parameter.append(ValueTerminal(value[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                                                   <span class="s4">'misplaced-special'</span><span class="s1">))</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_phrase(value)</span>
            <span class="s1">invalid_parameter.append(token)</span>
    <span class="s2">return </span><span class="s1">invalid_parameter</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_ttext(value):</span>
    <span class="s0">&quot;&quot;&quot;ttext = &lt;matches _ttext_matcher&gt; 
 
    We allow any non-TOKEN_ENDS in ttext, but add defects to the token's 
    defects list if we find non-ttext characters.  We also register defects for 
    *any* non-printables even though the RFC doesn't exclude all of them, 
    because we follow the spirit of RFC 5322. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = _non_token_end_matcher(value)</span>
    <span class="s2">if not </span><span class="s1">m:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected ttext but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">ttext = m.group()</span>
    <span class="s1">value = value[len(ttext):]</span>
    <span class="s1">ttext = ValueTerminal(ttext</span><span class="s2">, </span><span class="s4">'ttext'</span><span class="s1">)</span>
    <span class="s1">_validate_xtext(ttext)</span>
    <span class="s2">return </span><span class="s1">ttext</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_token(value):</span>
    <span class="s0">&quot;&quot;&quot;token = [CFWS] 1*ttext [CFWS] 
 
    The RFC equivalent of ttext is any US-ASCII chars except space, ctls, or 
    tspecials.  We also exclude tabs even though the RFC doesn't. 
 
    The RFC implies the CFWS but is not explicit about it in the BNF. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mtoken = Token()</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">mtoken.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">TOKEN_ENDS:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected token but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_ttext(value)</span>
    <span class="s1">mtoken.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">mtoken.append(token)</span>
    <span class="s2">return </span><span class="s1">mtoken</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_attrtext(value):</span>
    <span class="s0">&quot;&quot;&quot;attrtext = 1*(any non-ATTRIBUTE_ENDS character) 
 
    We allow any non-ATTRIBUTE_ENDS in attrtext, but add defects to the 
    token's defects list if we find non-attrtext characters.  We also register 
    defects for *any* non-printables even though the RFC doesn't exclude all of 
    them, because we follow the spirit of RFC 5322. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = _non_attribute_end_matcher(value)</span>
    <span class="s2">if not </span><span class="s1">m:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected attrtext but found {!r}&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">attrtext = m.group()</span>
    <span class="s1">value = value[len(attrtext):]</span>
    <span class="s1">attrtext = ValueTerminal(attrtext</span><span class="s2">, </span><span class="s4">'attrtext'</span><span class="s1">)</span>
    <span class="s1">_validate_xtext(attrtext)</span>
    <span class="s2">return </span><span class="s1">attrtext</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_attribute(value):</span>
    <span class="s0">&quot;&quot;&quot; [CFWS] 1*attrtext [CFWS] 
 
    This version of the BNF makes the CFWS explicit, and as usual we use a 
    value terminal for the actual run of characters.  The RFC equivalent of 
    attrtext is the token characters, with the subtraction of '*', &quot;'&quot;, and '%'. 
    We include tab in the excluded set just as we do for token. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">attribute = Attribute()</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">attribute.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">ATTRIBUTE_ENDS:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected token but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_attrtext(value)</span>
    <span class="s1">attribute.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">attribute.append(token)</span>
    <span class="s2">return </span><span class="s1">attribute</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_extended_attrtext(value):</span>
    <span class="s0">&quot;&quot;&quot;attrtext = 1*(any non-ATTRIBUTE_ENDS character plus '%') 
 
    This is a special parsing routine so that we get a value that 
    includes % escapes as a single string (which we decode as a single 
    string later). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = _non_extended_attribute_end_matcher(value)</span>
    <span class="s2">if not </span><span class="s1">m:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected extended attrtext but found {!r}&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">attrtext = m.group()</span>
    <span class="s1">value = value[len(attrtext):]</span>
    <span class="s1">attrtext = ValueTerminal(attrtext</span><span class="s2">, </span><span class="s4">'extended-attrtext'</span><span class="s1">)</span>
    <span class="s1">_validate_xtext(attrtext)</span>
    <span class="s2">return </span><span class="s1">attrtext</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_extended_attribute(value):</span>
    <span class="s0">&quot;&quot;&quot; [CFWS] 1*extended_attrtext [CFWS] 
 
    This is like the non-extended version except we allow % characters, so that 
    we can pick up an encoded value as a single string. 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># XXX: should we have an ExtendedAttribute TokenList?</span>
    <span class="s1">attribute = Attribute()</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">attribute.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">EXTENDED_ATTRIBUTE_ENDS:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span>
            <span class="s4">&quot;expected token but found '{}'&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_extended_attrtext(value)</span>
    <span class="s1">attribute.append(token)</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">attribute.append(token)</span>
    <span class="s2">return </span><span class="s1">attribute</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_section(value):</span>
    <span class="s0">&quot;&quot;&quot; '*' digits 
 
    The formal BNF is more complicated because leading 0s are not allowed.  We 
    check for that and add a defect.  We also assume no CFWS is allowed between 
    the '*' and the digits, though the RFC is not crystal clear on that. 
    The caller should already have dealt with leading CFWS. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">section = Section()</span>
    <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'*'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;Expected section but found {}&quot;</span><span class="s1">.format(</span>
                                        <span class="s1">value))</span>
    <span class="s1">section.append(ValueTerminal(</span><span class="s4">'*'</span><span class="s2">, </span><span class="s4">'section-marker'</span><span class="s1">))</span>
    <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">if not </span><span class="s1">value </span><span class="s2">or not </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">].isdigit():</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;Expected section number but &quot;</span>
                                      <span class="s4">&quot;found {}&quot;</span><span class="s1">.format(value))</span>
    <span class="s1">digits = </span><span class="s4">''</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">].isdigit():</span>
        <span class="s1">digits += value[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">if </span><span class="s1">digits[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'0' </span><span class="s2">and </span><span class="s1">digits != </span><span class="s4">'0'</span><span class="s1">:</span>
        <span class="s1">section.defects.append(errors.InvalidHeaderError(</span><span class="s4">&quot;section number&quot;</span>
            <span class="s4">&quot;has an invalid leading 0&quot;</span><span class="s1">))</span>
    <span class="s1">section.number = int(digits)</span>
    <span class="s1">section.append(ValueTerminal(digits</span><span class="s2">, </span><span class="s4">'digits'</span><span class="s1">))</span>
    <span class="s2">return </span><span class="s1">section</span><span class="s2">, </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">get_value(value):</span>
    <span class="s0">&quot;&quot;&quot; quoted-string / attribute 
 
    &quot;&quot;&quot;</span>
    <span class="s1">v = Value()</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;Expected value but found end of string&quot;</span><span class="s1">)</span>
    <span class="s1">leader = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">leader</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;Expected value but found &quot;</span>
                                      <span class="s4">&quot;only {}&quot;</span><span class="s1">.format(leader))</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'&quot;'</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_quoted_string(value)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_extended_attribute(value)</span>
    <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">token[:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
    <span class="s1">v.append(token)</span>
    <span class="s2">return </span><span class="s1">v</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">get_parameter(value):</span>
    <span class="s0">&quot;&quot;&quot; attribute [section] [&quot;*&quot;] [CFWS] &quot;=&quot; value 
 
    The CFWS is implied by the RFC but not made explicit in the BNF.  This 
    simplified form of the BNF from the RFC is made to conform with the RFC BNF 
    through some extra checks.  We do it this way because it makes both error 
    recovery and working with the resulting parse tree easier. 
    &quot;&quot;&quot;</span>
    <span class="s3"># It is possible CFWS would also be implicitly allowed between the section</span>
    <span class="s3"># and the 'extended-attribute' marker (the '*') , but we've never seen that</span>
    <span class="s3"># in the wild and we will therefore ignore the possibility.</span>
    <span class="s1">param = Parameter()</span>
    <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_attribute(value)</span>
    <span class="s1">param.append(token)</span>
    <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">';'</span><span class="s1">:</span>
        <span class="s1">param.defects.append(errors.InvalidHeaderDefect(</span><span class="s4">&quot;Parameter contains &quot;</span>
            <span class="s4">&quot;name ({}) but no value&quot;</span><span class="s1">.format(token)))</span>
        <span class="s2">return </span><span class="s1">param</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'*'</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_section(value)</span>
            <span class="s1">param.sectioned = </span><span class="s2">True</span>
            <span class="s1">param.append(token)</span>
        <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
            <span class="s2">pass</span>
        <span class="s2">if not </span><span class="s1">value:</span>
            <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;Incomplete parameter&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'*'</span><span class="s1">:</span>
            <span class="s1">param.append(ValueTerminal(</span><span class="s4">'*'</span><span class="s2">, </span><span class="s4">'extended-parameter-marker'</span><span class="s1">))</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s1">param.extended = </span><span class="s2">True</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'='</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;Parameter not followed by '='&quot;</span><span class="s1">)</span>
    <span class="s1">param.append(ValueTerminal(</span><span class="s4">'='</span><span class="s2">, </span><span class="s4">'parameter-separator'</span><span class="s1">))</span>
    <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s1">leader = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
        <span class="s1">param.append(token)</span>
    <span class="s1">remainder = </span><span class="s2">None</span>
    <span class="s1">appendto = param</span>
    <span class="s2">if </span><span class="s1">param.extended </span><span class="s2">and </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'&quot;'</span><span class="s1">:</span>
        <span class="s3"># Now for some serious hackery to handle the common invalid case of</span>
        <span class="s3"># double quotes around an extended value.  We also accept (with defect)</span>
        <span class="s3"># a value marked as encoded that isn't really.</span>
        <span class="s1">qstring</span><span class="s2">, </span><span class="s1">remainder = get_quoted_string(value)</span>
        <span class="s1">inner_value = qstring.stripped_value</span>
        <span class="s1">semi_valid = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">param.section_number == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">inner_value </span><span class="s2">and </span><span class="s1">inner_value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">&quot;'&quot;</span><span class="s1">:</span>
                <span class="s1">semi_valid = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">token</span><span class="s2">, </span><span class="s1">rest = get_attrtext(inner_value)</span>
                <span class="s2">if </span><span class="s1">rest </span><span class="s2">and </span><span class="s1">rest[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">&quot;'&quot;</span><span class="s1">:</span>
                    <span class="s1">semi_valid = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">token</span><span class="s2">, </span><span class="s1">rest = get_extended_attrtext(inner_value)</span>
            <span class="s2">except</span><span class="s1">:</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">rest:</span>
                    <span class="s1">semi_valid = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">semi_valid:</span>
            <span class="s1">param.defects.append(errors.InvalidHeaderDefect(</span>
                <span class="s4">&quot;Quoted string value for extended parameter is invalid&quot;</span><span class="s1">))</span>
            <span class="s1">param.append(qstring)</span>
            <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">qstring:</span>
                <span class="s2">if </span><span class="s1">t.token_type == </span><span class="s4">'bare-quoted-string'</span><span class="s1">:</span>
                    <span class="s1">t[:] = []</span>
                    <span class="s1">appendto = t</span>
                    <span class="s2">break</span>
            <span class="s1">value = inner_value</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">remainder = </span><span class="s2">None</span>
            <span class="s1">param.defects.append(errors.InvalidHeaderDefect(</span>
                <span class="s4">&quot;Parameter marked as extended but appears to have a &quot;</span>
                <span class="s4">&quot;quoted string value that is non-encoded&quot;</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">&quot;'&quot;</span><span class="s1">:</span>
        <span class="s1">token = </span><span class="s2">None</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_value(value)</span>
    <span class="s2">if not </span><span class="s1">param.extended </span><span class="s2">or </span><span class="s1">param.section_number &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">&quot;'&quot;</span><span class="s1">:</span>
            <span class="s1">appendto.append(token)</span>
            <span class="s2">if </span><span class="s1">remainder </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">assert not </span><span class="s1">value</span><span class="s2">, </span><span class="s1">value</span>
                <span class="s1">value = remainder</span>
            <span class="s2">return </span><span class="s1">param</span><span class="s2">, </span><span class="s1">value</span>
        <span class="s1">param.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Apparent initial-extended-value but attribute &quot;</span>
            <span class="s4">&quot;was not marked as extended or was not initial section&quot;</span><span class="s1">))</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s3"># Assume the charset/lang is missing and the token is the value.</span>
        <span class="s1">param.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Missing required charset/lang delimiters&quot;</span><span class="s1">))</span>
        <span class="s1">appendto.append(token)</span>
        <span class="s2">if </span><span class="s1">remainder </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">param</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">token </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">token:</span>
                <span class="s2">if </span><span class="s1">t.token_type == </span><span class="s4">'extended-attrtext'</span><span class="s1">:</span>
                    <span class="s2">break</span>
            <span class="s1">t.token_type == </span><span class="s4">'attrtext'</span>
            <span class="s1">appendto.append(t)</span>
            <span class="s1">param.charset = t.value</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">&quot;'&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;Expected RFC2231 char/lang encoding &quot;</span>
                                          <span class="s4">&quot;delimiter, but found {!r}&quot;</span><span class="s1">.format(value))</span>
        <span class="s1">appendto.append(ValueTerminal(</span><span class="s4">&quot;'&quot;</span><span class="s2">, </span><span class="s4">'RFC2231 delimiter'</span><span class="s1">))</span>
        <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">&quot;'&quot;</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_attrtext(value)</span>
            <span class="s1">appendto.append(token)</span>
            <span class="s1">param.lang = token.value</span>
            <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">&quot;'&quot;</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">errors.HeaderParseError(</span><span class="s4">&quot;Expected RFC2231 char/lang encoding &quot;</span>
                                  <span class="s4">&quot;delimiter, but found {}&quot;</span><span class="s1">.format(value))</span>
        <span class="s1">appendto.append(ValueTerminal(</span><span class="s4">&quot;'&quot;</span><span class="s2">, </span><span class="s4">'RFC2231 delimiter'</span><span class="s1">))</span>
        <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">if </span><span class="s1">remainder </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s3"># Treat the rest of value as bare quoted string content.</span>
        <span class="s1">v = Value()</span>
        <span class="s2">while </span><span class="s1">value:</span>
            <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">WSP:</span>
                <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_fws(value)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_qcontent(value)</span>
            <span class="s1">v.append(token)</span>
        <span class="s1">token = v</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_value(value)</span>
    <span class="s1">appendto.append(token)</span>
    <span class="s2">if </span><span class="s1">remainder </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">assert not </span><span class="s1">value</span><span class="s2">, </span><span class="s1">value</span>
        <span class="s1">value = remainder</span>
    <span class="s2">return </span><span class="s1">param</span><span class="s2">, </span><span class="s1">value</span>

<span class="s2">def </span><span class="s1">parse_mime_parameters(value):</span>
    <span class="s0">&quot;&quot;&quot; parameter *( &quot;;&quot; parameter ) 
 
    That BNF is meant to indicate this routine should only be called after 
    finding and handling the leading ';'.  There is no corresponding rule in 
    the formal RFC grammar, but it is more convenient for us for the set of 
    parameters to be treated as its own TokenList. 
 
    This is 'parse' routine because it consumes the reminaing value, but it 
    would never be called to parse a full header.  Instead it is called to 
    parse everything after the non-parameter value of a specific MIME header. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mime_parameters = MimeParameters()</span>
    <span class="s2">while </span><span class="s1">value:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_parameter(value)</span>
            <span class="s1">mime_parameters.append(token)</span>
        <span class="s2">except </span><span class="s1">errors.HeaderParseError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s1">leader = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">CFWS_LEADER:</span>
                <span class="s1">leader</span><span class="s2">, </span><span class="s1">value = get_cfws(value)</span>
            <span class="s2">if not </span><span class="s1">value:</span>
                <span class="s1">mime_parameters.append(leader)</span>
                <span class="s2">return </span><span class="s1">mime_parameters</span>
            <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">';'</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">leader </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">mime_parameters.append(leader)</span>
                <span class="s1">mime_parameters.defects.append(errors.InvalidHeaderDefect(</span>
                    <span class="s4">&quot;parameter entry with no content&quot;</span><span class="s1">))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_invalid_parameter(value)</span>
                <span class="s2">if </span><span class="s1">leader:</span>
                    <span class="s1">token[:</span><span class="s5">0</span><span class="s1">] = [leader]</span>
                <span class="s1">mime_parameters.append(token)</span>
                <span class="s1">mime_parameters.defects.append(errors.InvalidHeaderDefect(</span>
                    <span class="s4">&quot;invalid parameter {!r}&quot;</span><span class="s1">.format(token)))</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">';'</span><span class="s1">:</span>
            <span class="s3"># Junk after the otherwise valid parameter.  Mark it as</span>
            <span class="s3"># invalid, but it will have a value.</span>
            <span class="s1">param = mime_parameters[-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">param.token_type = </span><span class="s4">'invalid-parameter'</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_invalid_parameter(value)</span>
            <span class="s1">param.extend(token)</span>
            <span class="s1">mime_parameters.defects.append(errors.InvalidHeaderDefect(</span>
                <span class="s4">&quot;parameter with invalid trailing text {!r}&quot;</span><span class="s1">.format(token)))</span>
        <span class="s2">if </span><span class="s1">value:</span>
            <span class="s3"># Must be a ';' at this point.</span>
            <span class="s1">mime_parameters.append(ValueTerminal(</span><span class="s4">';'</span><span class="s2">, </span><span class="s4">'parameter-separator'</span><span class="s1">))</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">return </span><span class="s1">mime_parameters</span>

<span class="s2">def </span><span class="s1">_find_mime_parameters(tokenlist</span><span class="s2">, </span><span class="s1">value):</span>
    <span class="s0">&quot;&quot;&quot;Do our best to find the parameters in an invalid MIME header 
 
    &quot;&quot;&quot;</span>
    <span class="s2">while </span><span class="s1">value </span><span class="s2">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">';'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">PHRASE_ENDS:</span>
            <span class="s1">tokenlist.append(ValueTerminal(value[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'misplaced-special'</span><span class="s1">))</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_phrase(value)</span>
            <span class="s1">tokenlist.append(token)</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s2">return</span>
    <span class="s1">tokenlist.append(ValueTerminal(</span><span class="s4">';'</span><span class="s2">, </span><span class="s4">'parameter-separator'</span><span class="s1">))</span>
    <span class="s1">tokenlist.append(parse_mime_parameters(value[</span><span class="s5">1</span><span class="s1">:]))</span>

<span class="s2">def </span><span class="s1">parse_content_type_header(value):</span>
    <span class="s0">&quot;&quot;&quot; maintype &quot;/&quot; subtype *( &quot;;&quot; parameter ) 
 
    The maintype and substype are tokens.  Theoretically they could 
    be checked against the official IANA list + x-token, but we 
    don't do that. 
    &quot;&quot;&quot;</span>
    <span class="s1">ctype = ContentType()</span>
    <span class="s1">recover = </span><span class="s2">False</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s1">ctype.defects.append(errors.HeaderMissingRequiredValue(</span>
            <span class="s4">&quot;Missing content type specification&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">ctype</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_token(value)</span>
    <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
        <span class="s1">ctype.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Expected content maintype but found {!r}&quot;</span><span class="s1">.format(value)))</span>
        <span class="s1">_find_mime_parameters(ctype</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">return </span><span class="s1">ctype</span>
    <span class="s1">ctype.append(token)</span>
    <span class="s3"># XXX: If we really want to follow the formal grammer we should make</span>
    <span class="s3"># mantype and subtype specialized TokenLists here.  Probably not worth it.</span>
    <span class="s2">if not </span><span class="s1">value </span><span class="s2">or </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'/'</span><span class="s1">:</span>
        <span class="s1">ctype.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Invalid content type&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">value:</span>
            <span class="s1">_find_mime_parameters(ctype</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">return </span><span class="s1">ctype</span>
    <span class="s1">ctype.maintype = token.value.strip().lower()</span>
    <span class="s1">ctype.append(ValueTerminal(</span><span class="s4">'/'</span><span class="s2">, </span><span class="s4">'content-type-separator'</span><span class="s1">))</span>
    <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_token(value)</span>
    <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
        <span class="s1">ctype.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Expected content subtype but found {!r}&quot;</span><span class="s1">.format(value)))</span>
        <span class="s1">_find_mime_parameters(ctype</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">return </span><span class="s1">ctype</span>
    <span class="s1">ctype.append(token)</span>
    <span class="s1">ctype.subtype = token.value.strip().lower()</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s2">return </span><span class="s1">ctype</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">';'</span><span class="s1">:</span>
        <span class="s1">ctype.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Only parameters are valid after content type, but &quot;</span>
            <span class="s4">&quot;found {!r}&quot;</span><span class="s1">.format(value)))</span>
        <span class="s3"># The RFC requires that a syntactically invalid content-type be treated</span>
        <span class="s3"># as text/plain.  Perhaps we should postel this, but we should probably</span>
        <span class="s3"># only do that if we were checking the subtype value against IANA.</span>
        <span class="s2">del </span><span class="s1">ctype.maintype</span><span class="s2">, </span><span class="s1">ctype.subtype</span>
        <span class="s1">_find_mime_parameters(ctype</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">return </span><span class="s1">ctype</span>
    <span class="s1">ctype.append(ValueTerminal(</span><span class="s4">';'</span><span class="s2">, </span><span class="s4">'parameter-separator'</span><span class="s1">))</span>
    <span class="s1">ctype.append(parse_mime_parameters(value[</span><span class="s5">1</span><span class="s1">:]))</span>
    <span class="s2">return </span><span class="s1">ctype</span>

<span class="s2">def </span><span class="s1">parse_content_disposition_header(value):</span>
    <span class="s0">&quot;&quot;&quot; disposition-type *( &quot;;&quot; parameter ) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">disp_header = ContentDisposition()</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s1">disp_header.defects.append(errors.HeaderMissingRequiredValue(</span>
            <span class="s4">&quot;Missing content disposition&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">disp_header</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_token(value)</span>
    <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
        <span class="s1">ctype.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Expected content disposition but found {!r}&quot;</span><span class="s1">.format(value)))</span>
        <span class="s1">_find_mime_parameters(disp_header</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">return </span><span class="s1">disp_header</span>
    <span class="s1">disp_header.append(token)</span>
    <span class="s1">disp_header.content_disposition = token.value.strip().lower()</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s2">return </span><span class="s1">disp_header</span>
    <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">';'</span><span class="s1">:</span>
        <span class="s1">disp_header.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Only parameters are valid after content disposition, but &quot;</span>
            <span class="s4">&quot;found {!r}&quot;</span><span class="s1">.format(value)))</span>
        <span class="s1">_find_mime_parameters(disp_header</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">return </span><span class="s1">disp_header</span>
    <span class="s1">disp_header.append(ValueTerminal(</span><span class="s4">';'</span><span class="s2">, </span><span class="s4">'parameter-separator'</span><span class="s1">))</span>
    <span class="s1">disp_header.append(parse_mime_parameters(value[</span><span class="s5">1</span><span class="s1">:]))</span>
    <span class="s2">return </span><span class="s1">disp_header</span>

<span class="s2">def </span><span class="s1">parse_content_transfer_encoding_header(value):</span>
    <span class="s0">&quot;&quot;&quot; mechanism 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># We should probably validate the values, since the list is fixed.</span>
    <span class="s1">cte_header = ContentTransferEncoding()</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s1">cte_header.defects.append(errors.HeaderMissingRequiredValue(</span>
            <span class="s4">&quot;Missing content transfer encoding&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">cte_header</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_token(value)</span>
    <span class="s2">except </span><span class="s1">errors.HeaderParseError:</span>
        <span class="s1">ctype.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Expected content trnasfer encoding but found {!r}&quot;</span><span class="s1">.format(value)))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">cte_header.append(token)</span>
        <span class="s1">cte_header.cte = token.value.strip().lower()</span>
    <span class="s2">if not </span><span class="s1">value:</span>
        <span class="s2">return </span><span class="s1">cte_header</span>
    <span class="s2">while </span><span class="s1">value:</span>
        <span class="s1">cte_header.defects.append(errors.InvalidHeaderDefect(</span>
            <span class="s4">&quot;Extra text after content transfer encoding&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">PHRASE_ENDS:</span>
            <span class="s1">cte_header.append(ValueTerminal(value[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'misplaced-special'</span><span class="s1">))</span>
            <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">token</span><span class="s2">, </span><span class="s1">value = get_phrase(value)</span>
            <span class="s1">cte_header.append(token)</span>
    <span class="s2">return </span><span class="s1">cte_header</span>
</pre>
</body>
</html>