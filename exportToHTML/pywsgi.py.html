<html>
<head>
<title>pywsgi.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pywsgi.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2005-2009, eventlet contributors</span>
<span class="s0"># Copyright (c) 2009-2018, gevent contributors</span>
<span class="s2">&quot;&quot;&quot; 
A pure-Python, gevent-friendly WSGI server. 
 
The server is provided in :class:`WSGIServer`, but most of the actual 
WSGI work is handled by :class:`WSGIHandler` --- a new instance is 
created for each request. The server can be customized to use 
different subclasses of :class:`WSGIHandler`. 
 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">absolute_import</span>

<span class="s0"># FIXME: Can we refactor to make smallor?</span>
<span class="s0"># pylint:disable=too-many-lines</span>

<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">from </span><span class="s1">io </span><span class="s3">import </span><span class="s1">BytesIO</span>
<span class="s3">import </span><span class="s1">string</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">import </span><span class="s1">traceback</span>
<span class="s3">from </span><span class="s1">datetime </span><span class="s3">import </span><span class="s1">datetime</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">urllib </span><span class="s3">import </span><span class="s1">unquote</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">from </span><span class="s1">urllib.parse </span><span class="s3">import </span><span class="s1">unquote </span><span class="s0"># python 2 pylint:disable=import-error,no-name-in-module</span>

<span class="s3">from </span><span class="s1">gevent </span><span class="s3">import </span><span class="s1">socket</span>
<span class="s3">import </span><span class="s1">gevent</span>
<span class="s3">from </span><span class="s1">gevent.server </span><span class="s3">import </span><span class="s1">StreamServer</span>
<span class="s3">from </span><span class="s1">gevent.hub </span><span class="s3">import </span><span class="s1">GreenletExit</span>
<span class="s3">from </span><span class="s1">gevent._compat </span><span class="s3">import </span><span class="s1">PY3</span><span class="s3">, </span><span class="s1">reraise</span>

<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span>
<span class="s3">if </span><span class="s1">PY3:</span>
    <span class="s1">unquote_latin1 = partial(unquote</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s4">'latin-1'</span><span class="s1">)</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">unquote_latin1 = unquote</span>

<span class="s1">_no_undoc_members = </span><span class="s3">True </span><span class="s0"># Don't put undocumented things into sphinx</span>

<span class="s1">__all__ = [</span>
    <span class="s4">'WSGIServer'</span><span class="s3">,</span>
    <span class="s4">'WSGIHandler'</span><span class="s3">,</span>
    <span class="s4">'LoggingLogAdapter'</span><span class="s3">,</span>
    <span class="s4">'Environ'</span><span class="s3">,</span>
    <span class="s4">'SecureEnviron'</span><span class="s3">,</span>
    <span class="s4">'WSGISecureEnviron'</span><span class="s3">,</span>
<span class="s1">]</span>


<span class="s1">MAX_REQUEST_LINE = </span><span class="s5">8192</span>
<span class="s0"># Weekday and month names for HTTP date/time formatting; always English!</span>
<span class="s1">_WEEKDAYNAME = [</span><span class="s4">&quot;Mon&quot;</span><span class="s3">, </span><span class="s4">&quot;Tue&quot;</span><span class="s3">, </span><span class="s4">&quot;Wed&quot;</span><span class="s3">, </span><span class="s4">&quot;Thu&quot;</span><span class="s3">, </span><span class="s4">&quot;Fri&quot;</span><span class="s3">, </span><span class="s4">&quot;Sat&quot;</span><span class="s3">, </span><span class="s4">&quot;Sun&quot;</span><span class="s1">]</span>
<span class="s1">_MONTHNAME = [</span><span class="s3">None,  </span><span class="s0"># Dummy so we can use 1-based month numbers</span>
              <span class="s4">&quot;Jan&quot;</span><span class="s3">, </span><span class="s4">&quot;Feb&quot;</span><span class="s3">, </span><span class="s4">&quot;Mar&quot;</span><span class="s3">, </span><span class="s4">&quot;Apr&quot;</span><span class="s3">, </span><span class="s4">&quot;May&quot;</span><span class="s3">, </span><span class="s4">&quot;Jun&quot;</span><span class="s3">,</span>
              <span class="s4">&quot;Jul&quot;</span><span class="s3">, </span><span class="s4">&quot;Aug&quot;</span><span class="s3">, </span><span class="s4">&quot;Sep&quot;</span><span class="s3">, </span><span class="s4">&quot;Oct&quot;</span><span class="s3">, </span><span class="s4">&quot;Nov&quot;</span><span class="s3">, </span><span class="s4">&quot;Dec&quot;</span><span class="s1">]</span>

<span class="s0"># The contents of the &quot;HEX&quot; grammar rule for HTTP, upper and lowercase A-F plus digits,</span>
<span class="s0"># in byte form for comparing to the network.</span>
<span class="s1">_HEX = string.hexdigits.encode(</span><span class="s4">'ascii'</span><span class="s1">)</span>

<span class="s0"># Errors</span>
<span class="s1">_ERRORS = {}</span>
<span class="s1">_INTERNAL_ERROR_STATUS = </span><span class="s4">'500 Internal Server Error'</span>
<span class="s1">_INTERNAL_ERROR_BODY = </span><span class="s6">b'Internal Server Error'</span>
<span class="s1">_INTERNAL_ERROR_HEADERS = [(</span><span class="s4">'Content-Type'</span><span class="s3">, </span><span class="s4">'text/plain'</span><span class="s1">)</span><span class="s3">,</span>
                           <span class="s1">(</span><span class="s4">'Connection'</span><span class="s3">, </span><span class="s4">'close'</span><span class="s1">)</span><span class="s3">,</span>
                           <span class="s1">(</span><span class="s4">'Content-Length'</span><span class="s3">, </span><span class="s1">str(len(_INTERNAL_ERROR_BODY)))]</span>
<span class="s1">_ERRORS[</span><span class="s5">500</span><span class="s1">] = (_INTERNAL_ERROR_STATUS</span><span class="s3">, </span><span class="s1">_INTERNAL_ERROR_HEADERS</span><span class="s3">, </span><span class="s1">_INTERNAL_ERROR_BODY)</span>

<span class="s1">_BAD_REQUEST_STATUS = </span><span class="s4">'400 Bad Request'</span>
<span class="s1">_BAD_REQUEST_BODY = </span><span class="s4">''</span>
<span class="s1">_BAD_REQUEST_HEADERS = [(</span><span class="s4">'Content-Type'</span><span class="s3">, </span><span class="s4">'text/plain'</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">(</span><span class="s4">'Connection'</span><span class="s3">, </span><span class="s4">'close'</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">(</span><span class="s4">'Content-Length'</span><span class="s3">, </span><span class="s1">str(len(_BAD_REQUEST_BODY)))]</span>
<span class="s1">_ERRORS[</span><span class="s5">400</span><span class="s1">] = (_BAD_REQUEST_STATUS</span><span class="s3">, </span><span class="s1">_BAD_REQUEST_HEADERS</span><span class="s3">, </span><span class="s1">_BAD_REQUEST_BODY)</span>

<span class="s1">_REQUEST_TOO_LONG_RESPONSE = </span><span class="s6">b&quot;HTTP/1.1 414 Request URI Too Long</span><span class="s3">\r\n</span><span class="s6">Connection: close</span><span class="s3">\r\n</span><span class="s6">Content-length: 0</span><span class="s3">\r\n\r\n</span><span class="s6">&quot;</span>
<span class="s1">_BAD_REQUEST_RESPONSE = </span><span class="s6">b&quot;HTTP/1.1 400 Bad Request</span><span class="s3">\r\n</span><span class="s6">Connection: close</span><span class="s3">\r\n</span><span class="s6">Content-length: 0</span><span class="s3">\r\n\r\n</span><span class="s6">&quot;</span>
<span class="s1">_CONTINUE_RESPONSE = </span><span class="s6">b&quot;HTTP/1.1 100 Continue</span><span class="s3">\r\n\r\n</span><span class="s6">&quot;</span>


<span class="s3">def </span><span class="s1">format_date_time(timestamp):</span>
    <span class="s0"># Return a byte-string of the date and time in HTTP format</span>
    <span class="s0"># .. versionchanged:: 1.1b5</span>
    <span class="s0">#  Return a byte string, not a native string</span>
    <span class="s1">year</span><span class="s3">, </span><span class="s1">month</span><span class="s3">, </span><span class="s1">day</span><span class="s3">, </span><span class="s1">hh</span><span class="s3">, </span><span class="s1">mm</span><span class="s3">, </span><span class="s1">ss</span><span class="s3">, </span><span class="s1">wd</span><span class="s3">, </span><span class="s1">_y</span><span class="s3">, </span><span class="s1">_z = time.gmtime(timestamp)</span>
    <span class="s1">value = </span><span class="s4">&quot;%s, %02d %3s %4d %02d:%02d:%02d GMT&quot; </span><span class="s1">% (_WEEKDAYNAME[wd]</span><span class="s3">, </span><span class="s1">day</span><span class="s3">, </span><span class="s1">_MONTHNAME[month]</span><span class="s3">, </span><span class="s1">year</span><span class="s3">, </span><span class="s1">hh</span><span class="s3">, </span><span class="s1">mm</span><span class="s3">, </span><span class="s1">ss)</span>
    <span class="s3">if </span><span class="s1">PY3:</span>
        <span class="s1">value = value.encode(</span><span class="s4">&quot;latin-1&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">value</span>


<span class="s3">class </span><span class="s1">_InvalidClientInput(IOError):</span>
    <span class="s0"># Internal exception raised by Input indicating that the client</span>
    <span class="s0"># sent invalid data at the lowest level of the stream. The result</span>
    <span class="s0"># *should* be a HTTP 400 error.</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">_InvalidClientRequest(ValueError):</span>
    <span class="s0"># Internal exception raised by WSGIHandler.read_request indicating</span>
    <span class="s0"># that the client sent an HTTP request that cannot be parsed</span>
    <span class="s0"># (e.g., invalid grammar). The result *should* be an HTTP 400</span>
    <span class="s0"># error. It must have exactly one argument, the fully formatted</span>
    <span class="s0"># error string.</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">message):</span>
        <span class="s1">ValueError.__init__(self</span><span class="s3">, </span><span class="s1">message)</span>
        <span class="s1">self.formatted_message = message</span>


<span class="s3">class </span><span class="s1">Input(object):</span>

    <span class="s1">__slots__ = (</span><span class="s4">'rfile'</span><span class="s3">, </span><span class="s4">'content_length'</span><span class="s3">, </span><span class="s4">'socket'</span><span class="s3">, </span><span class="s4">'position'</span><span class="s3">,</span>
                 <span class="s4">'chunked_input'</span><span class="s3">, </span><span class="s4">'chunk_length'</span><span class="s3">, </span><span class="s4">'_chunked_input_error'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">rfile</span><span class="s3">, </span><span class="s1">content_length</span><span class="s3">, </span><span class="s1">socket=</span><span class="s3">None, </span><span class="s1">chunked_input=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0"># pylint:disable=redefined-outer-name</span>
        <span class="s1">self.rfile = rfile</span>
        <span class="s1">self.content_length = content_length</span>
        <span class="s1">self.socket = socket</span>
        <span class="s1">self.position = </span><span class="s5">0</span>
        <span class="s1">self.chunked_input = chunked_input</span>
        <span class="s1">self.chunk_length = -</span><span class="s5">1</span>
        <span class="s1">self._chunked_input_error = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">_discard(self):</span>
        <span class="s3">if </span><span class="s1">self._chunked_input_error:</span>
            <span class="s0"># We are in an unknown state, so we can't necessarily discard</span>
            <span class="s0"># the body (e.g., if the client keeps the socket open, we could hang</span>
            <span class="s0"># here forever).</span>
            <span class="s0"># In this case, we've raised an exception and the user of this object</span>
            <span class="s0"># is going to close the socket, so we don't have to discard</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">self.socket </span><span class="s3">is None and </span><span class="s1">(self.position &lt; (self.content_length </span><span class="s3">or </span><span class="s5">0</span><span class="s1">) </span><span class="s3">or </span><span class="s1">self.chunked_input):</span>
            <span class="s0"># ## Read and discard body</span>
            <span class="s3">while </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">d = self.read(</span><span class="s5">16384</span><span class="s1">)</span>
                <span class="s3">if not </span><span class="s1">d:</span>
                    <span class="s3">break</span>

    <span class="s3">def </span><span class="s1">_send_100_continue(self):</span>
        <span class="s3">if </span><span class="s1">self.socket </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.socket.sendall(_CONTINUE_RESPONSE)</span>
            <span class="s1">self.socket = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">_do_read(self</span><span class="s3">, </span><span class="s1">length=</span><span class="s3">None, </span><span class="s1">use_readline=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">use_readline:</span>
            <span class="s1">reader = self.rfile.readline</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">reader = self.rfile.read</span>
        <span class="s1">content_length = self.content_length</span>
        <span class="s3">if </span><span class="s1">content_length </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s0"># Either Content-Length or &quot;Transfer-Encoding: chunked&quot; must be present in a request with a body</span>
            <span class="s0"># if it was chunked, then this function would have not been called</span>
            <span class="s3">return </span><span class="s6">b''</span>

        <span class="s1">self._send_100_continue()</span>
        <span class="s1">left = content_length - self.position</span>
        <span class="s3">if </span><span class="s1">length </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">length = left</span>
        <span class="s3">elif </span><span class="s1">length &gt; left:</span>
            <span class="s1">length = left</span>
        <span class="s3">if not </span><span class="s1">length:</span>
            <span class="s3">return </span><span class="s6">b''</span>

        <span class="s0"># On Python 2, self.rfile is usually socket.makefile(), which</span>
        <span class="s0"># uses cStringIO.StringIO. If *length* is greater than the C</span>
        <span class="s0"># sizeof(int) (typically 32 bits signed), parsing the argument to</span>
        <span class="s0"># readline raises OverflowError. StringIO.read(), OTOH, uses</span>
        <span class="s0"># PySize_t, typically a long (64 bits). In a bare readline()</span>
        <span class="s0"># case, because the header lines we're trying to read with</span>
        <span class="s0"># readline are typically expected to be small, we can correct</span>
        <span class="s0"># that failure by simply doing a smaller call to readline and</span>
        <span class="s0"># appending; failures in read we let propagate.</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">read = reader(length)</span>
        <span class="s3">except </span><span class="s1">OverflowError:</span>
            <span class="s3">if not </span><span class="s1">use_readline:</span>
                <span class="s0"># Expecting to read more than 64 bits of data. Ouch!</span>
                <span class="s3">raise</span>
            <span class="s0"># We could loop on calls to smaller readline(), appending them</span>
            <span class="s0"># until we actually get a newline. For uses in this module,</span>
            <span class="s0"># we expect the actual length to be small, but WSGI applications</span>
            <span class="s0"># are allowed to pass in an arbitrary length. (This loop isn't optimal,</span>
            <span class="s0"># but even client applications *probably* have short lines.)</span>
            <span class="s1">read = </span><span class="s6">b''</span>
            <span class="s3">while </span><span class="s1">len(read) &lt; length </span><span class="s3">and not </span><span class="s1">read.endswith(</span><span class="s6">b'</span><span class="s3">\n</span><span class="s6">'</span><span class="s1">):</span>
                <span class="s1">read += reader(MAX_REQUEST_LINE)</span>

        <span class="s1">self.position += len(read)</span>
        <span class="s3">if </span><span class="s1">len(read) &lt; length:</span>
            <span class="s3">if </span><span class="s1">(use_readline </span><span class="s3">and not </span><span class="s1">read.endswith(</span><span class="s6">b&quot;</span><span class="s3">\n</span><span class="s6">&quot;</span><span class="s1">)) </span><span class="s3">or not </span><span class="s1">use_readline:</span>
                <span class="s3">raise </span><span class="s1">IOError(</span><span class="s4">&quot;unexpected end of file while reading request at position %s&quot; </span><span class="s1">% (self.position</span><span class="s3">,</span><span class="s1">))</span>

        <span class="s3">return </span><span class="s1">read</span>

    <span class="s3">def </span><span class="s1">__read_chunk_length(self</span><span class="s3">, </span><span class="s1">rfile):</span>
        <span class="s0"># Read and return the next integer chunk length. If no</span>
        <span class="s0"># chunk length can be read, raises _InvalidClientInput.</span>

        <span class="s0"># Here's the production for a chunk:</span>
        <span class="s0"># (http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html)</span>
        <span class="s0">#   chunk          = chunk-size [ chunk-extension ] CRLF</span>
        <span class="s0">#                    chunk-data CRLF</span>
        <span class="s0">#   chunk-size     = 1*HEX</span>
        <span class="s0">#   chunk-extension= *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )</span>
        <span class="s0">#   chunk-ext-name = token</span>
        <span class="s0">#   chunk-ext-val  = token | quoted-string</span>

        <span class="s0"># To cope with malicious or broken clients that fail to send valid</span>
        <span class="s0"># chunk lines, the strategy is to read character by character until we either reach</span>
        <span class="s0"># a ; or newline. If at any time we read a non-HEX digit, we bail. If we hit a</span>
        <span class="s0"># ;, indicating an chunk-extension, we'll read up to the next</span>
        <span class="s0"># MAX_REQUEST_LINE characters</span>
        <span class="s0"># looking for the CRLF, and if we don't find it, we bail. If we read more than 16 hex characters,</span>
        <span class="s0"># (the number needed to represent a 64-bit chunk size), we bail (this protects us from</span>
        <span class="s0"># a client that sends an infinite stream of `F`, for example).</span>

        <span class="s1">buf = BytesIO()</span>
        <span class="s3">while </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">char = rfile.read(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">char:</span>
                <span class="s1">self._chunked_input_error = </span><span class="s3">True</span>
                <span class="s3">raise </span><span class="s1">_InvalidClientInput(</span><span class="s4">&quot;EOF before chunk end reached&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">char == </span><span class="s6">b'</span><span class="s3">\r</span><span class="s6">'</span><span class="s1">:</span>
                <span class="s3">break</span>
            <span class="s3">if </span><span class="s1">char == </span><span class="s6">b';'</span><span class="s1">:</span>
                <span class="s3">break</span>

            <span class="s3">if </span><span class="s1">char </span><span class="s3">not in </span><span class="s1">_HEX:</span>
                <span class="s1">self._chunked_input_error = </span><span class="s3">True</span>
                <span class="s3">raise </span><span class="s1">_InvalidClientInput(</span><span class="s4">&quot;Non-hex data&quot;</span><span class="s3">, </span><span class="s1">char)</span>
            <span class="s1">buf.write(char)</span>
            <span class="s3">if </span><span class="s1">buf.tell() &gt; </span><span class="s5">16</span><span class="s1">:</span>
                <span class="s1">self._chunked_input_error = </span><span class="s3">True</span>
                <span class="s3">raise </span><span class="s1">_InvalidClientInput(</span><span class="s4">&quot;Chunk-size too large.&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">char == </span><span class="s6">b';'</span><span class="s1">:</span>
            <span class="s1">i = </span><span class="s5">0</span>
            <span class="s3">while </span><span class="s1">i &lt; MAX_REQUEST_LINE:</span>
                <span class="s1">char = rfile.read(</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">char == </span><span class="s6">b'</span><span class="s3">\r</span><span class="s6">'</span><span class="s1">:</span>
                    <span class="s3">break</span>
                <span class="s1">i += </span><span class="s5">1</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># we read more than MAX_REQUEST_LINE without</span>
                <span class="s0"># hitting CR</span>
                <span class="s1">self._chunked_input_error = </span><span class="s3">True</span>
                <span class="s3">raise </span><span class="s1">_InvalidClientInput(</span><span class="s4">&quot;Too large chunk extension&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">char == </span><span class="s6">b'</span><span class="s3">\r</span><span class="s6">'</span><span class="s1">:</span>
            <span class="s0"># We either got here from the main loop or from the</span>
            <span class="s0"># end of an extension</span>
            <span class="s1">char = rfile.read(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">char != </span><span class="s6">b'</span><span class="s3">\n</span><span class="s6">'</span><span class="s1">:</span>
                <span class="s1">self._chunked_input_error = </span><span class="s3">True</span>
                <span class="s3">raise </span><span class="s1">_InvalidClientInput(</span><span class="s4">&quot;Line didn't end in CRLF&quot;</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">int(buf.getvalue()</span><span class="s3">, </span><span class="s5">16</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_chunked_read(self</span><span class="s3">, </span><span class="s1">length=</span><span class="s3">None, </span><span class="s1">use_readline=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0"># pylint:disable=too-many-branches</span>
        <span class="s1">rfile = self.rfile</span>
        <span class="s1">self._send_100_continue()</span>

        <span class="s3">if </span><span class="s1">length == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s6">b&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">use_readline:</span>
            <span class="s1">reader = self.rfile.readline</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">reader = self.rfile.read</span>

        <span class="s1">response = []</span>
        <span class="s3">while </span><span class="s1">self.chunk_length != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">maxreadlen = self.chunk_length - self.position</span>
            <span class="s3">if </span><span class="s1">length </span><span class="s3">is not None and </span><span class="s1">length &lt; maxreadlen:</span>
                <span class="s1">maxreadlen = length</span>

            <span class="s3">if </span><span class="s1">maxreadlen &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">data = reader(maxreadlen)</span>
                <span class="s3">if not </span><span class="s1">data:</span>
                    <span class="s1">self.chunk_length = </span><span class="s5">0</span>
                    <span class="s1">self._chunked_input_error = </span><span class="s3">True</span>
                    <span class="s3">raise </span><span class="s1">IOError(</span><span class="s4">&quot;unexpected end of file while parsing chunked data&quot;</span><span class="s1">)</span>

                <span class="s1">datalen = len(data)</span>
                <span class="s1">response.append(data)</span>

                <span class="s1">self.position += datalen</span>
                <span class="s3">if </span><span class="s1">self.chunk_length == self.position:</span>
                    <span class="s1">rfile.readline()</span>

                <span class="s3">if </span><span class="s1">length </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">length -= datalen</span>
                    <span class="s3">if </span><span class="s1">length == </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s3">break</span>
                <span class="s3">if </span><span class="s1">use_readline </span><span class="s3">and </span><span class="s1">data[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s6">b&quot;</span><span class="s3">\n</span><span class="s6">&quot;</span><span class="s1">[</span><span class="s5">0</span><span class="s1">]:</span>
                    <span class="s3">break</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># We're at the beginning of a chunk, so we need to</span>
                <span class="s0"># determine the next size to read</span>
                <span class="s1">self.chunk_length = self.__read_chunk_length(rfile)</span>
                <span class="s1">self.position = </span><span class="s5">0</span>
                <span class="s3">if </span><span class="s1">self.chunk_length == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s0"># Last chunk. Terminates with a CRLF.</span>
                    <span class="s1">rfile.readline()</span>
        <span class="s3">return </span><span class="s6">b''</span><span class="s1">.join(response)</span>

    <span class="s3">def </span><span class="s1">read(self</span><span class="s3">, </span><span class="s1">length=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">length </span><span class="s3">is not None and </span><span class="s1">length &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">length = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">self.chunked_input:</span>
            <span class="s3">return </span><span class="s1">self._chunked_read(length)</span>
        <span class="s3">return </span><span class="s1">self._do_read(length)</span>

    <span class="s3">def </span><span class="s1">readline(self</span><span class="s3">, </span><span class="s1">size=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">size </span><span class="s3">is not None and </span><span class="s1">size &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">size = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">self.chunked_input:</span>
            <span class="s3">return </span><span class="s1">self._chunked_read(size</span><span class="s3">, True</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._do_read(size</span><span class="s3">, </span><span class="s1">use_readline=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">readlines(self</span><span class="s3">, </span><span class="s1">hint=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># pylint:disable=unused-argument</span>
        <span class="s3">return </span><span class="s1">list(self)</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">next(self):</span>
        <span class="s1">line = self.readline()</span>
        <span class="s3">if not </span><span class="s1">line:</span>
            <span class="s3">raise </span><span class="s1">StopIteration</span>
        <span class="s3">return </span><span class="s1">line</span>
    <span class="s1">__next__ = next</span>


<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">import </span><span class="s1">mimetools</span>
    <span class="s1">headers_factory = mimetools.Message</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s0"># adapt Python 3 HTTP headers to old API</span>
    <span class="s3">from </span><span class="s1">http </span><span class="s3">import </span><span class="s1">client </span><span class="s0"># pylint:disable=import-error</span>

    <span class="s3">class </span><span class="s1">OldMessage(client.HTTPMessage):</span>
        <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">**kwargs):</span>
            <span class="s1">super(client.HTTPMessage</span><span class="s3">, </span><span class="s1">self).__init__(**kwargs) </span><span class="s0"># pylint:disable=bad-super-call</span>
            <span class="s1">self.status = </span><span class="s4">''</span>

        <span class="s3">def </span><span class="s1">getheader(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.get(name</span><span class="s3">, </span><span class="s1">default)</span>

        <span class="s1">@property</span>
        <span class="s3">def </span><span class="s1">headers(self):</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self._headers:</span>
                <span class="s3">yield </span><span class="s4">'%s: %s</span><span class="s3">\r\n</span><span class="s4">' </span><span class="s1">% (key</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s1">@property</span>
        <span class="s3">def </span><span class="s1">typeheader(self):</span>
            <span class="s3">return </span><span class="s1">self.get(</span><span class="s4">'content-type'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">headers_factory(fp</span><span class="s3">, </span><span class="s1">*args): </span><span class="s0"># pylint:disable=unused-argument</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">ret = client.parse_headers(fp</span><span class="s3">, </span><span class="s1">_class=OldMessage)</span>
        <span class="s3">except </span><span class="s1">client.LineTooLong:</span>
            <span class="s1">ret = OldMessage()</span>
            <span class="s1">ret.status = </span><span class="s4">'Line too long'</span>
        <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">class </span><span class="s1">WSGIHandler(object):</span>
    <span class="s2">&quot;&quot;&quot; 
    Handles HTTP requests from a socket, creates the WSGI environment, and 
    interacts with the WSGI application. 
 
    This is the default value of :attr:`WSGIServer.handler_class`. 
    This class may be subclassed carefully, and that class set on a 
    :class:`WSGIServer` instance through a keyword argument at 
    construction time. 
 
    Instances are constructed with the same arguments as passed to the 
    server's :meth:`WSGIServer.handle` method followed by the server 
    itself. The application and environment are obtained from the server. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># pylint:disable=too-many-instance-attributes</span>

    <span class="s1">protocol_version = </span><span class="s4">'HTTP/1.1'</span>
    <span class="s3">if </span><span class="s1">PY3:</span>
        <span class="s0"># if we do like Py2, then headers_factory unconditionally</span>
        <span class="s0"># becomes a bound method, meaning the fp argument becomes WSGIHandler</span>
        <span class="s3">def </span><span class="s1">MessageClass(self</span><span class="s3">, </span><span class="s1">*args):</span>
            <span class="s3">return </span><span class="s1">headers_factory(*args)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">MessageClass = headers_factory</span>

    <span class="s0"># Attributes reset at various times for each request; not public</span>
    <span class="s0"># documented. Class attributes to keep the constructor fast</span>
    <span class="s0"># (but not make lint tools complain)</span>

    <span class="s1">status = </span><span class="s3">None </span><span class="s0"># byte string: b'200 OK'</span>
    <span class="s1">_orig_status = </span><span class="s3">None </span><span class="s0"># native string: '200 OK'</span>
    <span class="s1">response_headers = </span><span class="s3">None </span><span class="s0"># list of tuples (b'name', b'value')</span>
    <span class="s1">code = </span><span class="s3">None </span><span class="s0"># Integer parsed from status</span>
    <span class="s1">provided_date = </span><span class="s3">None</span>
    <span class="s1">provided_content_length = </span><span class="s3">None</span>
    <span class="s1">close_connection = </span><span class="s3">False</span>
    <span class="s1">time_start = </span><span class="s5">0 </span><span class="s0"># time.time() when begin handling request</span>
    <span class="s1">time_finish = </span><span class="s5">0 </span><span class="s0"># time.time() when done handling request</span>
    <span class="s1">headers_sent = </span><span class="s3">False </span><span class="s0"># Have we already sent headers?</span>
    <span class="s1">response_use_chunked = </span><span class="s3">False </span><span class="s0"># Write with transfer-encoding chunked</span>
    <span class="s0"># Was the connection upgraded? We shouldn't try to chunk writes in that</span>
    <span class="s0"># case.</span>
    <span class="s1">connection_upgraded = </span><span class="s3">False</span>
    <span class="s1">environ = </span><span class="s3">None </span><span class="s0"># Dict from self.get_environ</span>
    <span class="s1">application = </span><span class="s3">None </span><span class="s0"># application callable from self.server.application</span>
    <span class="s1">requestline = </span><span class="s3">None </span><span class="s0"># native str 'GET / HTTP/1.1'</span>
    <span class="s1">response_length = </span><span class="s5">0 </span><span class="s0"># How much data we sent</span>
    <span class="s1">result = </span><span class="s3">None </span><span class="s0"># The return value of the WSGI application</span>
    <span class="s1">wsgi_input = </span><span class="s3">None </span><span class="s0"># Instance of Input()</span>
    <span class="s1">content_length = </span><span class="s5">0 </span><span class="s0"># From application-provided headers Incoming</span>
    <span class="s0"># request headers, instance of MessageClass (gunicorn uses hasattr</span>
    <span class="s0"># on this so the default value needs to be compatible with the</span>
    <span class="s0"># API)</span>
    <span class="s1">headers = headers_factory(BytesIO())</span>
    <span class="s1">request_version = </span><span class="s3">None </span><span class="s0"># str: 'HTTP 1.1'</span>
    <span class="s1">command = </span><span class="s3">None </span><span class="s0"># str: 'GET'</span>
    <span class="s1">path = </span><span class="s3">None </span><span class="s0"># str: '/'</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">sock</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">server</span><span class="s3">, </span><span class="s1">rfile=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># Deprecation: The rfile kwarg was introduced in 1.0a1 as part</span>
        <span class="s0"># of a refactoring. It was never documented or used. It is</span>
        <span class="s0"># considered DEPRECATED and may be removed in the future. Its</span>
        <span class="s0"># use is not supported.</span>

        <span class="s1">self.socket = sock</span>
        <span class="s1">self.client_address = address</span>
        <span class="s1">self.server = server</span>
        <span class="s3">if </span><span class="s1">rfile </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.rfile = sock.makefile(</span><span class="s4">'rb'</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.rfile = rfile</span>

    <span class="s3">def </span><span class="s1">handle(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        The main request handling method, called by the server. 
 
        This method runs a request handling loop, calling 
        :meth:`handle_one_request` until all requests on the 
        connection have been handled (that is, it implements 
        keep-alive). 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">while </span><span class="s1">self.socket </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.time_start = time.time()</span>
                <span class="s1">self.time_finish = </span><span class="s5">0</span>

                <span class="s1">result = self.handle_one_request()</span>
                <span class="s3">if </span><span class="s1">result </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s3">break</span>
                <span class="s3">if </span><span class="s1">result </span><span class="s3">is True</span><span class="s1">:</span>
                    <span class="s3">continue</span>

                <span class="s1">self.status</span><span class="s3">, </span><span class="s1">response_body = result </span><span class="s0"># pylint:disable=unpacking-non-sequence</span>
                <span class="s1">self.socket.sendall(response_body)</span>
                <span class="s3">if </span><span class="s1">self.time_finish == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">self.time_finish = time.time()</span>
                <span class="s1">self.log_request()</span>
                <span class="s3">break</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.socket </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">_sock = getattr(self.socket</span><span class="s3">, </span><span class="s4">'_sock'</span><span class="s3">, None</span><span class="s1">) </span><span class="s0"># Python 3</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s0"># read out request data to prevent error: [Errno 104] Connection reset by peer</span>
                    <span class="s3">if </span><span class="s1">_sock:</span>
                        <span class="s3">try</span><span class="s1">:</span>
                            <span class="s0"># socket.recv would hang</span>
                            <span class="s1">_sock.recv(</span><span class="s5">16384</span><span class="s1">)</span>
                        <span class="s3">finally</span><span class="s1">:</span>
                            <span class="s1">_sock.close()</span>
                    <span class="s1">self.socket.close()</span>
                <span class="s3">except </span><span class="s1">socket.error:</span>
                    <span class="s3">pass</span>
            <span class="s1">self.__dict__.pop(</span><span class="s4">'socket'</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s1">self.__dict__.pop(</span><span class="s4">'rfile'</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s1">self.__dict__.pop(</span><span class="s4">'wsgi_input'</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_check_http_version(self):</span>
        <span class="s1">version_str = self.request_version</span>
        <span class="s3">if not </span><span class="s1">version_str.startswith(</span><span class="s4">&quot;HTTP/&quot;</span><span class="s1">):</span>
            <span class="s3">return False</span>
        <span class="s1">version = tuple(int(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">version_str[</span><span class="s5">5</span><span class="s1">:].split(</span><span class="s4">&quot;.&quot;</span><span class="s1">))  </span><span class="s0"># &quot;HTTP/&quot;</span>
        <span class="s3">if </span><span class="s1">version[</span><span class="s5">1</span><span class="s1">] &lt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">version &lt; (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">9</span><span class="s1">) </span><span class="s3">or </span><span class="s1">version &gt;= (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s1">):</span>
            <span class="s3">return False</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">read_request(self</span><span class="s3">, </span><span class="s1">raw_requestline):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parse the incoming request. 
 
        Parses various headers into ``self.headers`` using 
        :attr:`MessageClass`. Other attributes that are set upon a successful 
        return of this method include ``self.content_length`` and ``self.close_connection``. 
 
        :param str raw_requestline: A native :class:`str` representing 
           the request line. A processed version of this will be stored 
           into ``self.requestline``. 
 
        :raises ValueError: If the request is invalid. This error will 
           not be logged as a traceback (because it's a client issue, not a server problem). 
        :return: A boolean value indicating whether the request was successfully parsed. 
           This method should either return a true value or have raised a ValueError 
           with details about the parsing error. 
 
        .. versionchanged:: 1.1b6 
           Raise the previously documented :exc:`ValueError` in more cases instead of returning a 
           false value; this allows subclasses more opportunity to customize behaviour. 
        &quot;&quot;&quot;</span>
        <span class="s0"># pylint:disable=too-many-branches</span>
        <span class="s1">self.requestline = raw_requestline.rstrip()</span>
        <span class="s1">words = self.requestline.split()</span>
        <span class="s3">if </span><span class="s1">len(words) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">self.command</span><span class="s3">, </span><span class="s1">self.path</span><span class="s3">, </span><span class="s1">self.request_version = words</span>
            <span class="s3">if not </span><span class="s1">self._check_http_version():</span>
                <span class="s3">raise </span><span class="s1">_InvalidClientRequest(</span><span class="s4">'Invalid http version: %r' </span><span class="s1">% (raw_requestline</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s3">elif </span><span class="s1">len(words) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">self.command</span><span class="s3">, </span><span class="s1">self.path = words</span>
            <span class="s3">if </span><span class="s1">self.command != </span><span class="s4">&quot;GET&quot;</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">_InvalidClientRequest(</span><span class="s4">'Expected GET method: %r' </span><span class="s1">% (raw_requestline</span><span class="s3">,</span><span class="s1">))</span>
            <span class="s1">self.request_version = </span><span class="s4">&quot;HTTP/0.9&quot;</span>
            <span class="s0"># QQQ I'm pretty sure we can drop support for HTTP/0.9</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">_InvalidClientRequest(</span><span class="s4">'Invalid HTTP method: %r' </span><span class="s1">% (raw_requestline</span><span class="s3">,</span><span class="s1">))</span>

        <span class="s1">self.headers = self.MessageClass(self.rfile</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.headers.status:</span>
            <span class="s3">raise </span><span class="s1">_InvalidClientRequest(</span><span class="s4">'Invalid headers status: %r' </span><span class="s1">% (self.headers.status</span><span class="s3">,</span><span class="s1">))</span>

        <span class="s3">if </span><span class="s1">self.headers.get(</span><span class="s4">&quot;transfer-encoding&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">).lower() == </span><span class="s4">&quot;chunked&quot;</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">del </span><span class="s1">self.headers[</span><span class="s4">&quot;content-length&quot;</span><span class="s1">]</span>
            <span class="s3">except </span><span class="s1">KeyError:</span>
                <span class="s3">pass</span>

        <span class="s1">content_length = self.headers.get(</span><span class="s4">&quot;content-length&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">content_length </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">content_length = int(content_length)</span>
            <span class="s3">if </span><span class="s1">content_length &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">_InvalidClientRequest(</span><span class="s4">'Invalid Content-Length: %r' </span><span class="s1">% (content_length</span><span class="s3">,</span><span class="s1">))</span>

            <span class="s3">if </span><span class="s1">content_length </span><span class="s3">and </span><span class="s1">self.command </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'HEAD'</span><span class="s3">, </span><span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">_InvalidClientRequest(</span><span class="s4">'Unexpected Content-Length'</span><span class="s1">)</span>

        <span class="s1">self.content_length = content_length</span>

        <span class="s3">if </span><span class="s1">self.request_version == </span><span class="s4">&quot;HTTP/1.1&quot;</span><span class="s1">:</span>
            <span class="s1">conntype = self.headers.get(</span><span class="s4">&quot;Connection&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">).lower()</span>
            <span class="s1">self.close_connection = (conntype == </span><span class="s4">'close'</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">self.request_version == </span><span class="s4">'HTTP/1.0'</span><span class="s1">:</span>
            <span class="s1">conntype = self.headers.get(</span><span class="s4">&quot;Connection&quot;</span><span class="s3">, </span><span class="s4">&quot;close&quot;</span><span class="s1">).lower()</span>
            <span class="s1">self.close_connection = (conntype != </span><span class="s4">'keep-alive'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># XXX: HTTP 0.9. We should drop support</span>
            <span class="s1">self.close_connection = </span><span class="s3">True</span>

        <span class="s3">return True</span>

    <span class="s1">_print_unexpected_exc = staticmethod(traceback.print_exc)</span>

    <span class="s3">def </span><span class="s1">log_error(self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">if not </span><span class="s1">args:</span>
            <span class="s0"># Already fully formatted, no need to do it again; msg</span>
            <span class="s0"># might contain % chars that would lead to a formatting</span>
            <span class="s0"># error.</span>
            <span class="s1">message = msg</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">message = msg % args</span>
            <span class="s3">except </span><span class="s1">Exception: </span><span class="s0"># pylint:disable=broad-except</span>
                <span class="s1">self._print_unexpected_exc()</span>
                <span class="s1">message = </span><span class="s4">'%r %r' </span><span class="s1">% (msg</span><span class="s3">, </span><span class="s1">args)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">message = </span><span class="s4">'%s: %s' </span><span class="s1">% (self.socket</span><span class="s3">, </span><span class="s1">message)</span>
        <span class="s3">except </span><span class="s1">Exception: </span><span class="s0"># pylint:disable=broad-except</span>
            <span class="s3">pass</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.server.error_log.write(message + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">Exception: </span><span class="s0"># pylint:disable=broad-except</span>
            <span class="s1">self._print_unexpected_exc()</span>

    <span class="s3">def </span><span class="s1">read_requestline(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Read and return the HTTP request line. 
 
        Under both Python 2 and 3, this should return the native 
        ``str`` type; under Python 3, this probably means the bytes read 
        from the network need to be decoded (using the ISO-8859-1 charset, aka 
        latin-1). 
        &quot;&quot;&quot;</span>
        <span class="s1">line = self.rfile.readline(MAX_REQUEST_LINE)</span>
        <span class="s3">if </span><span class="s1">PY3:</span>
            <span class="s1">line = line.decode(</span><span class="s4">'latin-1'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">line</span>

    <span class="s3">def </span><span class="s1">handle_one_request(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Handles one HTTP request using ``self.socket`` and ``self.rfile``. 
 
        Each invocation of this method will do several things, including (but not limited to): 
 
        - Read the request line using :meth:`read_requestline`; 
        - Read the rest of the request, including headers, with :meth:`read_request`; 
        - Construct a new WSGI environment in ``self.environ`` using :meth:`get_environ`; 
        - Store the application in ``self.application``, retrieving it from the server; 
        - Handle the remainder of the request, including invoking the application, 
          with :meth:`handle_one_response` 
 
        There are several possible return values to indicate the state 
        of the client connection: 
 
        - ``None`` 
            The client connection is already closed or should 
            be closed because the WSGI application or client set the 
            ``Connection: close`` header. The request handling 
            loop should terminate and perform cleanup steps. 
        - (status, body) 
            An HTTP status and body tuple. The request was in error, 
            as detailed by the status and body. The request handling 
            loop should terminate, close the connection, and perform 
            cleanup steps. Note that the ``body`` is the complete contents 
            to send to the client, including all headers and the initial 
            status line. 
        - ``True`` 
            The literal ``True`` value. The request was successfully handled 
            and the response sent to the client by :meth:`handle_one_response`. 
            The connection remains open to process more requests and the connection 
            handling loop should call this method again. This is the typical return 
            value. 
 
        .. seealso:: :meth:`handle` 
 
        .. versionchanged:: 1.1b6 
           Funnel exceptions having to do with invalid HTTP requests through 
           :meth:`_handle_client_error` to allow subclasses to customize. Note that 
           this is experimental and may change in the future. 
        &quot;&quot;&quot;</span>
        <span class="s0"># pylint:disable=too-many-return-statements</span>
        <span class="s3">if </span><span class="s1">self.rfile.closed:</span>
            <span class="s3">return</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.requestline = self.read_requestline()</span>
            <span class="s0"># Account for old subclasses that haven't done this</span>
            <span class="s3">if </span><span class="s1">PY3 </span><span class="s3">and </span><span class="s1">isinstance(self.requestline</span><span class="s3">, </span><span class="s1">bytes):</span>
                <span class="s1">self.requestline = self.requestline.decode(</span><span class="s4">'latin-1'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">socket.error:</span>
            <span class="s0"># &quot;Connection reset by peer&quot; or other socket errors aren't interesting here</span>
            <span class="s3">return</span>

        <span class="s3">if not </span><span class="s1">self.requestline:</span>
            <span class="s3">return</span>

        <span class="s1">self.response_length = </span><span class="s5">0</span>

        <span class="s3">if </span><span class="s1">len(self.requestline) &gt;= MAX_REQUEST_LINE:</span>
            <span class="s3">return </span><span class="s1">(</span><span class="s4">'414'</span><span class="s3">, </span><span class="s1">_REQUEST_TOO_LONG_RESPONSE)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s0"># for compatibility with older versions of pywsgi, we pass self.requestline as an argument there</span>
            <span class="s0"># NOTE: read_request is supposed to raise ValueError on invalid input; allow old</span>
            <span class="s0"># subclasses that return a False value instead.</span>
            <span class="s0"># NOTE: This can mutate the value of self.headers, so self.get_environ() must not be</span>
            <span class="s0"># called until AFTER this call is done.</span>
            <span class="s3">if not </span><span class="s1">self.read_request(self.requestline):</span>
                <span class="s3">return </span><span class="s1">(</span><span class="s4">'400'</span><span class="s3">, </span><span class="s1">_BAD_REQUEST_RESPONSE)</span>
        <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">ex: </span><span class="s0"># pylint:disable=broad-except</span>
            <span class="s0"># Notice we don't use self.handle_error because it reports</span>
            <span class="s0"># a 500 error to the client, and this is almost certainly</span>
            <span class="s0"># a client error.</span>
            <span class="s0"># Provide a hook for subclasses.</span>
            <span class="s3">return </span><span class="s1">self._handle_client_error(ex)</span>

        <span class="s1">self.environ = self.get_environ()</span>
        <span class="s1">self.application = self.server.application</span>

        <span class="s1">self.handle_one_response()</span>

        <span class="s3">if </span><span class="s1">self.close_connection:</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">self.rfile.closed:</span>
            <span class="s3">return</span>

        <span class="s3">return True  </span><span class="s0"># read more requests</span>

    <span class="s3">def </span><span class="s1">_connection_upgrade_requested(self):</span>
        <span class="s3">if </span><span class="s1">self.headers.get(</span><span class="s4">'Connection'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">).lower() == </span><span class="s4">'upgrade'</span><span class="s1">:</span>
            <span class="s3">return True</span>
        <span class="s3">if </span><span class="s1">self.headers.get(</span><span class="s4">'Upgrade'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">).lower() == </span><span class="s4">'websocket'</span><span class="s1">:</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">finalize_headers(self):</span>
        <span class="s3">if </span><span class="s1">self.provided_date </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.response_headers.append((</span><span class="s6">b'Date'</span><span class="s3">, </span><span class="s1">format_date_time(time.time())))</span>

        <span class="s1">self.connection_upgraded = self.code == </span><span class="s5">101</span>

        <span class="s3">if </span><span class="s1">self.code </span><span class="s3">not in </span><span class="s1">(</span><span class="s5">304</span><span class="s3">, </span><span class="s5">204</span><span class="s1">):</span>
            <span class="s0"># the reply will include message-body; make sure we have either Content-Length or chunked</span>
            <span class="s3">if </span><span class="s1">self.provided_content_length </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">hasattr(self.result</span><span class="s3">, </span><span class="s4">'__len__'</span><span class="s1">):</span>
                    <span class="s1">total_len = sum(len(chunk) </span><span class="s3">for </span><span class="s1">chunk </span><span class="s3">in </span><span class="s1">self.result)</span>
                    <span class="s1">total_len_str = str(total_len)</span>
                    <span class="s3">if </span><span class="s1">PY3:</span>
                        <span class="s1">total_len_str = total_len_str.encode(</span><span class="s4">&quot;latin-1&quot;</span><span class="s1">)</span>
                    <span class="s1">self.response_headers.append((</span><span class="s6">b'Content-Length'</span><span class="s3">, </span><span class="s1">total_len_str))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self.response_use_chunked = (</span>
                        <span class="s3">not </span><span class="s1">self.connection_upgraded</span>
                        <span class="s3">and </span><span class="s1">self.request_version != </span><span class="s4">'HTTP/1.0'</span>
                    <span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">self.response_use_chunked:</span>
                        <span class="s1">self.response_headers.append((</span><span class="s6">b'Transfer-Encoding'</span><span class="s3">, </span><span class="s6">b'chunked'</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">_sendall(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.socket.sendall(data)</span>
        <span class="s3">except </span><span class="s1">socket.error </span><span class="s3">as </span><span class="s1">ex:</span>
            <span class="s1">self.status = </span><span class="s4">'socket error: %s' </span><span class="s1">% ex</span>
            <span class="s3">if </span><span class="s1">self.code &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">self.code = -self.code</span>
            <span class="s3">raise</span>
        <span class="s1">self.response_length += len(data)</span>

    <span class="s3">def </span><span class="s1">_write(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">,</span>
               <span class="s1">_bytearray=bytearray):</span>
        <span class="s3">if not </span><span class="s1">data:</span>
            <span class="s0"># The application/middleware are allowed to yield</span>
            <span class="s0"># empty bytestrings.</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">self.response_use_chunked:</span>
            <span class="s0"># Write the chunked encoding header</span>
            <span class="s1">header_str = </span><span class="s6">b'%x</span><span class="s3">\r\n</span><span class="s6">' </span><span class="s1">% len(data)</span>
            <span class="s1">towrite = _bytearray(header_str)</span>

            <span class="s0"># data</span>
            <span class="s1">towrite += data</span>
            <span class="s0"># trailer</span>
            <span class="s1">towrite += </span><span class="s6">b'</span><span class="s3">\r\n</span><span class="s6">'</span>
            <span class="s1">self._sendall(towrite)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._sendall(data)</span>

    <span class="s1">ApplicationError = AssertionError</span>

    <span class="s3">def </span><span class="s1">write(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s0"># The write() callable we return from start_response.</span>
        <span class="s0"># https://www.python.org/dev/peps/pep-3333/#the-write-callable</span>
        <span class="s0"># Supposed to do pretty much the same thing as yielding values</span>
        <span class="s0"># from the application's return.</span>
        <span class="s3">if </span><span class="s1">self.code </span><span class="s3">in </span><span class="s1">(</span><span class="s5">304</span><span class="s3">, </span><span class="s5">204</span><span class="s1">) </span><span class="s3">and </span><span class="s1">data:</span>
            <span class="s3">raise </span><span class="s1">self.ApplicationError(</span><span class="s4">'The %s response must have no body' </span><span class="s1">% self.code)</span>

        <span class="s3">if </span><span class="s1">self.headers_sent:</span>
            <span class="s1">self._write(data)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">self.status:</span>
                <span class="s3">raise </span><span class="s1">self.ApplicationError(</span><span class="s4">&quot;The application did not call start_response()&quot;</span><span class="s1">)</span>
            <span class="s1">self._write_with_headers(data)</span>

    <span class="s3">def </span><span class="s1">_write_with_headers(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">self.headers_sent = </span><span class="s3">True</span>
        <span class="s1">self.finalize_headers()</span>

        <span class="s0"># self.response_headers and self.status are already in latin-1, as encoded by self.start_response</span>
        <span class="s1">towrite = bytearray(</span><span class="s6">b'HTTP/1.1 '</span><span class="s1">)</span>
        <span class="s1">towrite += self.status</span>
        <span class="s1">towrite += </span><span class="s6">b'</span><span class="s3">\r\n</span><span class="s6">'</span>
        <span class="s3">for </span><span class="s1">header</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self.response_headers:</span>
            <span class="s1">towrite += header</span>
            <span class="s1">towrite += </span><span class="s6">b': '</span>
            <span class="s1">towrite += value</span>
            <span class="s1">towrite += </span><span class="s6">b&quot;</span><span class="s3">\r\n</span><span class="s6">&quot;</span>

        <span class="s1">towrite += </span><span class="s6">b'</span><span class="s3">\r\n</span><span class="s6">'</span>
        <span class="s1">self._sendall(towrite)</span>
        <span class="s0"># No need to copy the data into towrite; we may make an extra syscall</span>
        <span class="s0"># but the copy time could be substantial too, and it reduces the chances</span>
        <span class="s0"># of sendall being able to send everything in one go</span>
        <span class="s1">self._write(data)</span>

    <span class="s3">def </span><span class="s1">start_response(self</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">exc_info=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
         .. versionchanged:: 1.2a1 
            Avoid HTTP header injection by raising a :exc:`ValueError` 
            if *status* or any *header* name or value contains a carriage 
            return or newline. 
         .. versionchanged:: 1.1b5 
            Pro-actively handle checking the encoding of the status line 
            and headers during this method. On Python 2, avoid some 
            extra encodings. 
        &quot;&quot;&quot;</span>
        <span class="s0"># pylint:disable=too-many-branches,too-many-statements</span>
        <span class="s3">if </span><span class="s1">exc_info:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">self.headers_sent:</span>
                    <span class="s0"># Re-raise original exception if headers sent</span>
                    <span class="s1">reraise(*exc_info)</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s0"># Avoid dangling circular ref</span>
                <span class="s1">exc_info = </span><span class="s3">None</span>

        <span class="s0"># Pep 3333, &quot;The start_response callable&quot;:</span>
        <span class="s0"># https://www.python.org/dev/peps/pep-3333/#the-start-response-callable</span>
        <span class="s0"># &quot;Servers should check for errors in the headers at the time</span>
        <span class="s0"># start_response is called, so that an error can be raised</span>
        <span class="s0"># while the application is still running.&quot; Here, we check the encoding.</span>
        <span class="s0"># This aids debugging: headers especially are generated programmatically</span>
        <span class="s0"># and an encoding error in a loop or list comprehension yields an opaque</span>
        <span class="s0"># UnicodeError without any clue which header was wrong.</span>
        <span class="s0"># Note that this results in copying the header list at this point, not modifying it,</span>
        <span class="s0"># although we are allowed to do so if needed. This slightly increases memory usage.</span>
        <span class="s0"># We also check for HTTP Response Splitting vulnerabilities</span>
        <span class="s1">response_headers = []</span>
        <span class="s1">header = </span><span class="s3">None</span>
        <span class="s1">value = </span><span class="s3">None</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">header</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">headers:</span>
                <span class="s3">if not </span><span class="s1">isinstance(header</span><span class="s3">, </span><span class="s1">str):</span>
                    <span class="s3">raise </span><span class="s1">UnicodeError(</span><span class="s4">&quot;The header must be a native string&quot;</span><span class="s3">, </span><span class="s1">header</span><span class="s3">, </span><span class="s1">value)</span>
                <span class="s3">if not </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">str):</span>
                    <span class="s3">raise </span><span class="s1">UnicodeError(</span><span class="s4">&quot;The value must be a native string&quot;</span><span class="s3">, </span><span class="s1">header</span><span class="s3">, </span><span class="s1">value)</span>
                <span class="s3">if </span><span class="s4">'</span><span class="s3">\r</span><span class="s4">' </span><span class="s3">in </span><span class="s1">header </span><span class="s3">or </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">' </span><span class="s3">in </span><span class="s1">header:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'carriage return or newline in header name'</span><span class="s3">, </span><span class="s1">header)</span>
                <span class="s3">if </span><span class="s4">'</span><span class="s3">\r</span><span class="s4">' </span><span class="s3">in </span><span class="s1">value </span><span class="s3">or </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">' </span><span class="s3">in </span><span class="s1">value:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'carriage return or newline in header value'</span><span class="s3">, </span><span class="s1">value)</span>
                <span class="s0"># Either we're on Python 2, in which case bytes is correct, or</span>
                <span class="s0"># we're on Python 3 and the user screwed up (because it should be a native</span>
                <span class="s0"># string). In either case, make sure that this is latin-1 compatible. Under</span>
                <span class="s0"># Python 2, bytes.encode() will take a round-trip through the system encoding,</span>
                <span class="s0"># which may be ascii, which is not really what we want. However, the latin-1 encoding</span>
                <span class="s0"># can encode everything except control characters and the block from 0x7F to 0x9F, so</span>
                <span class="s0"># explicitly round-tripping bytes through the encoding is unlikely to be of much</span>
                <span class="s0"># benefit, so we go for speed (the WSGI spec specifically calls out allowing the range</span>
                <span class="s0"># from 0x00 to 0xFF, although the HTTP spec forbids the control characters).</span>
                <span class="s0"># Note: Some Python 2 implementations, like Jython, may allow non-octet (above 255) values</span>
                <span class="s0"># in their str implementation; this is mentioned in the WSGI spec, but we don't</span>
                <span class="s0"># run on any platform like that so we can assume that a str value is pure bytes.</span>
                <span class="s1">response_headers.append((header </span><span class="s3">if not </span><span class="s1">PY3 </span><span class="s3">else </span><span class="s1">header.encode(</span><span class="s4">&quot;latin-1&quot;</span><span class="s1">)</span><span class="s3">,</span>
                                         <span class="s1">value </span><span class="s3">if not </span><span class="s1">PY3 </span><span class="s3">else </span><span class="s1">value.encode(</span><span class="s4">&quot;latin-1&quot;</span><span class="s1">)))</span>
        <span class="s3">except </span><span class="s1">UnicodeEncodeError:</span>
            <span class="s0"># If we get here, we're guaranteed to have a header and value</span>
            <span class="s3">raise </span><span class="s1">UnicodeError(</span><span class="s4">&quot;Non-latin1 header&quot;</span><span class="s3">, </span><span class="s1">repr(header)</span><span class="s3">, </span><span class="s1">repr(value))</span>

        <span class="s0"># Same as above</span>
        <span class="s3">if not </span><span class="s1">isinstance(status</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s3">raise </span><span class="s1">UnicodeError(</span><span class="s4">&quot;The status string must be a native string&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s4">'</span><span class="s3">\r</span><span class="s4">' </span><span class="s3">in </span><span class="s1">status </span><span class="s3">or </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">' </span><span class="s3">in </span><span class="s1">status:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;carriage return or newline in status&quot;</span><span class="s3">, </span><span class="s1">status)</span>
        <span class="s0"># don't assign to anything until the validation is complete, including parsing the</span>
        <span class="s0"># code</span>
        <span class="s1">code = int(status.split(</span><span class="s4">' '</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s1">self.status = status </span><span class="s3">if not </span><span class="s1">PY3 </span><span class="s3">else </span><span class="s1">status.encode(</span><span class="s4">&quot;latin-1&quot;</span><span class="s1">)</span>
        <span class="s1">self._orig_status = status </span><span class="s0"># Preserve the native string for logging</span>
        <span class="s1">self.response_headers = response_headers</span>
        <span class="s1">self.code = code</span>

        <span class="s1">provided_connection = </span><span class="s3">None </span><span class="s0"># Did the wsgi app give us a Connection header?</span>
        <span class="s1">self.provided_date = </span><span class="s3">None</span>
        <span class="s1">self.provided_content_length = </span><span class="s3">None</span>

        <span class="s3">for </span><span class="s1">header</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">headers:</span>
            <span class="s1">header = header.lower()</span>
            <span class="s3">if </span><span class="s1">header == </span><span class="s4">'connection'</span><span class="s1">:</span>
                <span class="s1">provided_connection = value</span>
            <span class="s3">elif </span><span class="s1">header == </span><span class="s4">'date'</span><span class="s1">:</span>
                <span class="s1">self.provided_date = value</span>
            <span class="s3">elif </span><span class="s1">header == </span><span class="s4">'content-length'</span><span class="s1">:</span>
                <span class="s1">self.provided_content_length = value</span>

        <span class="s3">if </span><span class="s1">self.request_version == </span><span class="s4">'HTTP/1.0' </span><span class="s3">and </span><span class="s1">provided_connection </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">conntype = </span><span class="s6">b'close' </span><span class="s3">if </span><span class="s1">self.close_connection </span><span class="s3">else </span><span class="s6">b'keep-alive'</span>
            <span class="s1">response_headers.append((</span><span class="s6">b'Connection'</span><span class="s3">, </span><span class="s1">conntype))</span>
        <span class="s3">elif </span><span class="s1">provided_connection == </span><span class="s4">'close'</span><span class="s1">:</span>
            <span class="s1">self.close_connection = </span><span class="s3">True</span>

        <span class="s3">if </span><span class="s1">self.code </span><span class="s3">in </span><span class="s1">(</span><span class="s5">304</span><span class="s3">, </span><span class="s5">204</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">self.provided_content_length </span><span class="s3">is not None and </span><span class="s1">self.provided_content_length != </span><span class="s4">'0'</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s4">'Invalid Content-Length for %s response: %r (must be absent or zero)' </span><span class="s1">% (self.code</span><span class="s3">, </span><span class="s1">self.provided_content_length)</span>
                <span class="s3">if </span><span class="s1">PY3:</span>
                    <span class="s1">msg = msg.encode(</span><span class="s4">'latin-1'</span><span class="s1">)</span>
                <span class="s3">raise </span><span class="s1">self.ApplicationError(msg)</span>

        <span class="s3">return </span><span class="s1">self.write</span>

    <span class="s3">def </span><span class="s1">log_request(self):</span>
        <span class="s1">self.server.log.write(self.format_request() + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">format_request(self):</span>
        <span class="s1">now = datetime.now().replace(microsecond=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">length = self.response_length </span><span class="s3">or </span><span class="s4">'-'</span>
        <span class="s3">if </span><span class="s1">self.time_finish:</span>
            <span class="s1">delta = </span><span class="s4">'%.6f' </span><span class="s1">% (self.time_finish - self.time_start)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">delta = </span><span class="s4">'-'</span>
        <span class="s1">client_address = self.client_address[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">if </span><span class="s1">isinstance(self.client_address</span><span class="s3">, </span><span class="s1">tuple) </span><span class="s3">else </span><span class="s1">self.client_address</span>
        <span class="s3">return </span><span class="s4">'%s - - [%s] &quot;%s&quot; %s %s %s' </span><span class="s1">% (</span>
            <span class="s1">client_address </span><span class="s3">or </span><span class="s4">'-'</span><span class="s3">,</span>
            <span class="s1">now</span><span class="s3">,</span>
            <span class="s1">self.requestline </span><span class="s3">or </span><span class="s4">''</span><span class="s3">,</span>
            <span class="s0"># Use the native string version of the status, saved so we don't have to</span>
            <span class="s0"># decode. But fallback to the encoded 'status' in case of subclasses</span>
            <span class="s0"># (Is that really necessary? At least there's no overhead.)</span>
            <span class="s1">(self._orig_status </span><span class="s3">or </span><span class="s1">self.status </span><span class="s3">or </span><span class="s4">'000'</span><span class="s1">).split()[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">length</span><span class="s3">,</span>
            <span class="s1">delta)</span>

    <span class="s3">def </span><span class="s1">process_result(self):</span>
        <span class="s3">for </span><span class="s1">data </span><span class="s3">in </span><span class="s1">self.result:</span>
            <span class="s3">if </span><span class="s1">data:</span>
                <span class="s1">self.write(data)</span>
        <span class="s3">if </span><span class="s1">self.status </span><span class="s3">and not </span><span class="s1">self.headers_sent:</span>
            <span class="s0"># In other words, the application returned an empty</span>
            <span class="s0"># result iterable (and did not use the write callable)</span>
            <span class="s0"># Trigger the flush of the headers.</span>
            <span class="s1">self.write(</span><span class="s6">b''</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.response_use_chunked:</span>
            <span class="s1">self._sendall(</span><span class="s6">b'0</span><span class="s3">\r\n\r\n</span><span class="s6">'</span><span class="s1">)</span>


    <span class="s3">def </span><span class="s1">run_application(self):</span>
        <span class="s3">assert </span><span class="s1">self.result </span><span class="s3">is None</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.result = self.application(self.environ</span><span class="s3">, </span><span class="s1">self.start_response)</span>
            <span class="s1">self.process_result()</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">close = getattr(self.result</span><span class="s3">, </span><span class="s4">'close'</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">close </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">close()</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s0"># Discard the result. If it's a generator this can</span>
                <span class="s0"># free a lot of hidden resources (if we failed to iterate</span>
                <span class="s0"># all the way through it---the frames are automatically</span>
                <span class="s0"># cleaned up when StopIteration is raised); but other cases</span>
                <span class="s0"># could still free up resources sooner than otherwise.</span>
                <span class="s1">close = </span><span class="s3">None</span>
                <span class="s1">self.result = </span><span class="s3">None</span>

    <span class="s0">#: These errors are silently ignored by :meth:`handle_one_response` to avoid producing</span>
    <span class="s0">#: excess log entries on normal operating conditions. They indicate</span>
    <span class="s0">#: a remote client has disconnected and there is little or nothing</span>
    <span class="s0">#: this process can be expected to do about it. You may change this</span>
    <span class="s0">#: value in a subclass.</span>
    <span class="s0">#:</span>
    <span class="s0">#: The default value includes :data:`errno.EPIPE` and :data:`errno.ECONNRESET`.</span>
    <span class="s0">#: On Windows this also includes :data:`errno.WSAECONNABORTED`.</span>
    <span class="s0">#:</span>
    <span class="s0">#: This is a provisional API, subject to change. See :pr:`377`, :pr:`999`</span>
    <span class="s0">#: and :issue:`136`.</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 1.3</span>
    <span class="s1">ignored_socket_errors = (errno.EPIPE</span><span class="s3">, </span><span class="s1">errno.ECONNRESET)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">ignored_socket_errors += (errno.WSAECONNABORTED</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s3">except </span><span class="s1">AttributeError:</span>
        <span class="s3">pass </span><span class="s0"># Not windows</span>

    <span class="s3">def </span><span class="s1">handle_one_response(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Invoke the application to produce one response. 
 
        This is called by :meth:`handle_one_request` after all the 
        state for the request has been established. It is responsible 
        for error handling. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.time_start = time.time()</span>
        <span class="s1">self.status = </span><span class="s3">None</span>
        <span class="s1">self.headers_sent = </span><span class="s3">False</span>

        <span class="s1">self.result = </span><span class="s3">None</span>
        <span class="s1">self.response_use_chunked = </span><span class="s3">False</span>
        <span class="s1">self.connection_upgraded = </span><span class="s3">False</span>
        <span class="s1">self.response_length = </span><span class="s5">0</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.run_application()</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">self.wsgi_input._discard()</span>
                <span class="s3">except </span><span class="s1">(socket.error</span><span class="s3">, </span><span class="s1">IOError):</span>
                    <span class="s0"># Don't let exceptions during discarding</span>
                    <span class="s0"># input override any exception that may have been</span>
                    <span class="s0"># raised by the application, such as our own _InvalidClientInput.</span>
                    <span class="s0"># In the general case, these aren't even worth logging (see the comment</span>
                    <span class="s0"># just below)</span>
                    <span class="s3">pass</span>
        <span class="s3">except </span><span class="s1">_InvalidClientInput:</span>
            <span class="s1">self._send_error_response_if_possible(</span><span class="s5">400</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">socket.error </span><span class="s3">as </span><span class="s1">ex:</span>
            <span class="s3">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">self.ignored_socket_errors:</span>
                <span class="s0"># See description of self.ignored_socket_errors.</span>
                <span class="s3">if not </span><span class="s1">PY3:</span>
                    <span class="s1">sys.exc_clear()</span>
                <span class="s1">self.close_connection = </span><span class="s3">True</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.handle_error(*sys.exc_info())</span>
        <span class="s3">except</span><span class="s1">: </span><span class="s0"># pylint:disable=bare-except</span>
            <span class="s1">self.handle_error(*sys.exc_info())</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">self.time_finish = time.time()</span>
            <span class="s1">self.log_request()</span>

    <span class="s3">def </span><span class="s1">_send_error_response_if_possible(self</span><span class="s3">, </span><span class="s1">error_code):</span>
        <span class="s3">if </span><span class="s1">self.response_length:</span>
            <span class="s1">self.close_connection = </span><span class="s3">True</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">status</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">body = _ERRORS[error_code]</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.start_response(status</span><span class="s3">, </span><span class="s1">headers[:])</span>
                <span class="s1">self.write(body)</span>
            <span class="s3">except </span><span class="s1">socket.error:</span>
                <span class="s3">if not </span><span class="s1">PY3:</span>
                    <span class="s1">sys.exc_clear()</span>
                <span class="s1">self.close_connection = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">_log_error(self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">tb):</span>
        <span class="s0"># TODO: Shouldn't we dump this to wsgi.errors? If we did that now, it would</span>
        <span class="s0"># wind up getting logged twice</span>
        <span class="s3">if not </span><span class="s1">issubclass(t</span><span class="s3">, </span><span class="s1">GreenletExit):</span>
            <span class="s1">context = self.environ</span>
            <span class="s3">if not </span><span class="s1">isinstance(context</span><span class="s3">, </span><span class="s1">self.server.secure_environ_class):</span>
                <span class="s1">context = self.server.secure_environ_class(context)</span>
            <span class="s1">self.server.loop.handle_error(context</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">tb)</span>

    <span class="s3">def </span><span class="s1">handle_error(self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">tb):</span>
        <span class="s0"># Called for internal, unexpected errors, NOT invalid client input</span>
        <span class="s1">self._log_error(t</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">tb)</span>
        <span class="s1">t = v = tb = </span><span class="s3">None</span>
        <span class="s1">self._send_error_response_if_possible(</span><span class="s5">500</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_handle_client_error(self</span><span class="s3">, </span><span class="s1">ex):</span>
        <span class="s0"># Called for invalid client input</span>
        <span class="s0"># Returns the appropriate error response.</span>
        <span class="s3">if not </span><span class="s1">isinstance(ex</span><span class="s3">, </span><span class="s1">ValueError):</span>
            <span class="s0"># XXX: Why not self._log_error to send it through the loop's</span>
            <span class="s0"># handle_error method?</span>
            <span class="s1">traceback.print_exc()</span>
        <span class="s3">if </span><span class="s1">isinstance(ex</span><span class="s3">, </span><span class="s1">_InvalidClientRequest):</span>
            <span class="s0"># No formatting needed, that's already been handled. In fact, because the</span>
            <span class="s0"># formatted message contains user input, it might have a % in it, and attempting</span>
            <span class="s0"># to format that with no arguments would be an error.</span>
            <span class="s1">self.log_error(ex.formatted_message)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.log_error(</span><span class="s4">'Invalid request: %s'</span><span class="s3">, </span><span class="s1">str(ex) </span><span class="s3">or </span><span class="s1">ex.__class__.__name__)</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s4">'400'</span><span class="s3">, </span><span class="s1">_BAD_REQUEST_RESPONSE)</span>

    <span class="s3">def </span><span class="s1">_headers(self):</span>
        <span class="s1">key = </span><span class="s3">None</span>
        <span class="s1">value = </span><span class="s3">None</span>
        <span class="s1">IGNORED_KEYS = (</span><span class="s3">None, </span><span class="s4">'CONTENT_TYPE'</span><span class="s3">, </span><span class="s4">'CONTENT_LENGTH'</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">header </span><span class="s3">in </span><span class="s1">self.headers.headers:</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">is not None and </span><span class="s1">header[:</span><span class="s5">1</span><span class="s1">] </span><span class="s3">in </span><span class="s4">&quot; </span><span class="s3">\t</span><span class="s4">&quot;</span><span class="s1">:</span>
                <span class="s1">value += header</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">key </span><span class="s3">not in </span><span class="s1">IGNORED_KEYS:</span>
                <span class="s3">yield </span><span class="s4">'HTTP_' </span><span class="s1">+ key</span><span class="s3">, </span><span class="s1">value.strip()</span>

            <span class="s1">key</span><span class="s3">, </span><span class="s1">value = header.split(</span><span class="s4">':'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s4">'_' </span><span class="s3">in </span><span class="s1">key:</span>
                <span class="s0"># strip incoming bad veaders</span>
                <span class="s1">key = </span><span class="s3">None</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">key = key.replace(</span><span class="s4">'-'</span><span class="s3">, </span><span class="s4">'_'</span><span class="s1">).upper()</span>

        <span class="s3">if </span><span class="s1">key </span><span class="s3">not in </span><span class="s1">IGNORED_KEYS:</span>
            <span class="s3">yield </span><span class="s4">'HTTP_' </span><span class="s1">+ key</span><span class="s3">, </span><span class="s1">value.strip()</span>

    <span class="s3">def </span><span class="s1">get_environ(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Construct and return a new WSGI environment dictionary for a specific request. 
 
        This should begin with asking the server for the base environment 
        using :meth:`WSGIServer.get_environ`, and then proceed to add the 
        request specific values. 
 
        By the time this method is invoked the request line and request shall have 
        been parsed and ``self.headers`` shall be populated. 
        &quot;&quot;&quot;</span>
        <span class="s1">env = self.server.get_environ()</span>
        <span class="s1">env[</span><span class="s4">'REQUEST_METHOD'</span><span class="s1">] = self.command</span>
        <span class="s0"># SCRIPT_NAME is explicitly implementation defined. Using an</span>
        <span class="s0"># empty value for SCRIPT_NAME is both explicitly allowed by</span>
        <span class="s0"># both the CGI standard and WSGI PEPs, and also the thing that</span>
        <span class="s0"># makes the most sense from a generic server perspective (we</span>
        <span class="s0"># have no hierarchy or understanding of URLs or files, just a</span>
        <span class="s0"># single application to call. The empty string represents the</span>
        <span class="s0"># application root, which is what we have). Different WSGI</span>
        <span class="s0"># implementations handle this very differently, so portable</span>
        <span class="s0"># applications that rely on SCRIPT_NAME will have to use a</span>
        <span class="s0"># WSGI middleware to set it to a defined value, or otherwise</span>
        <span class="s0"># rely on server-specific mechanisms (e.g, on waitress, use</span>
        <span class="s0"># ``--url-prefix``, in gunicorn set the ``SCRIPT_NAME`` header</span>
        <span class="s0"># or process environment variable, in gevent subclass</span>
        <span class="s0"># WSGIHandler.)</span>
        <span class="s0">#</span>
        <span class="s0"># See https://github.com/gevent/gevent/issues/1667 for discussion.</span>
        <span class="s1">env[</span><span class="s4">'SCRIPT_NAME'</span><span class="s1">] = </span><span class="s4">''</span>

        <span class="s1">path</span><span class="s3">, </span><span class="s1">query = self.path.split(</span><span class="s4">'?'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">) </span><span class="s3">if </span><span class="s4">'?' </span><span class="s3">in </span><span class="s1">self.path </span><span class="s3">else </span><span class="s1">(self.path</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
        <span class="s0"># Note that self.path contains the original str object; if it contains</span>
        <span class="s0"># encoded escapes, it will NOT match PATH_INFO.</span>
        <span class="s1">env[</span><span class="s4">'PATH_INFO'</span><span class="s1">] = unquote_latin1(path)</span>
        <span class="s1">env[</span><span class="s4">'QUERY_STRING'</span><span class="s1">] = query</span>

        <span class="s3">if </span><span class="s1">self.headers.typeheader </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">env[</span><span class="s4">'CONTENT_TYPE'</span><span class="s1">] = self.headers.typeheader</span>

        <span class="s1">length = self.headers.getheader(</span><span class="s4">'content-length'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">length:</span>
            <span class="s1">env[</span><span class="s4">'CONTENT_LENGTH'</span><span class="s1">] = length</span>
        <span class="s1">env[</span><span class="s4">'SERVER_PROTOCOL'</span><span class="s1">] = self.request_version</span>

        <span class="s1">client_address = self.client_address</span>
        <span class="s3">if </span><span class="s1">isinstance(client_address</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s1">env[</span><span class="s4">'REMOTE_ADDR'</span><span class="s1">] = str(client_address[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">env[</span><span class="s4">'REMOTE_PORT'</span><span class="s1">] = str(client_address[</span><span class="s5">1</span><span class="s1">])</span>

        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self._headers():</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">env:</span>
                <span class="s3">if </span><span class="s4">'COOKIE' </span><span class="s3">in </span><span class="s1">key:</span>
                    <span class="s1">env[key] += </span><span class="s4">'; ' </span><span class="s1">+ value</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">env[key] += </span><span class="s4">',' </span><span class="s1">+ value</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">env[key] = value</span>

        <span class="s1">sock = self.socket </span><span class="s3">if </span><span class="s1">env.get(</span><span class="s4">'HTTP_EXPECT'</span><span class="s1">) == </span><span class="s4">'100-continue' </span><span class="s3">else None</span>

        <span class="s1">chunked = env.get(</span><span class="s4">'HTTP_TRANSFER_ENCODING'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">).lower() == </span><span class="s4">'chunked'</span>
        <span class="s0"># Input refuses to read if the data isn't chunked, and there is no content_length</span>
        <span class="s0"># provided. For 'Upgrade: Websocket' requests, neither of those things is true.</span>
        <span class="s1">handling_reads = </span><span class="s3">not </span><span class="s1">self._connection_upgrade_requested()</span>

        <span class="s1">self.wsgi_input = Input(self.rfile</span><span class="s3">, </span><span class="s1">self.content_length</span><span class="s3">, </span><span class="s1">socket=sock</span><span class="s3">, </span><span class="s1">chunked_input=chunked)</span>

        <span class="s1">env[</span><span class="s4">'wsgi.input'</span><span class="s1">] = self.wsgi_input </span><span class="s3">if </span><span class="s1">handling_reads </span><span class="s3">else </span><span class="s1">self.rfile</span>
        <span class="s0"># This is a non-standard flag indicating that our input stream is</span>
        <span class="s0"># self-terminated (returns EOF when consumed).</span>
        <span class="s0"># See https://github.com/gevent/gevent/issues/1308</span>
        <span class="s1">env[</span><span class="s4">'wsgi.input_terminated'</span><span class="s1">] = handling_reads</span>
        <span class="s3">return </span><span class="s1">env</span>


<span class="s3">class </span><span class="s1">_NoopLog(object):</span>
    <span class="s0"># Does nothing; implements just enough file-like methods</span>
    <span class="s0"># to pass the WSGI validator</span>

    <span class="s3">def </span><span class="s1">write(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># pylint:disable=unused-argument</span>
        <span class="s3">return</span>

    <span class="s3">def </span><span class="s1">flush(self):</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">writelines(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">LoggingLogAdapter(object):</span>
    <span class="s2">&quot;&quot;&quot; 
    An adapter for :class:`logging.Logger` instances 
    to let them be used with :class:`WSGIServer`. 
 
    .. warning:: Unless the entire process is monkey-patched at a very 
        early part of the lifecycle (before logging is configured), 
        loggers are likely to not be gevent-cooperative. For example, 
        the socket and syslog handlers use the socket module in a way 
        that can block, and most handlers acquire threading locks. 
 
    .. warning:: It *may* be possible for the logging functions to be 
       called in the :class:`gevent.Hub` greenlet. Code running in the 
       hub greenlet cannot use any gevent blocking functions without triggering 
       a ``LoopExit``. 
 
    .. versionadded:: 1.1a3 
 
    .. versionchanged:: 1.1b6 
       Attributes not present on this object are proxied to the underlying 
       logger instance. This permits using custom :class:`~logging.Logger` 
       subclasses (or indeed, even duck-typed objects). 
 
    .. versionchanged:: 1.1 
       Strip trailing newline characters on the message passed to :meth:`write` 
       because log handlers will usually add one themselves. 
    &quot;&quot;&quot;</span>

    <span class="s0"># gevent avoids importing and using logging because importing it and</span>
    <span class="s0"># creating loggers creates native locks unless monkey-patched.</span>

    <span class="s1">__slots__ = (</span><span class="s4">'_logger'</span><span class="s3">, </span><span class="s4">'_level'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">logger</span><span class="s3">, </span><span class="s1">level=</span><span class="s5">20</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Write information to the *logger* at the given *level* (default to INFO). 
        &quot;&quot;&quot;</span>
        <span class="s1">self._logger = logger</span>
        <span class="s1">self._level = level</span>

    <span class="s3">def </span><span class="s1">write(self</span><span class="s3">, </span><span class="s1">msg):</span>
        <span class="s3">if </span><span class="s1">msg </span><span class="s3">and </span><span class="s1">msg.endswith(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">):</span>
            <span class="s1">msg = msg[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">self._logger.log(self._level</span><span class="s3">, </span><span class="s1">msg)</span>

    <span class="s3">def </span><span class="s1">flush(self):</span>
        <span class="s2">&quot;No-op; required to be a file-like object&quot;</span>

    <span class="s3">def </span><span class="s1">writelines(self</span><span class="s3">, </span><span class="s1">lines):</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">lines:</span>
            <span class="s1">self.write(line)</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">return </span><span class="s1">getattr(self._logger</span><span class="s3">, </span><span class="s1">name)</span>

    <span class="s3">def </span><span class="s1">__setattr__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">LoggingLogAdapter.__slots__:</span>
            <span class="s1">setattr(self._logger</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">object.__setattr__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value)</span>

    <span class="s3">def </span><span class="s1">__delattr__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s1">delattr(self._logger</span><span class="s3">, </span><span class="s1">name)</span>

<span class="s0">####</span>
<span class="s0">## Environ classes.</span>
<span class="s0"># These subclass dict. They could subclass collections.UserDict on</span>
<span class="s0"># 3.3+ and proxy to the underlying real dict to avoid a copy if we</span>
<span class="s0"># have to print them (on 2.7 it's slightly more complicated to be an</span>
<span class="s0"># instance of collections.MutableMapping; UserDict.UserDict isn't.)</span>
<span class="s0"># Then we could have either the WSGIHandler.get_environ or the</span>
<span class="s0"># WSGIServer.get_environ return one of these proxies, and</span>
<span class="s0"># WSGIHandler.run_application would know to access the `environ.data`</span>
<span class="s0"># attribute to be able to pass the *real* dict to the application</span>
<span class="s0"># (because PEP3333 requires no subclasses, only actual dict objects;</span>
<span class="s0"># wsgiref.validator and webob.Request both enforce this). This has the</span>
<span class="s0"># advantage of not being fragile if anybody else tries to print/log</span>
<span class="s0"># self.environ (and not requiring a copy). However, if there are any</span>
<span class="s0"># subclasses of Handler or Server, this could break if they don't know</span>
<span class="s0"># to return this type.</span>
<span class="s0">####</span>

<span class="s3">class </span><span class="s1">Environ(dict):</span>
    <span class="s2">&quot;&quot;&quot; 
    A base class that can be used for WSGI environment objects. 
 
    Provisional API. 
 
    .. versionadded:: 1.2a1 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = () </span><span class="s0"># add no ivars or weakref ability</span>

    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s3">return </span><span class="s1">self.__class__(self)</span>

    <span class="s3">if not </span><span class="s1">hasattr(dict</span><span class="s3">, </span><span class="s4">'iteritems'</span><span class="s1">):</span>
        <span class="s0"># Python 3</span>
        <span class="s3">def </span><span class="s1">iteritems(self):</span>
            <span class="s3">return </span><span class="s1">self.items()</span>

    <span class="s3">def </span><span class="s1">__reduce_ex__(self</span><span class="s3">, </span><span class="s1">proto):</span>
        <span class="s3">return </span><span class="s1">(dict</span><span class="s3">, </span><span class="s1">()</span><span class="s3">, None, None, </span><span class="s1">iter(self.iteritems()))</span>

<span class="s3">class </span><span class="s1">SecureEnviron(Environ):</span>
    <span class="s2">&quot;&quot;&quot; 
    An environment that does not print its keys and values 
    by default. 
 
    Provisional API. 
 
    This is intended to keep potentially sensitive information like 
    HTTP authorization and cookies from being inadvertently printed 
    or logged. 
 
    For debugging, each instance can have its *secure_repr* attribute 
    set to ``False``, which will cause it to print like a normal dict. 
 
    When *secure_repr* is ``True`` (the default), then the value of 
    the *whitelist_keys* attribute is consulted; if this value is 
    true-ish, it should be a container (something that responds to 
    ``in``) of key names (typically a list or set). Keys and values in 
    this dictionary that are in *whitelist_keys* will then be printed, 
    while all other values will be masked. These values may be 
    customized on the class by setting the *default_secure_repr* and 
    *default_whitelist_keys*, respectively:: 
 
        &gt;&gt;&gt; environ = SecureEnviron(key='value') 
        &gt;&gt;&gt; environ # doctest: +ELLIPSIS 
        &lt;pywsgi.SecureEnviron dict (keys: 1) at ... 
 
    If we whitelist the key, it gets printed:: 
 
        &gt;&gt;&gt; environ.whitelist_keys = {'key'} 
        &gt;&gt;&gt; environ 
        {'key': 'value'} 
 
    A non-whitelisted key (*only*, to avoid doctest issues) is masked:: 
 
        &gt;&gt;&gt; environ['secure'] = 'secret'; del environ['key'] 
        &gt;&gt;&gt; environ 
        {'secure': '&lt;MASKED&gt;'} 
 
    We can turn it off entirely for the instance:: 
 
        &gt;&gt;&gt; environ.secure_repr = False 
        &gt;&gt;&gt; environ 
        {'secure': 'secret'} 
 
    We can also customize it at the class level (here we use a new 
    class to be explicit and to avoid polluting the true default 
    values; we would set this class to be the ``environ_class`` of the 
    server):: 
 
        &gt;&gt;&gt; class MyEnviron(SecureEnviron): 
        ...    default_whitelist_keys = ('key',) 
        ... 
        &gt;&gt;&gt; environ = MyEnviron({'key': 'value'}) 
        &gt;&gt;&gt; environ 
        {'key': 'value'} 
 
    .. versionadded:: 1.2a1 
    &quot;&quot;&quot;</span>

    <span class="s1">default_secure_repr = </span><span class="s3">True</span>
    <span class="s1">default_whitelist_keys = ()</span>
    <span class="s1">default_print_masked_keys = </span><span class="s3">True</span>

    <span class="s0"># Allow instances to override the class values,</span>
    <span class="s0"># but inherit from the class if not present. Keeps instances</span>
    <span class="s0"># small since we can't combine __slots__ with class attributes</span>
    <span class="s0"># of the same name.</span>
    <span class="s1">__slots__ = (</span><span class="s4">'secure_repr'</span><span class="s3">, </span><span class="s4">'whitelist_keys'</span><span class="s3">, </span><span class="s4">'print_masked_keys'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">SecureEnviron.__slots__:</span>
            <span class="s3">return </span><span class="s1">getattr(type(self)</span><span class="s3">, </span><span class="s4">'default_' </span><span class="s1">+ name)</span>
        <span class="s3">raise </span><span class="s1">AttributeError(name)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">if </span><span class="s1">self.secure_repr:</span>
            <span class="s1">whitelist = self.whitelist_keys</span>
            <span class="s1">print_masked = self.print_masked_keys</span>
            <span class="s3">if </span><span class="s1">whitelist:</span>
                <span class="s1">safe = {k: self[k] </span><span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">whitelist </span><span class="s3">else </span><span class="s4">&quot;&lt;MASKED&gt;&quot;</span>
                        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">self</span>
                        <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">whitelist </span><span class="s3">or </span><span class="s1">print_masked}</span>
                <span class="s1">safe_repr = repr(safe)</span>
                <span class="s3">if not </span><span class="s1">print_masked </span><span class="s3">and </span><span class="s1">len(safe) != len(self):</span>
                    <span class="s1">safe_repr = safe_repr[:-</span><span class="s5">1</span><span class="s1">] + </span><span class="s4">&quot;, (hidden keys: %d)}&quot; </span><span class="s1">% (len(self) - len(safe))</span>
                <span class="s3">return </span><span class="s1">safe_repr</span>
            <span class="s3">return </span><span class="s4">&quot;&lt;pywsgi.SecureEnviron dict (keys: %d) at %s&gt;&quot; </span><span class="s1">% (len(self)</span><span class="s3">, </span><span class="s1">id(self))</span>
        <span class="s3">return </span><span class="s1">Environ.__repr__(self)</span>
    <span class="s1">__str__ = __repr__</span>


<span class="s3">class </span><span class="s1">WSGISecureEnviron(SecureEnviron):</span>
    <span class="s2">&quot;&quot;&quot; 
    Specializes the default list of whitelisted keys to a few 
    common WSGI variables. 
 
    Example:: 
 
       &gt;&gt;&gt; environ = WSGISecureEnviron(REMOTE_ADDR='::1', HTTP_AUTHORIZATION='secret') 
       &gt;&gt;&gt; environ 
       {'REMOTE_ADDR': '::1', (hidden keys: 1)} 
       &gt;&gt;&gt; import pprint 
       &gt;&gt;&gt; pprint.pprint(environ) 
       {'REMOTE_ADDR': '::1', (hidden keys: 1)} 
       &gt;&gt;&gt; print(pprint.pformat(environ)) 
       {'REMOTE_ADDR': '::1', (hidden keys: 1)} 
    &quot;&quot;&quot;</span>
    <span class="s1">default_whitelist_keys = (</span><span class="s4">'REMOTE_ADDR'</span><span class="s3">, </span><span class="s4">'REMOTE_PORT'</span><span class="s3">, </span><span class="s4">'HTTP_HOST'</span><span class="s1">)</span>
    <span class="s1">default_print_masked_keys = </span><span class="s3">False</span>


<span class="s3">class </span><span class="s1">WSGIServer(StreamServer):</span>
    <span class="s2">&quot;&quot;&quot; 
    A WSGI server based on :class:`StreamServer` that supports HTTPS. 
 
 
    :keyword log: If given, an object with a ``write`` method to which 
        request (access) logs will be written. If not given, defaults 
        to :obj:`sys.stderr`. You may pass ``None`` to disable request 
        logging. You may use a wrapper, around e.g., :mod:`logging`, 
        to support objects that don't implement a ``write`` method. 
        (If you pass a :class:`~logging.Logger` instance, or in 
        general something that provides a ``log`` method but not a 
        ``write`` method, such a wrapper will automatically be created 
        and it will be logged to at the :data:`~logging.INFO` level.) 
 
    :keyword error_log: If given, a file-like object with ``write``, 
        ``writelines`` and ``flush`` methods to which error logs will 
        be written. If not given, defaults to :obj:`sys.stderr`. You 
        may pass ``None`` to disable error logging (not recommended). 
        You may use a wrapper, around e.g., :mod:`logging`, to support 
        objects that don't implement the proper methods. This 
        parameter will become the value for ``wsgi.errors`` in the 
        WSGI environment (if not already set). (As with *log*, 
        wrappers for :class:`~logging.Logger` instances and the like 
        will be created automatically and logged to at the :data:`~logging.ERROR` 
        level.) 
 
    .. seealso:: 
 
        :class:`LoggingLogAdapter` 
            See important warnings before attempting to use :mod:`logging`. 
 
    .. versionchanged:: 1.1a3 
        Added the ``error_log`` parameter, and set ``wsgi.errors`` in the WSGI 
        environment to this value. 
    .. versionchanged:: 1.1a3 
        Add support for passing :class:`logging.Logger` objects to the ``log`` and 
        ``error_log`` arguments. 
    .. versionchanged:: 20.6.0 
        Passing a ``handle`` kwarg to the constructor is now officially deprecated. 
    &quot;&quot;&quot;</span>

    <span class="s0">#: A callable taking three arguments: (socket, address, server) and returning</span>
    <span class="s0">#: an object with a ``handle()`` method. The callable is called once for</span>
    <span class="s0">#: each incoming socket request, as is its handle method. The handle method should not</span>
    <span class="s0">#: return until all use of the socket is complete.</span>
    <span class="s0">#:</span>
    <span class="s0">#: This class uses the :class:`WSGIHandler` object as the default value. You may</span>
    <span class="s0">#: subclass this class and set a different default value, or you may pass</span>
    <span class="s0">#: a value to use in the ``handler_class`` keyword constructor argument.</span>
    <span class="s1">handler_class = WSGIHandler</span>

    <span class="s0">#: The object to which request logs will be written.</span>
    <span class="s0">#: It must never be None. Initialized from the ``log`` constructor</span>
    <span class="s0">#: parameter.</span>
    <span class="s1">log = </span><span class="s3">None</span>

    <span class="s0">#: The object to which error logs will be written.</span>
    <span class="s0">#: It must never be None. Initialized from the ``error_log`` constructor</span>
    <span class="s0">#: parameter.</span>
    <span class="s1">error_log = </span><span class="s3">None</span>

    <span class="s0">#: The class of environ objects passed to the handlers.</span>
    <span class="s0">#: Must be a dict subclass. For compliance with :pep:`3333`</span>
    <span class="s0">#: and libraries like WebOb, this is simply :class:`dict`</span>
    <span class="s0">#: but this can be customized in a subclass or per-instance</span>
    <span class="s0">#: (probably to :class:`WSGISecureEnviron`).</span>
    <span class="s0">#:</span>
    <span class="s0">#: .. versionadded:: 1.2a1</span>
    <span class="s1">environ_class = dict</span>

    <span class="s0"># Undocumented internal detail: the class that WSGIHandler._log_error</span>
    <span class="s0"># will cast to before passing to the loop.</span>
    <span class="s1">secure_environ_class = WSGISecureEnviron</span>

    <span class="s1">base_env = {</span><span class="s4">'GATEWAY_INTERFACE'</span><span class="s1">: </span><span class="s4">'CGI/1.1'</span><span class="s3">,</span>
                <span class="s4">'SERVER_SOFTWARE'</span><span class="s1">: </span><span class="s4">'gevent/%d.%d Python/%d.%d' </span><span class="s1">% (gevent.version_info[:</span><span class="s5">2</span><span class="s1">] + sys.version_info[:</span><span class="s5">2</span><span class="s1">])</span><span class="s3">,</span>
                <span class="s4">'SCRIPT_NAME'</span><span class="s1">: </span><span class="s4">''</span><span class="s3">,</span>
                <span class="s4">'wsgi.version'</span><span class="s1">: (</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s4">'wsgi.multithread'</span><span class="s1">: </span><span class="s3">False, </span><span class="s0"># XXX: Aren't we really, though?</span>
                <span class="s4">'wsgi.multiprocess'</span><span class="s1">: </span><span class="s3">False,</span>
                <span class="s4">'wsgi.run_once'</span><span class="s1">: </span><span class="s3">False</span><span class="s1">}</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">listener</span><span class="s3">, </span><span class="s1">application=</span><span class="s3">None, </span><span class="s1">backlog=</span><span class="s3">None, </span><span class="s1">spawn=</span><span class="s4">'default'</span><span class="s3">,</span>
                 <span class="s1">log=</span><span class="s4">'default'</span><span class="s3">, </span><span class="s1">error_log=</span><span class="s4">'default'</span><span class="s3">,</span>
                 <span class="s1">handler_class=</span><span class="s3">None,</span>
                 <span class="s1">environ=</span><span class="s3">None, </span><span class="s1">**ssl_args):</span>
        <span class="s3">if </span><span class="s4">'handle' </span><span class="s3">in </span><span class="s1">ssl_args:</span>
            <span class="s0"># The ultimate base class (BaseServer) uses 'handle' for</span>
            <span class="s0"># the thing we call 'application'. We never deliberately</span>
            <span class="s0"># bass a `handle` argument to the base class, but one</span>
            <span class="s0"># could sneak in through ``**ssl_args``, even though that</span>
            <span class="s0"># is not the intent, while application is None. That</span>
            <span class="s0"># causes our own ``def handle`` method to be replaced,</span>
            <span class="s0"># probably leading to bad results. Passing a 'handle'</span>
            <span class="s0"># instead of an 'application' can really confuse things.</span>
            <span class="s3">import </span><span class="s1">warnings</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;Passing 'handle' kwarg to WSGIServer is deprecated. &quot;</span>
                          <span class="s4">&quot;Did you mean application?&quot;</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>

        <span class="s1">StreamServer.__init__(self</span><span class="s3">, </span><span class="s1">listener</span><span class="s3">, </span><span class="s1">backlog=backlog</span><span class="s3">, </span><span class="s1">spawn=spawn</span><span class="s3">, </span><span class="s1">**ssl_args)</span>

        <span class="s3">if </span><span class="s1">application </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.application = application</span>
        <span class="s3">if </span><span class="s1">handler_class </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.handler_class = handler_class</span>

        <span class="s0"># Note that we can't initialize these as class variables:</span>
        <span class="s0"># sys.stderr might get monkey patched at runtime.</span>
        <span class="s3">def </span><span class="s1">_make_log(l</span><span class="s3">, </span><span class="s1">level=</span><span class="s5">20</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">l == </span><span class="s4">'default'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">sys.stderr</span>
            <span class="s3">if </span><span class="s1">l </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">_NoopLog()</span>
            <span class="s3">if not </span><span class="s1">hasattr(l</span><span class="s3">, </span><span class="s4">'write'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">hasattr(l</span><span class="s3">, </span><span class="s4">'log'</span><span class="s1">):</span>
                <span class="s3">return </span><span class="s1">LoggingLogAdapter(l</span><span class="s3">, </span><span class="s1">level)</span>
            <span class="s3">return </span><span class="s1">l</span>
        <span class="s1">self.log = _make_log(log)</span>
        <span class="s1">self.error_log = _make_log(error_log</span><span class="s3">, </span><span class="s5">40</span><span class="s1">) </span><span class="s0"># logging.ERROR</span>

        <span class="s1">self.set_environ(environ)</span>
        <span class="s1">self.set_max_accept()</span>

    <span class="s3">def </span><span class="s1">set_environ(self</span><span class="s3">, </span><span class="s1">environ=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">environ </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.environ = environ</span>
        <span class="s1">environ_update = getattr(self</span><span class="s3">, </span><span class="s4">'environ'</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">self.environ = self.environ_class(self.base_env)</span>
        <span class="s3">if </span><span class="s1">self.ssl_enabled:</span>
            <span class="s1">self.environ[</span><span class="s4">'wsgi.url_scheme'</span><span class="s1">] = </span><span class="s4">'https'</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.environ[</span><span class="s4">'wsgi.url_scheme'</span><span class="s1">] = </span><span class="s4">'http'</span>
        <span class="s3">if </span><span class="s1">environ_update </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.environ.update(environ_update)</span>
        <span class="s3">if </span><span class="s1">self.environ.get(</span><span class="s4">'wsgi.errors'</span><span class="s1">) </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.environ[</span><span class="s4">'wsgi.errors'</span><span class="s1">] = self.error_log</span>

    <span class="s3">def </span><span class="s1">set_max_accept(self):</span>
        <span class="s3">if </span><span class="s1">self.environ.get(</span><span class="s4">'wsgi.multiprocess'</span><span class="s1">):</span>
            <span class="s1">self.max_accept = </span><span class="s5">1</span>

    <span class="s3">def </span><span class="s1">get_environ(self):</span>
        <span class="s3">return </span><span class="s1">self.environ_class(self.environ)</span>

    <span class="s3">def </span><span class="s1">init_socket(self):</span>
        <span class="s1">StreamServer.init_socket(self)</span>
        <span class="s1">self.update_environ()</span>

    <span class="s3">def </span><span class="s1">update_environ(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Called before the first request is handled to fill in WSGI environment values. 
 
        This includes getting the correct server name and port. 
        &quot;&quot;&quot;</span>
        <span class="s1">address = self.address</span>
        <span class="s3">if </span><span class="s1">isinstance(address</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s3">if </span><span class="s4">'SERVER_NAME' </span><span class="s3">not in </span><span class="s1">self.environ:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">name = socket.getfqdn(address[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s3">except </span><span class="s1">socket.error:</span>
                    <span class="s1">name = str(address[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s3">if </span><span class="s1">PY3 </span><span class="s3">and not </span><span class="s1">isinstance(name</span><span class="s3">, </span><span class="s1">str):</span>
                    <span class="s1">name = name.decode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
                <span class="s1">self.environ[</span><span class="s4">'SERVER_NAME'</span><span class="s1">] = name</span>
            <span class="s1">self.environ.setdefault(</span><span class="s4">'SERVER_PORT'</span><span class="s3">, </span><span class="s1">str(address[</span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.environ.setdefault(</span><span class="s4">'SERVER_NAME'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
            <span class="s1">self.environ.setdefault(</span><span class="s4">'SERVER_PORT'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">handle(self</span><span class="s3">, </span><span class="s1">sock</span><span class="s3">, </span><span class="s1">address):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create an instance of :attr:`handler_class` to handle the request. 
 
        This method blocks until the handler returns. 
        &quot;&quot;&quot;</span>
        <span class="s0"># pylint:disable=method-hidden</span>
        <span class="s1">handler = self.handler_class(sock</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s1">handler.handle()</span>

<span class="s3">def </span><span class="s1">_main():</span>
    <span class="s0"># Provisional main handler, for quick tests, not production</span>
    <span class="s0"># usage.</span>
    <span class="s3">from </span><span class="s1">gevent </span><span class="s3">import </span><span class="s1">monkey; monkey.patch_all()</span>

    <span class="s3">import </span><span class="s1">argparse</span>
    <span class="s3">import </span><span class="s1">importlib</span>

    <span class="s1">parser = argparse.ArgumentParser()</span>
    <span class="s1">parser.add_argument(</span><span class="s4">&quot;app&quot;</span><span class="s3">, </span><span class="s1">help=</span><span class="s4">&quot;dotted name of WSGI app callable [module:callable]&quot;</span><span class="s1">)</span>
    <span class="s1">parser.add_argument(</span><span class="s4">&quot;-b&quot;</span><span class="s3">, </span><span class="s4">&quot;--bind&quot;</span><span class="s3">,</span>
                        <span class="s1">help=</span><span class="s4">&quot;The socket to bind&quot;</span><span class="s3">,</span>
                        <span class="s1">default=</span><span class="s4">&quot;:8080&quot;</span><span class="s1">)</span>

    <span class="s1">args = parser.parse_args()</span>

    <span class="s1">module_name</span><span class="s3">, </span><span class="s1">app_name = args.app.split(</span><span class="s4">':'</span><span class="s1">)</span>
    <span class="s1">module = importlib.import_module(module_name)</span>
    <span class="s1">app = getattr(module</span><span class="s3">, </span><span class="s1">app_name)</span>
    <span class="s1">bind = args.bind</span>

    <span class="s1">server = WSGIServer(bind</span><span class="s3">, </span><span class="s1">app)</span>
    <span class="s1">server.serve_forever()</span>

<span class="s3">if </span><span class="s1">__name__ == </span><span class="s4">'__main__'</span><span class="s1">:</span>
    <span class="s1">_main()</span>
</pre>
</body>
</html>