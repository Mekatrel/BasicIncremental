<html>
<head>
<title>ro.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ro.py</font>
</center></td></tr></table>
<pre><span class="s0">##############################################################################</span>
<span class="s0">#</span>
<span class="s0"># Copyright (c) 2003 Zope Foundation and Contributors.</span>
<span class="s0"># All Rights Reserved.</span>
<span class="s0">#</span>
<span class="s0"># This software is subject to the provisions of the Zope Public License,</span>
<span class="s0"># Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY AND ALL EXPRESS OR IMPLIED</span>
<span class="s0"># WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="s0"># WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS</span>
<span class="s0"># FOR A PARTICULAR PURPOSE.</span>
<span class="s0">#</span>
<span class="s0">##############################################################################</span>
<span class="s2">&quot;&quot;&quot; 
Compute a resolution order for an object and its bases. 
 
.. versionchanged:: 5.0 
   The resolution order is now based on the same C3 order that Python 
   uses for classes. In complex instances of multiple inheritance, this 
   may result in a different ordering. 
 
   In older versions, the ordering wasn't required to be C3 compliant, 
   and for backwards compatibility, it still isn't. If the ordering 
   isn't C3 compliant (if it is *inconsistent*), zope.interface will 
   make a best guess to try to produce a reasonable resolution order. 
   Still (just as before), the results in such cases may be 
   surprising. 
 
.. rubric:: Environment Variables 
 
Due to the change in 5.0, certain environment variables can be used to control errors 
and warnings about inconsistent resolution orders. They are listed in priority order, with 
variables at the bottom generally overriding variables above them. 
 
ZOPE_INTERFACE_WARN_BAD_IRO 
    If this is set to &quot;1&quot;, then if there is at least one inconsistent resolution 
    order discovered, a warning (:class:`InconsistentResolutionOrderWarning`) will 
    be issued. Use the usual warning mechanisms to control this behaviour. The warning 
    text will contain additional information on debugging. 
ZOPE_INTERFACE_TRACK_BAD_IRO 
    If this is set to &quot;1&quot;, then zope.interface will log information about each 
    inconsistent resolution order discovered, and keep those details in memory in this module 
    for later inspection. 
ZOPE_INTERFACE_STRICT_IRO 
    If this is set to &quot;1&quot;, any attempt to use :func:`ro` that would produce a non-C3 
    ordering will fail by raising :class:`InconsistentResolutionOrderError`. 
 
.. important:: 
 
   ``ZOPE_INTERFACE_STRICT_IRO`` is intended to become the default in the future. 
 
There are two environment variables that are independent. 
 
ZOPE_INTERFACE_LOG_CHANGED_IRO 
    If this is set to &quot;1&quot;, then if the C3 resolution order is different from 
    the legacy resolution order for any given object, a message explaining the differences 
    will be logged. This is intended to be used for debugging complicated IROs. 
ZOPE_INTERFACE_USE_LEGACY_IRO 
    If this is set to &quot;1&quot;, then the C3 resolution order will *not* be used. The 
    legacy IRO will be used instead. This is a temporary measure and will be removed in the 
    future. It is intended to help during the transition. 
    It implies ``ZOPE_INTERFACE_LOG_CHANGED_IRO``. 
 
.. rubric:: Debugging Behaviour Changes in zope.interface 5 
 
Most behaviour changes from zope.interface 4 to 5 are related to 
inconsistent resolution orders. ``ZOPE_INTERFACE_STRICT_IRO`` is the 
most effective tool to find such inconsistent resolution orders, and 
we recommend running your code with this variable set if at all 
possible. Doing so will ensure that all interface resolution orders 
are consistent, and if they're not, will immediately point the way to 
where this is violated. 
 
Occasionally, however, this may not be enough. This is because in some 
cases, a C3 ordering can be found (the resolution order is fully 
consistent) that is substantially different from the ad-hoc legacy 
ordering. In such cases, you may find that you get an unexpected value 
returned when adapting one or more objects to an interface. To debug 
this, *also* enable ``ZOPE_INTERFACE_LOG_CHANGED_IRO`` and examine the 
output. The main thing to look for is changes in the relative 
positions of interfaces for which there are registered adapters. 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">print_function</span>
<span class="s1">__docformat__ = </span><span class="s4">'restructuredtext'</span>

<span class="s1">__all__ = [</span>
    <span class="s4">'ro'</span><span class="s3">,</span>
    <span class="s4">'InconsistentResolutionOrderError'</span><span class="s3">,</span>
    <span class="s4">'InconsistentResolutionOrderWarning'</span><span class="s3">,</span>
<span class="s1">]</span>

<span class="s1">__logger = </span><span class="s3">None</span>

<span class="s3">def </span><span class="s1">_logger():</span>
    <span class="s3">global </span><span class="s1">__logger </span><span class="s0"># pylint:disable=global-statement</span>
    <span class="s3">if </span><span class="s1">__logger </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">import </span><span class="s1">logging</span>
        <span class="s1">__logger = logging.getLogger(__name__)</span>
    <span class="s3">return </span><span class="s1">__logger</span>

<span class="s3">def </span><span class="s1">_legacy_mergeOrderings(orderings):</span>
    <span class="s2">&quot;&quot;&quot;Merge multiple orderings so that within-ordering order is preserved 
 
    Orderings are constrained in such a way that if an object appears 
    in two or more orderings, then the suffix that begins with the 
    object must be in both orderings. 
 
    For example: 
 
    &gt;&gt;&gt; _mergeOrderings([ 
    ... ['x', 'y', 'z'], 
    ... ['q', 'z'], 
    ... [1, 3, 5], 
    ... ['z'] 
    ... ]) 
    ['x', 'y', 'q', 1, 3, 5, 'z'] 
 
    &quot;&quot;&quot;</span>

    <span class="s1">seen = set()</span>
    <span class="s1">result = []</span>
    <span class="s3">for </span><span class="s1">ordering </span><span class="s3">in </span><span class="s1">reversed(orderings):</span>
        <span class="s3">for </span><span class="s1">o </span><span class="s3">in </span><span class="s1">reversed(ordering):</span>
            <span class="s3">if </span><span class="s1">o </span><span class="s3">not in </span><span class="s1">seen:</span>
                <span class="s1">seen.add(o)</span>
                <span class="s1">result.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">o)</span>

    <span class="s3">return </span><span class="s1">result</span>

<span class="s3">def </span><span class="s1">_legacy_flatten(begin):</span>
    <span class="s1">result = [begin]</span>
    <span class="s1">i = </span><span class="s5">0</span>
    <span class="s3">for </span><span class="s1">ob </span><span class="s3">in </span><span class="s1">iter(result):</span>
        <span class="s1">i += </span><span class="s5">1</span>
        <span class="s0"># The recursive calls can be avoided by inserting the base classes</span>
        <span class="s0"># into the dynamically growing list directly after the currently</span>
        <span class="s0"># considered object;  the iterator makes sure this will keep working</span>
        <span class="s0"># in the future, since it cannot rely on the length of the list</span>
        <span class="s0"># by definition.</span>
        <span class="s1">result[i:i] = ob.__bases__</span>
    <span class="s3">return </span><span class="s1">result</span>

<span class="s3">def </span><span class="s1">_legacy_ro(ob):</span>
    <span class="s3">return </span><span class="s1">_legacy_mergeOrderings([_legacy_flatten(ob)])</span>

<span class="s0">###</span>
<span class="s0"># Compare base objects using identity, not equality. This matches what</span>
<span class="s0"># the CPython MRO algorithm does, and is *much* faster to boot: that,</span>
<span class="s0"># plus some other small tweaks makes the difference between 25s and 6s</span>
<span class="s0"># in loading 446 plone/zope interface.py modules (1925 InterfaceClass,</span>
<span class="s0"># 1200 Implements, 1100 ClassProvides objects)</span>
<span class="s0">###</span>


<span class="s3">class </span><span class="s1">InconsistentResolutionOrderWarning(PendingDeprecationWarning):</span>
    <span class="s2">&quot;&quot;&quot; 
    The warning issued when an invalid IRO is requested. 
    &quot;&quot;&quot;</span>

<span class="s3">class </span><span class="s1">InconsistentResolutionOrderError(TypeError):</span>
    <span class="s2">&quot;&quot;&quot; 
    The error raised when an invalid IRO is requested in strict mode. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">c3</span><span class="s3">, </span><span class="s1">base_tree_remaining):</span>
        <span class="s1">self.C = c3.leaf</span>
        <span class="s1">base_tree = c3.base_tree</span>
        <span class="s1">self.base_ros = {</span>
            <span class="s1">base: base_tree[i + </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">base </span><span class="s3">in </span><span class="s1">enumerate(self.C.__bases__)</span>
        <span class="s1">}</span>
        <span class="s0"># Unfortunately, this doesn't necessarily directly match</span>
        <span class="s0"># up to any transformation on C.__bases__, because</span>
        <span class="s0"># if any were fully used up, they were removed already.</span>
        <span class="s1">self.base_tree_remaining = base_tree_remaining</span>

        <span class="s1">TypeError.__init__(self)</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">import </span><span class="s1">pprint</span>
        <span class="s3">return </span><span class="s4">&quot;%s: For object %r.</span><span class="s3">\n</span><span class="s4">Base ROs:</span><span class="s3">\n</span><span class="s4">%s</span><span class="s3">\n</span><span class="s4">Conflict Location:</span><span class="s3">\n</span><span class="s4">%s&quot; </span><span class="s1">% (</span>
            <span class="s1">self.__class__.__name__</span><span class="s3">,</span>
            <span class="s1">self.C</span><span class="s3">,</span>
            <span class="s1">pprint.pformat(self.base_ros)</span><span class="s3">,</span>
            <span class="s1">pprint.pformat(self.base_tree_remaining)</span><span class="s3">,</span>
        <span class="s1">)</span>


<span class="s3">class </span><span class="s1">_NamedBool(int): </span><span class="s0"># cannot actually inherit bool</span>

    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s1">inst = super(cls</span><span class="s3">, </span><span class="s1">_NamedBool).__new__(cls</span><span class="s3">, </span><span class="s1">val)</span>
        <span class="s1">inst.__name__ = name</span>
        <span class="s3">return </span><span class="s1">inst</span>


<span class="s3">class </span><span class="s1">_ClassBoolFromEnv(object):</span>
    <span class="s2">&quot;&quot;&quot; 
    Non-data descriptor that reads a transformed environment variable 
    as a boolean, and caches the result in the class. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__get__(self</span><span class="s3">, </span><span class="s1">inst</span><span class="s3">, </span><span class="s1">klass):</span>
        <span class="s3">import </span><span class="s1">os</span>
        <span class="s3">for </span><span class="s1">cls </span><span class="s3">in </span><span class="s1">klass.__mro__:</span>
            <span class="s1">my_name = </span><span class="s3">None</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">dir(klass):</span>
                <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">cls.__dict__ </span><span class="s3">and </span><span class="s1">cls.__dict__[k] </span><span class="s3">is </span><span class="s1">self:</span>
                    <span class="s1">my_name = k</span>
                    <span class="s3">break</span>
            <span class="s3">if </span><span class="s1">my_name </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">break</span>
        <span class="s3">else</span><span class="s1">: </span><span class="s0"># pragma: no cover</span>
            <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;Unable to find self&quot;</span><span class="s1">)</span>

        <span class="s1">env_name = </span><span class="s4">'ZOPE_INTERFACE_' </span><span class="s1">+ my_name</span>
        <span class="s1">val = os.environ.get(env_name</span><span class="s3">, </span><span class="s4">''</span><span class="s1">) == </span><span class="s4">'1'</span>
        <span class="s1">val = _NamedBool(val</span><span class="s3">, </span><span class="s1">my_name)</span>
        <span class="s1">setattr(klass</span><span class="s3">, </span><span class="s1">my_name</span><span class="s3">, </span><span class="s1">val)</span>
        <span class="s1">setattr(klass</span><span class="s3">, </span><span class="s4">'ORIG_' </span><span class="s1">+ my_name</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s3">return </span><span class="s1">val</span>


<span class="s3">class </span><span class="s1">_StaticMRO(object):</span>
    <span class="s0"># A previously resolved MRO, supplied by the caller.</span>
    <span class="s0"># Used in place of calculating it.</span>

    <span class="s1">had_inconsistency = </span><span class="s3">None </span><span class="s0"># We don't know...</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">C</span><span class="s3">, </span><span class="s1">mro):</span>
        <span class="s1">self.leaf = C</span>
        <span class="s1">self.__mro = tuple(mro)</span>

    <span class="s3">def </span><span class="s1">mro(self):</span>
        <span class="s3">return </span><span class="s1">list(self.__mro)</span>


<span class="s3">class </span><span class="s1">C3(object):</span>
    <span class="s0"># Holds the shared state during computation of an MRO.</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">resolver(C</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">, </span><span class="s1">base_mros):</span>
        <span class="s1">strict = strict </span><span class="s3">if </span><span class="s1">strict </span><span class="s3">is not None else </span><span class="s1">C3.STRICT_IRO</span>
        <span class="s1">factory = C3</span>
        <span class="s3">if </span><span class="s1">strict:</span>
            <span class="s1">factory = _StrictC3</span>
        <span class="s3">elif </span><span class="s1">C3.TRACK_BAD_IRO:</span>
            <span class="s1">factory = _TrackingC3</span>

        <span class="s1">memo = {}</span>
        <span class="s1">base_mros = base_mros </span><span class="s3">or </span><span class="s1">{}</span>
        <span class="s3">for </span><span class="s1">base</span><span class="s3">, </span><span class="s1">mro </span><span class="s3">in </span><span class="s1">base_mros.items():</span>
            <span class="s3">assert </span><span class="s1">base </span><span class="s3">in </span><span class="s1">C.__bases__</span>
            <span class="s1">memo[base] = _StaticMRO(base</span><span class="s3">, </span><span class="s1">mro)</span>

        <span class="s3">return </span><span class="s1">factory(C</span><span class="s3">, </span><span class="s1">memo)</span>

    <span class="s1">__mro = </span><span class="s3">None</span>
    <span class="s1">__legacy_ro = </span><span class="s3">None</span>
    <span class="s1">direct_inconsistency = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">C</span><span class="s3">, </span><span class="s1">memo):</span>
        <span class="s1">self.leaf = C</span>
        <span class="s1">self.memo = memo</span>
        <span class="s1">kind = self.__class__</span>

        <span class="s1">base_resolvers = []</span>
        <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">C.__bases__:</span>
            <span class="s3">if </span><span class="s1">base </span><span class="s3">not in </span><span class="s1">memo:</span>
                <span class="s1">resolver = kind(base</span><span class="s3">, </span><span class="s1">memo)</span>
                <span class="s1">memo[base] = resolver</span>
            <span class="s1">base_resolvers.append(memo[base])</span>

        <span class="s1">self.base_tree = [</span>
            <span class="s1">[C]</span>
        <span class="s1">] + [</span>
            <span class="s1">memo[base].mro() </span><span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">C.__bases__</span>
        <span class="s1">] + [</span>
            <span class="s1">list(C.__bases__)</span>
        <span class="s1">]</span>

        <span class="s1">self.bases_had_inconsistency = any(base.had_inconsistency </span><span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">base_resolvers)</span>

        <span class="s3">if </span><span class="s1">len(C.__bases__) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self.__mro = [C] + memo[C.__bases__[</span><span class="s5">0</span><span class="s1">]].mro()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">had_inconsistency(self):</span>
        <span class="s3">return </span><span class="s1">self.direct_inconsistency </span><span class="s3">or </span><span class="s1">self.bases_had_inconsistency</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">legacy_ro(self):</span>
        <span class="s3">if </span><span class="s1">self.__legacy_ro </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.__legacy_ro = tuple(_legacy_ro(self.leaf))</span>
        <span class="s3">return </span><span class="s1">list(self.__legacy_ro)</span>

    <span class="s1">TRACK_BAD_IRO = _ClassBoolFromEnv()</span>
    <span class="s1">STRICT_IRO = _ClassBoolFromEnv()</span>
    <span class="s1">WARN_BAD_IRO = _ClassBoolFromEnv()</span>
    <span class="s1">LOG_CHANGED_IRO = _ClassBoolFromEnv()</span>
    <span class="s1">USE_LEGACY_IRO = _ClassBoolFromEnv()</span>
    <span class="s1">BAD_IROS = ()</span>

    <span class="s3">def </span><span class="s1">_warn_iro(self):</span>
        <span class="s3">if not </span><span class="s1">self.WARN_BAD_IRO:</span>
            <span class="s0"># For the initial release, one must opt-in to see the warning.</span>
            <span class="s0"># In the future (2021?) seeing at least the first warning will</span>
            <span class="s0"># be the default</span>
            <span class="s3">return</span>
        <span class="s3">import </span><span class="s1">warnings</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;An inconsistent resolution order is being requested. &quot;</span>
            <span class="s4">&quot;(Interfaces should follow the Python class rules known as C3.) &quot;</span>
            <span class="s4">&quot;For backwards compatibility, zope.interface will allow this, &quot;</span>
            <span class="s4">&quot;making the best guess it can to produce as meaningful an order as possible. &quot;</span>
            <span class="s4">&quot;In the future this might be an error. Set the warning filter to error, or set &quot;</span>
            <span class="s4">&quot;the environment variable 'ZOPE_INTERFACE_TRACK_BAD_IRO' to '1' and examine &quot;</span>
            <span class="s4">&quot;ro.C3.BAD_IROS to debug, or set 'ZOPE_INTERFACE_STRICT_IRO' to raise exceptions.&quot;</span><span class="s3">,</span>
            <span class="s1">InconsistentResolutionOrderWarning</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">_can_choose_base(base</span><span class="s3">, </span><span class="s1">base_tree_remaining):</span>
        <span class="s0"># From C3:</span>
        <span class="s0"># nothead = [s for s in nonemptyseqs if cand in s[1:]]</span>
        <span class="s3">for </span><span class="s1">bases </span><span class="s3">in </span><span class="s1">base_tree_remaining:</span>
            <span class="s3">if not </span><span class="s1">bases </span><span class="s3">or </span><span class="s1">bases[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">is </span><span class="s1">base:</span>
                <span class="s3">continue</span>

            <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">bases:</span>
                <span class="s3">if </span><span class="s1">b </span><span class="s3">is </span><span class="s1">base:</span>
                    <span class="s3">return False</span>
        <span class="s3">return True</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">_nonempty_bases_ignoring(base_tree</span><span class="s3">, </span><span class="s1">ignoring):</span>
        <span class="s3">return </span><span class="s1">list(filter(</span><span class="s3">None, </span><span class="s1">[</span>
            <span class="s1">[b </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">bases </span><span class="s3">if </span><span class="s1">b </span><span class="s3">is not </span><span class="s1">ignoring]</span>
            <span class="s3">for </span><span class="s1">bases</span>
            <span class="s3">in </span><span class="s1">base_tree</span>
        <span class="s1">]))</span>

    <span class="s3">def </span><span class="s1">_choose_next_base(self</span><span class="s3">, </span><span class="s1">base_tree_remaining):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the next base. 
 
        The return value will either fit the C3 constraints or be our best 
        guess about what to do. If we cannot guess, this may raise an exception. 
        &quot;&quot;&quot;</span>
        <span class="s1">base = self._find_next_C3_base(base_tree_remaining)</span>
        <span class="s3">if </span><span class="s1">base </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">base</span>
        <span class="s3">return </span><span class="s1">self._guess_next_base(base_tree_remaining)</span>

    <span class="s3">def </span><span class="s1">_find_next_C3_base(self</span><span class="s3">, </span><span class="s1">base_tree_remaining):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the next base that fits the constraints, or ``None`` if there isn't one. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">bases </span><span class="s3">in </span><span class="s1">base_tree_remaining:</span>
            <span class="s1">base = bases[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">self._can_choose_base(base</span><span class="s3">, </span><span class="s1">base_tree_remaining):</span>
                <span class="s3">return </span><span class="s1">base</span>
        <span class="s3">return None</span>

    <span class="s3">class </span><span class="s1">_UseLegacyRO(Exception):</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">_guess_next_base(self</span><span class="s3">, </span><span class="s1">base_tree_remaining):</span>
        <span class="s0"># Narf. We may have an inconsistent order (we won't know for</span>
        <span class="s0"># sure until we check all the bases). Python cannot create</span>
        <span class="s0"># classes like this:</span>
        <span class="s0">#</span>
        <span class="s0"># class B1:</span>
        <span class="s0">#   pass</span>
        <span class="s0"># class B2(B1):</span>
        <span class="s0">#   pass</span>
        <span class="s0"># class C(B1, B2): # -&gt; TypeError; this is like saying C(B1, B2, B1).</span>
        <span class="s0">#  pass</span>
        <span class="s0">#</span>
        <span class="s0"># However, older versions of zope.interface were fine with this order.</span>
        <span class="s0"># A good example is ``providedBy(IOError())``. Because of the way</span>
        <span class="s0"># ``classImplements`` works, it winds up with ``__bases__`` ==</span>
        <span class="s0"># ``[IEnvironmentError, IIOError, IOSError, &lt;implementedBy Exception&gt;]``</span>
        <span class="s0"># (on Python 3). But ``IEnvironmentError`` is a base of both ``IIOError``</span>
        <span class="s0"># and ``IOSError``. Previously, we would get a resolution order of</span>
        <span class="s0"># ``[IIOError, IOSError, IEnvironmentError, IStandardError, IException, Interface]``</span>
        <span class="s0"># but the standard Python algorithm would forbid creating that order entirely.</span>

        <span class="s0"># Unlike Python's MRO, we attempt to resolve the issue. A few</span>
        <span class="s0"># heuristics have been tried. One was:</span>
        <span class="s0">#</span>
        <span class="s0"># Strip off the first (highest priority) base of each direct</span>
        <span class="s0"># base one at a time and seeing if we can come to an agreement</span>
        <span class="s0"># with the other bases. (We're trying for a partial ordering</span>
        <span class="s0"># here.) This often resolves cases (such as the IOSError case</span>
        <span class="s0"># above), and frequently produces the same ordering as the</span>
        <span class="s0"># legacy MRO did. If we looked at all the highest priority</span>
        <span class="s0"># bases and couldn't find any partial ordering, then we strip</span>
        <span class="s0"># them *all* out and begin the C3 step again. We take care not</span>
        <span class="s0"># to promote a common root over all others.</span>
        <span class="s0">#</span>
        <span class="s0"># If we only did the first part, stripped off the first</span>
        <span class="s0"># element of the first item, we could resolve simple cases.</span>
        <span class="s0"># But it tended to fail badly. If we did the whole thing, it</span>
        <span class="s0"># could be extremely painful from a performance perspective</span>
        <span class="s0"># for deep/wide things like Zope's OFS.SimpleItem.Item. Plus,</span>
        <span class="s0"># anytime you get ExtensionClass.Base into the mix, you're</span>
        <span class="s0"># likely to wind up in trouble, because it messes with the MRO</span>
        <span class="s0"># of classes. Sigh.</span>
        <span class="s0">#</span>
        <span class="s0"># So now, we fall back to the old linearization (fast to compute).</span>
        <span class="s1">self._warn_iro()</span>
        <span class="s1">self.direct_inconsistency = InconsistentResolutionOrderError(self</span><span class="s3">, </span><span class="s1">base_tree_remaining)</span>
        <span class="s3">raise </span><span class="s1">self._UseLegacyRO</span>

    <span class="s3">def </span><span class="s1">_merge(self):</span>
        <span class="s0"># Returns a merged *list*.</span>
        <span class="s1">result = self.__mro = []</span>
        <span class="s1">base_tree_remaining = self.base_tree</span>
        <span class="s1">base = </span><span class="s3">None</span>
        <span class="s3">while </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0"># Take last picked base out of the base tree wherever it is.</span>
            <span class="s0"># This differs slightly from the standard Python MRO and is needed</span>
            <span class="s0"># because we have no other step that prevents duplicates</span>
            <span class="s0"># from coming in (e.g., in the inconsistent fallback path)</span>
            <span class="s1">base_tree_remaining = self._nonempty_bases_ignoring(base_tree_remaining</span><span class="s3">, </span><span class="s1">base)</span>

            <span class="s3">if not </span><span class="s1">base_tree_remaining:</span>
                <span class="s3">return </span><span class="s1">result</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">base = self._choose_next_base(base_tree_remaining)</span>
            <span class="s3">except </span><span class="s1">self._UseLegacyRO:</span>
                <span class="s1">self.__mro = self.legacy_ro</span>
                <span class="s3">return </span><span class="s1">self.legacy_ro</span>

            <span class="s1">result.append(base)</span>

    <span class="s3">def </span><span class="s1">mro(self):</span>
        <span class="s3">if </span><span class="s1">self.__mro </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.__mro = tuple(self._merge())</span>
        <span class="s3">return </span><span class="s1">list(self.__mro)</span>


<span class="s3">class </span><span class="s1">_StrictC3(C3):</span>
    <span class="s1">__slots__ = ()</span>
    <span class="s3">def </span><span class="s1">_guess_next_base(self</span><span class="s3">, </span><span class="s1">base_tree_remaining):</span>
        <span class="s3">raise </span><span class="s1">InconsistentResolutionOrderError(self</span><span class="s3">, </span><span class="s1">base_tree_remaining)</span>


<span class="s3">class </span><span class="s1">_TrackingC3(C3):</span>
    <span class="s1">__slots__ = ()</span>
    <span class="s3">def </span><span class="s1">_guess_next_base(self</span><span class="s3">, </span><span class="s1">base_tree_remaining):</span>
        <span class="s3">import </span><span class="s1">traceback</span>
        <span class="s1">bad_iros = C3.BAD_IROS</span>
        <span class="s3">if </span><span class="s1">self.leaf </span><span class="s3">not in </span><span class="s1">bad_iros:</span>
            <span class="s3">if </span><span class="s1">bad_iros == ():</span>
                <span class="s3">import </span><span class="s1">weakref</span>
                <span class="s0"># This is a race condition, but it doesn't matter much.</span>
                <span class="s1">bad_iros = C3.BAD_IROS = weakref.WeakKeyDictionary()</span>
            <span class="s1">bad_iros[self.leaf] = t = (</span>
                <span class="s1">InconsistentResolutionOrderError(self</span><span class="s3">, </span><span class="s1">base_tree_remaining)</span><span class="s3">,</span>
                <span class="s1">traceback.format_stack()</span>
            <span class="s1">)</span>
            <span class="s1">_logger().warning(</span><span class="s4">&quot;Tracking inconsistent IRO: %s&quot;</span><span class="s3">, </span><span class="s1">t[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s3">return </span><span class="s1">C3._guess_next_base(self</span><span class="s3">, </span><span class="s1">base_tree_remaining)</span>


<span class="s3">class </span><span class="s1">_ROComparison(object):</span>
    <span class="s0"># Exists to compute and print a pretty string comparison</span>
    <span class="s0"># for differing ROs.</span>
    <span class="s0"># Since we're used in a logging context, and may actually never be printed,</span>
    <span class="s0"># this is a class so we can defer computing the diff until asked.</span>

    <span class="s0"># Components we use to build up the comparison report</span>
    <span class="s3">class </span><span class="s1">Item(object):</span>
        <span class="s1">prefix = </span><span class="s4">'  '</span>
        <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">item):</span>
            <span class="s1">self.item = item</span>
        <span class="s3">def </span><span class="s1">__str__(self):</span>
            <span class="s3">return </span><span class="s4">&quot;%s%s&quot; </span><span class="s1">% (</span>
                <span class="s1">self.prefix</span><span class="s3">,</span>
                <span class="s1">self.item</span><span class="s3">,</span>
            <span class="s1">)</span>

    <span class="s3">class </span><span class="s1">Deleted(Item):</span>
        <span class="s1">prefix = </span><span class="s4">'- '</span>

    <span class="s3">class </span><span class="s1">Inserted(Item):</span>
        <span class="s1">prefix = </span><span class="s4">'+ '</span>

    <span class="s1">Empty = str</span>

    <span class="s3">class </span><span class="s1">ReplacedBy(object): </span><span class="s0"># pragma: no cover</span>
        <span class="s1">prefix = </span><span class="s4">'- '</span>
        <span class="s1">suffix = </span><span class="s4">''</span>
        <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">total_count):</span>
            <span class="s1">self.chunk = chunk</span>
            <span class="s1">self.total_count = total_count</span>

        <span class="s3">def </span><span class="s1">__iter__(self):</span>
            <span class="s1">lines = [</span>
                <span class="s1">self.prefix + str(item) + self.suffix</span>
                <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">self.chunk</span>
            <span class="s1">]</span>
            <span class="s3">while </span><span class="s1">len(lines) &lt; self.total_count:</span>
                <span class="s1">lines.append(</span><span class="s4">''</span><span class="s1">)</span>

            <span class="s3">return </span><span class="s1">iter(lines)</span>

    <span class="s3">class </span><span class="s1">Replacing(ReplacedBy):</span>
        <span class="s1">prefix = </span><span class="s4">&quot;+ &quot;</span>
        <span class="s1">suffix = </span><span class="s4">''</span>


    <span class="s1">_c3_report = </span><span class="s3">None</span>
    <span class="s1">_legacy_report = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">c3</span><span class="s3">, </span><span class="s1">c3_ro</span><span class="s3">, </span><span class="s1">legacy_ro):</span>
        <span class="s1">self.c3 = c3</span>
        <span class="s1">self.c3_ro = c3_ro</span>
        <span class="s1">self.legacy_ro = legacy_ro</span>

    <span class="s3">def </span><span class="s1">__move(self</span><span class="s3">, </span><span class="s1">from_</span><span class="s3">, </span><span class="s1">to_</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">operation):</span>
        <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">chunk:</span>
            <span class="s1">to_.append(operation(x))</span>
            <span class="s1">from_.append(self.Empty())</span>

    <span class="s3">def </span><span class="s1">_generate_report(self):</span>
        <span class="s3">if </span><span class="s1">self._c3_report </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">import </span><span class="s1">difflib</span>
            <span class="s0"># The opcodes we get describe how to turn 'a' into 'b'. So</span>
            <span class="s0"># the old one (legacy) needs to be first ('a')</span>
            <span class="s1">matcher = difflib.SequenceMatcher(</span><span class="s3">None, </span><span class="s1">self.legacy_ro</span><span class="s3">, </span><span class="s1">self.c3_ro)</span>
            <span class="s0"># The reports are equal length sequences. We're going for a</span>
            <span class="s0"># side-by-side diff.</span>
            <span class="s1">self._c3_report = c3_report = []</span>
            <span class="s1">self._legacy_report = legacy_report = []</span>
            <span class="s3">for </span><span class="s1">opcode</span><span class="s3">, </span><span class="s1">leg1</span><span class="s3">, </span><span class="s1">leg2</span><span class="s3">, </span><span class="s1">c31</span><span class="s3">, </span><span class="s1">c32 </span><span class="s3">in </span><span class="s1">matcher.get_opcodes():</span>
                <span class="s1">c3_chunk = self.c3_ro[c31:c32]</span>
                <span class="s1">legacy_chunk = self.legacy_ro[leg1:leg2]</span>

                <span class="s3">if </span><span class="s1">opcode == </span><span class="s4">'equal'</span><span class="s1">:</span>
                    <span class="s0"># Guaranteed same length</span>
                    <span class="s1">c3_report.extend((self.Item(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">c3_chunk))</span>
                    <span class="s1">legacy_report.extend(self.Item(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">legacy_chunk)</span>
                <span class="s3">if </span><span class="s1">opcode == </span><span class="s4">'delete'</span><span class="s1">:</span>
                    <span class="s0"># Guaranteed same length</span>
                    <span class="s3">assert not </span><span class="s1">c3_chunk</span>
                    <span class="s1">self.__move(c3_report</span><span class="s3">, </span><span class="s1">legacy_report</span><span class="s3">, </span><span class="s1">legacy_chunk</span><span class="s3">, </span><span class="s1">self.Deleted)</span>
                <span class="s3">if </span><span class="s1">opcode == </span><span class="s4">'insert'</span><span class="s1">:</span>
                    <span class="s0"># Guaranteed same length</span>
                    <span class="s3">assert not </span><span class="s1">legacy_chunk</span>
                    <span class="s1">self.__move(legacy_report</span><span class="s3">, </span><span class="s1">c3_report</span><span class="s3">, </span><span class="s1">c3_chunk</span><span class="s3">, </span><span class="s1">self.Inserted)</span>
                <span class="s3">if </span><span class="s1">opcode == </span><span class="s4">'replace'</span><span class="s1">: </span><span class="s0"># pragma: no cover (How do you make it output this?)</span>
                    <span class="s0"># Either side could be longer.</span>
                    <span class="s1">chunk_size = max(len(c3_chunk)</span><span class="s3">, </span><span class="s1">len(legacy_chunk))</span>
                    <span class="s1">c3_report.extend(self.Replacing(c3_chunk</span><span class="s3">, </span><span class="s1">chunk_size))</span>
                    <span class="s1">legacy_report.extend(self.ReplacedBy(legacy_chunk</span><span class="s3">, </span><span class="s1">chunk_size))</span>

        <span class="s3">return </span><span class="s1">self._c3_report</span><span class="s3">, </span><span class="s1">self._legacy_report</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_inconsistent_label(self):</span>
        <span class="s1">inconsistent = []</span>
        <span class="s3">if </span><span class="s1">self.c3.direct_inconsistency:</span>
            <span class="s1">inconsistent.append(</span><span class="s4">'direct'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.c3.bases_had_inconsistency:</span>
            <span class="s1">inconsistent.append(</span><span class="s4">'bases'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s4">'+'</span><span class="s1">.join(inconsistent) </span><span class="s3">if </span><span class="s1">inconsistent </span><span class="s3">else </span><span class="s4">'no'</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s1">c3_report</span><span class="s3">, </span><span class="s1">legacy_report = self._generate_report()</span>
        <span class="s3">assert </span><span class="s1">len(c3_report) == len(legacy_report)</span>

        <span class="s1">left_lines = [str(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">legacy_report]</span>
        <span class="s1">right_lines = [str(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">c3_report]</span>

        <span class="s0"># We have the same number of lines in the report; this is not</span>
        <span class="s0"># necessarily the same as the number of items in either RO.</span>
        <span class="s3">assert </span><span class="s1">len(left_lines) == len(right_lines)</span>

        <span class="s1">padding = </span><span class="s4">' ' </span><span class="s1">* </span><span class="s5">2</span>
        <span class="s1">max_left = max(len(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">left_lines)</span>
        <span class="s1">max_right = max(len(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">right_lines)</span>

        <span class="s1">left_title = </span><span class="s4">'Legacy RO (len=%s)' </span><span class="s1">% (len(self.legacy_ro)</span><span class="s3">,</span><span class="s1">)</span>

        <span class="s1">right_title = </span><span class="s4">'C3 RO (len=%s; inconsistent=%s)' </span><span class="s1">% (</span>
            <span class="s1">len(self.c3_ro)</span><span class="s3">,</span>
            <span class="s1">self._inconsistent_label</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">lines = [</span>
            <span class="s1">(padding + left_title.ljust(max_left) + padding + right_title.ljust(max_right))</span><span class="s3">,</span>
            <span class="s1">padding + </span><span class="s4">'=' </span><span class="s1">* (max_left + len(padding) + max_right)</span>
        <span class="s1">]</span>
        <span class="s1">lines += [</span>
            <span class="s1">padding + left.ljust(max_left) + padding + right</span>
            <span class="s3">for </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right </span><span class="s3">in </span><span class="s1">zip(left_lines</span><span class="s3">, </span><span class="s1">right_lines)</span>
        <span class="s1">]</span>

        <span class="s3">return </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">.join(lines)</span>


<span class="s0"># Set to `Interface` once it is defined. This is used to</span>
<span class="s0"># avoid logging false positives about changed ROs.</span>
<span class="s1">_ROOT = </span><span class="s3">None</span>

<span class="s3">def </span><span class="s1">ro(C</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">None, </span><span class="s1">base_mros=</span><span class="s3">None, </span><span class="s1">log_changed_ro=</span><span class="s3">None, </span><span class="s1">use_legacy_ro=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    ro(C) -&gt; list 
 
    Compute the precedence list (mro) according to C3. 
 
    :return: A fresh `list` object. 
 
    .. versionchanged:: 5.0.0 
       Add the *strict*, *log_changed_ro* and *use_legacy_ro* 
       keyword arguments. These are provisional and likely to be 
       removed in the future. They are most useful for testing. 
    &quot;&quot;&quot;</span>
    <span class="s0"># The ``base_mros`` argument is for internal optimization and</span>
    <span class="s0"># not documented.</span>
    <span class="s1">resolver = C3.resolver(C</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">, </span><span class="s1">base_mros)</span>
    <span class="s1">mro = resolver.mro()</span>

    <span class="s1">log_changed = log_changed_ro </span><span class="s3">if </span><span class="s1">log_changed_ro </span><span class="s3">is not None else </span><span class="s1">resolver.LOG_CHANGED_IRO</span>
    <span class="s1">use_legacy = use_legacy_ro </span><span class="s3">if </span><span class="s1">use_legacy_ro </span><span class="s3">is not None else </span><span class="s1">resolver.USE_LEGACY_IRO</span>

    <span class="s3">if </span><span class="s1">log_changed </span><span class="s3">or </span><span class="s1">use_legacy:</span>
        <span class="s1">legacy_ro = resolver.legacy_ro</span>
        <span class="s3">assert </span><span class="s1">isinstance(legacy_ro</span><span class="s3">, </span><span class="s1">list)</span>
        <span class="s3">assert </span><span class="s1">isinstance(mro</span><span class="s3">, </span><span class="s1">list)</span>
        <span class="s1">changed = legacy_ro != mro</span>
        <span class="s3">if </span><span class="s1">changed:</span>
            <span class="s0"># Did only Interface move? The fix for issue #8 made that</span>
            <span class="s0"># somewhat common. It's almost certainly not a problem, though,</span>
            <span class="s0"># so allow ignoring it.</span>
            <span class="s1">legacy_without_root = [x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">legacy_ro </span><span class="s3">if </span><span class="s1">x </span><span class="s3">is not </span><span class="s1">_ROOT]</span>
            <span class="s1">mro_without_root = [x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">mro </span><span class="s3">if </span><span class="s1">x </span><span class="s3">is not </span><span class="s1">_ROOT]</span>
            <span class="s1">changed = legacy_without_root != mro_without_root</span>

        <span class="s3">if </span><span class="s1">changed:</span>
            <span class="s1">comparison = _ROComparison(resolver</span><span class="s3">, </span><span class="s1">mro</span><span class="s3">, </span><span class="s1">legacy_ro)</span>
            <span class="s1">_logger().warning(</span>
                <span class="s4">&quot;Object %r has different legacy and C3 MROs:</span><span class="s3">\n</span><span class="s4">%s&quot;</span><span class="s3">,</span>
                <span class="s1">C</span><span class="s3">, </span><span class="s1">comparison</span>
            <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">resolver.had_inconsistency </span><span class="s3">and </span><span class="s1">legacy_ro == mro:</span>
            <span class="s1">comparison = _ROComparison(resolver</span><span class="s3">, </span><span class="s1">mro</span><span class="s3">, </span><span class="s1">legacy_ro)</span>
            <span class="s1">_logger().warning(</span>
                <span class="s4">&quot;Object %r had inconsistent IRO and used the legacy RO:</span><span class="s3">\n</span><span class="s4">%s&quot;</span>
                <span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">Inconsistency entered at:</span><span class="s3">\n</span><span class="s4">%s&quot;</span><span class="s3">,</span>
                <span class="s1">C</span><span class="s3">, </span><span class="s1">comparison</span><span class="s3">, </span><span class="s1">resolver.direct_inconsistency</span>
            <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">use_legacy:</span>
            <span class="s3">return </span><span class="s1">legacy_ro</span>

    <span class="s3">return </span><span class="s1">mro</span>


<span class="s3">def </span><span class="s1">is_consistent(C):</span>
    <span class="s2">&quot;&quot;&quot; 
    Check if the resolution order for *C*, as computed by :func:`ro`, is consistent 
    according to C3. 
    &quot;&quot;&quot;</span>
    <span class="s3">return not </span><span class="s1">C3.resolver(C</span><span class="s3">, False, None</span><span class="s1">).had_inconsistency</span>
</pre>
</body>
</html>