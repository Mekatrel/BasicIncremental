<html>
<head>
<title>test__socket_dns.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test__socket_dns.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/python</span>
<span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">print_function</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">absolute_import</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">division</span>
<span class="s2">import </span><span class="s1">gevent</span>
<span class="s2">from </span><span class="s1">gevent </span><span class="s2">import </span><span class="s1">monkey</span>

<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>

<span class="s2">import </span><span class="s1">unittest</span>
<span class="s2">import </span><span class="s1">socket</span>
<span class="s2">from </span><span class="s1">time </span><span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">traceback</span>

<span class="s2">import </span><span class="s1">gevent.socket </span><span class="s2">as </span><span class="s1">gevent_socket</span>
<span class="s2">import </span><span class="s1">gevent.testing </span><span class="s2">as </span><span class="s1">greentest</span>

<span class="s2">from </span><span class="s1">gevent.testing </span><span class="s2">import </span><span class="s1">util</span>
<span class="s2">from </span><span class="s1">gevent.testing.six </span><span class="s2">import </span><span class="s1">xrange</span>
<span class="s2">from </span><span class="s1">gevent.testing </span><span class="s2">import </span><span class="s1">flaky</span>
<span class="s2">from </span><span class="s1">gevent.testing.skipping </span><span class="s2">import </span><span class="s1">skipWithoutExternalNetwork</span>


<span class="s1">resolver = gevent.get_hub().resolver</span>
<span class="s1">util.debug(</span><span class="s3">'Resolver: %s'</span><span class="s2">, </span><span class="s1">resolver)</span>

<span class="s2">if </span><span class="s1">getattr(resolver</span><span class="s2">, </span><span class="s3">'pool'</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None</span><span class="s1">:</span>
    <span class="s1">resolver.pool.size = </span><span class="s4">1</span>

<span class="s2">from </span><span class="s1">gevent.testing.sysinfo </span><span class="s2">import </span><span class="s1">RESOLVER_NOT_SYSTEM</span>
<span class="s2">from </span><span class="s1">gevent.testing.sysinfo </span><span class="s2">import </span><span class="s1">RESOLVER_DNSPYTHON</span>
<span class="s2">from </span><span class="s1">gevent.testing.sysinfo </span><span class="s2">import </span><span class="s1">RESOLVER_ARES</span>
<span class="s2">from </span><span class="s1">gevent.testing.sysinfo </span><span class="s2">import </span><span class="s1">PY2</span>
<span class="s2">from </span><span class="s1">gevent.testing.sysinfo </span><span class="s2">import </span><span class="s1">PYPY</span>

<span class="s2">import </span><span class="s1">gevent.testing.timing</span>


<span class="s2">assert </span><span class="s1">gevent_socket.gaierror </span><span class="s2">is </span><span class="s1">socket.gaierror</span>
<span class="s2">assert </span><span class="s1">gevent_socket.error </span><span class="s2">is </span><span class="s1">socket.error</span>


<span class="s1">RUN_ALL_HOST_TESTS = os.getenv(</span><span class="s3">'GEVENTTEST_RUN_ALL_ETC_HOST_TESTS'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">add(klass</span><span class="s2">, </span><span class="s1">hostname</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None,</span>
        <span class="s1">skip=</span><span class="s2">None, </span><span class="s1">skip_reason=</span><span class="s2">None,</span>
        <span class="s1">require_equal_errors=</span><span class="s2">True</span><span class="s1">):</span>

    <span class="s1">call = callable(hostname)</span>

    <span class="s2">def </span><span class="s1">_setattr(k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">func):</span>
        <span class="s2">if </span><span class="s1">skip:</span>
            <span class="s1">func = greentest.skipIf(skip</span><span class="s2">, </span><span class="s1">skip_reason</span><span class="s2">,</span><span class="s1">)(func)</span>
        <span class="s2">if not </span><span class="s1">hasattr(k</span><span class="s2">, </span><span class="s1">n):</span>
            <span class="s1">setattr(k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">func)</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">call:</span>
            <span class="s1">name = hostname.__name__</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name = re.sub(</span><span class="s3">r'[^\w]+'</span><span class="s2">, </span><span class="s3">'_'</span><span class="s2">, </span><span class="s1">repr(hostname))</span>
        <span class="s2">assert </span><span class="s1">name</span><span class="s2">, </span><span class="s1">repr(hostname)</span>

    <span class="s2">def </span><span class="s1">test_getaddrinfo_http(self):</span>
        <span class="s1">x = hostname() </span><span class="s2">if </span><span class="s1">call </span><span class="s2">else </span><span class="s1">hostname</span>
        <span class="s1">self._test(</span><span class="s3">'getaddrinfo'</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s3">'http'</span><span class="s2">,</span>
                   <span class="s1">require_equal_errors=require_equal_errors)</span>
    <span class="s1">test_getaddrinfo_http.__name__ = </span><span class="s3">'test_%s_getaddrinfo_http' </span><span class="s1">% name</span>
    <span class="s1">_setattr(klass</span><span class="s2">, </span><span class="s1">test_getaddrinfo_http.__name__</span><span class="s2">, </span><span class="s1">test_getaddrinfo_http)</span>

    <span class="s2">def </span><span class="s1">test_gethostbyname(self):</span>
        <span class="s1">x = hostname() </span><span class="s2">if </span><span class="s1">call </span><span class="s2">else </span><span class="s1">hostname</span>
        <span class="s1">ipaddr = self._test(</span><span class="s3">'gethostbyname'</span><span class="s2">, </span><span class="s1">x</span><span class="s2">,</span>
                            <span class="s1">require_equal_errors=require_equal_errors)</span>
        <span class="s2">if not </span><span class="s1">isinstance(ipaddr</span><span class="s2">, </span><span class="s1">Exception):</span>
            <span class="s1">self._test(</span><span class="s3">'gethostbyaddr'</span><span class="s2">, </span><span class="s1">ipaddr</span><span class="s2">,</span>
                       <span class="s1">require_equal_errors=require_equal_errors)</span>
    <span class="s1">test_gethostbyname.__name__ = </span><span class="s3">'test_%s_gethostbyname' </span><span class="s1">% name</span>
    <span class="s1">_setattr(klass</span><span class="s2">, </span><span class="s1">test_gethostbyname.__name__</span><span class="s2">, </span><span class="s1">test_gethostbyname)</span>

    <span class="s2">def </span><span class="s1">test_gethostbyname_ex(self):</span>
        <span class="s1">x = hostname() </span><span class="s2">if </span><span class="s1">call </span><span class="s2">else </span><span class="s1">hostname</span>
        <span class="s1">self._test(</span><span class="s3">'gethostbyname_ex'</span><span class="s2">, </span><span class="s1">x</span><span class="s2">,</span>
                   <span class="s1">require_equal_errors=require_equal_errors)</span>
    <span class="s1">test_gethostbyname_ex.__name__ = </span><span class="s3">'test_%s_gethostbyname_ex' </span><span class="s1">% name</span>
    <span class="s1">_setattr(klass</span><span class="s2">, </span><span class="s1">test_gethostbyname_ex.__name__</span><span class="s2">, </span><span class="s1">test_gethostbyname_ex)</span>

    <span class="s2">def </span><span class="s1">test4(self):</span>
        <span class="s1">x = hostname() </span><span class="s2">if </span><span class="s1">call </span><span class="s2">else </span><span class="s1">hostname</span>
        <span class="s1">self._test(</span><span class="s3">'gethostbyaddr'</span><span class="s2">, </span><span class="s1">x</span><span class="s2">,</span>
                   <span class="s1">require_equal_errors=require_equal_errors)</span>
    <span class="s1">test4.__name__ = </span><span class="s3">'test_%s_gethostbyaddr' </span><span class="s1">% name</span>
    <span class="s1">_setattr(klass</span><span class="s2">, </span><span class="s1">test4.__name__</span><span class="s2">, </span><span class="s1">test4)</span>

    <span class="s2">def </span><span class="s1">test5(self):</span>
        <span class="s1">x = hostname() </span><span class="s2">if </span><span class="s1">call </span><span class="s2">else </span><span class="s1">hostname</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s2">,</span>
                   <span class="s1">require_equal_errors=require_equal_errors)</span>
    <span class="s1">test5.__name__ = </span><span class="s3">'test_%s_getnameinfo' </span><span class="s1">% name</span>
    <span class="s1">_setattr(klass</span><span class="s2">, </span><span class="s1">test5.__name__</span><span class="s2">, </span><span class="s1">test5)</span>

<span class="s1">@skipWithoutExternalNetwork(</span><span class="s3">&quot;Tries to resolve and compare hostnames/addrinfo&quot;</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">TestCase(greentest.TestCase):</span>
    <span class="s1">maxDiff = </span><span class="s2">None</span>
    <span class="s1">__timeout__ = </span><span class="s4">30</span>
    <span class="s1">switch_expected = </span><span class="s2">None</span>

    <span class="s1">TRACE = </span><span class="s2">not </span><span class="s1">util.QUIET </span><span class="s2">and </span><span class="s1">os.getenv(</span><span class="s3">'GEVENT_DEBUG'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">) == </span><span class="s3">'trace'</span>
    <span class="s1">verbose_dns = TRACE</span>

    <span class="s2">def </span><span class="s1">trace(self</span><span class="s2">, </span><span class="s1">message</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">if </span><span class="s1">self.TRACE:</span>
            <span class="s1">util.debug(message</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s0"># Things that the stdlib should never raise and neither should we;</span>
    <span class="s0"># these indicate bugs in our code and we want to raise them.</span>
    <span class="s1">REAL_ERRORS = (AttributeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">NameError)</span>

    <span class="s2">def </span><span class="s1">__run_resolver(self</span><span class="s2">, </span><span class="s1">function</span><span class="s2">, </span><span class="s1">args):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">result = function(*args)</span>
            <span class="s2">assert not </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">BaseException)</span><span class="s2">, </span><span class="s1">repr(result)</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">except </span><span class="s1">self.REAL_ERRORS:</span>
            <span class="s2">raise</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">ex: </span><span class="s0"># pylint:disable=broad-except</span>
            <span class="s2">if </span><span class="s1">self.TRACE:</span>
                <span class="s1">traceback.print_exc()</span>
            <span class="s2">return </span><span class="s1">ex</span>

    <span class="s2">def </span><span class="s1">__trace_call(self</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">runtime</span><span class="s2">, </span><span class="s1">function</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">util.debug(self.__format_call(function</span><span class="s2">, </span><span class="s1">args))</span>
        <span class="s1">self.__trace_fresult(result</span><span class="s2">, </span><span class="s1">runtime)</span>

    <span class="s2">def </span><span class="s1">__format_call(self</span><span class="s2">, </span><span class="s1">function</span><span class="s2">, </span><span class="s1">args):</span>
        <span class="s1">args = repr(args)</span>
        <span class="s2">if </span><span class="s1">args.endswith(</span><span class="s3">',)'</span><span class="s1">):</span>
            <span class="s1">args = args[:-</span><span class="s4">2</span><span class="s1">] + </span><span class="s3">')'</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">module = function.__module__.replace(</span><span class="s3">'gevent._socketcommon'</span><span class="s2">, </span><span class="s3">'gevent'</span><span class="s1">)</span>
            <span class="s1">name = function.__name__</span>
            <span class="s2">return </span><span class="s3">'%s:%s%s' </span><span class="s1">% (module</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">args)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">return </span><span class="s1">function + args</span>

    <span class="s2">def </span><span class="s1">__trace_fresult(self</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">seconds):</span>
        <span class="s2">if </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Exception):</span>
            <span class="s1">msg = </span><span class="s3">'  -=&gt;  raised %r' </span><span class="s1">% (result</span><span class="s2">, </span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">'  -=&gt;  returned %r' </span><span class="s1">% (result</span><span class="s2">, </span><span class="s1">)</span>
        <span class="s1">time_ms = </span><span class="s3">' %.2fms' </span><span class="s1">% (seconds * </span><span class="s4">1000.0</span><span class="s2">, </span><span class="s1">)</span>
        <span class="s1">space = </span><span class="s4">80 </span><span class="s1">- len(msg) - len(time_ms)</span>
        <span class="s2">if </span><span class="s1">space &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">space = </span><span class="s3">' ' </span><span class="s1">* space</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">space = </span><span class="s3">''</span>
        <span class="s1">util.debug(msg + space + time_ms)</span>

    <span class="s2">if not </span><span class="s1">TRACE:</span>
        <span class="s2">def </span><span class="s1">run_resolver(self</span><span class="s2">, </span><span class="s1">function</span><span class="s2">, </span><span class="s1">func_args):</span>
            <span class="s1">now = time()</span>
            <span class="s2">return </span><span class="s1">self.__run_resolver(function</span><span class="s2">, </span><span class="s1">func_args)</span><span class="s2">, </span><span class="s1">time() - now</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">run_resolver(self</span><span class="s2">, </span><span class="s1">function</span><span class="s2">, </span><span class="s1">func_args):</span>
            <span class="s1">self.trace(self.__format_call(function</span><span class="s2">, </span><span class="s1">func_args))</span>
            <span class="s1">delta = time()</span>
            <span class="s1">result = self.__run_resolver(function</span><span class="s2">, </span><span class="s1">func_args)</span>
            <span class="s1">delta = time() - delta</span>
            <span class="s1">self.__trace_fresult(result</span><span class="s2">, </span><span class="s1">delta)</span>
            <span class="s2">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">delta</span>

    <span class="s2">def </span><span class="s1">setUp(self):</span>
        <span class="s1">super(TestCase</span><span class="s2">, </span><span class="s1">self).setUp()</span>
        <span class="s2">if not </span><span class="s1">self.verbose_dns:</span>
            <span class="s0"># Silence the default reporting of errors from the ThreadPool,</span>
            <span class="s0"># we handle those here.</span>
            <span class="s1">gevent.get_hub().exception_stream = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">tearDown(self):</span>
        <span class="s2">if not </span><span class="s1">self.verbose_dns:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">del </span><span class="s1">gevent.get_hub().exception_stream</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s2">pass </span><span class="s0"># Happens under leak tests</span>
        <span class="s1">super(TestCase</span><span class="s2">, </span><span class="s1">self).tearDown()</span>

    <span class="s2">def </span><span class="s1">should_log_results(self</span><span class="s2">, </span><span class="s1">result1</span><span class="s2">, </span><span class="s1">result2):</span>
        <span class="s2">if not </span><span class="s1">self.verbose_dns:</span>
            <span class="s2">return False</span>

        <span class="s2">if </span><span class="s1">isinstance(result1</span><span class="s2">, </span><span class="s1">BaseException) </span><span class="s2">and </span><span class="s1">isinstance(result2</span><span class="s2">, </span><span class="s1">BaseException):</span>
            <span class="s2">return </span><span class="s1">type(result1) </span><span class="s2">is not </span><span class="s1">type(result2)</span>
        <span class="s2">return </span><span class="s1">repr(result1) != repr(result2)</span>

    <span class="s2">def </span><span class="s1">_test(self</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s5">&quot;&quot;&quot; 
        Runs the function *func_name* with *args* and compares gevent and the system. 
 
        Keyword arguments are passed to the function itself; variable args are 
        used for the socket function. 
 
        Returns the gevent result. 
        &quot;&quot;&quot;</span>
        <span class="s1">gevent_func = getattr(gevent_socket</span><span class="s2">, </span><span class="s1">func_name)</span>
        <span class="s1">real_func = monkey.get_original(</span><span class="s3">'socket'</span><span class="s2">, </span><span class="s1">func_name)</span>

        <span class="s1">tester = getattr(self</span><span class="s2">, </span><span class="s3">'_run_test_' </span><span class="s1">+ func_name</span><span class="s2">, </span><span class="s1">self._run_test_generic)</span>
        <span class="s1">result = tester(func_name</span><span class="s2">, </span><span class="s1">real_func</span><span class="s2">, </span><span class="s1">gevent_func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">_real_result</span><span class="s2">, </span><span class="s1">time_real</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">time_gevent = result</span>

        <span class="s2">if </span><span class="s1">self.verbose_dns </span><span class="s2">and </span><span class="s1">time_gevent &gt; time_real + </span><span class="s4">0.02 </span><span class="s2">and </span><span class="s1">time_gevent &gt; </span><span class="s4">0.03</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">'gevent:%s%s took %dms versus %dms stdlib' </span><span class="s1">% (</span>
                <span class="s1">func_name</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">time_gevent * </span><span class="s4">1000.0</span><span class="s2">, </span><span class="s1">time_real * </span><span class="s4">1000.0</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">time_gevent &gt; time_real + </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">word = </span><span class="s3">'VERY'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">word = </span><span class="s3">'quite'</span>

            <span class="s1">util.log(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">WARNING: %s slow: %s'</span><span class="s2">, </span><span class="s1">word</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">color=</span><span class="s3">'warning'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">gevent_result</span>

    <span class="s2">def </span><span class="s1">_run_test_generic(self</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">, </span><span class="s1">real_func</span><span class="s2">, </span><span class="s1">gevent_func</span><span class="s2">, </span><span class="s1">func_args</span><span class="s2">,</span>
                          <span class="s1">require_equal_errors=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">real_result</span><span class="s2">, </span><span class="s1">time_real = self.run_resolver(real_func</span><span class="s2">, </span><span class="s1">func_args)</span>
        <span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">time_gevent = self.run_resolver(gevent_func</span><span class="s2">, </span><span class="s1">func_args)</span>
        <span class="s2">if </span><span class="s1">util.QUIET </span><span class="s2">and </span><span class="s1">self.should_log_results(real_result</span><span class="s2">, </span><span class="s1">gevent_result):</span>
            <span class="s1">util.log(</span><span class="s3">''</span><span class="s1">)</span>
            <span class="s1">self.__trace_call(real_result</span><span class="s2">, </span><span class="s1">time_real</span><span class="s2">, </span><span class="s1">real_func</span><span class="s2">, </span><span class="s1">func_args)</span>
            <span class="s1">self.__trace_call(gevent_result</span><span class="s2">, </span><span class="s1">time_gevent</span><span class="s2">, </span><span class="s1">gevent_func</span><span class="s2">, </span><span class="s1">func_args)</span>

        <span class="s1">self.assertEqualResults(real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">,</span>
                                <span class="s1">require_equal_errors=require_equal_errors)</span>
        <span class="s2">return </span><span class="s1">real_result</span><span class="s2">, </span><span class="s1">time_real</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">time_gevent</span>

    <span class="s2">def </span><span class="s1">_normalize_result(self</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">func_name):</span>
        <span class="s1">norm_name = </span><span class="s3">'_normalize_result_' </span><span class="s1">+ func_name</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s1">norm_name):</span>
            <span class="s2">return </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">norm_name)(result)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">NORMALIZE_GAI_IGNORE_CANONICAL_NAME = RESOLVER_ARES </span><span class="s0"># It tends to return them even when not asked for</span>
    <span class="s2">if not </span><span class="s1">RESOLVER_NOT_SYSTEM:</span>
        <span class="s2">def </span><span class="s1">_normalize_result_getaddrinfo(self</span><span class="s2">, </span><span class="s1">result):</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">def </span><span class="s1">_normalize_result_gethostbyname_ex(self</span><span class="s2">, </span><span class="s1">result):</span>
            <span class="s2">return </span><span class="s1">result</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">_normalize_result_gethostbyname_ex(self</span><span class="s2">, </span><span class="s1">result):</span>
            <span class="s0"># Often the second and third part of the tuple (hostname, aliaslist, ipaddrlist)</span>
            <span class="s0"># can be in different orders if we're hitting different servers,</span>
            <span class="s0"># or using the native and ares resolvers due to load-balancing techniques.</span>
            <span class="s0"># We sort them.</span>
            <span class="s2">if </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">BaseException):</span>
                <span class="s2">return </span><span class="s1">result</span>
            <span class="s0"># result[1].sort() # we wind up discarding this</span>

            <span class="s0"># On Py2 in test_russion_gethostbyname_ex, this</span>
            <span class="s0"># is actually an integer, for some reason. In TestLocalhost.tets__ip6_localhost,</span>
            <span class="s0"># the result isn't this long (maybe an error?).</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">result[</span><span class="s4">2</span><span class="s1">].sort()</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s2">pass</span>
            <span class="s2">except </span><span class="s1">IndexError:</span>
                <span class="s2">return </span><span class="s1">result</span>
            <span class="s0"># On some systems, a random alias is found in the aliaslist</span>
            <span class="s0"># by the system resolver, but not by cares, and vice versa. We deem the aliaslist</span>
            <span class="s0"># unimportant and discard it.</span>
            <span class="s0"># On some systems (Travis CI), the ipaddrlist for 'localhost' can come back</span>
            <span class="s0"># with two entries 127.0.0.1 (presumably two interfaces?) for c-ares</span>
            <span class="s1">ips = result[</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">ips == [</span><span class="s3">'127.0.0.1'</span><span class="s2">, </span><span class="s3">'127.0.0.1'</span><span class="s1">]:</span>
                <span class="s1">ips = [</span><span class="s3">'127.0.0.1'</span><span class="s1">]</span>
            <span class="s0"># On some systems, the hostname can get caps</span>
            <span class="s2">return </span><span class="s1">(result[</span><span class="s4">0</span><span class="s1">].lower()</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">ips)</span>

        <span class="s2">def </span><span class="s1">_normalize_result_getaddrinfo(self</span><span class="s2">, </span><span class="s1">result):</span>
            <span class="s0"># Result is a list</span>
            <span class="s0"># (family, socktype, proto, canonname, sockaddr)</span>
            <span class="s0"># e.g.,</span>
            <span class="s0"># (AF_INET, SOCK_STREAM, IPPROTO_TCP, 'readthedocs.io', (127.0.0.1, 80))</span>
            <span class="s2">if </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">BaseException):</span>
                <span class="s2">return </span><span class="s1">result</span>

            <span class="s0"># On Python 3, the builtin resolver can return SOCK_RAW results, but</span>
            <span class="s0"># c-ares doesn't do that. So we remove those if we find them.</span>
            <span class="s0"># Likewise, on certain Linux systems, even on Python 2, IPPROTO_SCTP (132)</span>
            <span class="s0"># results may be returned --- but that may not even have a constant in the</span>
            <span class="s0"># socket module! So to be safe, we strip out anything that's not</span>
            <span class="s0"># SOCK_STREAM or SOCK_DGRAM</span>
            <span class="s2">if </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">list):</span>
                <span class="s1">result = [</span>
                    <span class="s1">x</span>
                    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">result</span>
                    <span class="s2">if </span><span class="s1">x[</span><span class="s4">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(socket.SOCK_STREAM</span><span class="s2">, </span><span class="s1">socket.SOCK_DGRAM)</span>
                    <span class="s2">and </span><span class="s1">x[</span><span class="s4">2</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(socket.IPPROTO_TCP</span><span class="s2">, </span><span class="s1">socket.IPPROTO_UDP)</span>
                <span class="s1">]</span>

            <span class="s2">if </span><span class="s1">self.NORMALIZE_GAI_IGNORE_CANONICAL_NAME:</span>
                <span class="s1">result = [</span>
                    <span class="s1">(family</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">proto</span><span class="s2">, </span><span class="s3">''</span><span class="s2">, </span><span class="s1">addr)</span>
                    <span class="s2">for </span><span class="s1">family</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">proto</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">addr</span>
                    <span class="s2">in </span><span class="s1">result</span>
                <span class="s1">]</span>

            <span class="s2">if </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">list):</span>
                <span class="s1">result.sort()</span>
            <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_normalize_result_getnameinfo(self</span><span class="s2">, </span><span class="s1">result):</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">NORMALIZE_GHBA_IGNORE_ALIAS = </span><span class="s2">False</span>
    <span class="s2">def </span><span class="s1">_normalize_result_gethostbyaddr(self</span><span class="s2">, </span><span class="s1">result):</span>
        <span class="s2">if not </span><span class="s1">RESOLVER_NOT_SYSTEM:</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">if </span><span class="s1">self.NORMALIZE_GHBA_IGNORE_ALIAS </span><span class="s2">and </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s0"># On some systems, a random alias is found in the aliaslist</span>
            <span class="s0"># by the system resolver, but not by cares and vice versa. This is *probably* only the</span>
            <span class="s0"># case for localhost or things otherwise in /etc/hosts. We deem the aliaslist</span>
            <span class="s0"># unimportant and discard it.</span>
            <span class="s2">return </span><span class="s1">(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">result[</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_compare_exceptions_strict(self</span><span class="s2">, </span><span class="s1">real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">func_name):</span>
        <span class="s2">if </span><span class="s1">repr(real_result) == repr(gevent_result):</span>
            <span class="s0"># Catch things like `OverflowError('port must be 0-65535.',)```</span>
            <span class="s2">return</span>

        <span class="s1">msg = (func_name</span><span class="s2">, </span><span class="s3">'system:'</span><span class="s2">, </span><span class="s1">repr(real_result)</span><span class="s2">, </span><span class="s3">'gevent:'</span><span class="s2">, </span><span class="s1">repr(gevent_result))</span>
        <span class="s1">self.assertIs(type(gevent_result)</span><span class="s2">, </span><span class="s1">type(real_result)</span><span class="s2">, </span><span class="s1">msg)</span>

        <span class="s2">if </span><span class="s1">isinstance(real_result</span><span class="s2">, </span><span class="s1">TypeError):</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">PYPY </span><span class="s2">and </span><span class="s1">isinstance(real_result</span><span class="s2">, </span><span class="s1">socket.herror):</span>
            <span class="s0"># PyPy doesn't do errno or multiple arguments in herror;</span>
            <span class="s0"># it just puts a string like 'host lookup failed: &lt;thehost&gt;';</span>
            <span class="s0"># it must be doing that manually.</span>
            <span class="s2">return</span>

        <span class="s1">self.assertEqual(real_result.args</span><span class="s2">, </span><span class="s1">gevent_result.args</span><span class="s2">, </span><span class="s1">msg)</span>
        <span class="s2">if </span><span class="s1">hasattr(real_result</span><span class="s2">, </span><span class="s3">'errno'</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(real_result.errno</span><span class="s2">, </span><span class="s1">gevent_result.errno)</span>

    <span class="s2">def </span><span class="s1">_compare_exceptions_lenient(self</span><span class="s2">, </span><span class="s1">real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">func_name):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._compare_exceptions_strict(real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">func_name)</span>
        <span class="s2">except </span><span class="s1">AssertionError:</span>
            <span class="s0"># Allow raising different things in a few rare cases.</span>
            <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">func_name </span><span class="s2">not in </span><span class="s1">(</span>
                        <span class="s3">'getaddrinfo'</span><span class="s2">,</span>
                        <span class="s3">'gethostbyaddr'</span><span class="s2">,</span>
                        <span class="s3">'gethostbyname'</span><span class="s2">,</span>
                        <span class="s3">'gethostbyname_ex'</span><span class="s2">,</span>
                        <span class="s3">'getnameinfo'</span><span class="s2">,</span>
                    <span class="s1">)</span>
                    <span class="s2">or </span><span class="s1">type(real_result) </span><span class="s2">not in </span><span class="s1">(socket.herror</span><span class="s2">, </span><span class="s1">socket.gaierror)</span>
                    <span class="s2">or </span><span class="s1">type(gevent_result) </span><span class="s2">not in </span><span class="s1">(socket.herror</span><span class="s2">, </span><span class="s1">socket.gaierror</span><span class="s2">, </span><span class="s1">socket.error)</span>
            <span class="s1">):</span>
                <span class="s2">raise</span>
            <span class="s1">util.log(</span><span class="s3">'WARNING: error type mismatch for %s: %r (gevent) != %r (stdlib)'</span><span class="s2">,</span>
                     <span class="s1">func_name</span><span class="s2">,</span>
                     <span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">real_result</span><span class="s2">,</span>
                     <span class="s1">color=</span><span class="s3">'warning'</span><span class="s1">)</span>

    <span class="s1">_compare_exceptions = _compare_exceptions_lenient </span><span class="s2">if </span><span class="s1">RESOLVER_NOT_SYSTEM </span><span class="s2">else </span><span class="s1">_compare_exceptions_strict</span>

    <span class="s2">def </span><span class="s1">_compare_results(self</span><span class="s2">, </span><span class="s1">real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">func_name):</span>
        <span class="s2">if </span><span class="s1">real_result == gevent_result:</span>
            <span class="s2">return True</span>

        <span class="s1">compare_func = getattr(self</span><span class="s2">, </span><span class="s3">'_compare_results_' </span><span class="s1">+ func_name</span><span class="s2">,</span>
                               <span class="s1">self._generic_compare_results)</span>
        <span class="s2">return </span><span class="s1">compare_func(real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">func_name)</span>

    <span class="s2">def </span><span class="s1">_generic_compare_results(self</span><span class="s2">, </span><span class="s1">real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">func_name):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(real_result) != len(gevent_result):</span>
                <span class="s2">return False</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s2">return False</span>

        <span class="s2">return </span><span class="s1">all(self._compare_results(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">func_name)</span>
                   <span class="s2">for </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">y)</span>
                   <span class="s2">in </span><span class="s1">zip(real_result</span><span class="s2">, </span><span class="s1">gevent_result))</span>

    <span class="s2">def </span><span class="s1">_compare_results_getaddrinfo(self</span><span class="s2">, </span><span class="s1">real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">func_name):</span>
        <span class="s0"># On some systems, we find more results with</span>
        <span class="s0"># one resolver than we do with the other resolver.</span>
        <span class="s0"># So as long as they have some subset in common,</span>
        <span class="s0"># we'll take it.</span>
        <span class="s2">if not </span><span class="s1">set(real_result).isdisjoint(set(gevent_result)):</span>
            <span class="s2">return True</span>
        <span class="s2">return </span><span class="s1">self._generic_compare_results(real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">func_name)</span>

    <span class="s2">def </span><span class="s1">_compare_address_strings(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0"># IPv6 address from different requests might be different</span>
        <span class="s1">a_segments = a.count(</span><span class="s3">':'</span><span class="s1">)</span>
        <span class="s1">b_segments = b.count(</span><span class="s3">':'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">a_segments </span><span class="s2">and </span><span class="s1">b_segments:</span>
            <span class="s2">if </span><span class="s1">a_segments == b_segments </span><span class="s2">and </span><span class="s1">a_segments </span><span class="s2">in </span><span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s1">):</span>
                <span class="s2">return True</span>
            <span class="s2">if </span><span class="s1">a.rstrip(</span><span class="s3">':'</span><span class="s1">).startswith(b.rstrip(</span><span class="s3">':'</span><span class="s1">)) </span><span class="s2">or </span><span class="s1">b.rstrip(</span><span class="s3">':'</span><span class="s1">).startswith(a.rstrip(</span><span class="s3">':'</span><span class="s1">)):</span>
                <span class="s2">return True</span>
            <span class="s2">if </span><span class="s1">a_segments &gt;= </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">b_segments &gt;= </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">a.split(</span><span class="s3">':'</span><span class="s1">)[:</span><span class="s4">2</span><span class="s1">] == b.split(</span><span class="s3">':'</span><span class="s1">)[:</span><span class="s4">2</span><span class="s1">]:</span>
                <span class="s2">return True</span>

        <span class="s2">return </span><span class="s1">a.split(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)[-</span><span class="s4">1</span><span class="s1">] == b.split(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)[-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_compare_results_gethostbyname(self</span><span class="s2">, </span><span class="s1">real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">_func_name):</span>
        <span class="s0"># Both strings.</span>
        <span class="s2">return </span><span class="s1">self._compare_address_strings(real_result</span><span class="s2">, </span><span class="s1">gevent_result)</span>

    <span class="s2">def </span><span class="s1">_compare_results_gethostbyname_ex(self</span><span class="s2">, </span><span class="s1">real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">_func_name):</span>
        <span class="s0"># Results are IPv4 only:</span>
        <span class="s0">#   (hostname, [aliaslist], [ipaddrlist])</span>
        <span class="s0"># As for getaddrinfo, we'll just check the ipaddrlist has something in common.</span>
        <span class="s2">return not </span><span class="s1">set(real_result[</span><span class="s4">2</span><span class="s1">]).isdisjoint(set(gevent_result[</span><span class="s4">2</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">assertEqualResults(self</span><span class="s2">, </span><span class="s1">real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">func_name</span><span class="s2">,</span>
                           <span class="s1">require_equal_errors=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">errors = (</span>
            <span class="s1">OverflowError</span><span class="s2">,</span>
            <span class="s1">TypeError</span><span class="s2">,</span>
            <span class="s1">UnicodeError</span><span class="s2">,</span>
            <span class="s1">socket.error</span><span class="s2">,</span>
            <span class="s1">socket.gaierror</span><span class="s2">,</span>
            <span class="s1">socket.herror</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(real_result</span><span class="s2">, </span><span class="s1">errors) </span><span class="s2">and </span><span class="s1">isinstance(gevent_result</span><span class="s2">, </span><span class="s1">errors):</span>
            <span class="s2">if </span><span class="s1">require_equal_errors:</span>
                <span class="s1">self._compare_exceptions(real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">func_name)</span>
            <span class="s2">return</span>

        <span class="s1">real_result = self._normalize_result(real_result</span><span class="s2">, </span><span class="s1">func_name)</span>
        <span class="s1">gevent_result = self._normalize_result(gevent_result</span><span class="s2">, </span><span class="s1">func_name)</span>

        <span class="s2">if </span><span class="s1">self._compare_results(real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s1">func_name):</span>
            <span class="s2">return</span>

        <span class="s0"># If we're using a different resolver, allow the real resolver to generate an</span>
        <span class="s0"># error that the gevent resolver actually gets an answer to.</span>
        <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">RESOLVER_NOT_SYSTEM</span>
                <span class="s2">and </span><span class="s1">isinstance(real_result</span><span class="s2">, </span><span class="s1">errors)</span>
                <span class="s2">and not </span><span class="s1">isinstance(gevent_result</span><span class="s2">, </span><span class="s1">errors)</span>
        <span class="s1">):</span>
            <span class="s2">return</span>

        <span class="s0"># On PyPy, socket.getnameinfo() can produce results even when the hostname resolves to</span>
        <span class="s0"># multiple addresses, like www.gevent.org does. DNSPython (and c-ares?) don't do that,</span>
        <span class="s0"># they refuse to pick a name and raise ``socket.error``</span>
        <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">RESOLVER_NOT_SYSTEM</span>
                <span class="s2">and </span><span class="s1">PYPY</span>
                <span class="s2">and </span><span class="s1">func_name == </span><span class="s3">'getnameinfo'</span>
                <span class="s2">and </span><span class="s1">isinstance(gevent_result</span><span class="s2">, </span><span class="s1">socket.error)</span>
                <span class="s2">and not </span><span class="s1">isinstance(real_result</span><span class="s2">, </span><span class="s1">socket.error)</span>
        <span class="s1">):</span>
            <span class="s2">return</span>


        <span class="s0"># From 2.7 on, assertEqual does a better job highlighting the results than we would</span>
        <span class="s0"># because it calls assertSequenceEqual, which highlights the exact</span>
        <span class="s0"># difference in the tuple</span>
        <span class="s1">self.assertEqual(real_result</span><span class="s2">, </span><span class="s1">gevent_result)</span>


<span class="s2">class </span><span class="s1">TestTypeError(TestCase):</span>
    <span class="s2">pass</span>

<span class="s1">add(TestTypeError</span><span class="s2">, None</span><span class="s1">)</span>
<span class="s1">add(TestTypeError</span><span class="s2">, </span><span class="s4">25</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestHostname(TestCase):</span>
    <span class="s1">NORMALIZE_GHBA_IGNORE_ALIAS = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__normalize_name(self</span><span class="s2">, </span><span class="s1">result):</span>
        <span class="s2">if </span><span class="s1">(RESOLVER_ARES </span><span class="s2">or </span><span class="s1">RESOLVER_DNSPYTHON) </span><span class="s2">and </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s0"># The system resolver can return the FQDN, in the first result,</span>
            <span class="s0"># when given certain configurations. But c-ares and dnspython</span>
            <span class="s0"># do not.</span>
            <span class="s1">name = result[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">name = name.split(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">result = (name</span><span class="s2">,</span><span class="s1">) + result[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_normalize_result_gethostbyaddr(self</span><span class="s2">, </span><span class="s1">result):</span>
        <span class="s1">result = TestCase._normalize_result_gethostbyaddr(self</span><span class="s2">, </span><span class="s1">result)</span>
        <span class="s2">return </span><span class="s1">self.__normalize_name(result)</span>

    <span class="s2">def </span><span class="s1">_normalize_result_getnameinfo(self</span><span class="s2">, </span><span class="s1">result):</span>
        <span class="s1">result = TestCase._normalize_result_getnameinfo(self</span><span class="s2">, </span><span class="s1">result)</span>
        <span class="s2">if </span><span class="s1">PY2:</span>
            <span class="s0"># Not sure why we only saw this on Python 2</span>
            <span class="s1">result = self.__normalize_name(result)</span>
        <span class="s2">return </span><span class="s1">result</span>

<span class="s1">add(</span>
    <span class="s1">TestHostname</span><span class="s2">,</span>
    <span class="s1">socket.gethostname</span><span class="s2">,</span>
    <span class="s1">skip=greentest.RUNNING_ON_TRAVIS </span><span class="s2">and </span><span class="s1">greentest.RESOLVER_NOT_SYSTEM</span><span class="s2">,</span>
    <span class="s1">skip_reason=(</span><span class="s3">&quot;Sometimes get a different result for getaddrinfo &quot;</span>
                 <span class="s3">&quot;with dnspython; c-ares produces different results for &quot;</span>
                 <span class="s3">&quot;localhost on Travis beginning Sept 2019&quot;</span><span class="s1">)</span>
<span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestLocalhost(TestCase):</span>
    <span class="s0"># certain tests in test_patched_socket.py only work if getaddrinfo('localhost') does not switch</span>
    <span class="s0"># (e.g. NetworkConnectionAttributesTest.testSourceAddress)</span>
    <span class="s0">#switch_expected = False</span>
    <span class="s0"># XXX: The above has been commented out for some time. Apparently this isn't the case</span>
    <span class="s0"># anymore.</span>

    <span class="s2">def </span><span class="s1">_normalize_result_getaddrinfo(self</span><span class="s2">, </span><span class="s1">result):</span>
        <span class="s2">if </span><span class="s1">RESOLVER_NOT_SYSTEM:</span>
            <span class="s0"># We see that some impls (OS X) return extra results</span>
            <span class="s0"># like DGRAM that ares does not.</span>
            <span class="s2">return </span><span class="s1">()</span>
        <span class="s2">return </span><span class="s1">super(TestLocalhost</span><span class="s2">, </span><span class="s1">self)._normalize_result_getaddrinfo(result)</span>

    <span class="s1">NORMALIZE_GHBA_IGNORE_ALIAS = </span><span class="s2">True</span>
    <span class="s2">if </span><span class="s1">greentest.RUNNING_ON_TRAVIS </span><span class="s2">and </span><span class="s1">greentest.PY2 </span><span class="s2">and </span><span class="s1">RESOLVER_NOT_SYSTEM:</span>
        <span class="s2">def </span><span class="s1">_normalize_result_gethostbyaddr(self</span><span class="s2">, </span><span class="s1">result):</span>
            <span class="s0"># Beginning in November 2017 after an upgrade to Travis,</span>
            <span class="s0"># we started seeing ares return ::1 for localhost, but</span>
            <span class="s0"># the system resolver is still returning 127.0.0.1 under Python 2</span>
            <span class="s1">result = super(TestLocalhost</span><span class="s2">, </span><span class="s1">self)._normalize_result_gethostbyaddr(result)</span>
            <span class="s2">if </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">tuple):</span>
                <span class="s1">result = (result[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">result[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'127.0.0.1'</span><span class="s1">])</span>
            <span class="s2">return </span><span class="s1">result</span>


<span class="s1">add(</span>
    <span class="s1">TestLocalhost</span><span class="s2">, </span><span class="s3">'ip6-localhost'</span><span class="s2">,</span>
    <span class="s1">skip=RESOLVER_DNSPYTHON</span><span class="s2">, </span><span class="s0"># XXX: Fix these.</span>
    <span class="s1">skip_reason=</span><span class="s3">&quot;Can return gaierror(-2)&quot;</span>
<span class="s1">)</span>
<span class="s1">add(</span>
    <span class="s1">TestLocalhost</span><span class="s2">, </span><span class="s3">'localhost'</span><span class="s2">,</span>
    <span class="s1">skip=greentest.RUNNING_ON_TRAVIS</span><span class="s2">,</span>
    <span class="s1">skip_reason=</span><span class="s3">&quot;Can return gaierror(-2)&quot;</span>
<span class="s1">)</span>




<span class="s2">class </span><span class="s1">TestNonexistent(TestCase):</span>
    <span class="s2">pass</span>

<span class="s1">add(TestNonexistent</span><span class="s2">, </span><span class="s3">'nonexistentxxxyyy'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Test1234(TestCase):</span>
    <span class="s2">pass</span>

<span class="s1">add(Test1234</span><span class="s2">, </span><span class="s3">'1.2.3.4'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Test127001(TestCase):</span>
    <span class="s1">NORMALIZE_GHBA_IGNORE_ALIAS = </span><span class="s2">True</span>

<span class="s1">add(</span>
    <span class="s1">Test127001</span><span class="s2">, </span><span class="s3">'127.0.0.1'</span><span class="s2">,</span>
    <span class="s0"># skip=RESOLVER_DNSPYTHON,</span>
    <span class="s0"># skip_reason=&quot;Beginning Dec 1 2017, ares started returning ip6-localhost &quot;</span>
    <span class="s0"># &quot;instead of localhost&quot;</span>
<span class="s1">)</span>



<span class="s2">class </span><span class="s1">TestBroadcast(TestCase):</span>
    <span class="s1">switch_expected = </span><span class="s2">False</span>

    <span class="s2">if </span><span class="s1">RESOLVER_DNSPYTHON:</span>
        <span class="s0"># dnspython raises errors for broadcasthost/255.255.255.255, but the system</span>
        <span class="s0"># can resolve it.</span>

        <span class="s1">@unittest.skip(</span><span class="s3">'ares raises errors for broadcasthost/255.255.255.255'</span><span class="s1">)</span>
        <span class="s2">def </span><span class="s1">test__broadcast__gethostbyaddr(self):</span>
            <span class="s2">return</span>

        <span class="s1">test__broadcast__gethostbyname = test__broadcast__gethostbyaddr</span>

<span class="s1">add(TestBroadcast</span><span class="s2">, </span><span class="s3">'&lt;broadcast&gt;'</span><span class="s1">)</span>


<span class="s2">from </span><span class="s1">gevent.resolver._hostsfile </span><span class="s2">import </span><span class="s1">HostsFile</span>
<span class="s2">class </span><span class="s1">SanitizedHostsFile(HostsFile):</span>
    <span class="s2">def </span><span class="s1">iter_all_host_addr_pairs(self):</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">addr </span><span class="s2">in </span><span class="s1">super(SanitizedHostsFile</span><span class="s2">, </span><span class="s1">self).iter_all_host_addr_pairs():</span>
            <span class="s2">if </span><span class="s1">(RESOLVER_NOT_SYSTEM</span>
                    <span class="s2">and </span><span class="s1">(name.endswith(</span><span class="s3">'local'</span><span class="s1">) </span><span class="s0"># ignore bonjour, ares can't find them</span>
                         <span class="s0"># ignore common aliases that ares can't find</span>
                         <span class="s2">or </span><span class="s1">addr == </span><span class="s3">'255.255.255.255'</span>
                         <span class="s2">or </span><span class="s1">name == </span><span class="s3">'broadcasthost'</span>
                         <span class="s0"># We get extra results from some impls, like OS X</span>
                         <span class="s0"># it returns DGRAM results</span>
                         <span class="s2">or </span><span class="s1">name == </span><span class="s3">'localhost'</span><span class="s1">)):</span>
                <span class="s2">continue </span><span class="s0"># pragma: no cover</span>
            <span class="s2">if </span><span class="s1">name.endswith(</span><span class="s3">'local'</span><span class="s1">):</span>
                <span class="s0"># These can only be found if bonjour is running,</span>
                <span class="s0"># and are very slow to do so with the system resolver on OS X</span>
                <span class="s2">continue</span>
            <span class="s2">yield </span><span class="s1">name</span><span class="s2">, </span><span class="s1">addr</span>


<span class="s1">@greentest.skipIf(greentest.RUNNING_ON_CI</span><span class="s2">,</span>
                  <span class="s3">&quot;This sometimes randomly fails on Travis with ares and on appveyor, beginning Feb 13, 2018&quot;</span><span class="s1">)</span>
<span class="s0"># Probably due to round-robin DNS,</span>
<span class="s0"># since this is not actually the system's etc hosts file.</span>
<span class="s0"># TODO: Rethink this. We need something reliable. Go back to using</span>
<span class="s0"># the system's etc hosts?</span>
<span class="s2">class </span><span class="s1">TestEtcHosts(TestCase):</span>

    <span class="s1">MAX_HOSTS = int(os.getenv(</span><span class="s3">'GEVENTTEST_MAX_ETC_HOSTS'</span><span class="s2">, </span><span class="s3">'10'</span><span class="s1">))</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">populate_tests(cls):</span>
        <span class="s1">hf = SanitizedHostsFile(os.path.join(os.path.dirname(__file__)</span><span class="s2">,</span>
                                             <span class="s3">'hosts_file.txt'</span><span class="s1">))</span>
        <span class="s1">all_etc_hosts = sorted(hf.iter_all_host_addr_pairs())</span>
        <span class="s2">if </span><span class="s1">len(all_etc_hosts) &gt; cls.MAX_HOSTS </span><span class="s2">and not </span><span class="s1">RUN_ALL_HOST_TESTS:</span>
            <span class="s1">all_etc_hosts = all_etc_hosts[:cls.MAX_HOSTS]</span>

        <span class="s2">for </span><span class="s1">host</span><span class="s2">, </span><span class="s1">ip </span><span class="s2">in </span><span class="s1">all_etc_hosts:</span>
            <span class="s1">add(cls</span><span class="s2">, </span><span class="s1">host)</span>
            <span class="s1">add(cls</span><span class="s2">, </span><span class="s1">ip)</span>



<span class="s1">TestEtcHosts.populate_tests()</span>



<span class="s2">class </span><span class="s1">TestGeventOrg(TestCase):</span>
    <span class="s0"># For this test to work correctly, it needs to resolve to</span>
    <span class="s0"># an address with a single A record; round-robin DNS and multiple A records</span>
    <span class="s0"># may mess it up (subsequent requests---and we always make two---may return</span>
    <span class="s0"># unequal results). We used to use gevent.org, but that now has multiple A records;</span>
    <span class="s0"># trying www.gevent.org which is a CNAME to readthedocs.org then worked, but it became</span>
    <span class="s0"># an alias for python-gevent.readthedocs.org, which is an alias for readthedocs.io,</span>
    <span class="s0"># and which also has multiple addresses. So we run the resolver twice to try to get</span>
    <span class="s0"># the different answers, if needed.</span>
    <span class="s1">HOSTNAME = </span><span class="s3">'www.gevent.org'</span>


    <span class="s2">if </span><span class="s1">RESOLVER_NOT_SYSTEM:</span>
        <span class="s2">def </span><span class="s1">_normalize_result_gethostbyname(self</span><span class="s2">, </span><span class="s1">result):</span>
            <span class="s2">if </span><span class="s1">result == </span><span class="s3">'104.17.33.82'</span><span class="s1">:</span>
                <span class="s1">result = </span><span class="s3">'104.17.32.82'</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">def </span><span class="s1">_normalize_result_gethostbyname_ex(self</span><span class="s2">, </span><span class="s1">result):</span>
            <span class="s1">result = super(TestGeventOrg</span><span class="s2">, </span><span class="s1">self)._normalize_result_gethostbyname_ex(result)</span>
            <span class="s2">if </span><span class="s1">result[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">'python-gevent.readthedocs.org'</span><span class="s1">:</span>
                <span class="s1">result = (</span><span class="s3">'readthedocs.io'</span><span class="s2">, </span><span class="s1">) + result[</span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">test_AI_CANONNAME(self):</span>
        <span class="s0"># Not all systems support AI_CANONNAME; notably tha manylinux</span>
        <span class="s0"># resolvers *sometimes* do not. Specifically, sometimes they</span>
        <span class="s0"># provide the canonical name *only* on the first result.</span>

        <span class="s1">args = (</span>
            <span class="s0"># host</span>
            <span class="s1">TestGeventOrg.HOSTNAME</span><span class="s2">,</span>
            <span class="s0"># port</span>
            <span class="s2">None,</span>
            <span class="s0"># family</span>
            <span class="s1">socket.AF_INET</span><span class="s2">,</span>
            <span class="s0"># type</span>
            <span class="s4">0</span><span class="s2">,</span>
            <span class="s0"># proto</span>
            <span class="s4">0</span><span class="s2">,</span>
            <span class="s0"># flags</span>
            <span class="s1">socket.AI_CANONNAME</span>
        <span class="s1">)</span>
        <span class="s1">gevent_result = gevent_socket.getaddrinfo(*args)</span>
        <span class="s1">self.assertEqual(gevent_result[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'readthedocs.io'</span><span class="s1">)</span>
        <span class="s1">real_result = socket.getaddrinfo(*args)</span>

        <span class="s1">self.NORMALIZE_GAI_IGNORE_CANONICAL_NAME = </span><span class="s2">not </span><span class="s1">all(r[</span><span class="s4">3</span><span class="s1">] </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">real_result)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.assertEqualResults(real_result</span><span class="s2">, </span><span class="s1">gevent_result</span><span class="s2">, </span><span class="s3">'getaddrinfo'</span><span class="s1">)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">del </span><span class="s1">self.NORMALIZE_GAI_IGNORE_CANONICAL_NAME</span>

<span class="s1">add(TestGeventOrg</span><span class="s2">, </span><span class="s1">TestGeventOrg.HOSTNAME)</span>


<span class="s2">class </span><span class="s1">TestFamily(TestCase):</span>
    <span class="s2">def </span><span class="s1">test_inet(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getaddrinfo'</span><span class="s2">, </span><span class="s1">TestGeventOrg.HOSTNAME</span><span class="s2">, None, </span><span class="s1">socket.AF_INET)</span>

    <span class="s2">def </span><span class="s1">test_unspec(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getaddrinfo'</span><span class="s2">, </span><span class="s1">TestGeventOrg.HOSTNAME</span><span class="s2">, None, </span><span class="s1">socket.AF_UNSPEC)</span>

    <span class="s2">def </span><span class="s1">test_badvalue(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getaddrinfo'</span><span class="s2">, </span><span class="s1">TestGeventOrg.HOSTNAME</span><span class="s2">, None, </span><span class="s4">255</span><span class="s1">)</span>
        <span class="s1">self._test(</span><span class="s3">'getaddrinfo'</span><span class="s2">, </span><span class="s1">TestGeventOrg.HOSTNAME</span><span class="s2">, None, </span><span class="s4">255000</span><span class="s1">)</span>
        <span class="s1">self._test(</span><span class="s3">'getaddrinfo'</span><span class="s2">, </span><span class="s1">TestGeventOrg.HOSTNAME</span><span class="s2">, None, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">@unittest.skipIf(RESOLVER_DNSPYTHON</span><span class="s2">, </span><span class="s3">&quot;Raises the wrong errno&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_badtype(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getaddrinfo'</span><span class="s2">, </span><span class="s1">TestGeventOrg.HOSTNAME</span><span class="s2">, </span><span class="s3">'x'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Test_getaddrinfo(TestCase):</span>

    <span class="s2">def </span><span class="s1">_test_getaddrinfo(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">self._test(</span><span class="s3">'getaddrinfo'</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">test_80(self):</span>
        <span class="s1">self._test_getaddrinfo(TestGeventOrg.HOSTNAME</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_int_string(self):</span>
        <span class="s1">self._test_getaddrinfo(TestGeventOrg.HOSTNAME</span><span class="s2">, </span><span class="s3">'80'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_0(self):</span>
        <span class="s1">self._test_getaddrinfo(TestGeventOrg.HOSTNAME</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_http(self):</span>
        <span class="s1">self._test_getaddrinfo(TestGeventOrg.HOSTNAME</span><span class="s2">, </span><span class="s3">'http'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_notexistent_tld(self):</span>
        <span class="s1">self._test_getaddrinfo(</span><span class="s3">'myhost.mytld'</span><span class="s2">, </span><span class="s4">53</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_notexistent_dot_com(self):</span>
        <span class="s1">self._test_getaddrinfo(</span><span class="s3">'sdfsdfgu5e66098032453245wfdggd.com'</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test1(self):</span>
        <span class="s2">return </span><span class="s1">self._test_getaddrinfo(TestGeventOrg.HOSTNAME</span><span class="s2">, </span><span class="s4">52</span><span class="s2">, </span><span class="s1">socket.AF_UNSPEC</span><span class="s2">, </span><span class="s1">socket.SOCK_STREAM</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test2(self):</span>
        <span class="s2">return </span><span class="s1">self._test_getaddrinfo(TestGeventOrg.HOSTNAME</span><span class="s2">, </span><span class="s4">53</span><span class="s2">, </span><span class="s1">socket.AF_INET</span><span class="s2">, </span><span class="s1">socket.SOCK_DGRAM</span><span class="s2">, </span><span class="s4">17</span><span class="s1">)</span>

    <span class="s1">@unittest.skipIf(RESOLVER_DNSPYTHON</span><span class="s2">,</span>
                     <span class="s3">&quot;dnspython only returns some of the possibilities&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test3(self):</span>
        <span class="s2">return </span><span class="s1">self._test_getaddrinfo(</span><span class="s3">'google.com'</span><span class="s2">, </span><span class="s3">'http'</span><span class="s2">, </span><span class="s1">socket.AF_INET6)</span>


    <span class="s1">@greentest.skipIf(PY2</span><span class="s2">, </span><span class="s3">&quot;Enums only on Python 3.4+&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_enums(self):</span>
        <span class="s0"># https://github.com/gevent/gevent/issues/1310</span>

        <span class="s0"># On Python 3, getaddrinfo does special things to make sure that</span>
        <span class="s0"># the fancy enums are returned.</span>

        <span class="s1">gai = gevent_socket.getaddrinfo(</span><span class="s3">'example.com'</span><span class="s2">, </span><span class="s4">80</span><span class="s2">,</span>
                                        <span class="s1">socket.AF_INET</span><span class="s2">,</span>
                                        <span class="s1">socket.SOCK_STREAM</span><span class="s2">, </span><span class="s1">socket.IPPROTO_TCP)</span>
        <span class="s1">af</span><span class="s2">, </span><span class="s1">socktype</span><span class="s2">, </span><span class="s1">_proto</span><span class="s2">, </span><span class="s1">_canonname</span><span class="s2">, </span><span class="s1">_sa = gai[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.assertIs(socktype</span><span class="s2">, </span><span class="s1">socket.SOCK_STREAM)</span>
        <span class="s1">self.assertIs(af</span><span class="s2">, </span><span class="s1">socket.AF_INET)</span>

<span class="s2">class </span><span class="s1">TestInternational(TestCase):</span>
    <span class="s2">if </span><span class="s1">PY2:</span>
        <span class="s0"># We expect these to raise UnicodeEncodeError, which is a</span>
        <span class="s0"># subclass of ValueError</span>
        <span class="s1">REAL_ERRORS = set(TestCase.REAL_ERRORS) - {ValueError</span><span class="s2">,</span><span class="s1">}</span>

        <span class="s2">if </span><span class="s1">RESOLVER_ARES:</span>

            <span class="s2">def </span><span class="s1">test_russian_getaddrinfo_http(self):</span>
                <span class="s0"># And somehow, test_russion_getaddrinfo_http (``getaddrinfo(name, 'http')``)</span>
                <span class="s0"># manages to work with recent versions of Python 2, but our preemptive encoding</span>
                <span class="s0"># to ASCII causes it to fail with the c-ares resolver; but only that one test out of</span>
                <span class="s0"># all of them.</span>
                <span class="s1">self.skipTest(</span><span class="s3">&quot;ares fails to encode.&quot;</span><span class="s1">)</span>


<span class="s0"># dns python can actually resolve these: it uses</span>
<span class="s0"># the 2008 version of idna encoding, whereas on Python 2,</span>
<span class="s0"># with the default resolver, it tries to encode to ascii and</span>
<span class="s0"># raises a UnicodeEncodeError. So we get different results.</span>

<span class="s0"># Starting 20221027, on GitHub Actions and *some* versions of Python,</span>
<span class="s0"># we started getting a different error result from our own resolver</span>
<span class="s0"># compared to the system. This is very weird because our own resolver</span>
<span class="s0"># calls the system. I can't reproduce locally. Perhaps the two</span>
<span class="s0"># different answers are because of caching? One from the real DNS</span>
<span class="s0"># server, one from the local resolver library? Hence</span>
<span class="s0"># require_equal_errors=False</span>
<span class="s0"># ('system:', &quot;herror(2, 'Host name lookup failure')&quot;,</span>
<span class="s0">#  'gevent:', &quot;herror(1, 'Unknown host')&quot;)</span>
<span class="s1">add(TestInternational</span><span class="s2">, </span><span class="s3">u'президент.рф'</span><span class="s2">, </span><span class="s3">'russian'</span><span class="s2">,</span>
    <span class="s1">skip=(PY2 </span><span class="s2">and </span><span class="s1">RESOLVER_DNSPYTHON)</span><span class="s2">,</span>
    <span class="s1">skip_reason=</span><span class="s3">&quot;dnspython can actually resolve these&quot;</span><span class="s2">,</span>
    <span class="s1">require_equal_errors=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s1">add(TestInternational</span><span class="s2">, </span><span class="s3">u'президент.рф'</span><span class="s1">.encode(</span><span class="s3">'idna'</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'idna'</span><span class="s2">,</span>
    <span class="s1">require_equal_errors=</span><span class="s2">False</span><span class="s1">)</span>

<span class="s1">@skipWithoutExternalNetwork(</span><span class="s3">&quot;Tries to resolve and compare hostnames/addrinfo&quot;</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">TestInterrupted_gethostbyname(gevent.testing.timing.AbstractGenericWaitTestCase):</span>

    <span class="s0"># There are refs to a Waiter in the C code that don't go</span>
    <span class="s0"># away yet; one gc may or may not do it.</span>
    <span class="s1">@greentest.ignores_leakcheck</span>
    <span class="s2">def </span><span class="s1">test_returns_none_after_timeout(self):</span>
        <span class="s1">super(TestInterrupted_gethostbyname</span><span class="s2">, </span><span class="s1">self).test_returns_none_after_timeout()</span>

    <span class="s2">def </span><span class="s1">wait(self</span><span class="s2">, </span><span class="s1">timeout):</span>
        <span class="s2">with </span><span class="s1">gevent.Timeout(timeout</span><span class="s2">, False</span><span class="s1">):</span>
            <span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">xrange(</span><span class="s4">1000000</span><span class="s1">):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">gevent_socket.gethostbyname(</span><span class="s3">'www.x%s.com' </span><span class="s1">% index)</span>
                <span class="s2">except </span><span class="s1">socket.error:</span>
                    <span class="s2">pass</span>
            <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">'Timeout was not raised'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">cleanup(self):</span>
        <span class="s0"># Depending on timing, this can raise:</span>
        <span class="s0"># (This suddenly started happening on Apr 6 2016; www.x1000000.com</span>
        <span class="s0"># is apparently no longer around)</span>

        <span class="s0">#    File &quot;test__socket_dns.py&quot;, line 538, in cleanup</span>
        <span class="s0">#     gevent.get_hub().threadpool.join()</span>
        <span class="s0">#   File &quot;/home/travis/build/gevent/gevent/src/gevent/threadpool.py&quot;, line 108, in join</span>
        <span class="s0">#     sleep(delay)</span>
        <span class="s0">#   File &quot;/home/travis/build/gevent/gevent/src/gevent/hub.py&quot;, line 169, in sleep</span>
        <span class="s0">#     hub.wait(loop.timer(seconds, ref=ref))</span>
        <span class="s0">#   File &quot;/home/travis/build/gevent/gevent/src/gevent/hub.py&quot;, line 651, in wait</span>
        <span class="s0">#     result = waiter.get()</span>
        <span class="s0">#   File &quot;/home/travis/build/gevent/gevent/src/gevent/hub.py&quot;, line 899, in get</span>
        <span class="s0">#     return self.hub.switch()</span>
        <span class="s0">#   File &quot;/home/travis/build/gevent/gevent/src/greentest/greentest.py&quot;, line 520, in switch</span>
        <span class="s0">#     return _original_Hub.switch(self, *args)</span>
        <span class="s0">#   File &quot;/home/travis/build/gevent/gevent/src/gevent/hub.py&quot;, line 630, in switch</span>
        <span class="s0">#     return RawGreenlet.switch(self)</span>
        <span class="s0"># gaierror: [Errno -2] Name or service not known</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">gevent.get_hub().threadpool.join()</span>
        <span class="s2">except </span><span class="s1">Exception: </span><span class="s0"># pragma: no cover pylint:disable=broad-except</span>
            <span class="s1">traceback.print_exc()</span>


<span class="s0"># class TestInterrupted_getaddrinfo(greentest.GenericWaitTestCase):</span>
<span class="s0">#</span>
<span class="s0">#     def wait(self, timeout):</span>
<span class="s0">#         with gevent.Timeout(timeout, False):</span>
<span class="s0">#             for index in range(1000):</span>
<span class="s0">#                 try:</span>
<span class="s0">#                     gevent_socket.getaddrinfo('www.a%s.com' % index, 'http')</span>
<span class="s0">#                 except socket.gaierror:</span>
<span class="s0">#                     pass</span>


<span class="s2">class </span><span class="s1">TestBadName(TestCase):</span>
    <span class="s2">pass</span>

<span class="s1">add(TestBadName</span><span class="s2">, </span><span class="s3">'xxxxxxxxxxxx'</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">TestBadIP(TestCase):</span>
    <span class="s2">pass</span>

<span class="s1">add(TestBadIP</span><span class="s2">, </span><span class="s3">'1.2.3.400'</span><span class="s1">)</span>


<span class="s1">@greentest.skipIf(greentest.RUNNING_ON_TRAVIS</span><span class="s2">, </span><span class="s3">&quot;Travis began returning ip6-localhost&quot;</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">Test_getnameinfo_127001(TestCase):</span>

    <span class="s2">def </span><span class="s1">test(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'127.0.0.1'</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_DGRAM(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'127.0.0.1'</span><span class="s2">, </span><span class="s4">779</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'127.0.0.1'</span><span class="s2">, </span><span class="s4">779</span><span class="s1">)</span><span class="s2">, </span><span class="s1">socket.NI_DGRAM)</span>

    <span class="s2">def </span><span class="s1">test_NOFQDN(self):</span>
        <span class="s0"># I get ('localhost', 'www') with _socket but ('localhost.localdomain', 'www') with gevent.socket</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'127.0.0.1'</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)</span><span class="s2">, </span><span class="s1">socket.NI_NOFQDN)</span>

    <span class="s2">def </span><span class="s1">test_NAMEREQD(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'127.0.0.1'</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)</span><span class="s2">, </span><span class="s1">socket.NI_NAMEREQD)</span>


<span class="s2">class </span><span class="s1">Test_getnameinfo_geventorg(TestCase):</span>

    <span class="s1">@unittest.skipIf(RESOLVER_DNSPYTHON</span><span class="s2">,</span>
                     <span class="s3">&quot;dnspython raises an error when multiple results are returned&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_NUMERICHOST(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(TestGeventOrg.HOSTNAME</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(TestGeventOrg.HOSTNAME</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)</span><span class="s2">, </span><span class="s1">socket.NI_NUMERICHOST)</span>

    <span class="s1">@unittest.skipIf(RESOLVER_DNSPYTHON</span><span class="s2">,</span>
                     <span class="s3">&quot;dnspython raises an error when multiple results are returned&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_NUMERICSERV(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(TestGeventOrg.HOSTNAME</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)</span><span class="s2">, </span><span class="s1">socket.NI_NUMERICSERV)</span>

    <span class="s2">def </span><span class="s1">test_domain1(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(TestGeventOrg.HOSTNAME</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_domain2(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'www.gevent.org'</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_port_zero(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'www.gevent.org'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Test_getnameinfo_fail(TestCase):</span>

    <span class="s2">def </span><span class="s1">test_port_string(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'www.gevent.org'</span><span class="s2">, </span><span class="s3">'http'</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_flags(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'localhost'</span><span class="s2">, </span><span class="s4">80</span><span class="s1">)</span><span class="s2">, </span><span class="s4">55555555</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestInvalidPort(TestCase):</span>

    <span class="s1">@flaky.reraises_flaky_race_condition()</span>
    <span class="s2">def </span><span class="s1">test_overflow_neg_one(self):</span>
        <span class="s0"># An Appveyor beginning 2019-03-21, the system resolver</span>
        <span class="s0"># sometimes returns ('23.100.69.251', '65535') instead of</span>
        <span class="s0"># raising an error. That IP address belongs to</span>
        <span class="s0"># readthedocs[.io?] which is where www.gevent.org is a CNAME</span>
        <span class="s0"># to...but it doesn't actually *reverse* to readthedocs.io.</span>
        <span class="s0"># Can't reproduce locally, not sure what's happening</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'www.gevent.org'</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0"># Beginning with PyPy 2.7 7.1 on Appveyor, we sometimes see this</span>
    <span class="s0"># return an OverflowError instead of the TypeError about None</span>
    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s3">&quot;Errors dont match&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_typeerror_none(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'www.gevent.org'</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0"># Beginning with PyPy 2.7 7.1 on Appveyor, we sometimes see this</span>
    <span class="s0"># return an TypeError instead of the OverflowError.</span>
    <span class="s0"># XXX: But see Test_getnameinfo_fail.test_port_string where this does work.</span>
    <span class="s1">@greentest.skipOnLibuvOnPyPyOnWin(</span><span class="s3">&quot;Errors don't match&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_typeerror_str(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'www.gevent.org'</span><span class="s2">, </span><span class="s3">'x'</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_overflow_port_too_large(self):</span>
        <span class="s1">self._test(</span><span class="s3">'getnameinfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'www.gevent.org'</span><span class="s2">, </span><span class="s4">65536</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s3">'__main__'</span><span class="s1">:</span>
    <span class="s1">greentest.main()</span>
</pre>
</body>
</html>