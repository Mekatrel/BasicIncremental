<html>
<head>
<title>greenlet.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #ab51ba;}
.s5 { color: #0f9795;}
.s6 { color: #6897bb;}
.s7 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
greenlet.cpp</font>
</center></td></tr></table>
<pre><span class="s0">/* -*- indent-tabs-mode: nil; tab-width: 4; -*- */</span>
<span class="s0">/* Format with: 
 *  clang-format -i --style=file src/greenlet/greenlet.c 
 * 
 * 
 * Fix missing braces with: 
 *   clang-tidy src/greenlet/greenlet.c -fix -checks=&quot;readability-braces-around-statements&quot; 
*/</span>
<span class="s2">#include </span><span class="s1">&lt;cstdlib&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;string&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;algorithm&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;exception&gt;</span>


<span class="s2">#define </span><span class="s1">PY_SSIZE_T_CLEAN</span>
<span class="s2">#include </span><span class="s1">&lt;Python.h&gt;</span>
<span class="s2">#include </span><span class="s3">&quot;structmember.h&quot; </span><span class="s0">// PyMemberDef</span>

<span class="s2">#include </span><span class="s3">&quot;greenlet_internal.hpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;greenlet_refs.hpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;greenlet_slp_switch.hpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;greenlet_thread_state.hpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;greenlet_thread_support.hpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;greenlet_greenlet.hpp&quot;</span>

<span class="s4">using </span><span class="s1">greenlet::ThreadState;</span>
<span class="s4">using </span><span class="s1">greenlet::Mutex;</span>
<span class="s4">using </span><span class="s1">greenlet::LockGuard;</span>
<span class="s4">using </span><span class="s1">greenlet::LockInitError;</span>
<span class="s4">using </span><span class="s1">greenlet::PyErrOccurred;</span>
<span class="s4">using </span><span class="s1">greenlet::Require;</span>
<span class="s4">using </span><span class="s1">greenlet::PyFatalError;</span>
<span class="s4">using </span><span class="s1">greenlet::ExceptionState;</span>
<span class="s4">using </span><span class="s1">greenlet::StackState;</span>
<span class="s4">using </span><span class="s1">greenlet::Greenlet;</span>


<span class="s0">// Helpers for reference counting.</span>
<span class="s0">// XXX: running the test cases for greenlet 1.1.2 under Python 3.10+pydebug</span>
<span class="s0">// with zope.testrunner's &quot;report refcounts&quot; option shows a growth of</span>
<span class="s0">// over 500 references when running 90 tests at a steady state (10 repeats)</span>
<span class="s0">// Running in verbose mode and adding objgraph to report gives us this</span>
<span class="s0">// info in a steady state:</span>
<span class="s0">//   Ran 90 tests with 0 failures, 0 errors and 1 skipped in 2.120 seconds.</span>
<span class="s0">// Showing growth</span>
<span class="s0">// tuple                 2811       +16</span>
<span class="s0">// list                  1733       +14</span>
<span class="s0">// function              6304       +11</span>
<span class="s0">// dict                  3604        +9</span>
<span class="s0">// cell                   707        +9</span>
<span class="s0">// greenlet                81        +8</span>
<span class="s0">// method                 103        +5</span>
<span class="s0">// Genlet                  40        +4</span>
<span class="s0">// list_iterator           30        +3</span>
<span class="s0">// getset_descriptor      916        +2</span>
<span class="s0">//   sum detail refcount=341678   sys refcount=379357   change=523</span>
<span class="s0">//     Leak details, changes in instances and refcounts by type/class:</span>
<span class="s0">//     type/class                                               insts   refs</span>
<span class="s0">//     -------------------------------------------------------  -----   ----</span>
<span class="s0">//     builtins.NoneType                                            0      2</span>
<span class="s0">//     builtins.cell                                                9     20</span>
<span class="s0">//     builtins.code                                                0     31</span>
<span class="s0">//     builtins.dict                                               18     91</span>
<span class="s0">//     builtins.frame                                              20     32</span>
<span class="s0">//     builtins.function                                           11     28</span>
<span class="s0">//     builtins.getset_descriptor                                   2      2</span>
<span class="s0">//     builtins.int                                                 2     42</span>
<span class="s0">//     builtins.list                                               14     37</span>
<span class="s0">//     builtins.list_iterator                                       3      3</span>
<span class="s0">//     builtins.method                                              5      5</span>
<span class="s0">//     builtins.method_descriptor                                   0      9</span>
<span class="s0">//     builtins.str                                                11     76</span>
<span class="s0">//     builtins.traceback                                           1      2</span>
<span class="s0">//     builtins.tuple                                              20     42</span>
<span class="s0">//     builtins.type                                                2     28</span>
<span class="s0">//     builtins.weakref                                             2      2</span>
<span class="s0">//     greenlet.GreenletExit                                        1      1</span>
<span class="s0">//     greenlet.greenlet                                            8     26</span>
<span class="s0">//     greenlet.tests.test_contextvars.NoContextVarsTests           0      1</span>
<span class="s0">//     greenlet.tests.test_gc.object_with_finalizer                 1      1</span>
<span class="s0">//     greenlet.tests.test_generator_nested.Genlet                  4     26</span>
<span class="s0">//     greenlet.tests.test_greenlet.convoluted                      1      2</span>
<span class="s0">//     -------------------------------------------------------  -----   ----</span>
<span class="s0">//     total                                                      135    509</span>
<span class="s0">//</span>
<span class="s0">// As of the commit that adds this comment, we're doing better than</span>
<span class="s0">// 1.1.2, but still not perfect:</span>
<span class="s0">//   Ran 115 tests with 0 failures, 0 errors, 1 skipped in 8.623 seconds.</span>
<span class="s0">// tuple            21310       +23</span>
<span class="s0">// dict              5428       +18</span>
<span class="s0">// frame              183       +17</span>
<span class="s0">// list              1760       +14</span>
<span class="s0">// function          6359       +11</span>
<span class="s0">// cell               698        +8</span>
<span class="s0">// method             105        +5</span>
<span class="s0">// int               2709        +4</span>
<span class="s0">// TheGenlet           40        +4</span>
<span class="s0">// list_iterator       30        +3</span>
<span class="s0">//   sum detail refcount=345051   sys refcount=383043   change=494</span>
<span class="s0">//     Leak details, changes in instances and refcounts by type/class:</span>
<span class="s0">//     type/class                                               insts   refs</span>
<span class="s0">//     -------------------------------------------------------  -----   ----</span>
<span class="s0">//     builtins.NoneType                                            0     12</span>
<span class="s0">//     builtins.bool                                                0      2</span>
<span class="s0">//     builtins.cell                                                8     16</span>
<span class="s0">//     builtins.code                                                0     28</span>
<span class="s0">//     builtins.dict                                               18     74</span>
<span class="s0">//     builtins.frame                                              17     28</span>
<span class="s0">//     builtins.function                                           11     28</span>
<span class="s0">//     builtins.getset_descriptor                                   2      2</span>
<span class="s0">//     builtins.int                                                 4     44</span>
<span class="s0">//     builtins.list                                               14     39</span>
<span class="s0">//     builtins.list_iterator                                       3      3</span>
<span class="s0">//     builtins.method                                              5      5</span>
<span class="s0">//     builtins.method_descriptor                                   0      8</span>
<span class="s0">//     builtins.str                                                -2     69</span>
<span class="s0">//     builtins.tuple                                              23     42</span>
<span class="s0">//     builtins.type                                                2     28</span>
<span class="s0">//     builtins.weakref                                             2      2</span>
<span class="s0">//     greenlet.greenlet                                            1      1</span>
<span class="s0">//     greenlet.main_greenlet                                       1     16</span>
<span class="s0">//     greenlet.tests.test_contextvars.NoContextVarsTests           0      1</span>
<span class="s0">//     greenlet.tests.test_gc.object_with_finalizer                 1      1</span>
<span class="s0">//     greenlet.tests.test_generator_nested.TheGenlet               4     29</span>
<span class="s0">//     greenlet.tests.test_greenlet.convoluted                      1      2</span>
<span class="s0">//     greenlet.tests.test_leaks.HasFinalizerTracksInstances        2      2</span>
<span class="s0">//     -------------------------------------------------------  -----   ----</span>
<span class="s0">//     total                                                      117    482</span>

<span class="s4">using </span><span class="s1">greenlet::refs::BorrowedObject;</span>
<span class="s4">using </span><span class="s1">greenlet::refs::BorrowedGreenlet;</span>
<span class="s4">using </span><span class="s1">greenlet::refs::BorrowedMainGreenlet;</span>
<span class="s4">using </span><span class="s1">greenlet::refs::OwnedObject;</span>
<span class="s4">using </span><span class="s1">greenlet::refs::PyErrFetchParam;</span>
<span class="s4">using </span><span class="s1">greenlet::refs::PyArgParseParam;</span>
<span class="s4">using </span><span class="s1">greenlet::refs::ImmortalString;</span>
<span class="s4">using </span><span class="s1">greenlet::refs::ImmortalObject;</span>
<span class="s4">using </span><span class="s1">greenlet::refs::CreatedModule;</span>
<span class="s4">using </span><span class="s1">greenlet::refs::PyErrPieces;</span>
<span class="s4">using </span><span class="s1">greenlet::refs::PyObjectPointer;</span>
<span class="s4">using </span><span class="s1">greenlet::Greenlet;</span>
<span class="s4">using </span><span class="s1">greenlet::UserGreenlet;</span>
<span class="s4">using </span><span class="s1">greenlet::MainGreenlet;</span>


<span class="s0">// ******* Implementation of things from included files</span>
<span class="s1">template&lt;</span><span class="s4">typename </span><span class="s1">T, greenlet::refs::TypeChecker TC&gt;</span>
<span class="s1">greenlet::refs::_BorrowedGreenlet&lt;T, TC&gt;&amp; greenlet::refs::_BorrowedGreenlet&lt;T, TC&gt;::</span><span class="s4">operator</span><span class="s1">=(</span><span class="s2">const </span><span class="s1">greenlet::refs::BorrowedObject&amp; other)</span>
<span class="s1">{</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_set_raw_pointer(</span><span class="s4">static_cast</span><span class="s1">&lt;PyObject*&gt;(other));</span>
    <span class="s2">return </span><span class="s1">*</span><span class="s4">this</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">template &lt;</span><span class="s4">typename </span><span class="s1">T, greenlet::refs::TypeChecker TC&gt;</span>
<span class="s4">inline </span><span class="s1">greenlet::refs::_BorrowedGreenlet&lt;T, TC&gt;::</span><span class="s4">operator </span><span class="s1">Greenlet*() </span><span class="s2">const </span><span class="s1">G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">p) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s4">reinterpret_cast</span><span class="s1">&lt;PyGreenlet*&gt;(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">p)</span><span class="s5">-&gt;</span><span class="s1">pimpl;</span>
<span class="s1">}</span>

<span class="s1">template&lt;</span><span class="s4">typename </span><span class="s1">T, greenlet::refs::TypeChecker TC&gt;</span>
<span class="s1">greenlet::refs::_BorrowedGreenlet&lt;T, TC&gt;::_BorrowedGreenlet(</span><span class="s2">const </span><span class="s1">BorrowedObject&amp; p)</span>
    <span class="s1">: BorrowedReference&lt;T, TC&gt;(nullptr)</span>
<span class="s1">{</span>

    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_set_raw_pointer(p.borrow());</span>
<span class="s1">}</span>

<span class="s1">template &lt;</span><span class="s4">typename </span><span class="s1">T, greenlet::refs::TypeChecker TC&gt;</span>
<span class="s4">inline </span><span class="s1">greenlet::refs::_OwnedGreenlet&lt;T, TC&gt;::</span><span class="s4">operator </span><span class="s1">Greenlet*() </span><span class="s2">const </span><span class="s1">G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">p) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s4">reinterpret_cast</span><span class="s1">&lt;PyGreenlet*&gt;(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">p)</span><span class="s5">-&gt;</span><span class="s1">pimpl;</span>
<span class="s1">}</span>



<span class="s2">#ifdef </span><span class="s1">__clang__</span>
<span class="s1">#    pragma clang diagnostic push</span>
<span class="s1">#    pragma clang diagnostic ignored </span><span class="s3">&quot;-Wmissing-field-initializers&quot;</span>
<span class="s1">#    pragma clang diagnostic ignored </span><span class="s3">&quot;-Wwritable-strings&quot;</span>
<span class="s1">#elif defined(__GNUC__)</span>
<span class="s1">#    pragma GCC diagnostic push</span>
<span class="s0">//  warning: ISO C++ forbids converting a string constant to ‘char*’</span>
<span class="s0">// (The python APIs aren't const correct and accept writable char*)</span>
<span class="s1">#    pragma GCC diagnostic ignored </span><span class="s3">&quot;-Wwrite-strings&quot;</span>
<span class="s2">#endif</span>


<span class="s0">/*********************************************************** 
 
A PyGreenlet is a range of C stack addresses that must be 
saved and restored in such a way that the full range of the 
stack contains valid data when we switch to it. 
 
Stack layout for a greenlet: 
 
               |     ^^^       | 
               |  older data   | 
               |               | 
  stack_stop . |_______________| 
        .      |               | 
        .      | greenlet data | 
        .      |   in stack    | 
        .    * |_______________| . .  _____________  stack_copy + stack_saved 
        .      |               |     |             | 
        .      |     data      |     |greenlet data| 
        .      |   unrelated   |     |    saved    | 
        .      |      to       |     |   in heap   | 
 stack_start . |     this      | . . |_____________| stack_copy 
               |   greenlet    | 
               |               | 
               |  newer data   | 
               |     vvv       | 
 
 
Note that a greenlet's stack data is typically partly at its correct 
place in the stack, and partly saved away in the heap, but always in 
the above configuration: two blocks, the more recent one in the heap 
and the older one still in the stack (either block may be empty). 
 
Greenlets are chained: each points to the previous greenlet, which is 
the one that owns the data currently in the C stack above my 
stack_stop.  The currently running greenlet is the first element of 
this chain.  The main (initial) greenlet is the last one.  Greenlets 
whose stack is entirely in the heap can be skipped from the chain. 
 
The chain is not related to execution order, but only to the order 
in which bits of C stack happen to belong to greenlets at a particular 
point in time. 
 
The main greenlet doesn't have a stack_stop: it is responsible for the 
complete rest of the C stack, and we don't know where it begins.  We 
use (char*) -1, the largest possible address. 
 
States: 
  stack_stop == NULL &amp;&amp; stack_start == NULL:  did not start yet 
  stack_stop != NULL &amp;&amp; stack_start == NULL:  already finished 
  stack_stop != NULL &amp;&amp; stack_start != NULL:  active 
 
The running greenlet's stack_start is undefined but not NULL. 
 
 ***********************************************************/</span>

<span class="s0">/*** global state ***/</span>

<span class="s0">/* In the presence of multithreading, this is a bit tricky; see 
   greenlet_thread_state.hpp for details. 
*/</span>


<span class="s2">static </span><span class="s4">inline </span><span class="s1">OwnedObject</span>
<span class="s1">single_result(</span><span class="s2">const </span><span class="s1">OwnedObject&amp; results)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(results</span>
        <span class="s1">&amp;&amp; PyTuple_Check(results.borrow())</span>
        <span class="s1">&amp;&amp; PyTuple_GET_SIZE(results.borrow()) == </span><span class="s6">1</span><span class="s1">) {</span>
        <span class="s1">PyObject* result = PyTuple_GET_ITEM(results.borrow(), </span><span class="s6">0</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">OwnedObject::owning(result);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">results;</span>
<span class="s1">}</span>



<span class="s4">class </span><span class="s1">ImmortalEventName : </span><span class="s4">public </span><span class="s1">ImmortalString</span>
<span class="s1">{</span>
<span class="s4">private</span><span class="s1">:</span>
    <span class="s1">G_NO_COPIES_OF_CLS(ImmortalEventName);</span>
<span class="s4">public</span><span class="s1">:</span>
    <span class="s1">ImmortalEventName(</span><span class="s2">const char</span><span class="s1">* </span><span class="s2">const </span><span class="s1">str) : ImmortalString(str)</span>
    <span class="s1">{}</span>
<span class="s1">};</span>

<span class="s4">class </span><span class="s1">ImmortalException : </span><span class="s4">public </span><span class="s1">ImmortalObject</span>
<span class="s1">{</span>
<span class="s4">private</span><span class="s1">:</span>
    <span class="s1">G_NO_COPIES_OF_CLS(ImmortalException);</span>
<span class="s4">public</span><span class="s1">:</span>
    <span class="s1">ImmortalException(</span><span class="s2">const char</span><span class="s1">* </span><span class="s2">const </span><span class="s1">name, PyObject* base=nullptr) :</span>
        <span class="s1">ImmortalObject(name</span>
                       <span class="s0">// Python 2.7 isn't const correct</span>
                       <span class="s1">? Require(PyErr_NewException((</span><span class="s2">char</span><span class="s1">*)name, base, nullptr))</span>
                       <span class="s1">: nullptr)</span>
    <span class="s1">{}</span>

    <span class="s4">inline </span><span class="s2">bool </span><span class="s1">PyExceptionMatches() </span><span class="s2">const</span>
    <span class="s1">{</span>
        <span class="s2">return </span><span class="s1">PyErr_ExceptionMatches(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">p) &gt; </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

<span class="s1">};</span>

<span class="s0">// This encapsulates what were previously module global &quot;constants&quot;</span>
<span class="s0">// established at init time.</span>
<span class="s0">// This is a step towards Python3 style module state that allows</span>
<span class="s0">// reloading.</span>
<span class="s0">// We play some tricks with placement new to be able to allocate this</span>
<span class="s0">// object statically still, so that references to its members don't</span>
<span class="s0">// incur an extra pointer indirection.</span>
<span class="s4">class </span><span class="s1">GreenletGlobals</span>
<span class="s1">{</span>
<span class="s4">public</span><span class="s1">:</span>
    <span class="s2">const </span><span class="s1">ImmortalEventName event_switch;</span>
    <span class="s2">const </span><span class="s1">ImmortalEventName event_throw;</span>
    <span class="s2">const </span><span class="s1">ImmortalException PyExc_GreenletError;</span>
    <span class="s2">const </span><span class="s1">ImmortalException PyExc_GreenletExit;</span>
    <span class="s2">const </span><span class="s1">ImmortalObject empty_tuple;</span>
    <span class="s2">const </span><span class="s1">ImmortalObject empty_dict;</span>
    <span class="s2">const </span><span class="s1">ImmortalString str_run;</span>
    <span class="s1">Mutex* </span><span class="s2">const </span><span class="s1">thread_states_to_destroy_lock;</span>
    <span class="s1">greenlet::cleanup_queue_t thread_states_to_destroy;</span>

    <span class="s1">GreenletGlobals(</span><span class="s2">const int </span><span class="s1">UNUSED(dummy)) :</span>
        <span class="s1">event_switch(</span><span class="s6">0</span><span class="s1">),</span>
        <span class="s1">event_throw(</span><span class="s6">0</span><span class="s1">),</span>
        <span class="s1">PyExc_GreenletError(</span><span class="s6">0</span><span class="s1">),</span>
        <span class="s1">PyExc_GreenletExit(</span><span class="s6">0</span><span class="s1">),</span>
        <span class="s1">empty_tuple(</span><span class="s6">0</span><span class="s1">),</span>
        <span class="s1">empty_dict(</span><span class="s6">0</span><span class="s1">),</span>
        <span class="s1">str_run(</span><span class="s6">0</span><span class="s1">),</span>
        <span class="s1">thread_states_to_destroy_lock(</span><span class="s6">0</span><span class="s1">)</span>
    <span class="s1">{}</span>

    <span class="s1">GreenletGlobals() :</span>
        <span class="s1">event_switch(</span><span class="s3">&quot;switch&quot;</span><span class="s1">),</span>
        <span class="s1">event_throw(</span><span class="s3">&quot;throw&quot;</span><span class="s1">),</span>
        <span class="s1">PyExc_GreenletError(</span><span class="s3">&quot;greenlet.error&quot;</span><span class="s1">),</span>
        <span class="s1">PyExc_GreenletExit(</span><span class="s3">&quot;greenlet.GreenletExit&quot;</span><span class="s1">, PyExc_BaseException),</span>
        <span class="s1">empty_tuple(Require(PyTuple_New(</span><span class="s6">0</span><span class="s1">))),</span>
        <span class="s1">empty_dict(Require(PyDict_New())),</span>
        <span class="s1">str_run(</span><span class="s3">&quot;run&quot;</span><span class="s1">),</span>
        <span class="s1">thread_states_to_destroy_lock(</span><span class="s4">new </span><span class="s1">Mutex())</span>
    <span class="s1">{}</span>

    <span class="s1">~GreenletGlobals()</span>
    <span class="s1">{</span>
        <span class="s0">// This object is (currently) effectively immortal, and not</span>
        <span class="s0">// just because of those placement new tricks; if we try to</span>
        <span class="s0">// deallocate the static object we allocated, and overwrote,</span>
        <span class="s0">// we would be doing so at C++ teardown time, which is after</span>
        <span class="s0">// the final Python GIL is released, and we can't use the API</span>
        <span class="s0">// then.</span>
        <span class="s0">// (The members will still be destructed, but they also don't</span>
        <span class="s0">// do any deallocation.)</span>
    <span class="s1">}</span>

    <span class="s2">void </span><span class="s1">queue_to_destroy(ThreadState* ts) </span><span class="s2">const</span>
    <span class="s1">{</span>
        <span class="s0">// we're currently accessed through a static const object,</span>
        <span class="s0">// implicitly marking our members as const, so code can't just</span>
        <span class="s0">// call push_back (or pop_back) without casting away the</span>
        <span class="s0">// const.</span>
        <span class="s0">//</span>
        <span class="s0">// Do that for callers.</span>
        <span class="s1">greenlet::cleanup_queue_t&amp; q = </span><span class="s4">const_cast</span><span class="s1">&lt;greenlet::cleanup_queue_t&amp;&gt;(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_states_to_destroy);</span>
        <span class="s1">q.push_back(ts);</span>
    <span class="s1">}</span>

    <span class="s1">ThreadState* take_next_to_destroy() </span><span class="s2">const</span>
    <span class="s1">{</span>
        <span class="s1">greenlet::cleanup_queue_t&amp; q = </span><span class="s4">const_cast</span><span class="s1">&lt;greenlet::cleanup_queue_t&amp;&gt;(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_states_to_destroy);</span>
        <span class="s1">ThreadState* result = q.back();</span>
        <span class="s1">q.pop_back();</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s2">static const </span><span class="s1">GreenletGlobals mod_globs(</span><span class="s6">0</span><span class="s1">);</span>

<span class="s0">// Protected by the GIL. Incremented when we create a main greenlet,</span>
<span class="s0">// in a new thread, decremented when it is destroyed.</span>
<span class="s2">static </span><span class="s1">Py_ssize_t total_main_greenlets;</span>

<span class="s2">struct </span><span class="s1">ThreadState_DestroyWithGIL</span>
<span class="s1">{</span>
    <span class="s1">ThreadState_DestroyWithGIL(ThreadState* state)</span>
    <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(state &amp;&amp; state</span><span class="s5">-&gt;</span><span class="s1">has_main_greenlet()) {</span>
            <span class="s1">DestroyWithGIL(state);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">static int</span>
    <span class="s1">DestroyWithGIL(ThreadState* state)</span>
    <span class="s1">{</span>
        <span class="s0">// Holding the GIL.</span>
        <span class="s0">// Passed a non-shared pointer to the actual thread state.</span>
        <span class="s0">// state -&gt; main greenlet</span>
        <span class="s1">assert(state</span><span class="s5">-&gt;</span><span class="s1">has_main_greenlet());</span>
        <span class="s1">PyGreenlet* main(state</span><span class="s5">-&gt;</span><span class="s1">borrow_main_greenlet());</span>
        <span class="s0">// When we need to do cross-thread operations, we check this.</span>
        <span class="s0">// A NULL value means the thread died some time ago.</span>
        <span class="s0">// We do this here, rather than in a Python dealloc function</span>
        <span class="s0">// for the greenlet, in case there's still a reference out</span>
        <span class="s0">// there.</span>
        <span class="s4">static_cast</span><span class="s1">&lt;MainGreenlet*&gt;(main</span><span class="s5">-&gt;</span><span class="s1">pimpl)</span><span class="s5">-&gt;</span><span class="s1">thread_state(nullptr);</span>

        <span class="s2">delete </span><span class="s1">state; </span><span class="s0">// Deleting this runs the destructor, DECREFs the main greenlet.</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s2">#if </span><span class="s1">(PY_VERSION_HEX &gt;= </span><span class="s6">0x30800A0 </span><span class="s1">&amp;&amp; PY_VERSION_HEX &lt; </span><span class="s6">0x3090000</span><span class="s1">) &amp;&amp; !(defined(_WIN32) || defined(WIN32))</span>
<span class="s0">// XXX: From Python 3.8a3 [1] up until Python 3.9a6 [2][3],</span>
<span class="s0">// ``Py_AddPendingCall`` would try to produce a Python exception if</span>
<span class="s0">// the interpreter was in the beginning of shutting down when this</span>
<span class="s0">// function is called. However, ``Py_AddPendingCall`` doesn't require</span>
<span class="s0">// the GIL, and we are absolutely not holding it when we make that</span>
<span class="s0">// call. That means that trying to create the Python exception is</span>
<span class="s0">// using the C API in an undefined state; here the C API detects this</span>
<span class="s0">// and aborts the process with an error (&quot;Fatal Python error: Python</span>
<span class="s0">// memory allocator called without holding the GIL&quot;: Add -&gt;</span>
<span class="s0">// PyErr_SetString -&gt; PyUnicode_New -&gt; PyObject_Malloc). This arises</span>
<span class="s0">// (obviously) in multi-threaded programs and happens if one thread is</span>
<span class="s0">// exiting and cleaning up its thread-local data while the other</span>
<span class="s0">// thread is trying to shut down the interpreter. A crash on shutdown</span>
<span class="s0">// is still a crash and could result in data loss (e.g., daemon</span>
<span class="s0">// threads are still running, pending signal handlers may be present,</span>
<span class="s0">// buffers may not be flushed, there may be __del__ that need run,</span>
<span class="s0">// etc), so we have to work around it.</span>
<span class="s0">//</span>
<span class="s0">// Of course, we can (and do) check for whether the interpreter is</span>
<span class="s0">// shutting down before calling ``Py_AddPendingCall``, but that's a</span>
<span class="s0">// race condition since we don't hold the GIL, and so we may not</span>
<span class="s0">// actually get the right answer. Plus, ``Py_FinalizeEx`` actually</span>
<span class="s0">// calls ``_Py_FinishPendingCalls`` (which sets the pending-&gt;finishing</span>
<span class="s0">// flag, which is used to gate creating the exceptioen) *before*</span>
<span class="s0">// publishing any other data that would let us detect the shutdown</span>
<span class="s0">// (such as runtime-&gt;finalizing). So that point is moot.</span>
<span class="s0">//</span>
<span class="s0">// Our solution for those versions is to inline the same code, without</span>
<span class="s0">// the problematic bit that sets the exception. Unfortunately, all of</span>
<span class="s0">// the structure definitions are private/opaque, *and* we can't</span>
<span class="s0">// actually count on being able to include their definitions from</span>
<span class="s0">// ``internal/pycore_*``, because on some platforms those header files</span>
<span class="s0">// are incomplete (i.e., on macOS with macports 3.8, the includes are</span>
<span class="s0">// fine, but on Ubuntu jammy with 3.8 from ppa:deadsnakes or GitHub</span>
<span class="s0">// Actions 3.8 (I think it's Ubuntu 18.04), they con't be used; at</span>
<span class="s0">// least, I couldn't get them to work). So we need to define the</span>
<span class="s0">// structures and _PyRuntime data member ourself. Yet more</span>
<span class="s0">// unfortunately, _PyRuntime  won't link on Windows, so we can only do</span>
<span class="s0">// this on other platforms.</span>
<span class="s0">//</span>
<span class="s0">// [1] https://github.com/python/cpython/commit/842a2f07f2f08a935ef470bfdaeef40f87490cfc</span>
<span class="s0">// [2] https://github.com/python/cpython/commit/cfc3c2f8b34d3864717ab584c5b6c260014ba55a</span>
<span class="s0">// [3] https://github.com/python/cpython/issues/81308</span>
<span class="s1"># define GREENLET_BROKEN_PY_ADD_PENDING </span><span class="s6">1</span>

<span class="s0">// When defining these structures, the important thing is to get</span>
<span class="s0">// binary compatibility, i.e., structure layout. For that, we only</span>
<span class="s0">// need to define fields up to the ones we use; after that they're</span>
<span class="s0">// irrelevant UNLESS the structure is included in another structure</span>
<span class="s0">// *before* the structure we're interested in --- in that case, it</span>
<span class="s0">// must be complete. Ellipsis indicate elided trailing members.</span>
<span class="s0">// Pointer types are changed to void* to keep from having to define</span>
<span class="s0">// more structures.</span>

<span class="s0">// From &quot;internal/pycore_atomic.h&quot;</span>

<span class="s0">// There are several different definitions of this, including the</span>
<span class="s0">// plain ``int`` version, a ``volatile int`` and an ``_Atomic int``</span>
<span class="s0">// I don't think any of those change the size/layout.</span>
<span class="s2">typedef struct </span><span class="s1">_Py_atomic_int {</span>
    <span class="s2">volatile int </span><span class="s1">_value;</span>
<span class="s1">} _Py_atomic_int;</span>

<span class="s0">// This needs too much infrastructure, so we just do a regular store.</span>
<span class="s2">#define </span><span class="s1">_Py_atomic_store_relaxed(ATOMIC_VAL, NEW_VAL) \</span>
    <span class="s1">(ATOMIC_VAL)</span><span class="s5">-&gt;</span><span class="s1">_value = NEW_VAL</span>



<span class="s0">// From &quot;internal/pycore_pymem.h&quot;</span>
<span class="s2">#define </span><span class="s1">NUM_GENERATIONS </span><span class="s6">3</span>


<span class="s2">struct </span><span class="s1">gc_generation {</span>
    <span class="s1">PyGC_Head head; </span><span class="s0">// We already have this defined.</span>
    <span class="s2">int </span><span class="s1">threshold;</span>
    <span class="s2">int </span><span class="s1">count;</span>
<span class="s1">};</span>
<span class="s2">struct </span><span class="s1">gc_generation_stats {</span>
    <span class="s1">Py_ssize_t collections;</span>
    <span class="s1">Py_ssize_t collected;</span>
    <span class="s1">Py_ssize_t uncollectable;</span>
<span class="s1">};</span>

<span class="s2">struct </span><span class="s1">_gc_runtime_state {</span>
    <span class="s2">void </span><span class="s1">*trash_delete_later;</span>
    <span class="s2">int </span><span class="s1">trash_delete_nesting;</span>
    <span class="s2">int </span><span class="s1">enabled;</span>
    <span class="s2">int </span><span class="s1">debug;</span>
    <span class="s2">struct </span><span class="s1">gc_generation generations[NUM_GENERATIONS];</span>
    <span class="s2">void </span><span class="s1">*generation0;</span>
    <span class="s2">struct </span><span class="s1">gc_generation permanent_generation;</span>
    <span class="s2">struct </span><span class="s1">gc_generation_stats generation_stats[NUM_GENERATIONS];</span>
    <span class="s2">int </span><span class="s1">collecting;</span>
    <span class="s2">void </span><span class="s1">*garbage;</span>
    <span class="s2">void </span><span class="s1">*callbacks;</span>
    <span class="s1">Py_ssize_t long_lived_total;</span>
    <span class="s1">Py_ssize_t long_lived_pending;</span>
<span class="s1">};</span>

<span class="s0">// From &quot;internal/pycore_pystate.h&quot;</span>
<span class="s2">struct </span><span class="s1">_pending_calls {</span>
    <span class="s2">int </span><span class="s1">finishing;</span>
    <span class="s1">PyThread_type_lock lock;</span>
    <span class="s1">_Py_atomic_int calls_to_do;</span>
    <span class="s2">int </span><span class="s1">async_exc;</span>
<span class="s2">#define </span><span class="s1">NPENDINGCALLS </span><span class="s6">32</span>
    <span class="s2">struct </span><span class="s1">{</span>
        <span class="s2">int </span><span class="s1">(*func)(</span><span class="s2">void </span><span class="s1">*);</span>
        <span class="s2">void </span><span class="s1">*arg;</span>
    <span class="s1">} calls[NPENDINGCALLS];</span>
    <span class="s2">int </span><span class="s1">first;</span>
    <span class="s2">int </span><span class="s1">last;</span>
<span class="s1">};</span>

<span class="s2">struct </span><span class="s1">_ceval_runtime_state {</span>
    <span class="s2">int </span><span class="s1">recursion_limit;</span>
    <span class="s2">int </span><span class="s1">tracing_possible;</span>
    <span class="s1">_Py_atomic_int eval_breaker;</span>
    <span class="s1">_Py_atomic_int gil_drop_request;</span>
    <span class="s2">struct </span><span class="s1">_pending_calls pending;</span>
    <span class="s0">// ...</span>
<span class="s1">};</span>

<span class="s2">typedef struct </span><span class="s1">pyruntimestate {</span>
    <span class="s2">int </span><span class="s1">preinitializing;</span>
    <span class="s2">int </span><span class="s1">preinitialized;</span>
    <span class="s2">int </span><span class="s1">core_initialized;</span>
    <span class="s2">int </span><span class="s1">initialized;</span>
    <span class="s2">void </span><span class="s1">*finalizing;</span>

    <span class="s2">struct </span><span class="s1">pyinterpreters {</span>
        <span class="s1">PyThread_type_lock mutex;</span>
        <span class="s2">void </span><span class="s1">*head;</span>
        <span class="s2">void </span><span class="s1">*main;</span>
        <span class="s1">int64_t next_id;</span>
    <span class="s1">} interpreters;</span>
    <span class="s0">// XXX Remove this field once we have a tp_* slot.</span>
    <span class="s2">struct </span><span class="s1">_xidregistry {</span>
        <span class="s1">PyThread_type_lock mutex;</span>
        <span class="s2">void </span><span class="s1">*head;</span>
    <span class="s1">} xidregistry;</span>

    <span class="s2">unsigned long </span><span class="s1">main_thread;</span>

<span class="s2">#define </span><span class="s1">NEXITFUNCS </span><span class="s6">32</span>
    <span class="s2">void </span><span class="s1">(*exitfuncs[NEXITFUNCS])(</span><span class="s2">void</span><span class="s1">);</span>
    <span class="s2">int </span><span class="s1">nexitfuncs;</span>

    <span class="s2">struct </span><span class="s1">_gc_runtime_state gc;</span>
    <span class="s2">struct </span><span class="s1">_ceval_runtime_state ceval;</span>
    <span class="s0">// ...</span>
<span class="s1">} _PyRuntimeState;</span>

<span class="s2">#define </span><span class="s1">SIGNAL_PENDING_CALLS(ceval) \</span>
    <span class="s2">do </span><span class="s1">{ \</span>
        <span class="s1">_Py_atomic_store_relaxed(&amp;(ceval)</span><span class="s5">-&gt;</span><span class="s1">pending.calls_to_do, </span><span class="s6">1</span><span class="s1">); \</span>
        <span class="s1">_Py_atomic_store_relaxed(&amp;(ceval)</span><span class="s5">-&gt;</span><span class="s1">eval_breaker, </span><span class="s6">1</span><span class="s1">); \</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(</span><span class="s6">0</span><span class="s1">)</span>

<span class="s2">extern </span><span class="s1">_PyRuntimeState _PyRuntime;</span>

<span class="s2">#else</span>
<span class="s1"># define GREENLET_BROKEN_PY_ADD_PENDING </span><span class="s6">0</span>
<span class="s2">#endif</span>


<span class="s2">struct </span><span class="s1">ThreadState_DestroyNoGIL</span>
<span class="s1">{</span>
<span class="s2">#if </span><span class="s1">GREENLET_BROKEN_PY_ADD_PENDING</span>
    <span class="s2">static int </span><span class="s1">_push_pending_call(</span><span class="s2">struct </span><span class="s1">_pending_calls *pending,</span>
                                  <span class="s2">int </span><span class="s1">(*func)(</span><span class="s2">void </span><span class="s1">*), </span><span class="s2">void </span><span class="s1">*arg)</span>
    <span class="s1">{</span>
        <span class="s2">int </span><span class="s1">i = pending</span><span class="s5">-&gt;</span><span class="s1">last;</span>
        <span class="s2">int </span><span class="s1">j = (i + </span><span class="s6">1</span><span class="s1">) % NPENDINGCALLS;</span>
        <span class="s2">if </span><span class="s1">(j == pending</span><span class="s5">-&gt;</span><span class="s1">first) {</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">; </span><span class="s0">/* Queue full */</span>
        <span class="s1">}</span>
        <span class="s1">pending</span><span class="s5">-&gt;</span><span class="s1">calls[i].func = func;</span>
        <span class="s1">pending</span><span class="s5">-&gt;</span><span class="s1">calls[i].arg = arg;</span>
        <span class="s1">pending</span><span class="s5">-&gt;</span><span class="s1">last = j;</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">static int </span><span class="s1">AddPendingCall(</span><span class="s2">int </span><span class="s1">(*func)(</span><span class="s2">void </span><span class="s1">*), </span><span class="s2">void </span><span class="s1">*arg)</span>
    <span class="s1">{</span>
        <span class="s1">_PyRuntimeState *runtime = &amp;_PyRuntime;</span>
        <span class="s2">if </span><span class="s1">(!runtime) {</span>
            <span class="s0">// obviously impossible</span>
            <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">struct </span><span class="s1">_pending_calls *pending = &amp;runtime</span><span class="s5">-&gt;</span><span class="s1">ceval.pending;</span>
        <span class="s2">if </span><span class="s1">(!pending</span><span class="s5">-&gt;</span><span class="s1">lock) {</span>
            <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">int </span><span class="s1">result = </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s1">PyThread_acquire_lock(pending</span><span class="s5">-&gt;</span><span class="s1">lock, WAIT_LOCK);</span>
        <span class="s2">if </span><span class="s1">(!pending</span><span class="s5">-&gt;</span><span class="s1">finishing) {</span>
            <span class="s1">result = _push_pending_call(pending, func, arg);</span>
        <span class="s1">}</span>
        <span class="s1">PyThread_release_lock(pending</span><span class="s5">-&gt;</span><span class="s1">lock);</span>
        <span class="s1">SIGNAL_PENDING_CALLS(&amp;runtime</span><span class="s5">-&gt;</span><span class="s1">ceval);</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
<span class="s2">#else</span>
    <span class="s0">// Python &lt; 3.8 or &gt;= 3.9</span>
    <span class="s2">static int </span><span class="s1">AddPendingCall(</span><span class="s2">int </span><span class="s1">(*func)(</span><span class="s2">void</span><span class="s1">*), </span><span class="s2">void</span><span class="s1">* arg)</span>
    <span class="s1">{</span>
        <span class="s2">return </span><span class="s1">Py_AddPendingCall(func, arg);</span>
    <span class="s1">}</span>
<span class="s2">#endif</span>

    <span class="s1">ThreadState_DestroyNoGIL(ThreadState* state)</span>
    <span class="s1">{</span>
        <span class="s0">// We are *NOT* holding the GIL. Our thread is in the middle</span>
        <span class="s0">// of its death throes and the Python thread state is already</span>
        <span class="s0">// gone so we can't use most Python APIs. One that is safe is</span>
        <span class="s0">// ``Py_AddPendingCall``, unless the interpreter itself has</span>
        <span class="s0">// been torn down. There is a limited number of calls that can</span>
        <span class="s0">// be queued: 32 (NPENDINGCALLS) in CPython 3.10, so we</span>
        <span class="s0">// coalesce these calls using our own queue.</span>
        <span class="s2">if </span><span class="s1">(state &amp;&amp; state</span><span class="s5">-&gt;</span><span class="s1">has_main_greenlet()) {</span>
            <span class="s0">// mark the thread as dead ASAP.</span>
            <span class="s0">// this is racy! If we try to throw or switch to a</span>
            <span class="s0">// greenlet from this thread from some other thread before</span>
            <span class="s0">// we clear the state pointer, it won't realize the state</span>
            <span class="s0">// is dead which can crash the process.</span>
            <span class="s1">PyGreenlet* p = state</span><span class="s5">-&gt;</span><span class="s1">borrow_main_greenlet();</span>
            <span class="s1">assert(p</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">thread_state() == state || p</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">thread_state() == nullptr);</span>
            <span class="s4">static_cast</span><span class="s1">&lt;MainGreenlet*&gt;(p</span><span class="s5">-&gt;</span><span class="s1">pimpl)</span><span class="s5">-&gt;</span><span class="s1">thread_state(nullptr);</span>
        <span class="s1">}</span>

        <span class="s0">// NOTE: Because we're not holding the GIL here, some other</span>
        <span class="s0">// Python thread could run and call ``os.fork()``, which would</span>
        <span class="s0">// be bad if that happenend while we are holding the cleanup</span>
        <span class="s0">// lock (it wouldn't function in the child process).</span>
        <span class="s0">// Make a best effort to try to keep the duration we hold the</span>
        <span class="s0">// lock short.</span>
        <span class="s0">// TODO: On platforms that support it, use ``pthread_atfork`` to</span>
        <span class="s0">// drop this lock.</span>
        <span class="s1">LockGuard cleanup_lock(*mod_globs.thread_states_to_destroy_lock);</span>

        <span class="s2">if </span><span class="s1">(state &amp;&amp; state</span><span class="s5">-&gt;</span><span class="s1">has_main_greenlet()) {</span>
            <span class="s0">// Because we don't have the GIL, this is a race condition.</span>
            <span class="s2">if </span><span class="s1">(!PyInterpreterState_Head()) {</span>
                <span class="s0">// We have to leak the thread state, if the</span>
                <span class="s0">// interpreter has shut down when we're getting</span>
                <span class="s0">// deallocated, we can't run the cleanup code that</span>
                <span class="s0">// deleting it would imply.</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">mod_globs.queue_to_destroy(state);</span>
            <span class="s2">if </span><span class="s1">(mod_globs.thread_states_to_destroy.size() == </span><span class="s6">1</span><span class="s1">) {</span>
                <span class="s0">// We added the first item to the queue. We need to schedule</span>
                <span class="s0">// the cleanup.</span>
                <span class="s2">int </span><span class="s1">result = ThreadState_DestroyNoGIL::AddPendingCall(</span>
                    <span class="s1">ThreadState_DestroyNoGIL::DestroyQueueWithGIL,</span>
                    <span class="s1">NULL);</span>
                <span class="s2">if </span><span class="s1">(result &lt; </span><span class="s6">0</span><span class="s1">) {</span>
                    <span class="s0">// Hmm, what can we do here?</span>
                    <span class="s1">fprintf(stderr,</span>
                            <span class="s3">&quot;greenlet: WARNING: failed in call to Py_AddPendingCall; &quot;</span>
                            <span class="s3">&quot;expect a memory leak.</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">static int</span>
    <span class="s1">DestroyQueueWithGIL(</span><span class="s2">void</span><span class="s1">* UNUSED(arg))</span>
    <span class="s1">{</span>
        <span class="s0">// We're holding the GIL here, so no Python code should be able to</span>
        <span class="s0">// run to call ``os.fork()``.</span>
        <span class="s2">while </span><span class="s1">(</span><span class="s6">1</span><span class="s1">) {</span>
            <span class="s1">ThreadState* to_destroy;</span>
            <span class="s1">{</span>
                <span class="s1">LockGuard cleanup_lock(*mod_globs.thread_states_to_destroy_lock);</span>
                <span class="s2">if </span><span class="s1">(mod_globs.thread_states_to_destroy.empty()) {</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">to_destroy = mod_globs.take_next_to_destroy();</span>
            <span class="s1">}</span>
            <span class="s0">// Drop the lock while we do the actual deletion.</span>
            <span class="s1">ThreadState_DestroyWithGIL::DestroyWithGIL(to_destroy);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

<span class="s1">};</span>

<span class="s0">// The intent when GET_THREAD_STATE() is used multiple times in a function is to</span>
<span class="s0">// take a reference to it in a local variable, to avoid the</span>
<span class="s0">// thread-local indirection. On some platforms (macOS),</span>
<span class="s0">// accessing a thread-local involves a function call (plus an initial</span>
<span class="s0">// function call in each function that uses a thread local); in</span>
<span class="s0">// contrast, static volatile variables are at some pre-computed offset.</span>

<span class="s2">#if </span><span class="s1">G_USE_STANDARD_THREADING == </span><span class="s6">1</span>
<span class="s2">typedef </span><span class="s1">greenlet::ThreadStateCreator&lt;ThreadState_DestroyNoGIL&gt; ThreadStateCreator;</span>
<span class="s2">static </span><span class="s1">G_THREAD_LOCAL_VAR ThreadStateCreator g_thread_state_global;</span>
<span class="s2">#define </span><span class="s1">GET_THREAD_STATE() g_thread_state_global</span>
<span class="s2">#else</span>
<span class="s0">// if we're not using standard threading, we're using</span>
<span class="s0">// the Python thread-local dictionary to perform our cleanup,</span>
<span class="s0">// which means we're deallocated when holding the GIL. The</span>
<span class="s0">// thread state is valid enough still for us to destroy</span>
<span class="s0">// stuff.</span>
<span class="s2">typedef </span><span class="s1">greenlet::ThreadStateCreator&lt;ThreadState_DestroyWithGIL&gt; ThreadStateCreator;</span>
<span class="s2">#define </span><span class="s1">G_THREAD_STATE_DICT_CLEANUP_TYPE</span>
<span class="s2">#include </span><span class="s3">&quot;greenlet_thread_state_dict_cleanup.hpp&quot;</span>
<span class="s2">typedef </span><span class="s1">greenlet::refs::OwnedReference&lt;PyGreenletCleanup&gt; OwnedGreenletCleanup;</span>
<span class="s0">// RECALL: legacy thread-local objects (__thread on GCC, __declspec(thread) on</span>
<span class="s0">// MSVC) can't have constructors or destructors, they have to be</span>
<span class="s0">// constant. So we indirect through a pointer and a function.</span>
<span class="s2">static </span><span class="s1">G_THREAD_LOCAL_VAR ThreadStateCreator* _g_thread_state_global_ptr = nullptr;</span>
<span class="s2">static </span><span class="s1">ThreadStateCreator&amp; GET_THREAD_STATE()</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!_g_thread_state_global_ptr) {</span>
        <span class="s0">// NOTE: If any of this fails, we'll probably go on to hard</span>
        <span class="s0">// crash the process, because we're returning a reference to a</span>
        <span class="s0">// null pointer. we've called Py_FatalError(), but have no way</span>
        <span class="s0">// to communicate that to the caller. Since these should</span>
        <span class="s0">// essentially never fail unless the entire process is borked,</span>
        <span class="s0">// a hard crash with a decent C++ backtrace from the exception</span>
        <span class="s0">// is much more useful.</span>
        <span class="s1">_g_thread_state_global_ptr = </span><span class="s4">new </span><span class="s1">ThreadStateCreator();</span>
        <span class="s2">if </span><span class="s1">(!_g_thread_state_global_ptr) {</span>
            <span class="s4">throw </span><span class="s1">PyFatalError(</span><span class="s3">&quot;greenlet: Failed to create greenlet thread state.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">OwnedGreenletCleanup cleanup(OwnedGreenletCleanup::consuming(PyType_GenericAlloc(&amp;PyGreenletCleanup_Type, </span><span class="s6">0</span><span class="s1">)));</span>
        <span class="s2">if </span><span class="s1">(!cleanup) {</span>
            <span class="s4">throw </span><span class="s1">PyFatalError(</span><span class="s3">&quot;greenlet: Failed to create greenlet thread state cleanup.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">cleanup</span><span class="s5">-&gt;</span><span class="s1">thread_state_creator = _g_thread_state_global_ptr;</span>
        <span class="s1">assert(PyObject_GC_IsTracked(cleanup.borrow_o()));</span>

        <span class="s1">PyObject* ts_dict_w = PyThreadState_GetDict();</span>
        <span class="s2">if </span><span class="s1">(!ts_dict_w) {</span>
            <span class="s4">throw </span><span class="s1">PyFatalError(</span><span class="s3">&quot;greenlet: Failed to get Python thread state.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(PyDict_SetItemString(ts_dict_w, </span><span class="s3">&quot;__greenlet_cleanup&quot;</span><span class="s1">, cleanup.borrow_o()) &lt; </span><span class="s6">0</span><span class="s1">) {</span>
            <span class="s4">throw </span><span class="s1">PyFatalError(</span><span class="s3">&quot;greenlet: Failed to save cleanup key in Python thread state.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">*_g_thread_state_global_ptr;</span>
<span class="s1">}</span>
<span class="s2">#endif</span>


<span class="s1">Greenlet::Greenlet(PyGreenlet* p)</span>
<span class="s1">{</span>
    <span class="s1">p </span><span class="s5">-&gt;</span><span class="s1">pimpl = </span><span class="s4">this</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">Greenlet::Greenlet(PyGreenlet* p, </span><span class="s2">const </span><span class="s1">StackState&amp; initial_stack)</span>
    <span class="s1">: stack_state(initial_stack)</span>
<span class="s1">{</span>
    <span class="s0">// can't use a delegating constructor because of</span>
    <span class="s0">// MSVC for Python 2.7</span>
    <span class="s1">p</span><span class="s5">-&gt;</span><span class="s1">pimpl = </span><span class="s4">this</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">UserGreenlet::UserGreenlet(PyGreenlet* p,BorrowedGreenlet the_parent)</span>
    <span class="s1">: Greenlet(p), _parent(the_parent)</span>
<span class="s1">{</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_self = p;</span>
<span class="s1">}</span>


<span class="s1">MainGreenlet::MainGreenlet(PyGreenlet* p, ThreadState* state)</span>
    <span class="s1">: Greenlet(p, StackState::make_main()),</span>
      <span class="s1">_self(p),</span>
      <span class="s1">_thread_state(state)</span>
<span class="s1">{</span>
    <span class="s1">total_main_greenlets++;</span>
<span class="s1">}</span>

<span class="s1">ThreadState*</span>
<span class="s1">MainGreenlet::thread_state() </span><span class="s2">const </span><span class="s1">G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_thread_state;</span>
<span class="s1">}</span>

<span class="s2">void</span>
<span class="s1">MainGreenlet::thread_state(ThreadState* t) G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s1">assert(!t);</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_thread_state = t;</span>
<span class="s1">}</span>

<span class="s1">BorrowedGreenlet</span>
<span class="s1">UserGreenlet::self() </span><span class="s2">const </span><span class="s1">G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_self;</span>
<span class="s1">}</span>

<span class="s1">BorrowedGreenlet</span>
<span class="s1">MainGreenlet::self() </span><span class="s2">const </span><span class="s1">G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">BorrowedGreenlet(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_self.borrow());</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">BorrowedMainGreenlet</span>
<span class="s1">UserGreenlet::main_greenlet() </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">BorrowedMainGreenlet</span>
<span class="s1">MainGreenlet::main_greenlet() </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_self;</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyGreenlet*</span>
<span class="s1">green_create_main(ThreadState* state)</span>
<span class="s1">{</span>
    <span class="s1">PyGreenlet* gmain;</span>

    <span class="s0">/* create the main greenlet for this thread */</span>
    <span class="s1">gmain = (PyGreenlet*)PyType_GenericAlloc(&amp;PyGreenlet_Type, </span><span class="s6">0</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(gmain == NULL) {</span>
        <span class="s1">Py_FatalError(</span><span class="s3">&quot;green_create_main failed to alloc&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>
    <span class="s4">new </span><span class="s1">MainGreenlet(gmain, state);</span>

    <span class="s1">assert(Py_REFCNT(gmain) == </span><span class="s6">1</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">gmain;</span>
<span class="s1">}</span>


<span class="s1">BorrowedMainGreenlet</span>
<span class="s1">UserGreenlet::find_main_greenlet_in_lineage() </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">started()) {</span>
        <span class="s1">assert(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet);</span>
        <span class="s2">return </span><span class="s1">BorrowedMainGreenlet(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_parent) {</span>
        <span class="s0">/* garbage collected greenlet in chain */</span>
        <span class="s0">// XXX: WHAT?</span>
        <span class="s2">return </span><span class="s1">BorrowedMainGreenlet(nullptr);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_parent</span><span class="s5">-&gt;</span><span class="s1">find_main_greenlet_in_lineage();</span>
<span class="s1">}</span>


<span class="s1">BorrowedMainGreenlet</span>
<span class="s1">MainGreenlet::find_main_greenlet_in_lineage() </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">BorrowedMainGreenlet(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_self);</span>
<span class="s1">}</span>

<span class="s0">/***********************************************************/</span>

<span class="s0">/* Some functions must not be inlined: 
   * slp_restore_state, when inlined into slp_switch might cause 
     it to restore stack over its own local variables 
   * slp_save_state, when inlined would add its own local 
     variables to the saved stack, wasting space 
   * slp_switch, cannot be inlined for obvious reasons 
   * g_initialstub, when inlined would receive a pointer into its 
     own stack frame, leading to incomplete stack save/restore 
 
g_initialstub is a member function and declared virtual so that the 
compiler always calls it through a vtable. 
 
slp_save_state and slp_restore_state are also member functions. They 
are called from trampoline functions that themselves are declared as 
not eligible for inlining. 
*/</span>



<span class="s0">/* add forward declarations */</span>


<span class="s2">static void</span>
<span class="s1">g_calltrace(</span><span class="s2">const </span><span class="s1">OwnedObject&amp; tracefunc,</span>
            <span class="s2">const </span><span class="s1">ImmortalEventName&amp; event,</span>
            <span class="s2">const </span><span class="s1">BorrowedGreenlet&amp; origin,</span>
            <span class="s2">const </span><span class="s1">BorrowedGreenlet&amp; target);</span>

<span class="s2">static </span><span class="s1">OwnedObject</span>
<span class="s1">g_handle_exit(</span><span class="s2">const </span><span class="s1">OwnedObject&amp; greenlet_result);</span>





<span class="s0">/** 
 * CAUTION: May invoke arbitrary Python code. 
 * 
 * Figure out what the result of ``greenlet.switch(arg, kwargs)`` 
 * should be and transfers ownership of it to the left-hand-side. 
 * 
 * If switch() was just passed an arg tuple, then we'll just return that. 
 * If only keyword arguments were passed, then we'll pass the keyword 
 * argument dict. Otherwise, we'll create a tuple of (args, kwargs) and 
 * return both. 
 */</span>
<span class="s1">OwnedObject&amp; </span><span class="s4">operator</span><span class="s1">&lt;&lt;=(OwnedObject&amp; lhs, greenlet::SwitchingArgs&amp; rhs) G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s0">// Because this may invoke arbitrary Python code, which could</span>
    <span class="s0">// result in switching back to us, we need to get the</span>
    <span class="s0">// arguments locally on the stack.</span>
    <span class="s1">assert(rhs);</span>
    <span class="s1">OwnedObject args = rhs.args();</span>
    <span class="s1">OwnedObject kwargs = rhs.kwargs();</span>
    <span class="s1">rhs.CLEAR();</span>
    <span class="s0">// We shouldn't be called twice for the same switch.</span>
    <span class="s1">assert(args || kwargs);</span>
    <span class="s1">assert(!rhs);</span>

    <span class="s2">if </span><span class="s1">(!kwargs) {</span>
        <span class="s1">lhs = args;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(!PyDict_Size(kwargs.borrow())) {</span>
        <span class="s1">lhs = args;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(!PySequence_Length(args.borrow())) {</span>
        <span class="s1">lhs = kwargs;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">lhs = OwnedObject::consuming(PyTuple_Pack(</span><span class="s6">2</span><span class="s1">, args.borrow(), kwargs.borrow()));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">lhs;</span>
<span class="s1">}</span>



<span class="s2">void </span><span class="s1">Greenlet::release_args()</span>
<span class="s1">{</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args.CLEAR();</span>
<span class="s1">}</span>


<span class="s2">void</span><span class="s1">* UserGreenlet::</span><span class="s4">operator new</span><span class="s1">(size_t UNUSED(count))</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">allocator.allocate(</span><span class="s6">1</span><span class="s1">);</span>
<span class="s1">}</span>


<span class="s2">void </span><span class="s1">UserGreenlet::</span><span class="s4">operator </span><span class="s2">delete</span><span class="s1">(</span><span class="s2">void</span><span class="s1">* ptr)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">allocator.deallocate(</span><span class="s4">static_cast</span><span class="s1">&lt;UserGreenlet*&gt;(ptr),</span>
                                <span class="s6">1</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">void</span><span class="s1">* MainGreenlet::</span><span class="s4">operator new</span><span class="s1">(size_t UNUSED(count))</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">allocator.allocate(</span><span class="s6">1</span><span class="s1">);</span>
<span class="s1">}</span>


<span class="s2">void </span><span class="s1">MainGreenlet::</span><span class="s4">operator </span><span class="s2">delete</span><span class="s1">(</span><span class="s2">void</span><span class="s1">* ptr)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">allocator.deallocate(</span><span class="s4">static_cast</span><span class="s1">&lt;MainGreenlet*&gt;(ptr),</span>
                                <span class="s6">1</span><span class="s1">);</span>
<span class="s1">}</span>


<span class="s1">OwnedObject</span>
<span class="s1">Greenlet::throw_GreenletExit_during_dealloc(</span><span class="s2">const </span><span class="s1">ThreadState&amp; UNUSED(current_thread_state))</span>
<span class="s1">{</span>
    <span class="s0">// If we're killed because we lost all references in the</span>
    <span class="s0">// middle of a switch, that's ok. Don't reset the args/kwargs,</span>
    <span class="s0">// we still want to pass them to the parent.</span>
    <span class="s1">PyErr_SetString(mod_globs.PyExc_GreenletExit,</span>
                    <span class="s3">&quot;Killing the greenlet because all references have vanished.&quot;</span><span class="s1">);</span>
    <span class="s0">// To get here it had to have run before</span>
    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">g_switch();</span>
<span class="s1">}</span>

<span class="s1">OwnedObject</span>
<span class="s1">UserGreenlet::throw_GreenletExit_during_dealloc(</span><span class="s2">const </span><span class="s1">ThreadState&amp; current_thread_state)</span>
<span class="s1">{</span>
    <span class="s0">/* The dying greenlet cannot be a parent of ts_current 
       because the 'parent' field chain would hold a 
       reference */</span>
    <span class="s1">UserGreenlet::ParentIsCurrentGuard with_current_parent(</span><span class="s4">this</span><span class="s1">, current_thread_state);</span>

    <span class="s0">// We don't care about the return value, only whether an</span>
    <span class="s0">// exception happened. Whether or not an exception happens,</span>
    <span class="s0">// we need to restore the parent in case the greenlet gets</span>
    <span class="s0">// resurrected.</span>
    <span class="s2">return </span><span class="s1">Greenlet::throw_GreenletExit_during_dealloc(current_thread_state);</span>
<span class="s1">}</span>

<span class="s1">ThreadState*</span>
<span class="s1">UserGreenlet::thread_state() </span><span class="s2">const </span><span class="s1">G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s0">// TODO: maybe make this throw, if the thread state isn't there?</span>
    <span class="s0">// if (!this-&gt;main_greenlet) {</span>
    <span class="s0">//     throw std::runtime_error(&quot;No thread state&quot;); // TODO: Better exception</span>
    <span class="s0">// }</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet</span><span class="s5">-&gt;</span><span class="s1">thread_state();</span>
<span class="s1">}</span>



<span class="s2">bool</span>
<span class="s1">UserGreenlet::was_running_in_dead_thread() </span><span class="s2">const </span><span class="s1">G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet &amp;&amp; !</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state();</span>
<span class="s1">}</span>

<span class="s2">bool</span>
<span class="s1">MainGreenlet::was_running_in_dead_thread() </span><span class="s2">const </span><span class="s1">G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_thread_state;</span>
<span class="s1">}</span>

<span class="s4">inline </span><span class="s2">void</span>
<span class="s1">Greenlet::slp_restore_state() G_NOEXCEPT</span>
<span class="s1">{</span>
<span class="s2">#ifdef </span><span class="s1">SLP_BEFORE_RESTORE_STATE</span>
    <span class="s1">SLP_BEFORE_RESTORE_STATE();</span>
<span class="s2">#endif</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state.copy_heap_to_stack(</span>
           <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">borrow_current()</span><span class="s5">-&gt;</span><span class="s1">stack_state);</span>
<span class="s1">}</span>


<span class="s4">inline </span><span class="s2">int</span>
<span class="s1">Greenlet::slp_save_state(</span><span class="s2">char </span><span class="s1">*</span><span class="s2">const </span><span class="s1">stackref) G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s0">// XXX: This used to happen in the middle, before saving, but</span>
    <span class="s0">// after finding the next owner. Does that matter? This is</span>
    <span class="s0">// only defined for Sparc/GCC where it flushes register</span>
    <span class="s0">// windows to the stack (I think)</span>
<span class="s2">#ifdef </span><span class="s1">SLP_BEFORE_SAVE_STATE</span>
    <span class="s1">SLP_BEFORE_SAVE_STATE();</span>
<span class="s2">#endif</span>
    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state.copy_stack_to_heap(stackref,</span>
                                                <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">borrow_current()</span><span class="s5">-&gt;</span><span class="s1">stack_state);</span>
<span class="s1">}</span>


<span class="s1">OwnedObject</span>
<span class="s1">UserGreenlet::g_switch()</span>
<span class="s1">{</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">check_switch_allowed();</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">release_args();</span>
        <span class="s4">throw</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Switching greenlets used to attempt to clean out ones that need</span>
    <span class="s0">// deleted *if* we detected a thread switch. Should it still do</span>
    <span class="s0">// that?</span>
    <span class="s0">// An issue is that if we delete a greenlet from another thread,</span>
    <span class="s0">// it gets queued to this thread, and ``kill_greenlet()`` switches</span>
    <span class="s0">// back into the greenlet</span>

    <span class="s0">/* find the real target by ignoring dead greenlets, 
       and if necessary starting a greenlet. */</span>
    <span class="s1">switchstack_result_t err;</span>
    <span class="s1">Greenlet* target = </span><span class="s4">this</span><span class="s1">;</span>
    <span class="s0">// TODO: probably cleaner to handle the case where we do</span>
    <span class="s0">// switch to ourself separately from the other cases.</span>
    <span class="s0">// This can probably even further be simplified if we keep</span>
    <span class="s0">// track of the switching_state we're going for and just call</span>
    <span class="s0">// into g_switch() if it's not ourself. The main problem with that</span>
    <span class="s0">// is that we would be using more stack space.</span>
    <span class="s2">bool </span><span class="s1">target_was_me = </span><span class="s4">true</span><span class="s1">;</span>
    <span class="s2">while </span><span class="s1">(target) {</span>

        <span class="s2">if </span><span class="s1">(target</span><span class="s5">-&gt;</span><span class="s1">active()) {</span>
            <span class="s2">if </span><span class="s1">(!target_was_me) {</span>
                <span class="s1">target</span><span class="s5">-&gt;</span><span class="s1">args() &lt;&lt;= </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args;</span>
                <span class="s1">assert(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args);</span>
            <span class="s1">}</span>
            <span class="s1">err = target</span><span class="s5">-&gt;</span><span class="s1">g_switchstack();</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!target</span><span class="s5">-&gt;</span><span class="s1">started()) {</span>
            <span class="s0">// We never encounter a main greenlet that's not started.</span>
            <span class="s1">assert(!target</span><span class="s5">-&gt;</span><span class="s1">main());</span>
            <span class="s1">UserGreenlet* real_target = </span><span class="s4">static_cast</span><span class="s1">&lt;UserGreenlet*&gt;(target);</span>
            <span class="s1">assert(real_target);</span>
            <span class="s2">void</span><span class="s1">* dummymarker;</span>

            <span class="s2">if </span><span class="s1">(!target_was_me) {</span>
                <span class="s1">target</span><span class="s5">-&gt;</span><span class="s1">args() &lt;&lt;= </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args;</span>
                <span class="s1">assert(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args);</span>
            <span class="s1">}</span>

            <span class="s4">try </span><span class="s1">{</span>
                <span class="s0">// This can only throw back to us while we're</span>
                <span class="s0">// still in this greenlet. Once the new greenlet</span>
                <span class="s0">// is bootstrapped, it has its own exception state.</span>
                <span class="s1">err = real_target</span><span class="s5">-&gt;</span><span class="s1">g_initialstub(&amp;dummymarker);</span>
            <span class="s1">}</span>
            <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
                <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">release_args();</span>
                <span class="s4">throw</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">GreenletStartedWhileInPython&amp;) {</span>
                <span class="s0">// The greenlet was started sometime before this</span>
                <span class="s0">// greenlet actually switched to it, i.e.,</span>
                <span class="s0">// &quot;concurrent&quot; calls to switch() or throw().</span>
                <span class="s0">// We need to retry the switch.</span>
                <span class="s0">// Note that the current greenlet has been reset</span>
                <span class="s0">// to this one (or we wouldn't be running!)</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">target = target</span><span class="s5">-&gt;</span><span class="s1">parent();</span>
        <span class="s1">target_was_me = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">// The this pointer and all other stack or register based</span>
    <span class="s0">// variables are invalid now, at least where things succeed</span>
    <span class="s0">// above.</span>
    <span class="s0">// But this one, probably not so much? It's not clear if it's</span>
    <span class="s0">// safe to throw an exception at this point.</span>

    <span class="s2">if </span><span class="s1">(err.status &lt; </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s0">// XXX: This code path is untested.</span>
        <span class="s1">assert(PyErr_Occurred());</span>
        <span class="s1">assert(!err.the_state_that_switched);</span>
        <span class="s1">assert(!err.origin_greenlet);</span>
        <span class="s2">return </span><span class="s1">OwnedObject();</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">err.the_state_that_switched</span><span class="s5">-&gt;</span><span class="s1">g_switch_finish(err);</span>
<span class="s1">}</span>

<span class="s1">OwnedObject</span>
<span class="s1">MainGreenlet::g_switch()</span>
<span class="s1">{</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">check_switch_allowed();</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">release_args();</span>
        <span class="s4">throw</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">switchstack_result_t err = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">g_switchstack();</span>
    <span class="s2">if </span><span class="s1">(err.status &lt; </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s0">// XXX: This code path is untested.</span>
        <span class="s1">assert(PyErr_Occurred());</span>
        <span class="s1">assert(!err.the_state_that_switched);</span>
        <span class="s1">assert(!err.origin_greenlet);</span>
        <span class="s2">return </span><span class="s1">OwnedObject();</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">err.the_state_that_switched</span><span class="s5">-&gt;</span><span class="s1">g_switch_finish(err);</span>
<span class="s1">}</span>


<span class="s1">OwnedGreenlet</span>
<span class="s1">Greenlet::g_switchstack_success() G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s1">PyThreadState* tstate = PyThreadState_GET();</span>
    <span class="s0">// restore the saved state</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state &gt;&gt; tstate;</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">exception_state &gt;&gt; tstate;</span>

    <span class="s0">// The thread state hasn't been changed yet.</span>
    <span class="s1">ThreadState* thread_state = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state();</span>
    <span class="s1">OwnedGreenlet result(thread_state</span><span class="s5">-&gt;</span><span class="s1">get_current());</span>
    <span class="s1">thread_state</span><span class="s5">-&gt;</span><span class="s1">set_current(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self());</span>
    <span class="s0">//assert(thread_state-&gt;borrow_current().borrow() == this-&gt;_self);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>


<span class="s1">Greenlet::switchstack_result_t</span>
<span class="s1">UserGreenlet::g_initialstub(</span><span class="s2">void</span><span class="s1">* mark)</span>
<span class="s1">{</span>
    <span class="s1">OwnedObject run;</span>

    <span class="s0">// We need to grab a reference to the current switch arguments</span>
    <span class="s0">// in case we're entered concurrently during the call to</span>
    <span class="s0">// GetAttr() and have to try again.</span>
    <span class="s0">// We'll restore them when we return in that case.</span>
    <span class="s0">// Scope them tightly to avoid ref leaks.</span>
    <span class="s1">{</span>
        <span class="s1">SwitchingArgs args(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args);</span>

        <span class="s0">/* save exception in case getattr clears it */</span>
        <span class="s1">PyErrPieces saved;</span>

        <span class="s0">/* 
          self.run is the object to call in the new greenlet. 
          This could run arbitrary python code and switch greenlets! 
        */</span>
        <span class="s1">run = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_self.PyRequireAttr(mod_globs.str_run);</span>

        <span class="s0">/* restore saved exception */</span>
        <span class="s1">saved.PyErrRestore();</span>


        <span class="s0">/* recheck that it's safe to switch in case greenlet reparented anywhere above */</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">check_switch_allowed();</span>

        <span class="s0">/* by the time we got here another start could happen elsewhere, 
         * that means it should now be a regular switch. 
         * This can happen if the Python code is a subclass that implements 
         * __getattribute__ or __getattr__, or makes ``run`` a descriptor; 
         * all of those can run arbitrary code that switches back into 
         * this greenlet. 
         */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state.started()) {</span>
            <span class="s0">// the successful switch cleared these out, we need to</span>
            <span class="s0">// restore our version.</span>
            <span class="s1">assert(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args);</span>
            <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args &lt;&lt;= args;</span>

            <span class="s4">throw </span><span class="s1">GreenletStartedWhileInPython();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Sweet, if we got here, we have the go-ahead and will switch</span>
    <span class="s0">// greenlets.</span>
    <span class="s0">// Nothing we do from here on out should allow for a thread or</span>
    <span class="s0">// greenlet switch: No arbitrary calls to Python, including</span>
    <span class="s0">// decref'ing</span>

<span class="s2">#if </span><span class="s1">GREENLET_USE_CFRAME</span>
    <span class="s0">/* OK, we need it, we're about to switch greenlets, save the state. */</span>
    <span class="s0">/* 
      See green_new(). This is a stack-allocated variable used 
      while *self* is in PyObject_Call(). 
      We want to defer copying the state info until we're sure 
      we need it and are in a stable place to do so. 
    */</span>
    <span class="s1">_PyCFrame trace_info;</span>

    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.set_new_cframe(trace_info);</span>
<span class="s2">#endif</span>
    <span class="s0">/* start the greenlet */</span>
    <span class="s1">ThreadState&amp; thread_state = GET_THREAD_STATE().state();</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state = StackState(mark,</span>
                                   <span class="s1">thread_state.borrow_current()</span><span class="s5">-&gt;</span><span class="s1">stack_state);</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.set_initial_state(PyThreadState_GET());</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">exception_state.clear();</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet = thread_state.get_main_greenlet();</span>

    <span class="s0">/* perform the initial switch */</span>
    <span class="s1">switchstack_result_t err = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">g_switchstack();</span>
    <span class="s0">/* returns twice! 
       The 1st time with ``err == 1``: we are in the new greenlet. 
       This one owns a greenlet that used to be current. 
       The 2nd time with ``err &lt;= 0``: back in the caller's 
       greenlet; this happens if the child finishes or switches 
       explicitly to us. Either way, the ``err`` variable is 
       created twice at the same memory location, but possibly 
       having different ``origin`` values. Note that it's not 
       constructed for the second time until the switch actually happens. 
    */</span>
    <span class="s2">if </span><span class="s1">(err.status == </span><span class="s6">1</span><span class="s1">) {</span>
        <span class="s0">// This never returns! Calling inner_bootstrap steals</span>
        <span class="s0">// the contents of our run object within this stack frame, so</span>
        <span class="s0">// it is not valid to do anything with it.</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">inner_bootstrap(err.origin_greenlet, run);</span>
        <span class="s1">Py_FatalError(</span><span class="s3">&quot;greenlet: inner_bootstrap returned</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">// The child will take care of decrefing this.</span>
    <span class="s1">run.relinquish_ownership();</span>

    <span class="s0">// In contrast, notice that we're keeping the origin greenlet</span>
    <span class="s0">// around as an owned reference; we need it to call the trace</span>
    <span class="s0">// function for the switch back into the parent. It was only</span>
    <span class="s0">// captured at the time the switch actually happened, though,</span>
    <span class="s0">// so we haven't been keeping an extra reference around this</span>
    <span class="s0">// whole time.</span>

    <span class="s0">/* back in the parent */</span>
    <span class="s2">if </span><span class="s1">(err.status &lt; </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s0">/* start failed badly, restore greenlet state */</span>
        <span class="s0">// XXX: This code path is not tested.</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state = StackState();</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet.CLEAR();</span>
        <span class="s1">fprintf(stderr, </span><span class="s3">&quot;greenlet: g_initialstub: starting child failed.</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">err;</span>
<span class="s1">}</span>


<span class="s2">void</span>
<span class="s1">UserGreenlet::inner_bootstrap(OwnedGreenlet&amp; origin_greenlet, OwnedObject&amp; _run) G_NOEXCEPT_WIN32</span>
<span class="s1">{</span>
    <span class="s0">// The arguments here would be another great place for move.</span>
    <span class="s0">// As it is, we take them as a reference so that when we clear</span>
    <span class="s0">// them we clear what's on the stack above us. Do that NOW, and</span>
    <span class="s0">// without using a C++ RAII object,</span>
    <span class="s0">// so there's no way that exiting the parent frame can clear it,</span>
    <span class="s0">// or we clear it unexpectedly. This arises in the context of the</span>
    <span class="s0">// interpreter shutting down. See https://github.com/python-greenlet/greenlet/issues/325</span>
    <span class="s1">PyObject* run = _run.relinquish_ownership();</span>

    <span class="s0">/* in the new greenlet */</span>
    <span class="s1">assert(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">borrow_current() == </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_self);</span>
    <span class="s0">// C++ exceptions cannot propagate to the parent greenlet from</span>
    <span class="s0">// here. (TODO: Do we need a catch(...) clause, perhaps on the</span>
    <span class="s0">// function itself? ALl we could do is terminate the program.)</span>
    <span class="s0">// NOTE: On 32-bit Windows, the call chain is extremely</span>
    <span class="s0">// important here in ways that are subtle, having to do with</span>
    <span class="s0">// the depth of the SEH list. The call to restore it MUST NOT</span>
    <span class="s0">// add a new SEH handler to the list, or we'll restore it to</span>
    <span class="s0">// the wrong thing.</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">restore_exception_state();</span>
    <span class="s0">/* stack variables from above are no good and also will not unwind! */</span>
    <span class="s0">// EXCEPT: That can't be true, we access run, among others, here.</span>

    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state.set_active(); </span><span class="s0">/* running */</span>

    <span class="s0">// XXX: We could clear this much earlier, right?</span>
    <span class="s0">// Or would that introduce the possibility of running Python</span>
    <span class="s0">// code when we don't want to?</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_run_callable.CLEAR();</span>


    <span class="s0">// We're about to possibly run Python code again, which</span>
    <span class="s0">// could switch back to us, so we need to grab the</span>
    <span class="s0">// arguments locally.</span>
    <span class="s1">SwitchingArgs args;</span>
    <span class="s1">args &lt;&lt;= </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args;</span>
    <span class="s1">assert(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args);</span>

    <span class="s0">// The first switch we need to manually call the trace</span>
    <span class="s0">// function here instead of in g_switch_finish, because we</span>
    <span class="s0">// never return there.</span>

    <span class="s2">if </span><span class="s1">(OwnedObject tracefunc = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">get_tracefunc()) {</span>
        <span class="s4">try </span><span class="s1">{</span>
            <span class="s1">g_calltrace(tracefunc,</span>
                        <span class="s1">args ? mod_globs.event_switch : mod_globs.event_throw,</span>
                        <span class="s1">origin_greenlet,</span>
                        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_self);</span>
        <span class="s1">}</span>
        <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
            <span class="s0">/* Turn trace errors into switch throws */</span>
            <span class="s1">args.CLEAR();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// We no longer need the origin, it was only here for</span>
    <span class="s0">// tracing.</span>
    <span class="s0">// We may never actually exit this stack frame so we need</span>
    <span class="s0">// to explicitly clear it.</span>
    <span class="s0">// This could run Python code and switch.</span>
    <span class="s1">origin_greenlet.CLEAR();</span>

    <span class="s1">OwnedObject result;</span>
    <span class="s2">if </span><span class="s1">(!args) {</span>
        <span class="s0">/* pending exception */</span>
        <span class="s1">result = NULL;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s0">/* call g.run(*args, **kwargs) */</span>
        <span class="s0">// This could result in further switches</span>
        <span class="s4">try </span><span class="s1">{</span>
            <span class="s0">//result = run.PyCall(args.args(), args.kwargs());</span>
            <span class="s1">result = OwnedObject::consuming(PyObject_Call(run, args.args().borrow(), args.kwargs().borrow()));</span>
        <span class="s1">}</span>
        <span class="s4">catch</span><span class="s1">(...) {</span>
            <span class="s0">// Unhandled C++ exception!</span>

            <span class="s0">// If we declare ourselves as noexcept, if we don't catch</span>
            <span class="s0">// this here, most platforms will just abort() the</span>
            <span class="s0">// process. But on 64-bit Windows with older versions of</span>
            <span class="s0">// the C runtime, this can actually corrupt memory and</span>
            <span class="s0">// just return. We see this when compiling with the</span>
            <span class="s0">// Windows 7.0 SDK targeting Windows Server 2008, but not</span>
            <span class="s0">// when using the Appveyor Visual Studio 2019 image. So</span>
            <span class="s0">// this currently only affects Python 2.7 on Windows 64.</span>
            <span class="s0">// That is, the tests pass and the runtime aborts</span>
            <span class="s0">// everywhere else.</span>
            <span class="s0">//</span>
            <span class="s0">// However, if we catch it and try to continue with a</span>
            <span class="s0">// Python error, then all Windows 64 bit platforms corrupt</span>
            <span class="s0">// memory. So all we can do is manually abort, hopefully</span>
            <span class="s0">// with a good error message. (Note that the above was</span>
            <span class="s0">// tested WITHOUT the `/EHr` switch being used at compile</span>
            <span class="s0">// time, so MSVC may have &quot;optimized&quot; out important</span>
            <span class="s0">// checking. Using that switch, we may be in a better</span>
            <span class="s0">// place in terms of memory corruption.) But sometimes it</span>
            <span class="s0">// can't be caught here at all, which is confusing but not</span>
            <span class="s0">// terribly surprising; so again, the G_NOEXCEPT_WIN32</span>
            <span class="s0">// plus &quot;/EHr&quot;.</span>
            <span class="s0">//</span>
            <span class="s0">// Hopefully the basic C stdlib is still functional enough</span>
            <span class="s0">// for us to at least print an error.</span>
            <span class="s0">//</span>
            <span class="s0">// It gets more complicated than that, though, on some</span>
            <span class="s0">// platforms, specifically at least Linux/gcc/libstdc++. They use</span>
            <span class="s0">// an exception to unwind the stack when a background</span>
            <span class="s0">// thread exits. (See comments about G_NOEXCEPT.) So this</span>
            <span class="s0">// may not actually represent anything untoward. On those</span>
            <span class="s0">// platforms we allow throws of this to propagate, or</span>
            <span class="s0">// attempt to anyway.</span>
<span class="s1"># </span><span class="s2">if </span><span class="s1">defined(WIN32) || defined(_WIN32)</span>
            <span class="s1">Py_FatalError(</span>
                <span class="s3">&quot;greenlet: Unhandled C++ exception from a greenlet run function. &quot;</span>
                <span class="s3">&quot;Because memory is likely corrupted, terminating process.&quot;</span><span class="s1">);</span>
            <span class="s1">std::abort();</span>
<span class="s2">#else</span>
            <span class="s4">throw</span><span class="s1">;</span>
<span class="s2">#endif</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">args.CLEAR();</span>
    <span class="s1">Py_CLEAR(run);</span>

    <span class="s2">if </span><span class="s1">(!result</span>
        <span class="s1">&amp;&amp; mod_globs.PyExc_GreenletExit.PyExceptionMatches()</span>
        <span class="s1">&amp;&amp; (</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args)) {</span>
        <span class="s0">// This can happen, for example, if our only reference</span>
        <span class="s0">// goes away after we switch back to the parent.</span>
        <span class="s0">// See test_dealloc_switch_args_not_lost</span>
        <span class="s1">PyErrPieces clear_error;</span>
        <span class="s1">result &lt;&lt;= </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args;</span>
        <span class="s1">result = single_result(result);</span>
    <span class="s1">}</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">release_args();</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.did_finish(PyThreadState_GET());</span>

    <span class="s1">result = g_handle_exit(result);</span>
    <span class="s1">assert(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">borrow_current() == </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_self);</span>

    <span class="s0">/* jump back to parent */</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state.set_inactive(); </span><span class="s0">/* dead */</span>


    <span class="s0">// TODO: Can we decref some things here? Release our main greenlet</span>
    <span class="s0">// and maybe parent?</span>
    <span class="s2">for </span><span class="s1">(Greenlet* parent = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_parent;</span>
         <span class="s1">parent;</span>
         <span class="s1">parent = parent</span><span class="s5">-&gt;</span><span class="s1">parent()) {</span>
        <span class="s0">// We need to somewhere consume a reference to</span>
        <span class="s0">// the result; in most cases we'll never have control</span>
        <span class="s0">// back in this stack frame again. Calling</span>
        <span class="s0">// green_switch actually adds another reference!</span>
        <span class="s0">// This would probably be clearer with a specific API</span>
        <span class="s0">// to hand results to the parent.</span>
        <span class="s1">parent</span><span class="s5">-&gt;</span><span class="s1">args() &lt;&lt;= result;</span>
        <span class="s1">assert(!result);</span>
        <span class="s0">// The parent greenlet now owns the result; in the</span>
        <span class="s0">// typical case we'll never get back here to assign to</span>
        <span class="s0">// result and thus release the reference.</span>
        <span class="s4">try </span><span class="s1">{</span>
            <span class="s1">result = parent</span><span class="s5">-&gt;</span><span class="s1">g_switch();</span>
        <span class="s1">}</span>
        <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
            <span class="s0">// Ignore.</span>
        <span class="s1">}</span>

        <span class="s0">/* Return here means switch to parent failed, 
         * in which case we throw *current* exception 
         * to the next parent in chain. 
         */</span>
        <span class="s1">assert(!result);</span>
    <span class="s1">}</span>
    <span class="s0">/* We ran out of parents, cannot continue */</span>
    <span class="s1">PyErr_WriteUnraisable(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self().borrow_o());</span>
    <span class="s1">Py_FatalError(</span><span class="s3">&quot;greenlet: ran out of parent greenlets while propagating exception; &quot;</span>
                  <span class="s3">&quot;cannot continue&quot;</span><span class="s1">);</span>
    <span class="s1">std::abort();</span>
<span class="s1">}</span>


<span class="s1">Greenlet::switchstack_result_t</span>
<span class="s1">Greenlet::g_switchstack(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
    <span class="s1">{ </span><span class="s0">/* save state */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">is_current(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self())) {</span>
            <span class="s0">// Hmm, nothing to do.</span>
            <span class="s0">// TODO: Does this bypass trace events that are</span>
            <span class="s0">// important?</span>
            <span class="s2">return </span><span class="s1">switchstack_result_t(</span><span class="s6">0</span><span class="s1">,</span>
                                        <span class="s4">this</span><span class="s1">, </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">borrow_current());</span>
        <span class="s1">}</span>
        <span class="s1">BorrowedGreenlet current = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">borrow_current();</span>
        <span class="s1">PyThreadState* tstate = PyThreadState_GET();</span>
        <span class="s1">current</span><span class="s5">-&gt;</span><span class="s1">python_state &lt;&lt; tstate;</span>
        <span class="s1">current</span><span class="s5">-&gt;</span><span class="s1">exception_state &lt;&lt; tstate;</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.will_switch_from(tstate);</span>
        <span class="s1">switching_thread_state = </span><span class="s4">this</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">// If this is the first switch into a greenlet, this will</span>
    <span class="s0">// return twice, once with 1 in the new greenlet, once with 0</span>
    <span class="s0">// in the origin.</span>
    <span class="s2">int </span><span class="s1">err = slp_switch();</span>

    <span class="s2">if </span><span class="s1">(err &lt; </span><span class="s6">0</span><span class="s1">) { </span><span class="s0">/* error */</span>
        <span class="s0">// XXX: This code path is not tested.</span>
        <span class="s1">BorrowedGreenlet current(GET_THREAD_STATE().state().borrow_current());</span>
        <span class="s0">//current-&gt;top_frame = NULL; // This probably leaks?</span>
        <span class="s1">current</span><span class="s5">-&gt;</span><span class="s1">exception_state.clear();</span>

        <span class="s1">switching_thread_state = nullptr;</span>
        <span class="s0">//GET_THREAD_STATE().state().wref_target(NULL);</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">release_args();</span>
        <span class="s0">// It's important to make sure not to actually return an</span>
        <span class="s0">// owned greenlet here, no telling how long before it</span>
        <span class="s0">// could be cleaned up.</span>
        <span class="s0">// TODO: Can this be a throw? How stable is the stack in</span>
        <span class="s0">// an error case like this?</span>
        <span class="s2">return </span><span class="s1">switchstack_result_t(err);</span>
    <span class="s1">}</span>

    <span class="s0">// No stack-based variables are valid anymore.</span>

    <span class="s0">// But the global is volatile so we can reload it without the</span>
    <span class="s0">// compiler caching it from earlier.</span>
    <span class="s1">Greenlet* after_switch = switching_thread_state;</span>
    <span class="s1">OwnedGreenlet origin = after_switch</span><span class="s5">-&gt;</span><span class="s1">g_switchstack_success();</span>
    <span class="s1">switching_thread_state = nullptr;</span>
    <span class="s2">return </span><span class="s1">switchstack_result_t(err, after_switch, origin);</span>
<span class="s1">}</span>


<span class="s4">inline </span><span class="s2">void</span>
<span class="s1">Greenlet::check_switch_allowed() </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s0">// TODO: Make this take a parameter of the current greenlet,</span>
    <span class="s0">// or current main greenlet, to make the check for</span>
    <span class="s0">// cross-thread switching cheaper. Surely somewhere up the</span>
    <span class="s0">// call stack we've already accessed the thread local variable.</span>

    <span class="s0">// We expect to always have a main greenlet now; accessing the thread state</span>
    <span class="s0">// created it. However, if we get here and cleanup has already</span>
    <span class="s0">// begun because we're a greenlet that was running in a</span>
    <span class="s0">// (now dead) thread, these invariants will not hold true. In</span>
    <span class="s0">// fact, accessing `this-&gt;thread_state` may not even be possible.</span>

    <span class="s0">// If the thread this greenlet was running in is dead,</span>
    <span class="s0">// we'll still have a reference to a main greenlet, but the</span>
    <span class="s0">// thread state pointer we have is bogus.</span>
    <span class="s0">// TODO: Give the objects an API to determine if they belong</span>
    <span class="s0">// to a dead thread.</span>

    <span class="s2">const </span><span class="s1">BorrowedMainGreenlet main_greenlet = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">find_main_greenlet_in_lineage();</span>

    <span class="s2">if </span><span class="s1">(!main_greenlet) {</span>
        <span class="s4">throw </span><span class="s1">PyErrOccurred(mod_globs.PyExc_GreenletError,</span>
                            <span class="s3">&quot;cannot switch to a garbage collected greenlet&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!main_greenlet</span><span class="s5">-&gt;</span><span class="s1">thread_state()) {</span>
        <span class="s4">throw </span><span class="s1">PyErrOccurred(mod_globs.PyExc_GreenletError,</span>
                            <span class="s3">&quot;cannot switch to a different thread (which happens to have exited)&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">// The main greenlet we found was from the .parent lineage.</span>
    <span class="s0">// That may or may not have any relationship to the main</span>
    <span class="s0">// greenlet of the running thread. We can't actually access</span>
    <span class="s0">// our this-&gt;thread_state members to try to check that,</span>
    <span class="s0">// because it could be in the process of getting destroyed,</span>
    <span class="s0">// but setting the main_greenlet-&gt;thread_state member to NULL</span>
    <span class="s0">// may not be visible yet. So we need to check against the</span>
    <span class="s0">// current thread state (once the cheaper checks are out of</span>
    <span class="s0">// the way)</span>
    <span class="s2">const </span><span class="s1">BorrowedMainGreenlet current_main_greenlet = GET_THREAD_STATE().state().borrow_main_greenlet();</span>
    <span class="s2">if </span><span class="s1">(</span>
        <span class="s0">// lineage main greenlet is not this thread's greenlet</span>
        <span class="s1">current_main_greenlet != main_greenlet</span>
        <span class="s1">|| (</span>
            <span class="s0">// atteched to some thread</span>
            <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">main_greenlet()</span>
            <span class="s0">// XXX: Same condition as above. Was this supposed to be</span>
            <span class="s0">// this-&gt;main_greenlet()?</span>
            <span class="s1">&amp;&amp; current_main_greenlet != main_greenlet)</span>
        <span class="s0">// switching into a known dead thread (XXX: which, if we get here,</span>
        <span class="s0">// is bad, because we just accessed the thread state, which is</span>
        <span class="s0">// gone!)</span>
        <span class="s1">|| (!current_main_greenlet</span><span class="s5">-&gt;</span><span class="s1">thread_state())) {</span>
        <span class="s4">throw </span><span class="s1">PyErrOccurred(mod_globs.PyExc_GreenletError,</span>
                            <span class="s3">&quot;cannot switch to a different thread&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>


<span class="s1">OwnedObject</span>
<span class="s1">Greenlet::g_switch_finish(</span><span class="s2">const </span><span class="s1">switchstack_result_t&amp; err)</span>
<span class="s1">{</span>

    <span class="s1">ThreadState&amp; state = *</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state();</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s0">// Our only caller handles the bad error case</span>
        <span class="s1">assert(err.status &gt;= </span><span class="s6">0</span><span class="s1">);</span>
        <span class="s1">assert(state.borrow_current() == </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self());</span>

        <span class="s2">if </span><span class="s1">(OwnedObject tracefunc = state.get_tracefunc()) {</span>
            <span class="s1">g_calltrace(tracefunc,</span>
                        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">args() ? mod_globs.event_switch : mod_globs.event_throw,</span>
                        <span class="s1">err.origin_greenlet,</span>
                        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self());</span>
        <span class="s1">}</span>
        <span class="s0">// The above could have invoked arbitrary Python code, but</span>
        <span class="s0">// it couldn't switch back to this object and *also*</span>
        <span class="s0">// throw an exception, so the args won't have changed.</span>

        <span class="s2">if </span><span class="s1">(PyErr_Occurred()) {</span>
            <span class="s0">// We get here if we fell of the end of the run() function</span>
            <span class="s0">// raising an exception. The switch itself was</span>
            <span class="s0">// successful, but the function raised.</span>
            <span class="s0">// valgrind reports that memory allocated here can still</span>
            <span class="s0">// be reached after a test run.</span>
            <span class="s4">throw </span><span class="s1">PyErrOccurred();</span>
        <span class="s1">}</span>

        <span class="s1">OwnedObject result;</span>
        <span class="s1">result &lt;&lt;= </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args;</span>
        <span class="s1">assert(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args);</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s0">/* Turn switch errors into switch throws */</span>
        <span class="s0">/* Turn trace errors into switch throws */</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">release_args();</span>
        <span class="s4">throw</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>


<span class="s1">greenlet::PythonAllocator&lt;UserGreenlet&gt; UserGreenlet::allocator;</span>
<span class="s1">greenlet::PythonAllocator&lt;MainGreenlet&gt; MainGreenlet::allocator;</span>


<span class="s2">extern </span><span class="s3">&quot;C&quot; </span><span class="s1">{</span>
<span class="s2">static int </span><span class="s1">GREENLET_NOINLINE(slp_save_state_trampoline)(</span><span class="s2">char</span><span class="s1">* stackref)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">switching_thread_state</span><span class="s5">-&gt;</span><span class="s1">slp_save_state(stackref);</span>
<span class="s1">}</span>
<span class="s2">static void </span><span class="s1">GREENLET_NOINLINE(slp_restore_state_trampoline)()</span>
<span class="s1">{</span>
    <span class="s1">switching_thread_state</span><span class="s5">-&gt;</span><span class="s1">slp_restore_state();</span>
<span class="s1">}</span>
<span class="s1">}</span>



<span class="s0">/***********************************************************/</span>

<span class="s4">class </span><span class="s1">TracingGuard</span>
<span class="s1">{</span>
<span class="s4">private</span><span class="s1">:</span>
    <span class="s1">PyThreadState* tstate;</span>
<span class="s4">public</span><span class="s1">:</span>
    <span class="s1">TracingGuard()</span>
        <span class="s1">: tstate(PyThreadState_GET())</span>
    <span class="s1">{</span>
        <span class="s1">PyThreadState_EnterTracing(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">tstate);</span>
    <span class="s1">}</span>

    <span class="s1">~TracingGuard()</span>
    <span class="s1">{</span>
        <span class="s1">PyThreadState_LeaveTracing(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">tstate);</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">tstate = nullptr;</span>
    <span class="s1">}</span>

    <span class="s4">inline </span><span class="s2">void </span><span class="s1">CallTraceFunction(</span><span class="s2">const </span><span class="s1">OwnedObject&amp; tracefunc,</span>
                                  <span class="s2">const </span><span class="s1">ImmortalEventName&amp; event,</span>
                                  <span class="s2">const </span><span class="s1">BorrowedGreenlet&amp; origin,</span>
                                  <span class="s2">const </span><span class="s1">BorrowedGreenlet&amp; target)</span>
    <span class="s1">{</span>
        <span class="s0">// TODO: This calls tracefunc(event, (origin, target)). Add a shortcut</span>
        <span class="s0">// function for that that's specialized to avoid the Py_BuildValue</span>
        <span class="s0">// string parsing, or start with just using &quot;ON&quot; format with PyTuple_Pack(2,</span>
        <span class="s0">// origin, target). That seems like what the N format is meant</span>
        <span class="s0">// for.</span>
        <span class="s0">// XXX: Why does event not automatically cast back to a PyObject?</span>
        <span class="s0">// It tries to call the &quot;deleted constructor ImmortalEventName</span>
        <span class="s0">// const&quot; instead.</span>
        <span class="s1">assert(tracefunc);</span>
        <span class="s1">assert(event);</span>
        <span class="s1">assert(origin);</span>
        <span class="s1">assert(target);</span>
        <span class="s1">NewReference retval(PyObject_CallFunction(tracefunc.borrow(),</span>
                                             <span class="s3">&quot;O(OO)&quot;</span><span class="s1">,</span>
                                             <span class="s1">event.borrow(),</span>
                                             <span class="s1">origin.borrow(),</span>
                                             <span class="s1">target.borrow()));</span>
        <span class="s2">if </span><span class="s1">(!retval) {</span>
            <span class="s4">throw </span><span class="s1">PyErrOccurred();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s2">static void</span>
<span class="s1">g_calltrace(</span><span class="s2">const </span><span class="s1">OwnedObject&amp; tracefunc,</span>
            <span class="s2">const </span><span class="s1">ImmortalEventName&amp; event,</span>
            <span class="s2">const </span><span class="s1">BorrowedGreenlet&amp; origin,</span>
            <span class="s2">const </span><span class="s1">BorrowedGreenlet&amp; target)</span>
<span class="s1">{</span>
    <span class="s1">PyErrPieces saved_exc;</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">TracingGuard tracing_guard;</span>
        <span class="s1">tracing_guard.CallTraceFunction(tracefunc, event, origin, target);</span>
    <span class="s1">}</span>
    <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s0">// In case of exceptions trace function is removed,</span>
        <span class="s0">// and any existing exception is replaced with the tracing</span>
        <span class="s0">// exception.</span>
        <span class="s1">GET_THREAD_STATE().state().set_tracefunc(Py_None);</span>
        <span class="s4">throw</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">saved_exc.PyErrRestore();</span>
<span class="s1">}</span>



<span class="s2">static </span><span class="s1">OwnedObject</span>
<span class="s1">g_handle_exit(</span><span class="s2">const </span><span class="s1">OwnedObject&amp; greenlet_result)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!greenlet_result &amp;&amp; mod_globs.PyExc_GreenletExit.PyExceptionMatches()) {</span>
        <span class="s0">/* catch and ignore GreenletExit */</span>
        <span class="s1">PyErrFetchParam val;</span>
        <span class="s1">PyErr_Fetch(PyErrFetchParam(), val, PyErrFetchParam());</span>
        <span class="s2">if </span><span class="s1">(!val) {</span>
            <span class="s2">return </span><span class="s1">OwnedObject::None();</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">OwnedObject(val);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(greenlet_result) {</span>
        <span class="s0">// package the result into a 1-tuple</span>
        <span class="s0">// PyTuple_Pack increments the reference of its arguments,</span>
        <span class="s0">// so we always need to decref the greenlet result;</span>
        <span class="s0">// the owner will do that.</span>
        <span class="s2">return </span><span class="s1">OwnedObject::consuming(PyTuple_Pack(</span><span class="s6">1</span><span class="s1">, greenlet_result.borrow()));</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">OwnedObject();</span>
<span class="s1">}</span>



<span class="s0">/***********************************************************/</span>

<span class="s2">static </span><span class="s1">PyGreenlet*</span>
<span class="s1">green_new(PyTypeObject* type, PyObject* UNUSED(args), PyObject* UNUSED(kwds))</span>
<span class="s1">{</span>
    <span class="s1">PyGreenlet* o =</span>
        <span class="s1">(PyGreenlet*)PyBaseObject_Type.tp_new(type, mod_globs.empty_tuple, mod_globs.empty_dict);</span>
    <span class="s2">if </span><span class="s1">(o) {</span>
        <span class="s4">new </span><span class="s1">UserGreenlet(o, GET_THREAD_STATE().state().borrow_current());</span>
        <span class="s1">assert(Py_REFCNT(o) == </span><span class="s6">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">o;</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">green_setrun(BorrowedGreenlet self, BorrowedObject nrun, </span><span class="s2">void</span><span class="s1">* c);</span>
<span class="s2">static int</span>
<span class="s1">green_setparent(BorrowedGreenlet self, BorrowedObject nparent, </span><span class="s2">void</span><span class="s1">* c);</span>

<span class="s2">static int</span>
<span class="s1">green_init(BorrowedGreenlet self, BorrowedObject args, BorrowedObject kwargs)</span>
<span class="s1">{</span>
    <span class="s1">PyArgParseParam run;</span>
    <span class="s1">PyArgParseParam nparent;</span>
    <span class="s2">static const char</span><span class="s1">* </span><span class="s2">const </span><span class="s1">kwlist[] = {</span>
        <span class="s3">&quot;run&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;parent&quot;</span><span class="s1">,</span>
        <span class="s1">NULL</span>
    <span class="s1">};</span>

    <span class="s0">// recall: The O specifier does NOT increase the reference count.</span>
    <span class="s2">if </span><span class="s1">(!PyArg_ParseTupleAndKeywords(</span>
             <span class="s1">args, kwargs, </span><span class="s3">&quot;|OO:green&quot;</span><span class="s1">, (</span><span class="s2">char</span><span class="s1">**)kwlist, &amp;run, &amp;nparent)) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(run) {</span>
        <span class="s2">if </span><span class="s1">(green_setrun(self, run, NULL)) {</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(nparent &amp;&amp; !nparent.is_None()) {</span>
        <span class="s2">return </span><span class="s1">green_setparent(self, nparent, NULL);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s1">UserGreenlet::ParentIsCurrentGuard::ParentIsCurrentGuard(UserGreenlet* p,</span>
                                                     <span class="s2">const </span><span class="s1">ThreadState&amp; thread_state)</span>
    <span class="s1">: oldparent(p</span><span class="s5">-&gt;</span><span class="s1">_parent),</span>
      <span class="s1">greenlet(p)</span>
<span class="s1">{</span>
    <span class="s1">p</span><span class="s5">-&gt;</span><span class="s1">_parent = thread_state.get_current();</span>
<span class="s1">}</span>

<span class="s1">UserGreenlet::ParentIsCurrentGuard::~ParentIsCurrentGuard()</span>
<span class="s1">{</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">greenlet</span><span class="s5">-&gt;</span><span class="s1">_parent = oldparent;</span>
    <span class="s1">oldparent.CLEAR();</span>
<span class="s1">}</span>


<span class="s2">void</span>
<span class="s1">Greenlet::murder_in_place()</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">active()) {</span>
        <span class="s1">assert(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">is_currently_running_in_some_thread());</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">deactivate_and_free();</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">void</span>
<span class="s1">UserGreenlet::murder_in_place()</span>
<span class="s1">{</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet.CLEAR();</span>
    <span class="s1">Greenlet::murder_in_place();</span>
<span class="s1">}</span>

<span class="s4">inline </span><span class="s2">void</span>
<span class="s1">Greenlet::deactivate_and_free()</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">active()) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">// Throw away any saved stack.</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state = StackState();</span>
    <span class="s1">assert(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state.active());</span>
    <span class="s0">// Throw away any Python references.</span>
    <span class="s0">// We're holding a borrowed reference to the last</span>
    <span class="s0">// frame we executed. Since we borrowed it, the</span>
    <span class="s0">// normal traversal, clear, and dealloc functions</span>
    <span class="s0">// ignore it, meaning it leaks. (The thread state</span>
    <span class="s0">// object can't find it to clear it when that's</span>
    <span class="s0">// deallocated either, because by definition if we</span>
    <span class="s0">// got an object on this list, it wasn't</span>
    <span class="s0">// running and the thread state doesn't have</span>
    <span class="s0">// this frame.)</span>
    <span class="s0">// So here, we *do* clear it.</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.tp_clear(</span><span class="s4">true</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">bool</span>
<span class="s1">Greenlet::belongs_to_thread(</span><span class="s2">const </span><span class="s1">ThreadState* thread_state) </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state() </span><span class="s0">// not running anywhere, or thread</span>
                              <span class="s0">// exited</span>
        <span class="s1">|| !thread_state) { </span><span class="s0">// same, or there is no thread state.</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s4">true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">bool</span>
<span class="s1">UserGreenlet::belongs_to_thread(</span><span class="s2">const </span><span class="s1">ThreadState* thread_state) </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">Greenlet::belongs_to_thread(thread_state) &amp;&amp; </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet == thread_state</span><span class="s5">-&gt;</span><span class="s1">borrow_main_greenlet();</span>
<span class="s1">}</span>

<span class="s2">void</span>
<span class="s1">Greenlet::deallocing_greenlet_in_thread(</span><span class="s2">const </span><span class="s1">ThreadState* current_thread_state)</span>
<span class="s1">{</span>
    <span class="s0">/* Cannot raise an exception to kill the greenlet if 
       it is not running in the same thread! */</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">belongs_to_thread(current_thread_state)) {</span>
        <span class="s1">assert(current_thread_state);</span>
        <span class="s0">// To get here it had to have run before</span>
        <span class="s0">/* Send the greenlet a GreenletExit exception. */</span>

        <span class="s0">// We don't care about the return value, only whether an</span>
        <span class="s0">// exception happened.</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">throw_GreenletExit_during_dealloc(*current_thread_state);</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Not the same thread! Temporarily save the greenlet</span>
    <span class="s0">// into its thread's deleteme list, *if* it exists.</span>
    <span class="s0">// If that thread has already exited, and processed its pending</span>
    <span class="s0">// cleanup, we'll never be able to clean everything up: we won't</span>
    <span class="s0">// be able to raise an exception.</span>
    <span class="s0">// That's mostly OK! Since we can't add it to a list, our refcount</span>
    <span class="s0">// won't increase, and we'll go ahead with the DECREFs later.</span>
    <span class="s1">ThreadState *</span><span class="s2">const  </span><span class="s1">thread_state = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state();</span>
    <span class="s2">if </span><span class="s1">(thread_state) {</span>
        <span class="s1">thread_state</span><span class="s5">-&gt;</span><span class="s1">delete_when_thread_running(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self());</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// The thread is dead, we can't raise an exception.</span>
        <span class="s0">// We need to make it look non-active, though, so that dealloc</span>
        <span class="s0">// finishes killing it.</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">deactivate_and_free();</span>
    <span class="s1">}</span>
    <span class="s2">return</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s2">int</span>
<span class="s1">Greenlet::tp_traverse(visitproc visit, </span><span class="s2">void</span><span class="s1">* arg)</span>
<span class="s1">{</span>

    <span class="s2">int </span><span class="s1">result;</span>
    <span class="s2">if </span><span class="s1">((result = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">exception_state.tp_traverse(visit, arg)) != </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s0">//XXX: This is ugly. But so is handling everything having to do</span>
    <span class="s0">//with the top frame.</span>
    <span class="s2">bool </span><span class="s1">visit_top_frame = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">was_running_in_dead_thread();</span>
    <span class="s0">// When true, the thread is dead. Our implicit weak reference to the</span>
    <span class="s0">// frame is now all that's left; we consider ourselves to</span>
    <span class="s0">// strongly own it now.</span>
    <span class="s2">if </span><span class="s1">((result = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.tp_traverse(visit, arg, visit_top_frame)) != </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">int</span>
<span class="s1">UserGreenlet::tp_traverse(visitproc visit, </span><span class="s2">void</span><span class="s1">* arg)</span>
<span class="s1">{</span>
    <span class="s1">Py_VISIT(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_parent.borrow_o());</span>
    <span class="s1">Py_VISIT(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet.borrow_o());</span>
    <span class="s1">Py_VISIT(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_run_callable.borrow_o());</span>

    <span class="s2">return </span><span class="s1">Greenlet::tp_traverse(visit, arg);</span>
<span class="s1">}</span>

<span class="s2">int</span>
<span class="s1">MainGreenlet::tp_traverse(visitproc visit, </span><span class="s2">void</span><span class="s1">* arg)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_thread_state) {</span>
        <span class="s0">// we've already traversed main, (self), don't do it again.</span>
        <span class="s2">int </span><span class="s1">result = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_thread_state</span><span class="s5">-&gt;</span><span class="s1">tp_traverse(visit, arg, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(result) {</span>
            <span class="s2">return </span><span class="s1">result;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">Greenlet::tp_traverse(visit, arg);</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">green_traverse(PyGreenlet* self, visitproc visit, </span><span class="s2">void</span><span class="s1">* arg)</span>
<span class="s1">{</span>
    <span class="s0">// We must only visit referenced objects, i.e. only objects</span>
    <span class="s0">// Py_INCREF'ed by this greenlet (directly or indirectly):</span>
    <span class="s0">//</span>
    <span class="s0">// - stack_prev is not visited: holds previous stack pointer, but it's not</span>
    <span class="s0">//    referenced</span>
    <span class="s0">// - frames are not visited as we don't strongly reference them;</span>
    <span class="s0">//    alive greenlets are not garbage collected</span>
    <span class="s0">//    anyway. This can be a problem, however, if this greenlet is</span>
    <span class="s0">//    never allowed to finish, and is referenced from the frame: we</span>
    <span class="s0">//    have an uncollectible cycle in that case. Note that the</span>
    <span class="s0">//    frame object itself is also frequently not even tracked by the GC</span>
    <span class="s0">//    starting with Python 3.7 (frames are allocated by the</span>
    <span class="s0">//    interpreter untracked, and only become tracked when their</span>
    <span class="s0">//    evaluation is finished if they have a refcount &gt; 1). All of</span>
    <span class="s0">//    this is to say that we should probably strongly reference</span>
    <span class="s0">//    the frame object. Doing so, while always allowing GC on a</span>
    <span class="s0">//    greenlet, solves several leaks for us.</span>

    <span class="s1">Py_VISIT(self</span><span class="s5">-&gt;</span><span class="s1">dict);</span>
    <span class="s2">if </span><span class="s1">(!self</span><span class="s5">-&gt;</span><span class="s1">pimpl) {</span>
        <span class="s0">// Hmm. I have seen this at interpreter shutdown time,</span>
        <span class="s0">// I think. That's very odd because this doesn't go away until</span>
        <span class="s0">// we're ``green_dealloc()``, at which point we shouldn't be</span>
        <span class="s0">// traversed anymore.</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">tp_traverse(visit, arg);</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">green_is_gc(BorrowedGreenlet self)</span>
<span class="s1">{</span>
    <span class="s2">int </span><span class="s1">result = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s0">/* Main greenlet can be garbage collected since it can only 
       become unreachable if the underlying thread exited. 
       Active greenlets --- including those that are suspended --- 
       cannot be garbage collected, however. 
    */</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">main() || !self</span><span class="s5">-&gt;</span><span class="s1">active()) {</span>
        <span class="s1">result = </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">// The main greenlet pointer will eventually go away after the thread dies.</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">was_running_in_dead_thread()) {</span>
        <span class="s0">// Our thread is dead! We can never run again. Might as well</span>
        <span class="s0">// GC us. Note that if a tuple containing only us and other</span>
        <span class="s0">// immutable objects had been scanned before this, when we</span>
        <span class="s0">// would have returned 0, the tuple will take itself out of GC</span>
        <span class="s0">// tracking and never be investigated again. So that could</span>
        <span class="s0">// result in both us and the tuple leaking due to an</span>
        <span class="s0">// unreachable/uncollectible reference. The same goes for</span>
        <span class="s0">// dictionaries.</span>
        <span class="s0">//</span>
        <span class="s0">// It's not a great idea to be changing our GC state on the</span>
        <span class="s0">// fly.</span>
        <span class="s1">result = </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>


<span class="s2">int</span>
<span class="s1">Greenlet::tp_clear()</span>
<span class="s1">{</span>
    <span class="s2">bool </span><span class="s1">own_top_frame = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">was_running_in_dead_thread();</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">exception_state.tp_clear();</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.tp_clear(own_top_frame);</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">int</span>
<span class="s1">UserGreenlet::tp_clear()</span>
<span class="s1">{</span>
    <span class="s1">Greenlet::tp_clear();</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_parent.CLEAR();</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet.CLEAR();</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_run_callable.CLEAR();</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s2">static int</span>
<span class="s1">green_clear(PyGreenlet* self)</span>
<span class="s1">{</span>
    <span class="s0">/* Greenlet is only cleared if it is about to be collected. 
       Since active greenlets are not garbage collectable, we can 
       be sure that, even if they are deallocated during clear, 
       nothing they reference is in unreachable or finalizers, 
       so even if it switches we are relatively safe. */</span>
    <span class="s0">// XXX: Are we responsible for clearing weakrefs here?</span>
    <span class="s1">Py_CLEAR(self</span><span class="s5">-&gt;</span><span class="s1">dict);</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">tp_clear();</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Returns 0 on failure (the object was resurrected) or 1 on success. 
 **/</span>
<span class="s2">static int</span>
<span class="s1">_green_dealloc_kill_started_non_main_greenlet(BorrowedGreenlet self)</span>
<span class="s1">{</span>
    <span class="s0">/* Hacks hacks hacks copied from instance_dealloc() */</span>
    <span class="s0">/* Temporarily resurrect the greenlet. */</span>
    <span class="s1">assert(self.REFCNT() == </span><span class="s6">0</span><span class="s1">);</span>
    <span class="s1">Py_SET_REFCNT(self.borrow(), </span><span class="s6">1</span><span class="s1">);</span>
    <span class="s0">/* Save the current exception, if any. */</span>
    <span class="s1">PyErrPieces saved_err;</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s0">// BY THE TIME WE GET HERE, the state may actually be going</span>
        <span class="s0">// away</span>
        <span class="s0">// if we're shutting down the interpreter and freeing thread</span>
        <span class="s0">// entries,</span>
        <span class="s0">// this could result in freeing greenlets that were leaked. So</span>
        <span class="s0">// we can't try to read the state.</span>
        <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">deallocing_greenlet_in_thread(</span>
              <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span>
              <span class="s1">? </span><span class="s4">static_cast</span><span class="s1">&lt;ThreadState*&gt;(GET_THREAD_STATE())</span>
              <span class="s1">: nullptr);</span>
    <span class="s1">}</span>
    <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s1">PyErr_WriteUnraisable(self.borrow_o());</span>
        <span class="s0">/* XXX what else should we do? */</span>
    <span class="s1">}</span>
    <span class="s0">/* Check for no resurrection must be done while we keep 
     * our internal reference, otherwise PyFile_WriteObject 
     * causes recursion if using Py_INCREF/Py_DECREF 
     */</span>
    <span class="s2">if </span><span class="s1">(self.REFCNT() == </span><span class="s6">1 </span><span class="s1">&amp;&amp; self</span><span class="s5">-&gt;</span><span class="s1">active()) {</span>
        <span class="s0">/* Not resurrected, but still not dead! 
           XXX what else should we do? we complain. */</span>
        <span class="s1">PyObject* f = PySys_GetObject(</span><span class="s3">&quot;stderr&quot;</span><span class="s1">);</span>
        <span class="s1">Py_INCREF(self.borrow_o()); </span><span class="s0">/* leak! */</span>
        <span class="s2">if </span><span class="s1">(f != NULL) {</span>
            <span class="s1">PyFile_WriteString(</span><span class="s3">&quot;GreenletExit did not kill &quot;</span><span class="s1">, f);</span>
            <span class="s1">PyFile_WriteObject(self.borrow_o(), f, </span><span class="s6">0</span><span class="s1">);</span>
            <span class="s1">PyFile_WriteString(</span><span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">, f);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">/* Restore the saved exception. */</span>
    <span class="s1">saved_err.PyErrRestore();</span>
    <span class="s0">/* Undo the temporary resurrection; can't use DECREF here, 
     * it would cause a recursive call. 
     */</span>
    <span class="s1">assert(self.REFCNT() &gt; </span><span class="s6">0</span><span class="s1">);</span>

    <span class="s1">Py_ssize_t refcnt = self.REFCNT() - </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">Py_SET_REFCNT(self.borrow_o(), refcnt);</span>
    <span class="s2">if </span><span class="s1">(refcnt != </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s0">/* Resurrected! */</span>
        <span class="s1">_Py_NewReference(self.borrow_o());</span>
        <span class="s1">Py_SET_REFCNT(self.borrow_o(), refcnt);</span>
        <span class="s0">/* Better to use tp_finalizer slot (PEP 442) 
         * and call ``PyObject_CallFinalizerFromDealloc``, 
         * but that's only supported in Python 3.4+; see 
         * Modules/_io/iobase.c for an example. 
         * 
         * The following approach is copied from iobase.c in CPython 2.7. 
         * (along with much of this function in general). Here's their 
         * comment: 
         * 
         * When called from a heap type's dealloc, the type will be 
         * decref'ed on return (see e.g. subtype_dealloc in typeobject.c). */</span>
        <span class="s2">if </span><span class="s1">(PyType_HasFeature(self.TYPE(), Py_TPFLAGS_HEAPTYPE)) {</span>
            <span class="s1">Py_INCREF(self.TYPE());</span>
        <span class="s1">}</span>

        <span class="s1">PyObject_GC_Track((PyObject*)self);</span>

        <span class="s1">_Py_DEC_REFTOTAL;</span>
<span class="s2">#ifdef </span><span class="s1">COUNT_ALLOCS</span>
        <span class="s1">--Py_TYPE(self)</span><span class="s5">-&gt;</span><span class="s1">tp_frees;</span>
        <span class="s1">--Py_TYPE(self)</span><span class="s5">-&gt;</span><span class="s1">tp_allocs;</span>
<span class="s2">#endif </span><span class="s0">/* COUNT_ALLOCS */</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s6">1</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s1">Greenlet::~Greenlet()</span>
<span class="s1">{</span>
    <span class="s0">// XXX: Can't do this. tp_clear is a virtual function, and by the</span>
    <span class="s0">// time we're here, we've sliced off our child classes.</span>
    <span class="s0">//this-&gt;tp_clear();</span>
<span class="s1">}</span>

<span class="s1">UserGreenlet::~UserGreenlet()</span>
<span class="s1">{</span>
    <span class="s0">// Python 3.11: If we don't clear out the raw frame datastack</span>
    <span class="s0">// when deleting an unfinished greenlet,</span>
    <span class="s0">// TestLeaks.test_untracked_memory_doesnt_increase_unfinished_thread_dealloc_in_main fails.</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.did_finish(nullptr);</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">tp_clear();</span>
<span class="s1">}</span>

<span class="s1">MainGreenlet::~MainGreenlet()</span>
<span class="s1">{</span>
    <span class="s1">total_main_greenlets--;</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">tp_clear();</span>
<span class="s1">}</span>

<span class="s2">static void</span>
<span class="s1">green_dealloc(PyGreenlet* self)</span>
<span class="s1">{</span>
    <span class="s1">PyObject_GC_UnTrack(self);</span>
    <span class="s1">BorrowedGreenlet me(self);</span>
    <span class="s2">if </span><span class="s1">(me</span><span class="s5">-&gt;</span><span class="s1">active()</span>
        <span class="s1">&amp;&amp; me</span><span class="s5">-&gt;</span><span class="s1">started()</span>
        <span class="s1">&amp;&amp; !me</span><span class="s5">-&gt;</span><span class="s1">main()) {</span>
        <span class="s2">if </span><span class="s1">(!_green_dealloc_kill_started_non_main_greenlet(me)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">weakreflist != NULL) {</span>
        <span class="s1">PyObject_ClearWeakRefs((PyObject*)self);</span>
    <span class="s1">}</span>
    <span class="s1">Py_CLEAR(self</span><span class="s5">-&gt;</span><span class="s1">dict);</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">pimpl) {</span>
        <span class="s0">// In case deleting this, which frees some memory,</span>
        <span class="s0">// somehow winds up calling back into us. That's usually a</span>
        <span class="s0">//bug in our code.</span>
        <span class="s1">Greenlet* p = self</span><span class="s5">-&gt;</span><span class="s1">pimpl;</span>
        <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl = nullptr;</span>
        <span class="s2">delete </span><span class="s1">p;</span>
    <span class="s1">}</span>
    <span class="s0">// and finally we're done. self is now invalid.</span>
    <span class="s1">Py_TYPE(self)</span><span class="s5">-&gt;</span><span class="s1">tp_free((PyObject*)self);</span>
<span class="s1">}</span>



<span class="s2">static </span><span class="s1">OwnedObject</span>
<span class="s1">throw_greenlet(BorrowedGreenlet self, PyErrPieces&amp; err_pieces)</span>
<span class="s1">{</span>
    <span class="s1">PyObject* result = nullptr;</span>
    <span class="s1">err_pieces.PyErrRestore();</span>
    <span class="s1">assert(PyErr_Occurred());</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">started() &amp;&amp; !self</span><span class="s5">-&gt;</span><span class="s1">active()) {</span>
        <span class="s0">/* dead greenlet: turn GreenletExit into a regular return */</span>
        <span class="s1">result = g_handle_exit(OwnedObject()).relinquish_ownership();</span>
    <span class="s1">}</span>

    <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">args() &lt;&lt;= result;</span>

    <span class="s2">return </span><span class="s1">single_result(self</span><span class="s5">-&gt;</span><span class="s1">g_switch());</span>
<span class="s1">}</span>



<span class="s1">PyDoc_STRVAR(</span>
    <span class="s1">green_switch_doc,</span>
    <span class="s3">&quot;switch(*args, **kwargs)</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;Switch execution to this greenlet.</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;If this greenlet has never been run, then this greenlet</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;will be switched to using the body of ``self.run(*args, **kwargs)``.</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;If the greenlet is active (has been run, but was switch()'ed</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;out before leaving its run function), then this greenlet will</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;be resumed and the return value to its switch call will be</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;None if no arguments are given, the given argument if one</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;argument is given, or the args tuple and keyword args dict if</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;multiple arguments are given.</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;If the greenlet is dead, or is the current greenlet then this</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;function will simply return the arguments using the same rules as</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;above.</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_switch(PyGreenlet* self, PyObject* args, PyObject* kwargs)</span>
<span class="s1">{</span>
    <span class="s4">using </span><span class="s1">greenlet::SwitchingArgs;</span>
    <span class="s1">SwitchingArgs switch_args(OwnedObject::owning(args), OwnedObject::owning(kwargs));</span>
    <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">args() &lt;&lt;= switch_args;</span>


    <span class="s0">// If we're switching out of a greenlet, and that switch is the</span>
    <span class="s0">// last thing the greenlet does, the greenlet ought to be able to</span>
    <span class="s0">// go ahead and die at that point. Currently, someone else must</span>
    <span class="s0">// manually switch back to the greenlet so that we &quot;fall off the</span>
    <span class="s0">// end&quot; and can perform cleanup. You'd think we'd be able to</span>
    <span class="s0">// figure out that this is happening using the frame's ``f_lasti``</span>
    <span class="s0">// member, which is supposed to be an index into</span>
    <span class="s0">// ``frame-&gt;f_code-&gt;co_code``, the bytecode string. However, in</span>
    <span class="s0">// recent interpreters, ``f_lasti`` tends not to be updated thanks</span>
    <span class="s0">// to things like the PREDICT() macros in ceval.c. So it doesn't</span>
    <span class="s0">// really work to do that in many cases. For example, the Python</span>
    <span class="s0">// code:</span>
    <span class="s0">//     def run():</span>
    <span class="s0">//         greenlet.getcurrent().parent.switch()</span>
    <span class="s0">// produces bytecode of len 16, with the actual call to switch()</span>
    <span class="s0">// being at index 10 (in Python 3.10). However, the reported</span>
    <span class="s0">// ``f_lasti`` we actually see is...5! (Which happens to be the</span>
    <span class="s0">// second byte of the CALL_METHOD op for ``getcurrent()``).</span>

    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">OwnedObject result = single_result(self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">g_switch());</span>
<span class="s2">#ifndef </span><span class="s1">NDEBUG</span>
        <span class="s0">// Note that the current greenlet isn't necessarily self. If self</span>
        <span class="s0">// finished, we went to one of its parents.</span>
        <span class="s1">assert(!self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">args());</span>

        <span class="s2">const </span><span class="s1">BorrowedGreenlet&amp; current = GET_THREAD_STATE().state().borrow_current();</span>
        <span class="s0">// It's possible it's never been switched to.</span>
        <span class="s1">assert(!current</span><span class="s5">-&gt;</span><span class="s1">args());</span>
<span class="s2">#endif</span>
        <span class="s2">return </span><span class="s1">result.relinquish_ownership();</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">PyDoc_STRVAR(</span>
    <span class="s1">green_throw_doc,</span>
    <span class="s3">&quot;Switches execution to this greenlet, but immediately raises the</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;given exception in this greenlet.  If no argument is provided, the &quot;</span>
    <span class="s3">&quot;exception</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;defaults to `greenlet.GreenletExit`.  The normal exception</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;propagation rules apply, as described for `switch`.  Note that calling &quot;</span>
    <span class="s3">&quot;this</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;method is almost equivalent to the following::</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;    def raiser():</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;        raise typ, val, tb</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;    g_raiser = greenlet(raiser, parent=g)</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;    g_raiser.switch()</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;except that this trick does not work for the</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;`greenlet.GreenletExit` exception, which would not propagate</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;from ``g_raiser`` to ``g``.</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_throw(PyGreenlet* self, PyObject* args)</span>
<span class="s1">{</span>
    <span class="s1">PyArgParseParam typ(mod_globs.PyExc_GreenletExit);</span>
    <span class="s1">PyArgParseParam val;</span>
    <span class="s1">PyArgParseParam tb;</span>

    <span class="s2">if </span><span class="s1">(!PyArg_ParseTuple(args, </span><span class="s3">&quot;|OOO:throw&quot;</span><span class="s1">, &amp;typ, &amp;val, &amp;tb)) {</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s4">try </span><span class="s1">{</span>
        <span class="s0">// Both normalizing the error and the actual throw_greenlet</span>
        <span class="s0">// could throw PyErrOccurred.</span>
        <span class="s1">PyErrPieces err_pieces(typ.borrow(), val.borrow(), tb.borrow());</span>

        <span class="s2">return </span><span class="s1">throw_greenlet(self, err_pieces).relinquish_ownership();</span>
    <span class="s1">}</span>
    <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">green_bool(PyGreenlet* self)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">active();</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getdict(PyGreenlet* self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">dict == NULL) {</span>
        <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">dict = PyDict_New();</span>
        <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">dict == NULL) {</span>
            <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">Py_INCREF(self</span><span class="s5">-&gt;</span><span class="s1">dict);</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">dict;</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">green_setdict(PyGreenlet* self, PyObject* val, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s1">PyObject* tmp;</span>

    <span class="s2">if </span><span class="s1">(val == NULL) {</span>
        <span class="s1">PyErr_SetString(PyExc_TypeError, </span><span class="s3">&quot;__dict__ may not be deleted&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!PyDict_Check(val)) {</span>
        <span class="s1">PyErr_SetString(PyExc_TypeError, </span><span class="s3">&quot;__dict__ must be a dictionary&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">tmp = self</span><span class="s5">-&gt;</span><span class="s1">dict;</span>
    <span class="s1">Py_INCREF(val);</span>
    <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">dict = val;</span>
    <span class="s1">Py_XDECREF(tmp);</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static bool</span>
<span class="s1">_green_not_dead(BorrowedGreenlet self)</span>
<span class="s1">{</span>
    <span class="s0">// XXX: Where else should we do this?</span>
    <span class="s0">// Probably on entry to most Python-facing functions?</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">was_running_in_dead_thread()) {</span>
        <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">deactivate_and_free();</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">active() || !self</span><span class="s5">-&gt;</span><span class="s1">started();</span>
<span class="s1">}</span>


<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getdead(BorrowedGreenlet self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(_green_not_dead(self)) {</span>
        <span class="s1">Py_RETURN_FALSE;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">Py_RETURN_TRUE;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_get_stack_saved(PyGreenlet* self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">PyLong_FromSsize_t(self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">stack_saved());</span>
<span class="s1">}</span>


<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getrun(BorrowedGreenlet self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">OwnedObject result(self</span><span class="s5">-&gt;</span><span class="s1">run());</span>
        <span class="s2">return </span><span class="s1">result.relinquish_ownership();</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">void</span>
<span class="s1">UserGreenlet::run(</span><span class="s2">const </span><span class="s1">BorrowedObject nrun)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">started()) {</span>
        <span class="s4">throw </span><span class="s1">AttributeError(</span>
                        <span class="s3">&quot;run cannot be set &quot;</span>
                        <span class="s3">&quot;after the start of the greenlet&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_run_callable = nrun;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">OwnedObject&amp;</span>
<span class="s1">MainGreenlet::run() </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s4">throw </span><span class="s1">AttributeError(</span><span class="s3">&quot;Main greenlets do not have a run attribute.&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">void</span>
<span class="s1">MainGreenlet::run(</span><span class="s2">const </span><span class="s1">BorrowedObject UNUSED(nrun))</span>
<span class="s1">{</span>
   <span class="s4">throw </span><span class="s1">AttributeError(</span><span class="s3">&quot;Main greenlets do not have a run attribute.&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">green_setrun(BorrowedGreenlet self, BorrowedObject nrun, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">run(nrun);</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getparent(BorrowedGreenlet self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">parent().acquire_or_None();</span>
<span class="s1">}</span>

<span class="s4">using </span><span class="s1">greenlet::AttributeError;</span>

<span class="s2">const </span><span class="s1">OwnedGreenlet</span>
<span class="s1">UserGreenlet::parent() </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_parent;</span>
<span class="s1">}</span>

<span class="s2">void</span>
<span class="s1">UserGreenlet::parent(</span><span class="s2">const </span><span class="s1">BorrowedObject raw_new_parent)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!raw_new_parent) {</span>
        <span class="s4">throw </span><span class="s1">AttributeError(</span><span class="s3">&quot;can't delete attribute&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">BorrowedMainGreenlet main_greenlet_of_new_parent;</span>
    <span class="s1">BorrowedGreenlet new_parent(raw_new_parent.borrow()); </span><span class="s0">// could</span>
                                                          <span class="s0">// throw</span>
                                                          <span class="s0">// TypeError!</span>
    <span class="s2">for </span><span class="s1">(BorrowedGreenlet p = new_parent; p; p = p</span><span class="s5">-&gt;</span><span class="s1">parent()) {</span>
        <span class="s2">if </span><span class="s1">(p == </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_self) {</span>
            <span class="s4">throw </span><span class="s1">ValueError(</span><span class="s3">&quot;cyclic parent chain&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">main_greenlet_of_new_parent = p</span><span class="s5">-&gt;</span><span class="s1">main_greenlet();</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!main_greenlet_of_new_parent) {</span>
        <span class="s4">throw </span><span class="s1">ValueError(</span><span class="s3">&quot;parent must not be garbage collected&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">started()</span>
        <span class="s1">&amp;&amp; </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_main_greenlet != main_greenlet_of_new_parent) {</span>
        <span class="s4">throw </span><span class="s1">ValueError(</span><span class="s3">&quot;parent cannot be on a different thread&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_parent = new_parent;</span>
<span class="s1">}</span>

<span class="s2">void</span>
<span class="s1">MainGreenlet::parent(</span><span class="s2">const </span><span class="s1">BorrowedObject raw_new_parent)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!raw_new_parent) {</span>
        <span class="s4">throw </span><span class="s1">AttributeError(</span><span class="s3">&quot;can't delete attribute&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">throw </span><span class="s1">AttributeError(</span><span class="s3">&quot;cannot set the parent of a main greenlet&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">OwnedGreenlet</span>
<span class="s1">MainGreenlet::parent() </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">OwnedGreenlet(); </span><span class="s0">// null becomes None</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">green_setparent(BorrowedGreenlet self, BorrowedObject nparent, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">parent(nparent);</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">#ifdef </span><span class="s1">Py_CONTEXT_H</span>
<span class="s1">#    define GREENLET_NO_CONTEXTVARS_REASON </span><span class="s3">&quot;This build of greenlet&quot;</span>
<span class="s2">#else</span>
<span class="s1">#    define GREENLET_NO_CONTEXTVARS_REASON </span><span class="s3">&quot;This Python interpreter&quot;</span>
<span class="s2">#endif</span>

<span class="s4">namespace </span><span class="s1">greenlet</span>
<span class="s1">{</span>

<span class="s1">template&lt;&gt;</span>
<span class="s2">const </span><span class="s1">OwnedObject</span>
<span class="s1">Greenlet::context&lt;GREENLET_WHEN_PY37&gt;(GREENLET_WHEN_PY37::Yes) </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s4">using </span><span class="s1">greenlet::PythonStateContext;</span>
    <span class="s1">OwnedObject result;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">is_currently_running_in_some_thread()) {</span>
        <span class="s0">/* Currently running greenlet: context is stored in the thread state, 
           not the greenlet object. */</span>
        <span class="s2">if </span><span class="s1">(GET_THREAD_STATE().state().is_current(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self())) {</span>
            <span class="s1">result = PythonStateContext&lt;G_IS_PY37&gt;::context(PyThreadState_GET());</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s4">throw </span><span class="s1">ValueError(</span>
                            <span class="s3">&quot;cannot get context of a &quot;</span>
                            <span class="s3">&quot;greenlet that is running in a different thread&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s0">/* Greenlet is not running: just return context. */</span>
        <span class="s1">result = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.context();</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!result) {</span>
        <span class="s1">result = OwnedObject::None();</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s1">template&lt;&gt;</span>
<span class="s2">const </span><span class="s1">OwnedObject</span>
<span class="s1">Greenlet::context&lt;GREENLET_WHEN_NOT_PY37&gt;(GREENLET_WHEN_NOT_PY37::No) </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s4">throw </span><span class="s1">AttributeError(</span>
                         <span class="s1">GREENLET_NO_CONTEXTVARS_REASON</span>
                         <span class="s3">&quot;does not support context variables&quot;</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s1">template&lt;&gt;</span>
<span class="s2">void </span><span class="s1">Greenlet::context&lt;GREENLET_WHEN_PY37&gt;(BorrowedObject given, GREENLET_WHEN_PY37::Yes)</span>
<span class="s1">{</span>
    <span class="s4">using </span><span class="s1">greenlet::PythonStateContext;</span>
    <span class="s2">if </span><span class="s1">(!given) {</span>
        <span class="s4">throw </span><span class="s1">AttributeError(</span><span class="s3">&quot;can't delete context attribute&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(given.is_None()) {</span>
        <span class="s0">/* &quot;Empty context&quot; is stored as NULL, not None. */</span>
        <span class="s1">given = nullptr;</span>
    <span class="s1">}</span>

    <span class="s0">//checks type, incrs refcnt</span>
    <span class="s1">greenlet::refs::OwnedContext context(given);</span>
    <span class="s1">PyThreadState* tstate = PyThreadState_GET();</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">is_currently_running_in_some_thread()) {</span>
        <span class="s2">if </span><span class="s1">(!GET_THREAD_STATE().state().is_current(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self())) {</span>
            <span class="s4">throw </span><span class="s1">ValueError(</span><span class="s3">&quot;cannot set context of a greenlet&quot;</span>
                             <span class="s3">&quot; that is running in a different thread&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s0">/* Currently running greenlet: context is stored in the thread state, 
           not the greenlet object. */</span>
        <span class="s1">OwnedObject octx = OwnedObject::consuming(PythonStateContext&lt;G_IS_PY37&gt;::context(tstate));</span>
        <span class="s1">PythonStateContext&lt;G_IS_PY37&gt;::context(tstate, context.relinquish_ownership());</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s0">/* Greenlet is not running: just set context. Note that the 
           greenlet may be dead.*/</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.context() = context;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">template&lt;&gt;</span>
<span class="s2">void</span>
<span class="s1">Greenlet::context&lt;GREENLET_WHEN_NOT_PY37&gt;(BorrowedObject UNUSED(given), GREENLET_WHEN_NOT_PY37::No)</span>
<span class="s1">{</span>
    <span class="s4">throw </span><span class="s1">AttributeError(</span>
                         <span class="s1">GREENLET_NO_CONTEXTVARS_REASON</span>
                         <span class="s3">&quot;does not support context variables&quot;</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s1">};</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getcontext(</span><span class="s2">const </span><span class="s1">PyGreenlet* self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s2">const </span><span class="s1">Greenlet *</span><span class="s2">const </span><span class="s1">g = self</span><span class="s5">-&gt;</span><span class="s1">pimpl;</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">OwnedObject result(g</span><span class="s5">-&gt;</span><span class="s1">context&lt;G_IS_PY37&gt;());</span>
        <span class="s2">return </span><span class="s1">result.relinquish_ownership();</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">green_setcontext(BorrowedGreenlet self, PyObject* nctx, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">context&lt;G_IS_PY37&gt;(nctx, G_IS_PY37::IsIt());</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#undef </span><span class="s1">GREENLET_NO_CONTEXTVARS_REASON</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getframe(BorrowedGreenlet self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s2">const </span><span class="s1">PythonState::OwnedFrame&amp; top_frame = self</span><span class="s5">-&gt;</span><span class="s1">top_frame();</span>
    <span class="s2">return </span><span class="s1">top_frame.acquire_or_None();</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getstate(PyGreenlet* self)</span>
<span class="s1">{</span>
    <span class="s1">PyErr_Format(PyExc_TypeError,</span>
                 <span class="s3">&quot;cannot serialize '%s' object&quot;</span><span class="s1">,</span>
                 <span class="s1">Py_TYPE(self)</span><span class="s5">-&gt;</span><span class="s1">tp_name);</span>
    <span class="s2">return </span><span class="s1">nullptr;</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_repr(BorrowedGreenlet self)</span>
<span class="s1">{</span>
    <span class="s0">/* 
      Return a string like 
      &lt;greenlet.greenlet at 0xdeadbeef [current][active started]|dead main&gt; 
 
      The handling of greenlets across threads is not super good. 
      We mostly use the internal definitions of these terms, but they 
      generally should make sense to users as well. 
     */</span>
    <span class="s1">PyObject* result;</span>
    <span class="s2">int </span><span class="s1">never_started = !self</span><span class="s5">-&gt;</span><span class="s1">started() &amp;&amp; !self</span><span class="s5">-&gt;</span><span class="s1">active();</span>

    <span class="s2">const char</span><span class="s1">* </span><span class="s2">const </span><span class="s1">tp_name = Py_TYPE(self)</span><span class="s5">-&gt;</span><span class="s1">tp_name;</span>

    <span class="s2">if </span><span class="s1">(_green_not_dead(self)) {</span>
        <span class="s0">/* XXX: The otid= is almost useless because you can't correlate it to 
         any thread identifier exposed to Python. We could use 
         PyThreadState_GET()-&gt;thread_id, but we'd need to save that in the 
         greenlet, or save the whole PyThreadState object itself. 
 
         As it stands, its only useful for identifying greenlets from the same thread. 
        */</span>
        <span class="s2">const char</span><span class="s1">* state_in_thread;</span>
        <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">was_running_in_dead_thread()) {</span>
            <span class="s0">// The thread it was running in is dead!</span>
            <span class="s0">// This can happen, especially at interpreter shut down.</span>
            <span class="s0">// It complicates debugging output because it may be</span>
            <span class="s0">// impossible to access the current thread state at that</span>
            <span class="s0">// time. Thus, don't access the current thread state.</span>
            <span class="s1">state_in_thread = </span><span class="s3">&quot; (thread exited)&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">state_in_thread = GET_THREAD_STATE().state().is_current(self)</span>
                <span class="s1">? </span><span class="s3">&quot; current&quot;</span>
                <span class="s1">: (self</span><span class="s5">-&gt;</span><span class="s1">started() ? </span><span class="s3">&quot; suspended&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">result = GNative_FromFormat(</span>
            <span class="s3">&quot;&lt;%s object at %p (otid=%p)%s%s%s%s&gt;&quot;</span><span class="s1">,</span>
            <span class="s1">tp_name,</span>
            <span class="s1">self.borrow_o(),</span>
            <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">thread_state(),</span>
            <span class="s1">state_in_thread,</span>
            <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">active() ? </span><span class="s3">&quot; active&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">,</span>
            <span class="s1">never_started ? </span><span class="s3">&quot; pending&quot; </span><span class="s1">: </span><span class="s3">&quot; started&quot;</span><span class="s1">,</span>
            <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">main() ? </span><span class="s3">&quot; main&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span>
        <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">result = GNative_FromFormat(</span>
            <span class="s3">&quot;&lt;%s object at %p (otid=%p) %sdead&gt;&quot;</span><span class="s1">,</span>
            <span class="s1">tp_name,</span>
            <span class="s1">self.borrow_o(),</span>
            <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">thread_state(),</span>
            <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">was_running_in_dead_thread()</span>
            <span class="s1">? </span><span class="s3">&quot;(thread exited) &quot;</span>
            <span class="s1">: </span><span class="s3">&quot;&quot;</span>
            <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s0">/***************************************************************************** 
 * C interface 
 * 
 * These are exported using the CObject API 
 */</span>
<span class="s2">extern </span><span class="s3">&quot;C&quot; </span><span class="s1">{</span>
<span class="s2">static </span><span class="s1">PyGreenlet*</span>
<span class="s1">PyGreenlet_GetCurrent(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">GET_THREAD_STATE().state().get_current().relinquish_ownership();</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">PyGreenlet_SetParent(PyGreenlet* g, PyGreenlet* nparent)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">green_setparent((PyGreenlet*)g, (PyObject*)nparent, NULL);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyGreenlet*</span>
<span class="s1">PyGreenlet_New(PyObject* run, PyGreenlet* parent)</span>
<span class="s1">{</span>
    <span class="s4">using </span><span class="s1">greenlet::refs::NewDictReference;</span>
    <span class="s0">// In the past, we didn't use green_new and green_init, but that</span>
    <span class="s0">// was a maintenance issue because we duplicated code. This way is</span>
    <span class="s0">// much safer, but slightly slower. If that's a problem, we could</span>
    <span class="s0">// refactor green_init to separate argument parsing from initialization.</span>
    <span class="s1">OwnedGreenlet g = OwnedGreenlet::consuming(green_new(&amp;PyGreenlet_Type, nullptr, nullptr));</span>
    <span class="s2">if </span><span class="s1">(!g) {</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">NewDictReference kwargs;</span>
        <span class="s2">if </span><span class="s1">(run) {</span>
            <span class="s1">kwargs.SetItem(mod_globs.str_run, run);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(parent) {</span>
            <span class="s1">kwargs.SetItem(</span><span class="s3">&quot;parent&quot;</span><span class="s1">, (PyObject*)parent);</span>
        <span class="s1">}</span>

        <span class="s1">Require(green_init(g, mod_globs.empty_tuple, kwargs));</span>
    <span class="s1">}</span>
    <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">g.relinquish_ownership();</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">PyGreenlet_Switch(PyGreenlet* g, PyObject* args, PyObject* kwargs)</span>
<span class="s1">{</span>
    <span class="s1">PyGreenlet* self = (PyGreenlet*)g;</span>

    <span class="s2">if </span><span class="s1">(!PyGreenlet_Check(self)) {</span>
        <span class="s1">PyErr_BadArgument();</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(args == NULL) {</span>
        <span class="s1">args = mod_globs.empty_tuple;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(kwargs == NULL || !PyDict_Check(kwargs)) {</span>
        <span class="s1">kwargs = NULL;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">green_switch(g, args, kwargs);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">PyGreenlet_Throw(PyGreenlet* self, PyObject* typ, PyObject* val, PyObject* tb)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!PyGreenlet_Check(self)) {</span>
        <span class="s1">PyErr_BadArgument();</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">PyErrPieces err_pieces(typ, val, tb);</span>
        <span class="s2">return </span><span class="s1">throw_greenlet(self, err_pieces).relinquish_ownership();</span>
    <span class="s1">}</span>
    <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">Extern_PyGreenlet_MAIN(PyGreenlet* self)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!PyGreenlet_Check(self)) {</span>
        <span class="s1">PyErr_BadArgument();</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">main();</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">Extern_PyGreenlet_ACTIVE(PyGreenlet* self)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!PyGreenlet_Check(self)) {</span>
        <span class="s1">PyErr_BadArgument();</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">active();</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">Extern_PyGreenlet_STARTED(PyGreenlet* self)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!PyGreenlet_Check(self)) {</span>
        <span class="s1">PyErr_BadArgument();</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">started();</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyGreenlet*</span>
<span class="s1">Extern_PyGreenlet_GET_PARENT(PyGreenlet* self)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!PyGreenlet_Check(self)) {</span>
        <span class="s1">PyErr_BadArgument();</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>
    <span class="s0">// This can return NULL even if there is no exception</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">parent().acquire();</span>
<span class="s1">}</span>
<span class="s1">} </span><span class="s0">// extern C.</span>
<span class="s0">/** End C API ****************************************************************/</span>

<span class="s2">static </span><span class="s1">PyMethodDef green_methods[] = {</span>
    <span class="s1">{</span><span class="s3">&quot;switch&quot;</span><span class="s1">,</span>
     <span class="s4">reinterpret_cast</span><span class="s1">&lt;PyCFunction&gt;(green_switch),</span>
     <span class="s1">METH_VARARGS | METH_KEYWORDS,</span>
     <span class="s1">green_switch_doc},</span>
    <span class="s1">{</span><span class="s3">&quot;throw&quot;</span><span class="s1">, (PyCFunction)green_throw, METH_VARARGS, green_throw_doc},</span>
    <span class="s1">{</span><span class="s3">&quot;__getstate__&quot;</span><span class="s1">, (PyCFunction)green_getstate, METH_NOARGS, NULL},</span>
    <span class="s1">{NULL, NULL} </span><span class="s0">/* sentinel */</span>
<span class="s1">};</span>

<span class="s2">static </span><span class="s1">PyGetSetDef green_getsets[] = {</span>
    <span class="s1">{</span><span class="s3">&quot;__dict__&quot;</span><span class="s1">, (getter)green_getdict, (setter)green_setdict, </span><span class="s0">/*XXX*/ </span><span class="s1">NULL},</span>
    <span class="s1">{</span><span class="s3">&quot;run&quot;</span><span class="s1">, (getter)green_getrun, (setter)green_setrun, </span><span class="s0">/*XXX*/ </span><span class="s1">NULL},</span>
    <span class="s1">{</span><span class="s3">&quot;parent&quot;</span><span class="s1">, (getter)green_getparent, (setter)green_setparent, </span><span class="s0">/*XXX*/ </span><span class="s1">NULL},</span>
    <span class="s1">{</span><span class="s3">&quot;gr_frame&quot;</span><span class="s1">, (getter)green_getframe, NULL, </span><span class="s0">/*XXX*/ </span><span class="s1">NULL},</span>
    <span class="s1">{</span><span class="s3">&quot;gr_context&quot;</span><span class="s1">,</span>
     <span class="s1">(getter)green_getcontext,</span>
     <span class="s1">(setter)green_setcontext,</span>
     <span class="s0">/*XXX*/ </span><span class="s1">NULL},</span>
    <span class="s1">{</span><span class="s3">&quot;dead&quot;</span><span class="s1">, (getter)green_getdead, NULL, </span><span class="s0">/*XXX*/ </span><span class="s1">NULL},</span>
    <span class="s1">{</span><span class="s3">&quot;_stack_saved&quot;</span><span class="s1">, (getter)green_get_stack_saved, NULL, </span><span class="s0">/*XXX*/ </span><span class="s1">NULL},</span>
    <span class="s1">{NULL}};</span>

<span class="s2">static </span><span class="s1">PyMemberDef green_members[] = {</span>
    <span class="s1">{NULL}</span>
<span class="s1">};</span>

<span class="s2">static </span><span class="s1">PyNumberMethods green_as_number = {</span>
    <span class="s1">NULL, </span><span class="s0">/* nb_add */</span>
    <span class="s1">NULL, </span><span class="s0">/* nb_subtract */</span>
    <span class="s1">NULL, </span><span class="s0">/* nb_multiply */</span>
<span class="s2">#if </span><span class="s1">PY_MAJOR_VERSION &lt; </span><span class="s6">3</span>
    <span class="s1">NULL, </span><span class="s0">/* nb_divide */</span>
<span class="s2">#endif</span>
    <span class="s1">NULL,                </span><span class="s0">/* nb_remainder */</span>
    <span class="s1">NULL,                </span><span class="s0">/* nb_divmod */</span>
    <span class="s1">NULL,                </span><span class="s0">/* nb_power */</span>
    <span class="s1">NULL,                </span><span class="s0">/* nb_negative */</span>
    <span class="s1">NULL,                </span><span class="s0">/* nb_positive */</span>
    <span class="s1">NULL,                </span><span class="s0">/* nb_absolute */</span>
    <span class="s1">(inquiry)green_bool, </span><span class="s0">/* nb_bool */</span>
<span class="s1">};</span>


<span class="s1">PyTypeObject PyGreenlet_Type = {</span>
    <span class="s1">PyVarObject_HEAD_INIT(NULL, </span><span class="s6">0</span><span class="s1">)</span>
    <span class="s3">&quot;greenlet.greenlet&quot;</span><span class="s1">, </span><span class="s0">/* tp_name */</span>
    <span class="s2">sizeof</span><span class="s1">(PyGreenlet),  </span><span class="s0">/* tp_basicsize */</span>
    <span class="s6">0</span><span class="s1">,                   </span><span class="s0">/* tp_itemsize */</span>
    <span class="s0">/* methods */</span>
    <span class="s1">(destructor)green_dealloc, </span><span class="s0">/* tp_dealloc */</span>
    <span class="s6">0</span><span class="s1">,                         </span><span class="s0">/* tp_print */</span>
    <span class="s6">0</span><span class="s1">,                         </span><span class="s0">/* tp_getattr */</span>
    <span class="s6">0</span><span class="s1">,                         </span><span class="s0">/* tp_setattr */</span>
    <span class="s6">0</span><span class="s1">,                         </span><span class="s0">/* tp_compare */</span>
    <span class="s1">(reprfunc)green_repr,      </span><span class="s0">/* tp_repr */</span>
    <span class="s1">&amp;green_as_number,          </span><span class="s0">/* tp_as _number*/</span>
    <span class="s6">0</span><span class="s1">,                         </span><span class="s0">/* tp_as _sequence*/</span>
    <span class="s6">0</span><span class="s1">,                         </span><span class="s0">/* tp_as _mapping*/</span>
    <span class="s6">0</span><span class="s1">,                         </span><span class="s0">/* tp_hash */</span>
    <span class="s6">0</span><span class="s1">,                         </span><span class="s0">/* tp_call */</span>
    <span class="s6">0</span><span class="s1">,                         </span><span class="s0">/* tp_str */</span>
    <span class="s6">0</span><span class="s1">,                         </span><span class="s0">/* tp_getattro */</span>
    <span class="s6">0</span><span class="s1">,                         </span><span class="s0">/* tp_setattro */</span>
    <span class="s6">0</span><span class="s1">,                         </span><span class="s0">/* tp_as_buffer*/</span>
    <span class="s1">G_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, </span><span class="s0">/* tp_flags */</span>
    <span class="s3">&quot;greenlet(run=None, parent=None) -&gt; greenlet</span><span class="s7">\n\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;Creates a new greenlet object (without running it).</span><span class="s7">\n\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot; - *run* -- The callable to invoke.</span><span class="s7">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot; - *parent* -- The parent greenlet. The default is the current &quot;</span>
    <span class="s3">&quot;greenlet.&quot;</span><span class="s1">,                        </span><span class="s0">/* tp_doc */</span>
    <span class="s1">(traverseproc)green_traverse, </span><span class="s0">/* tp_traverse */</span>
    <span class="s1">(inquiry)green_clear,         </span><span class="s0">/* tp_clear */</span>
    <span class="s6">0</span><span class="s1">,                                  </span><span class="s0">/* tp_richcompare */</span>
    <span class="s1">offsetof(PyGreenlet, weakreflist),  </span><span class="s0">/* tp_weaklistoffset */</span>
    <span class="s6">0</span><span class="s1">,                                  </span><span class="s0">/* tp_iter */</span>
    <span class="s6">0</span><span class="s1">,                                  </span><span class="s0">/* tp_iternext */</span>
    <span class="s1">green_methods,                      </span><span class="s0">/* tp_methods */</span>
    <span class="s1">green_members,                      </span><span class="s0">/* tp_members */</span>
    <span class="s1">green_getsets,                      </span><span class="s0">/* tp_getset */</span>
    <span class="s6">0</span><span class="s1">,                                  </span><span class="s0">/* tp_base */</span>
    <span class="s6">0</span><span class="s1">,                                  </span><span class="s0">/* tp_dict */</span>
    <span class="s6">0</span><span class="s1">,                                  </span><span class="s0">/* tp_descr_get */</span>
    <span class="s6">0</span><span class="s1">,                                  </span><span class="s0">/* tp_descr_set */</span>
    <span class="s1">offsetof(PyGreenlet, dict),         </span><span class="s0">/* tp_dictoffset */</span>
    <span class="s1">(initproc)green_init,               </span><span class="s0">/* tp_init */</span>
    <span class="s1">PyType_GenericAlloc,                  </span><span class="s0">/* tp_alloc */</span>
    <span class="s1">(newfunc)green_new,                          </span><span class="s0">/* tp_new */</span>
    <span class="s1">PyObject_GC_Del,                   </span><span class="s0">/* tp_free */</span>
    <span class="s1">(inquiry)green_is_gc,         </span><span class="s0">/* tp_is_gc */</span>
<span class="s1">};</span>



<span class="s1">PyDoc_STRVAR(mod_getcurrent_doc,</span>
             <span class="s3">&quot;getcurrent() -&gt; greenlet</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;Returns the current greenlet (i.e. the one which called this &quot;</span>
             <span class="s3">&quot;function).</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">mod_getcurrent(PyObject* UNUSED(module))</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">GET_THREAD_STATE().state().get_current().relinquish_ownership_o();</span>
<span class="s1">}</span>

<span class="s1">PyDoc_STRVAR(mod_settrace_doc,</span>
             <span class="s3">&quot;settrace(callback) -&gt; object</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;Sets a new tracing function and returns the previous one.</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">mod_settrace(PyObject* UNUSED(module), PyObject* args)</span>
<span class="s1">{</span>
    <span class="s1">PyArgParseParam tracefunc;</span>
    <span class="s2">if </span><span class="s1">(!PyArg_ParseTuple(args, </span><span class="s3">&quot;O&quot;</span><span class="s1">, &amp;tracefunc)) {</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>
    <span class="s1">ThreadState&amp; state = GET_THREAD_STATE();</span>
    <span class="s1">OwnedObject previous = state.get_tracefunc();</span>
    <span class="s2">if </span><span class="s1">(!previous) {</span>
        <span class="s1">previous = Py_None;</span>
    <span class="s1">}</span>

    <span class="s1">state.set_tracefunc(tracefunc);</span>

    <span class="s2">return </span><span class="s1">previous.relinquish_ownership();</span>
<span class="s1">}</span>

<span class="s1">PyDoc_STRVAR(mod_gettrace_doc,</span>
             <span class="s3">&quot;gettrace() -&gt; object</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;Returns the currently set tracing function, or None.</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">mod_gettrace(PyObject* UNUSED(module))</span>
<span class="s1">{</span>
    <span class="s1">OwnedObject tracefunc = GET_THREAD_STATE().state().get_tracefunc();</span>
    <span class="s2">if </span><span class="s1">(!tracefunc) {</span>
        <span class="s1">tracefunc = Py_None;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">tracefunc.relinquish_ownership();</span>
<span class="s1">}</span>

<span class="s1">PyDoc_STRVAR(mod_set_thread_local_doc,</span>
             <span class="s3">&quot;set_thread_local(key, value) -&gt; None</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;Set a value in the current thread-local dictionary. Debbuging only.</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">mod_set_thread_local(PyObject* UNUSED(module), PyObject* args)</span>
<span class="s1">{</span>
    <span class="s1">PyArgParseParam key;</span>
    <span class="s1">PyArgParseParam value;</span>
    <span class="s1">PyObject* result = NULL;</span>

    <span class="s2">if </span><span class="s1">(PyArg_UnpackTuple(args, </span><span class="s3">&quot;set_thread_local&quot;</span><span class="s1">, </span><span class="s6">2</span><span class="s1">, </span><span class="s6">2</span><span class="s1">, &amp;key, &amp;value)) {</span>
        <span class="s2">if</span><span class="s1">(PyDict_SetItem(</span>
                          <span class="s1">PyThreadState_GetDict(), </span><span class="s0">// borrow</span>
                          <span class="s1">key,</span>
                          <span class="s1">value) == </span><span class="s6">0 </span><span class="s1">) {</span>
            <span class="s0">// success</span>
            <span class="s1">Py_INCREF(Py_None);</span>
            <span class="s1">result = Py_None;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s1">PyDoc_STRVAR(mod_get_pending_cleanup_count_doc,</span>
             <span class="s3">&quot;get_pending_cleanup_count() -&gt; Integer</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;Get the number of greenlet cleanup operations pending. Testing only.</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">);</span>


<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">mod_get_pending_cleanup_count(PyObject* UNUSED(module))</span>
<span class="s1">{</span>
    <span class="s1">LockGuard cleanup_lock(*mod_globs.thread_states_to_destroy_lock);</span>
    <span class="s2">return </span><span class="s1">PyLong_FromSize_t(mod_globs.thread_states_to_destroy.size());</span>
<span class="s1">}</span>

<span class="s1">PyDoc_STRVAR(mod_get_total_main_greenlets_doc,</span>
             <span class="s3">&quot;get_total_main_greenlets() -&gt; Integer</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;Quickly return the number of main greenlets that exist. Testing only.</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">mod_get_total_main_greenlets(PyObject* UNUSED(module))</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">PyLong_FromSize_t(total_main_greenlets);</span>
<span class="s1">}</span>

<span class="s1">PyDoc_STRVAR(mod_get_clocks_used_doing_optional_cleanup_doc,</span>
             <span class="s3">&quot;get_clocks_used_doing_optional_cleanup() -&gt; Integer</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;Get the number of clock ticks the program has used doing optional &quot;</span>
             <span class="s3">&quot;greenlet cleanup.</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;Beginning in greenlet 2.0, greenlet tries to find and dispose of greenlets</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;that leaked after a thread exited. This requires invoking Python's garbage collector,</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;which may have a performance cost proportional to the number of live objects.</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;This function returns the amount of processor time</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;greenlet has used to do this. In programs that run with very large amounts of live</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;objects, this metric can be used to decide whether the cost of doing this cleanup</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;is worth the memory leak being corrected. If not, you can disable the cleanup</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;using ``enable_optional_cleanup(False)``.</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;The units are arbitrary and can only be compared to themselves (similarly to ``time.clock()``);</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;for example, to see how it scales with your heap. You can attempt to convert them into seconds</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;by dividing by the value of CLOCKS_PER_SEC.&quot;</span>
             <span class="s3">&quot;If cleanup has been disabled, returns None.&quot;</span>
             <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;This is an implementation specific, provisional API. It may be changed or removed</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;in the future.</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;.. versionadded:: 2.0&quot;</span>
             <span class="s1">);</span>
<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">mod_get_clocks_used_doing_optional_cleanup(PyObject* UNUSED(module))</span>
<span class="s1">{</span>
    <span class="s1">std::clock_t&amp; clocks = ThreadState::clocks_used_doing_gc();</span>

    <span class="s2">if </span><span class="s1">(clocks == std::clock_t(-</span><span class="s6">1</span><span class="s1">)) {</span>
        <span class="s1">Py_RETURN_NONE;</span>
    <span class="s1">}</span>
    <span class="s0">// This might not actually work on some implementations; clock_t</span>
    <span class="s0">// is an opaque type.</span>
    <span class="s2">return </span><span class="s1">PyLong_FromSsize_t(clocks);</span>
<span class="s1">}</span>

<span class="s1">PyDoc_STRVAR(mod_enable_optional_cleanup_doc,</span>
             <span class="s3">&quot;mod_enable_optional_cleanup(bool) -&gt; None</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;Enable or disable optional cleanup operations.</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;See ``get_clocks_used_doing_optional_cleanup()`` for details.</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s1">);</span>
<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">mod_enable_optional_cleanup(PyObject* UNUSED(module), PyObject* flag)</span>
<span class="s1">{</span>
    <span class="s2">int </span><span class="s1">is_true = PyObject_IsTrue(flag);</span>
    <span class="s2">if </span><span class="s1">(is_true == -</span><span class="s6">1</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>

    <span class="s1">std::clock_t&amp; clocks = ThreadState::clocks_used_doing_gc();</span>
    <span class="s2">if </span><span class="s1">(is_true) {</span>
        <span class="s0">// If we already have a value, we don't want to lose it.</span>
        <span class="s2">if </span><span class="s1">(clocks == std::clock_t(-</span><span class="s6">1</span><span class="s1">)) {</span>
            <span class="s1">clocks = </span><span class="s6">0</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">clocks = std::clock_t(-</span><span class="s6">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">Py_RETURN_NONE;</span>
<span class="s1">}</span>

<span class="s1">PyDoc_STRVAR(mod_get_tstate_trash_delete_nesting_doc,</span>
             <span class="s3">&quot;get_tstate_trash_delete_nesting() -&gt; Integer</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">&quot;</span>
             <span class="s3">&quot;Return the 'trash can' nesting level. Testing only.</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">mod_get_tstate_trash_delete_nesting(PyObject* UNUSED(module))</span>
<span class="s1">{</span>
    <span class="s1">PyThreadState* tstate = PyThreadState_GET();</span>
    <span class="s2">return </span><span class="s1">PyLong_FromLong(tstate</span><span class="s5">-&gt;</span><span class="s1">trash_delete_nesting);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyMethodDef GreenMethods[] = {</span>
    <span class="s1">{</span><span class="s3">&quot;getcurrent&quot;</span><span class="s1">,</span>
     <span class="s1">(PyCFunction)mod_getcurrent,</span>
     <span class="s1">METH_NOARGS,</span>
     <span class="s1">mod_getcurrent_doc},</span>
    <span class="s1">{</span><span class="s3">&quot;settrace&quot;</span><span class="s1">, (PyCFunction)mod_settrace, METH_VARARGS, mod_settrace_doc},</span>
    <span class="s1">{</span><span class="s3">&quot;gettrace&quot;</span><span class="s1">, (PyCFunction)mod_gettrace, METH_NOARGS, mod_gettrace_doc},</span>
    <span class="s1">{</span><span class="s3">&quot;set_thread_local&quot;</span><span class="s1">, (PyCFunction)mod_set_thread_local, METH_VARARGS, mod_set_thread_local_doc},</span>
    <span class="s1">{</span><span class="s3">&quot;get_pending_cleanup_count&quot;</span><span class="s1">, (PyCFunction)mod_get_pending_cleanup_count, METH_NOARGS, mod_get_pending_cleanup_count_doc},</span>
    <span class="s1">{</span><span class="s3">&quot;get_total_main_greenlets&quot;</span><span class="s1">, (PyCFunction)mod_get_total_main_greenlets, METH_NOARGS, mod_get_total_main_greenlets_doc},</span>
    <span class="s1">{</span><span class="s3">&quot;get_clocks_used_doing_optional_cleanup&quot;</span><span class="s1">, (PyCFunction)mod_get_clocks_used_doing_optional_cleanup, METH_NOARGS, mod_get_clocks_used_doing_optional_cleanup_doc},</span>
    <span class="s1">{</span><span class="s3">&quot;enable_optional_cleanup&quot;</span><span class="s1">, (PyCFunction)mod_enable_optional_cleanup, METH_O, mod_enable_optional_cleanup_doc},</span>
    <span class="s1">{</span><span class="s3">&quot;get_tstate_trash_delete_nesting&quot;</span><span class="s1">, (PyCFunction)mod_get_tstate_trash_delete_nesting, METH_NOARGS, mod_get_tstate_trash_delete_nesting_doc},</span>
    <span class="s1">{NULL, NULL} </span><span class="s0">/* Sentinel */</span>
<span class="s1">};</span>

<span class="s2">static const char</span><span class="s1">* </span><span class="s2">const </span><span class="s1">copy_on_greentype[] = {</span>
    <span class="s3">&quot;getcurrent&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;error&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;GreenletExit&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;settrace&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;gettrace&quot;</span><span class="s1">,</span>
    <span class="s1">NULL</span>
<span class="s1">};</span>

<span class="s2">static struct </span><span class="s1">PyModuleDef greenlet_module_def = {</span>
    <span class="s1">PyModuleDef_HEAD_INIT,</span>
    <span class="s3">&quot;greenlet._greenlet&quot;</span><span class="s1">,</span>
    <span class="s1">NULL,</span>
    <span class="s1">-</span><span class="s6">1</span><span class="s1">,</span>
    <span class="s1">GreenMethods,</span>
<span class="s1">};</span>



<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">greenlet_internal_mod_init() G_NOEXCEPT</span>
<span class="s1">{</span>
    <span class="s2">static void</span><span class="s1">* _PyGreenlet_API[PyGreenlet_API_pointers];</span>
    <span class="s1">GREENLET_NOINLINE_INIT();</span>

    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">CreatedModule m(greenlet_module_def);</span>

        <span class="s1">Require(PyType_Ready(&amp;PyGreenlet_Type));</span>

<span class="s2">#if </span><span class="s1">G_USE_STANDARD_THREADING == </span><span class="s6">0</span>
        <span class="s1">Require(PyType_Ready(&amp;PyGreenletCleanup_Type));</span>
<span class="s2">#endif</span>

        <span class="s4">new</span><span class="s1">((</span><span class="s2">void</span><span class="s1">*)&amp;mod_globs) GreenletGlobals;</span>
        <span class="s1">ThreadState::init();</span>

        <span class="s1">m.PyAddObject(</span><span class="s3">&quot;greenlet&quot;</span><span class="s1">, PyGreenlet_Type);</span>
        <span class="s1">m.PyAddObject(</span><span class="s3">&quot;error&quot;</span><span class="s1">, mod_globs.PyExc_GreenletError);</span>
        <span class="s1">m.PyAddObject(</span><span class="s3">&quot;GreenletExit&quot;</span><span class="s1">, mod_globs.PyExc_GreenletExit);</span>

        <span class="s1">m.PyAddObject(</span><span class="s3">&quot;GREENLET_USE_GC&quot;</span><span class="s1">, </span><span class="s6">1</span><span class="s1">);</span>
        <span class="s1">m.PyAddObject(</span><span class="s3">&quot;GREENLET_USE_TRACING&quot;</span><span class="s1">, </span><span class="s6">1</span><span class="s1">);</span>
        <span class="s0">// The macros are eithre 0 or 1; the 0 case can be interpreted</span>
        <span class="s0">// the same as NULL, which is ambiguous with a pointer.</span>
        <span class="s1">m.PyAddObject(</span><span class="s3">&quot;GREENLET_USE_CONTEXT_VARS&quot;</span><span class="s1">, (</span><span class="s2">long</span><span class="s1">)GREENLET_PY37);</span>
        <span class="s1">m.PyAddObject(</span><span class="s3">&quot;GREENLET_USE_STANDARD_THREADING&quot;</span><span class="s1">, (</span><span class="s2">long</span><span class="s1">)G_USE_STANDARD_THREADING);</span>

        <span class="s1">OwnedObject clocks_per_sec = OwnedObject::consuming(PyLong_FromSsize_t(CLOCKS_PER_SEC));</span>
        <span class="s1">m.PyAddObject(</span><span class="s3">&quot;CLOCKS_PER_SEC&quot;</span><span class="s1">, clocks_per_sec);</span>

        <span class="s0">/* also publish module-level data as attributes of the greentype. */</span>
        <span class="s0">// XXX: This is weird, and enables a strange pattern of</span>
        <span class="s0">// confusing the class greenlet with the module greenlet; with</span>
        <span class="s0">// the exception of (possibly) ``getcurrent()``, this</span>
        <span class="s0">// shouldn't be encouraged so don't add new items here.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const char</span><span class="s1">* </span><span class="s2">const</span><span class="s1">* p = copy_on_greentype; *p; p++) {</span>
            <span class="s1">OwnedObject o = m.PyRequireAttr(*p);</span>
            <span class="s1">PyDict_SetItemString(PyGreenlet_Type.tp_dict, *p, o.borrow());</span>
        <span class="s1">}</span>

        <span class="s0">/* 
         * Expose C API 
         */</span>

        <span class="s0">/* types */</span>
        <span class="s1">_PyGreenlet_API[PyGreenlet_Type_NUM] = (</span><span class="s2">void</span><span class="s1">*)&amp;PyGreenlet_Type;</span>

        <span class="s0">/* exceptions */</span>
        <span class="s1">_PyGreenlet_API[PyExc_GreenletError_NUM] = (</span><span class="s2">void</span><span class="s1">*)mod_globs.PyExc_GreenletError;</span>
        <span class="s1">_PyGreenlet_API[PyExc_GreenletExit_NUM] = (</span><span class="s2">void</span><span class="s1">*)mod_globs.PyExc_GreenletExit;</span>

        <span class="s0">/* methods */</span>
        <span class="s1">_PyGreenlet_API[PyGreenlet_New_NUM] = (</span><span class="s2">void</span><span class="s1">*)PyGreenlet_New;</span>
        <span class="s1">_PyGreenlet_API[PyGreenlet_GetCurrent_NUM] = (</span><span class="s2">void</span><span class="s1">*)PyGreenlet_GetCurrent;</span>
        <span class="s1">_PyGreenlet_API[PyGreenlet_Throw_NUM] = (</span><span class="s2">void</span><span class="s1">*)PyGreenlet_Throw;</span>
        <span class="s1">_PyGreenlet_API[PyGreenlet_Switch_NUM] = (</span><span class="s2">void</span><span class="s1">*)PyGreenlet_Switch;</span>
        <span class="s1">_PyGreenlet_API[PyGreenlet_SetParent_NUM] = (</span><span class="s2">void</span><span class="s1">*)PyGreenlet_SetParent;</span>

        <span class="s0">/* Previously macros, but now need to be functions externally. */</span>
        <span class="s1">_PyGreenlet_API[PyGreenlet_MAIN_NUM] = (</span><span class="s2">void</span><span class="s1">*)Extern_PyGreenlet_MAIN;</span>
        <span class="s1">_PyGreenlet_API[PyGreenlet_STARTED_NUM] = (</span><span class="s2">void</span><span class="s1">*)Extern_PyGreenlet_STARTED;</span>
        <span class="s1">_PyGreenlet_API[PyGreenlet_ACTIVE_NUM] = (</span><span class="s2">void</span><span class="s1">*)Extern_PyGreenlet_ACTIVE;</span>
        <span class="s1">_PyGreenlet_API[PyGreenlet_GET_PARENT_NUM] = (</span><span class="s2">void</span><span class="s1">*)Extern_PyGreenlet_GET_PARENT;</span>

        <span class="s0">/* XXX: Note that our module name is ``greenlet._greenlet``, but for 
           backwards compatibility with existing C code, we need the _C_API to 
           be directly in greenlet. 
        */</span>
        <span class="s2">const </span><span class="s1">NewReference c_api_object(Require(</span>
                                           <span class="s1">PyCapsule_New(</span>
                                               <span class="s1">(</span><span class="s2">void</span><span class="s1">*)_PyGreenlet_API,</span>
                                               <span class="s3">&quot;greenlet._C_API&quot;</span><span class="s1">,</span>
                                               <span class="s1">NULL)));</span>
        <span class="s1">m.PyAddObject(</span><span class="s3">&quot;_C_API&quot;</span><span class="s1">, c_api_object);</span>
        <span class="s1">assert(c_api_object.REFCNT() == </span><span class="s6">2</span><span class="s1">);</span>

        <span class="s0">// cerr &lt;&lt; &quot;Sizes:&quot;</span>
        <span class="s0">//      &lt;&lt; &quot;\n\tGreenlet       : &quot; &lt;&lt; sizeof(Greenlet)</span>
        <span class="s0">//      &lt;&lt; &quot;\n\tUserGreenlet   : &quot; &lt;&lt; sizeof(UserGreenlet)</span>
        <span class="s0">//      &lt;&lt; &quot;\n\tMainGreenlet   : &quot; &lt;&lt; sizeof(MainGreenlet)</span>
        <span class="s0">//      &lt;&lt; &quot;\n\tExceptionState : &quot; &lt;&lt; sizeof(greenlet::ExceptionState)</span>
        <span class="s0">//      &lt;&lt; &quot;\n\tPythonState    : &quot; &lt;&lt; sizeof(greenlet::PythonState)</span>
        <span class="s0">//      &lt;&lt; &quot;\n\tStackState     : &quot; &lt;&lt; sizeof(greenlet::StackState)</span>
        <span class="s0">//      &lt;&lt; &quot;\n\tSwitchingArgs  : &quot; &lt;&lt; sizeof(greenlet::SwitchingArgs)</span>
        <span class="s0">//      &lt;&lt; &quot;\n\tOwnedObject    : &quot; &lt;&lt; sizeof(greenlet::refs::OwnedObject)</span>
        <span class="s0">//      &lt;&lt; &quot;\n\tBorrowedObject : &quot; &lt;&lt; sizeof(greenlet::refs::BorrowedObject)</span>
        <span class="s0">//      &lt;&lt; &quot;\n\tPyGreenlet     : &quot; &lt;&lt; sizeof(PyGreenlet)</span>
        <span class="s0">//      &lt;&lt; endl;</span>

        <span class="s2">return </span><span class="s1">m.borrow(); </span><span class="s0">// But really it's the main reference.</span>
    <span class="s1">}</span>
    <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">LockInitError&amp; e) {</span>
        <span class="s1">PyErr_SetString(PyExc_MemoryError, e.what());</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>
    <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

<span class="s1">}</span>

<span class="s2">extern </span><span class="s3">&quot;C&quot; </span><span class="s1">{</span>
<span class="s2">#if </span><span class="s1">PY_MAJOR_VERSION &gt;= </span><span class="s6">3</span>
<span class="s1">PyMODINIT_FUNC</span>
<span class="s1">PyInit__greenlet(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">greenlet_internal_mod_init();</span>
<span class="s1">}</span>
<span class="s2">#else</span>
<span class="s1">PyMODINIT_FUNC</span>
<span class="s1">init_greenlet(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
    <span class="s1">greenlet_internal_mod_init();</span>
<span class="s1">}</span>
<span class="s2">#endif</span>
<span class="s1">};</span>

<span class="s2">#ifdef </span><span class="s1">__clang__</span>
<span class="s1">#    pragma clang diagnostic pop</span>
<span class="s1">#elif defined(__GNUC__)</span>
<span class="s1">#    pragma GCC diagnostic pop</span>
<span class="s2">#endif</span>
</pre>
</body>
</html>