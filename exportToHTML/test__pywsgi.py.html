<html>
<head>
<title>test__pywsgi.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test__pywsgi.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2007, Linden Research, Inc.</span>
<span class="s0"># Copyright (c) 2009-2010 gevent contributors</span>
<span class="s0"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="s0"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="s0"># in the Software without restriction, including without limitation the rights</span>
<span class="s0"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="s0"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="s0"># furnished to do so, subject to the following conditions:</span>
<span class="s0">#</span>
<span class="s0"># The above copyright notice and this permission notice shall be included in</span>
<span class="s0"># all copies or substantial portions of the Software.</span>
<span class="s0">#</span>
<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="s0"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="s0"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="s0"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="s0"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="s0"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<span class="s0"># THE SOFTWARE.</span>
<span class="s0"># pylint: disable=too-many-lines,unused-argument,too-many-ancestors</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">print_function</span>

<span class="s2">from </span><span class="s1">gevent </span><span class="s2">import </span><span class="s1">monkey</span>

<span class="s1">monkey.patch_all()</span>

<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">urllib.parse </span><span class="s2">import </span><span class="s1">parse_qs</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s0"># Python 2</span>
    <span class="s2">from </span><span class="s1">urlparse </span><span class="s2">import </span><span class="s1">parse_qs</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">try</span><span class="s1">:</span>
    <span class="s0"># On Python 2, we want the C-optimized version if</span>
    <span class="s0"># available; it has different corner-case behaviour than</span>
    <span class="s0"># the Python implementation, and it used by socket.makefile</span>
    <span class="s0"># by default.</span>
    <span class="s2">from </span><span class="s1">cStringIO </span><span class="s2">import </span><span class="s1">StringIO</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">BytesIO </span><span class="s2">as </span><span class="s1">StringIO</span>
<span class="s2">import </span><span class="s1">weakref</span>
<span class="s2">import </span><span class="s1">unittest</span>
<span class="s2">from </span><span class="s1">wsgiref.validate </span><span class="s2">import </span><span class="s1">validator</span>

<span class="s2">import </span><span class="s1">gevent.testing </span><span class="s2">as </span><span class="s1">greentest</span>
<span class="s2">import </span><span class="s1">gevent</span>
<span class="s2">from </span><span class="s1">gevent.testing </span><span class="s2">import </span><span class="s1">PY3</span><span class="s2">, </span><span class="s1">PYPY</span>
<span class="s2">from </span><span class="s1">gevent.testing.exception </span><span class="s2">import </span><span class="s1">ExpectedException</span>
<span class="s2">from </span><span class="s1">gevent </span><span class="s2">import </span><span class="s1">socket</span>
<span class="s2">from </span><span class="s1">gevent </span><span class="s2">import </span><span class="s1">pywsgi</span>
<span class="s2">from </span><span class="s1">gevent.pywsgi </span><span class="s2">import </span><span class="s1">Input</span>


<span class="s2">class </span><span class="s1">ExpectedAssertionError(ExpectedException</span><span class="s2">, </span><span class="s1">AssertionError):</span>
    <span class="s3">&quot;&quot;&quot;An expected assertion error&quot;&quot;&quot;</span>

<span class="s1">CONTENT_LENGTH = </span><span class="s4">'Content-Length'</span>
<span class="s1">CONN_ABORTED_ERRORS = greentest.CONN_ABORTED_ERRORS</span>

<span class="s1">REASONS = {</span>
    <span class="s5">200</span><span class="s1">: </span><span class="s4">'OK'</span><span class="s2">,</span>
    <span class="s5">500</span><span class="s1">: </span><span class="s4">'Internal Server Error'</span>
<span class="s1">}</span>


<span class="s2">class </span><span class="s1">ConnectionClosed(Exception):</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">read_headers(fd):</span>
    <span class="s1">response_line = fd.readline()</span>
    <span class="s2">if not </span><span class="s1">response_line:</span>
        <span class="s2">raise </span><span class="s1">ConnectionClosed</span>
    <span class="s1">response_line = response_line.decode(</span><span class="s4">'latin-1'</span><span class="s1">)</span>
    <span class="s1">headers = {}</span>
    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s1">line = fd.readline().strip()</span>
        <span class="s2">if not </span><span class="s1">line:</span>
            <span class="s2">break</span>
        <span class="s1">line = line.decode(</span><span class="s4">'latin-1'</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">key</span><span class="s2">, </span><span class="s1">value = line.split(</span><span class="s4">': '</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">except</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">'Failed to split: %r' </span><span class="s1">% (line</span><span class="s2">, </span><span class="s1">))</span>
            <span class="s2">raise</span>
        <span class="s2">assert </span><span class="s1">key.lower() </span><span class="s2">not in </span><span class="s1">{x.lower() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">headers}</span><span class="s2">, </span><span class="s4">'Header %r:%r sent more than once: %r' </span><span class="s1">% (key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">headers)</span>
        <span class="s1">headers[key] = value</span>
    <span class="s2">return </span><span class="s1">response_line</span><span class="s2">, </span><span class="s1">headers</span>


<span class="s2">def </span><span class="s1">iread_chunks(fd):</span>
    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s1">line = fd.readline()</span>
        <span class="s1">chunk_size = line.strip()</span>
        <span class="s1">chunk_size = int(chunk_size</span><span class="s2">, </span><span class="s5">16</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">chunk_size == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">crlf = fd.read(</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">crlf == </span><span class="s6">b'</span><span class="s2">\r\n</span><span class="s6">'</span><span class="s2">, </span><span class="s1">repr(crlf)</span>
            <span class="s2">break</span>
        <span class="s1">data = fd.read(chunk_size)</span>
        <span class="s2">yield </span><span class="s1">data</span>
        <span class="s1">crlf = fd.read(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">crlf == </span><span class="s6">b'</span><span class="s2">\r\n</span><span class="s6">'</span><span class="s2">, </span><span class="s1">repr(crlf)</span>


<span class="s2">class </span><span class="s1">Response(object):</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">status_line</span><span class="s2">, </span><span class="s1">headers):</span>
        <span class="s1">self.status_line = status_line</span>
        <span class="s1">self.headers = headers</span>
        <span class="s1">self.body = </span><span class="s2">None</span>
        <span class="s1">self.chunks = </span><span class="s2">False</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">version</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">self.reason = status_line[:-</span><span class="s5">2</span><span class="s1">].split(</span><span class="s4">' '</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">self.code = int(code)</span>
            <span class="s1">HTTP</span><span class="s2">, </span><span class="s1">self.version = version.split(</span><span class="s4">'/'</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">HTTP == </span><span class="s4">'HTTP'</span><span class="s2">, </span><span class="s1">repr(HTTP)</span>
            <span class="s2">assert </span><span class="s1">self.version </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'1.0'</span><span class="s2">, </span><span class="s4">'1.1'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">repr(self.version)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s1">print(</span><span class="s4">'Error: %r' </span><span class="s1">% status_line)</span>
            <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">yield </span><span class="s1">self.status_line</span>
        <span class="s2">yield </span><span class="s1">self.headers</span>
        <span class="s2">yield </span><span class="s1">self.body</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">args = (self.__class__.__name__</span><span class="s2">, </span><span class="s1">self.status_line</span><span class="s2">, </span><span class="s1">self.headers</span><span class="s2">, </span><span class="s1">self.body</span><span class="s2">, </span><span class="s1">self.chunks)</span>
        <span class="s2">return </span><span class="s4">'&lt;%s status_line=%r headers=%r body=%r chunks=%r&gt;' </span><span class="s1">% args</span>

    <span class="s2">def </span><span class="s1">assertCode(self</span><span class="s2">, </span><span class="s1">code):</span>
        <span class="s2">if </span><span class="s1">hasattr(code</span><span class="s2">, </span><span class="s4">'__contains__'</span><span class="s1">):</span>
            <span class="s2">assert </span><span class="s1">self.code </span><span class="s2">in </span><span class="s1">code</span><span class="s2">, </span><span class="s4">'Unexpected code: %r (expected %r)</span><span class="s2">\n</span><span class="s4">%s' </span><span class="s1">% (self.code</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">self.code == code</span><span class="s2">, </span><span class="s4">'Unexpected code: %r (expected %r)</span><span class="s2">\n</span><span class="s4">%s' </span><span class="s1">% (self.code</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s2">def </span><span class="s1">assertReason(self</span><span class="s2">, </span><span class="s1">reason):</span>
        <span class="s2">assert </span><span class="s1">self.reason == reason</span><span class="s2">, </span><span class="s4">'Unexpected reason: %r (expected %r)</span><span class="s2">\n</span><span class="s4">%s' </span><span class="s1">% (self.reason</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s2">def </span><span class="s1">assertVersion(self</span><span class="s2">, </span><span class="s1">version):</span>
        <span class="s2">assert </span><span class="s1">self.version == version</span><span class="s2">, </span><span class="s4">'Unexpected version: %r (expected %r)</span><span class="s2">\n</span><span class="s4">%s' </span><span class="s1">% (self.version</span><span class="s2">, </span><span class="s1">version</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s2">def </span><span class="s1">assertHeader(self</span><span class="s2">, </span><span class="s1">header</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">real_value = self.headers.get(header</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">real_value == value</span><span class="s2">, </span><span class="s1">\</span>
            <span class="s4">'Unexpected header %r: %r (expected %r)</span><span class="s2">\n</span><span class="s4">%s' </span><span class="s1">% (header</span><span class="s2">, </span><span class="s1">real_value</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s2">def </span><span class="s1">assertBody(self</span><span class="s2">, </span><span class="s1">body):</span>
        <span class="s2">if </span><span class="s1">isinstance(body</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">PY3:</span>
            <span class="s1">body = body.encode(</span><span class="s4">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">self.body == body</span><span class="s2">, </span><span class="s4">'Unexpected body: %r (expected %r)</span><span class="s2">\n</span><span class="s4">%s' </span><span class="s1">% (self.body</span><span class="s2">, </span><span class="s1">body</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">read(cls</span><span class="s2">, </span><span class="s1">fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">200</span><span class="s2">, </span><span class="s1">reason=</span><span class="s4">'default'</span><span class="s2">, </span><span class="s1">version=</span><span class="s4">'1.1'</span><span class="s2">,</span>
             <span class="s1">body=</span><span class="s2">None, </span><span class="s1">chunks=</span><span class="s2">None, </span><span class="s1">content_length=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># pylint:disable=too-many-branches</span>
        <span class="s1">_status_line</span><span class="s2">, </span><span class="s1">headers = read_headers(fd)</span>
        <span class="s1">self = cls(_status_line</span><span class="s2">, </span><span class="s1">headers)</span>
        <span class="s2">if </span><span class="s1">code </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.assertCode(code)</span>
        <span class="s2">if </span><span class="s1">reason == </span><span class="s4">'default'</span><span class="s1">:</span>
            <span class="s1">reason = REASONS.get(code)</span>
        <span class="s2">if </span><span class="s1">reason </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.assertReason(reason)</span>
        <span class="s2">if </span><span class="s1">version </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.assertVersion(version)</span>
        <span class="s2">if </span><span class="s1">self.code == </span><span class="s5">100</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">if </span><span class="s1">content_length </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(content_length</span><span class="s2">, </span><span class="s1">int):</span>
                <span class="s1">content_length = str(content_length)</span>
            <span class="s1">self.assertHeader(</span><span class="s4">'Content-Length'</span><span class="s2">, </span><span class="s1">content_length)</span>

        <span class="s2">if </span><span class="s4">'chunked' </span><span class="s2">in </span><span class="s1">headers.get(</span><span class="s4">'Transfer-Encoding'</span><span class="s2">, </span><span class="s4">''</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">CONTENT_LENGTH </span><span class="s2">in </span><span class="s1">headers:</span>
                <span class="s1">print(</span><span class="s4">&quot;WARNING: server used chunked transfer-encoding despite having Content-Length header (libevent 1.x's bug)&quot;</span><span class="s1">)</span>
            <span class="s1">self.chunks = list(iread_chunks(fd))</span>
            <span class="s1">self.body = </span><span class="s6">b''</span><span class="s1">.join(self.chunks)</span>
        <span class="s2">elif </span><span class="s1">CONTENT_LENGTH </span><span class="s2">in </span><span class="s1">headers:</span>
            <span class="s1">num = int(headers[CONTENT_LENGTH])</span>
            <span class="s1">self.body = fd.read(num)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.body = fd.read()</span>

        <span class="s2">if </span><span class="s1">body </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.assertBody(body)</span>
        <span class="s2">if </span><span class="s1">chunks </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">chunks == self.chunks</span><span class="s2">, </span><span class="s1">(chunks</span><span class="s2">, </span><span class="s1">self.chunks)</span>
        <span class="s2">return </span><span class="s1">self</span>

<span class="s1">read_http = Response.read</span>


<span class="s2">class </span><span class="s1">TestCase(greentest.TestCase):</span>
    <span class="s1">server = </span><span class="s2">None</span>
    <span class="s1">validator = staticmethod(validator)</span>
    <span class="s1">application = </span><span class="s2">None</span>

    <span class="s0"># Bind to default address, which should give us ipv6 (when available)</span>
    <span class="s0"># and ipv4. (see self.connect())</span>
    <span class="s1">listen_addr = greentest.DEFAULT_BIND_ADDR</span>
    <span class="s0"># connect on ipv4, even though we bound to ipv6 too</span>
    <span class="s0"># to prove ipv4 works...except on Windows, it apparently doesn't.</span>
    <span class="s0"># So use the hostname.</span>
    <span class="s1">connect_addr = greentest.DEFAULT_LOCAL_HOST_ADDR</span>

    <span class="s2">class </span><span class="s1">handler_class(pywsgi.WSGIHandler):</span>
        <span class="s1">ApplicationError = ExpectedAssertionError</span>

    <span class="s2">def </span><span class="s1">init_logger(self):</span>
        <span class="s2">import </span><span class="s1">logging</span>
        <span class="s1">logger = logging.getLogger(</span><span class="s4">'gevent.tests.pywsgi'</span><span class="s1">)</span>
        <span class="s1">logger.setLevel(logging.CRITICAL)</span>
        <span class="s2">return </span><span class="s1">logger</span>

    <span class="s2">def </span><span class="s1">init_server(self</span><span class="s2">, </span><span class="s1">application):</span>
        <span class="s1">logger = self.logger = self.init_logger()</span>
        <span class="s1">self.server = pywsgi.WSGIServer(</span>
            <span class="s1">(self.listen_addr</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">application</span><span class="s2">,</span>
            <span class="s1">log=logger</span><span class="s2">, </span><span class="s1">error_log=logger</span><span class="s2">,</span>
            <span class="s1">handler_class=self.handler_class</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">setUp(self):</span>
        <span class="s1">application = self.application</span>
        <span class="s2">if </span><span class="s1">self.validator </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">application = self.validator(application)</span>
        <span class="s1">self.init_server(application)</span>
        <span class="s1">self.server.start()</span>
        <span class="s2">while not </span><span class="s1">self.server.server_port:</span>
            <span class="s1">print(</span><span class="s4">&quot;Waiting on server port&quot;</span><span class="s1">)</span>
        <span class="s1">self.port = self.server.server_port</span>
        <span class="s2">assert </span><span class="s1">self.port</span>
        <span class="s1">greentest.TestCase.setUp(self)</span>

    <span class="s2">if </span><span class="s1">greentest.CPYTHON </span><span class="s2">and </span><span class="s1">greentest.PY2:</span>
        <span class="s0"># Keeping raw sockets alive keeps SSL sockets</span>
        <span class="s0"># from being closed too, at least on CPython2, so we</span>
        <span class="s0"># need to use weakrefs.</span>

        <span class="s0"># In contrast, on PyPy, *only* having a weakref lets the</span>
        <span class="s0"># original socket die and leak</span>

        <span class="s2">def </span><span class="s1">_close_on_teardown(self</span><span class="s2">, </span><span class="s1">resource):</span>
            <span class="s1">self.close_on_teardown.append(weakref.ref(resource))</span>
            <span class="s2">return </span><span class="s1">resource</span>

        <span class="s2">def </span><span class="s1">_tearDownCloseOnTearDown(self):</span>
            <span class="s1">self.close_on_teardown = [r() </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">self.close_on_teardown </span><span class="s2">if </span><span class="s1">r() </span><span class="s2">is not None</span><span class="s1">]</span>
            <span class="s1">super(TestCase</span><span class="s2">, </span><span class="s1">self)._tearDownCloseOnTearDown()</span>

    <span class="s2">def </span><span class="s1">tearDown(self):</span>
        <span class="s1">greentest.TestCase.tearDown(self)</span>
        <span class="s2">if </span><span class="s1">self.server </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">gevent.Timeout.start_new(</span><span class="s5">0.5</span><span class="s1">):</span>
                <span class="s1">self.server.stop()</span>
        <span class="s1">self.server = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">greentest.PYPY:</span>
            <span class="s2">import </span><span class="s1">gc</span>
            <span class="s1">gc.collect()</span>
            <span class="s1">gc.collect()</span>


    <span class="s1">@contextmanager</span>
    <span class="s2">def </span><span class="s1">connect(self):</span>
        <span class="s1">conn = socket.create_connection((self.connect_addr</span><span class="s2">, </span><span class="s1">self.port))</span>
        <span class="s1">result = conn</span>
        <span class="s2">if </span><span class="s1">PY3:</span>
            <span class="s1">conn_makefile = conn.makefile</span>

            <span class="s2">def </span><span class="s1">makefile(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
                <span class="s2">if </span><span class="s4">'bufsize' </span><span class="s2">in </span><span class="s1">kwargs:</span>
                    <span class="s1">kwargs[</span><span class="s4">'buffering'</span><span class="s1">] = kwargs.pop(</span><span class="s4">'bufsize'</span><span class="s1">)</span>

                <span class="s2">if </span><span class="s4">'mode' </span><span class="s2">in </span><span class="s1">kwargs:</span>
                    <span class="s2">return </span><span class="s1">conn_makefile(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

                <span class="s0"># Under Python3, you can't read and write to the same</span>
                <span class="s0"># makefile() opened in (default) r, and r+ is not allowed</span>
                <span class="s1">kwargs[</span><span class="s4">'mode'</span><span class="s1">] = </span><span class="s4">'rwb'</span>
                <span class="s1">rconn = conn_makefile(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
                <span class="s1">_rconn_write = rconn.write</span>

                <span class="s2">def </span><span class="s1">write(data):</span>
                    <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">str):</span>
                        <span class="s1">data = data.encode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
                    <span class="s2">return </span><span class="s1">_rconn_write(data)</span>
                <span class="s1">rconn.write = write</span>
                <span class="s1">self._close_on_teardown(rconn)</span>
                <span class="s2">return </span><span class="s1">rconn</span>

            <span class="s2">class </span><span class="s1">proxy(object):</span>
                <span class="s2">def </span><span class="s1">__getattribute__(self</span><span class="s2">, </span><span class="s1">name):</span>
                    <span class="s2">if </span><span class="s1">name == </span><span class="s4">'makefile'</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">makefile</span>
                    <span class="s2">return </span><span class="s1">getattr(conn</span><span class="s2">, </span><span class="s1">name)</span>
            <span class="s1">result = proxy()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">result</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">result.close()</span>

    <span class="s1">@contextmanager</span>
    <span class="s2">def </span><span class="s1">makefile(self):</span>
        <span class="s2">with </span><span class="s1">self.connect() </span><span class="s2">as </span><span class="s1">sock:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">result = sock.makefile(bufsize=</span><span class="s5">1</span><span class="s1">) </span><span class="s0"># pylint:disable=unexpected-keyword-arg</span>
                <span class="s2">yield </span><span class="s1">result</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">result.close()</span>

    <span class="s2">def </span><span class="s1">urlopen(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">with </span><span class="s1">self.connect() </span><span class="s2">as </span><span class="s1">sock:</span>
            <span class="s2">with </span><span class="s1">sock.makefile(bufsize=</span><span class="s5">1</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fd: </span><span class="s0"># pylint:disable=unexpected-keyword-arg</span>
                <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">HTTP_CLIENT_VERSION = </span><span class="s4">'1.1'</span>
    <span class="s1">DEFAULT_EXTRA_CLIENT_HEADERS = {}</span>

    <span class="s2">def </span><span class="s1">format_request(self</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'GET'</span><span class="s2">, </span><span class="s1">path=</span><span class="s4">'/'</span><span class="s2">, </span><span class="s1">**headers):</span>
        <span class="s1">def_headers = self.DEFAULT_EXTRA_CLIENT_HEADERS.copy()</span>
        <span class="s1">def_headers.update(headers)</span>
        <span class="s1">headers = def_headers</span>

        <span class="s1">headers = </span><span class="s4">'</span><span class="s2">\r\n</span><span class="s4">'</span><span class="s1">.join(</span><span class="s4">'%s: %s' </span><span class="s1">% item </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">headers.items())</span>
        <span class="s1">headers = headers + </span><span class="s4">'</span><span class="s2">\r\n</span><span class="s4">' </span><span class="s2">if </span><span class="s1">headers </span><span class="s2">else </span><span class="s1">headers</span>
        <span class="s1">result = (</span>
            <span class="s4">'%(method)s %(path)s HTTP/%(http_ver)s</span><span class="s2">\r\n</span><span class="s4">'</span>
            <span class="s4">'Host: localhost</span><span class="s2">\r\n</span><span class="s4">'</span>
            <span class="s4">'%(headers)s'</span>
            <span class="s4">'</span><span class="s2">\r\n</span><span class="s4">'</span>
        <span class="s1">)</span>
        <span class="s1">result = result % dict(</span>
            <span class="s1">method=method</span><span class="s2">,</span>
            <span class="s1">path=path</span><span class="s2">,</span>
            <span class="s1">http_ver=self.HTTP_CLIENT_VERSION</span><span class="s2">,</span>
            <span class="s1">headers=headers</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">result</span>


<span class="s2">class </span><span class="s1">CommonTestMixin(object):</span>
    <span class="s1">PIPELINE_NOT_SUPPORTED_EXS = ()</span>
    <span class="s1">EXPECT_CLOSE = </span><span class="s2">False</span>
    <span class="s1">EXPECT_KEEPALIVE = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(self.format_request())</span>
            <span class="s1">response = read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'hello world'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">response.headers.get(</span><span class="s4">'Connection'</span><span class="s1">) == </span><span class="s4">'close'</span><span class="s1">:</span>
                <span class="s1">self.assertTrue(self.EXPECT_CLOSE</span><span class="s2">, </span><span class="s4">&quot;Server closed connection, not expecting that&quot;</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">response</span><span class="s2">, None</span>

            <span class="s1">self.assertFalse(self.EXPECT_CLOSE)</span>
            <span class="s2">if </span><span class="s1">self.EXPECT_KEEPALIVE:</span>
                <span class="s1">response.assertHeader(</span><span class="s4">'Connection'</span><span class="s2">, </span><span class="s4">'keep-alive'</span><span class="s1">)</span>
            <span class="s1">fd.write(self.format_request(path=</span><span class="s4">'/notexist'</span><span class="s1">))</span>
            <span class="s1">dne_response = read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">404</span><span class="s2">, </span><span class="s1">reason=</span><span class="s4">'Not Found'</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'not found'</span><span class="s1">)</span>
            <span class="s1">fd.write(self.format_request())</span>
            <span class="s1">response = read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'hello world'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">response</span><span class="s2">, </span><span class="s1">dne_response</span>



    <span class="s2">def </span><span class="s1">test_pipeline(self):</span>
        <span class="s1">exception = AssertionError(</span><span class="s4">'HTTP pipelining not supported; the second request is thrown away'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(self.format_request() + self.format_request(path=</span><span class="s4">'/notexist'</span><span class="s1">))</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'hello world'</span><span class="s1">)</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">timeout = gevent.Timeout.start_new(</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">exception=exception)</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">404</span><span class="s2">, </span><span class="s1">reason=</span><span class="s4">'Not Found'</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'not found'</span><span class="s1">)</span>
                <span class="s2">finally</span><span class="s1">:</span>
                    <span class="s1">timeout.close()</span>
            <span class="s2">except </span><span class="s1">self.PIPELINE_NOT_SUPPORTED_EXS:</span>
                <span class="s2">pass</span>
            <span class="s2">except </span><span class="s1">AssertionError </span><span class="s2">as </span><span class="s1">ex:</span>
                <span class="s2">if </span><span class="s1">ex </span><span class="s2">is not </span><span class="s1">exception:</span>
                    <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">test_connection_close(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(self.format_request())</span>
            <span class="s1">response = read_http(fd)</span>
            <span class="s2">if </span><span class="s1">response.headers.get(</span><span class="s4">'Connection'</span><span class="s1">) == </span><span class="s4">'close'</span><span class="s1">:</span>
                <span class="s1">self.assertTrue(self.EXPECT_CLOSE</span><span class="s2">, </span><span class="s4">&quot;Server closed connection, not expecting that&quot;</span><span class="s1">)</span>
                <span class="s2">return</span>
            <span class="s1">self.assertFalse(self.EXPECT_CLOSE)</span>
            <span class="s2">if </span><span class="s1">self.EXPECT_KEEPALIVE:</span>
                <span class="s1">response.assertHeader(</span><span class="s4">'Connection'</span><span class="s2">, </span><span class="s4">'keep-alive'</span><span class="s1">)</span>

            <span class="s1">fd.write(self.format_request(Connection=</span><span class="s4">'close'</span><span class="s1">))</span>
            <span class="s1">read_http(fd)</span>
            <span class="s1">fd.write(self.format_request())</span>
            <span class="s0"># This may either raise, or it may return an empty response,</span>
            <span class="s0"># depend on timing and the Python version.</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">result = fd.readline()</span>
            <span class="s2">except </span><span class="s1">socket.error </span><span class="s2">as </span><span class="s1">ex:</span>
                <span class="s2">if </span><span class="s1">ex.args[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">CONN_ABORTED_ERRORS:</span>
                    <span class="s2">raise</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.assertFalse(</span>
                    <span class="s1">result</span><span class="s2">,</span>
                    <span class="s4">'The remote side is expected to close the connection, but it sent %r'</span>
                    <span class="s1">% (result</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s1">@unittest.skip(</span><span class="s4">&quot;Not sure&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_006_reject_long_urls(self):</span>
        <span class="s1">path_parts = []</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">3000</span><span class="s1">):</span>
            <span class="s1">path_parts.append(</span><span class="s4">'path'</span><span class="s1">)</span>
        <span class="s1">path = </span><span class="s4">'/'</span><span class="s1">.join(path_parts)</span>

        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">request = </span><span class="s4">'GET /%s HTTP/1.0</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n\r\n</span><span class="s4">' </span><span class="s1">% path</span>
            <span class="s1">fd.write(request)</span>
            <span class="s1">result = fd.readline()</span>
            <span class="s1">status = result.split(</span><span class="s4">' '</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">self.assertEqual(status</span><span class="s2">, </span><span class="s4">'414'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestNoChunks(CommonTestMixin</span><span class="s2">, </span><span class="s1">TestCase):</span>
    <span class="s0"># when returning a list of strings a shortcut is employed by the server:</span>
    <span class="s0"># it calculates the content-length and joins all the chunks before sending</span>
    <span class="s1">validator = </span><span class="s2">None</span>
    <span class="s1">last_environ = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_check_environ(self</span><span class="s2">, </span><span class="s1">input_terminated=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">input_terminated:</span>
            <span class="s1">self.assertTrue(self.last_environ.get(</span><span class="s4">'wsgi.input_terminated'</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.assertFalse(self.last_environ[</span><span class="s4">'wsgi.input_terminated'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">self.last_environ = env</span>
        <span class="s1">path = env[</span><span class="s4">'PATH_INFO'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">path == </span><span class="s4">'/'</span><span class="s1">:</span>
            <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s6">b'hello '</span><span class="s2">, </span><span class="s6">b'world'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">path == </span><span class="s4">'/websocket'</span><span class="s1">:</span>
            <span class="s1">write = start_response(</span><span class="s4">'101 Switching Protocols'</span><span class="s2">,</span>
                                   <span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)</span><span class="s2">,</span>
                                    <span class="s0"># Con:close is to make our simple client</span>
                                    <span class="s0"># happy; otherwise it wants to read data from the</span>
                                    <span class="s0"># body thot's being kept open.</span>
                                    <span class="s1">(</span><span class="s4">'Connection'</span><span class="s2">, </span><span class="s4">'close'</span><span class="s1">)])</span>
            <span class="s1">write(</span><span class="s6">b''</span><span class="s1">) </span><span class="s0"># Trigger finalizing the headers now.</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s6">b'upgrading to'</span><span class="s2">, </span><span class="s6">b'websocket'</span><span class="s1">]</span>
        <span class="s1">start_response(</span><span class="s4">'404 Not Found'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s6">b'not '</span><span class="s2">, </span><span class="s6">b'found'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">response</span><span class="s2">, </span><span class="s1">dne_response = super(TestNoChunks</span><span class="s2">, </span><span class="s1">self).test_basic()</span>
        <span class="s1">self._check_environ()</span>
        <span class="s1">self.assertFalse(response.chunks)</span>
        <span class="s1">response.assertHeader(</span><span class="s4">'Content-Length'</span><span class="s2">, </span><span class="s4">'11'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">dne_response </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.assertFalse(dne_response.chunks)</span>
            <span class="s1">dne_response.assertHeader(</span><span class="s4">'Content-Length'</span><span class="s2">, </span><span class="s4">'9'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dne(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(self.format_request(path=</span><span class="s4">'/notexist'</span><span class="s1">))</span>
            <span class="s1">response = read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">404</span><span class="s2">, </span><span class="s1">reason=</span><span class="s4">'Not Found'</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'not found'</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(response.chunks)</span>
        <span class="s1">self._check_environ()</span>
        <span class="s1">response.assertHeader(</span><span class="s4">'Content-Length'</span><span class="s2">, </span><span class="s4">'9'</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">TestConnectionUpgrades(TestNoChunks):</span>

    <span class="s2">def </span><span class="s1">test_connection_upgrade(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(self.format_request(path=</span><span class="s4">'/websocket'</span><span class="s2">, </span><span class="s1">Connection=</span><span class="s4">'upgrade'</span><span class="s1">))</span>
            <span class="s1">response = read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">101</span><span class="s1">)</span>

        <span class="s1">self._check_environ(input_terminated=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(response.chunks)</span>

    <span class="s2">def </span><span class="s1">test_upgrade_websocket(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(self.format_request(path=</span><span class="s4">'/websocket'</span><span class="s2">, </span><span class="s1">Upgrade=</span><span class="s4">'websocket'</span><span class="s1">))</span>
            <span class="s1">response = read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">101</span><span class="s1">)</span>

        <span class="s1">self._check_environ(input_terminated=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(response.chunks)</span>


<span class="s2">class </span><span class="s1">TestNoChunks10(TestNoChunks):</span>
    <span class="s1">HTTP_CLIENT_VERSION = </span><span class="s4">'1.0'</span>
    <span class="s1">PIPELINE_NOT_SUPPORTED_EXS = (ConnectionClosed</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">EXPECT_CLOSE = </span><span class="s2">True</span>

<span class="s2">class </span><span class="s1">TestNoChunks10KeepAlive(TestNoChunks10):</span>
    <span class="s1">DEFAULT_EXTRA_CLIENT_HEADERS = {</span>
        <span class="s4">'Connection'</span><span class="s1">: </span><span class="s4">'keep-alive'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">EXPECT_CLOSE = </span><span class="s2">False</span>
    <span class="s1">EXPECT_KEEPALIVE = </span><span class="s2">True</span>


<span class="s2">class </span><span class="s1">TestExplicitContentLength(TestNoChunks): </span><span class="s0"># pylint:disable=too-many-ancestors</span>
    <span class="s0"># when returning a list of strings a shortcut is employed by the</span>
    <span class="s0"># server - it caculates the content-length</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">self.last_environ = env</span>
        <span class="s1">self.assertTrue(env.get(</span><span class="s4">'wsgi.input_terminated'</span><span class="s1">))</span>
        <span class="s1">path = env[</span><span class="s4">'PATH_INFO'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">path == </span><span class="s4">'/'</span><span class="s1">:</span>
            <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'Content-Length'</span><span class="s2">, </span><span class="s4">'11'</span><span class="s1">)])</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s6">b'hello '</span><span class="s2">, </span><span class="s6">b'world'</span><span class="s1">]</span>

        <span class="s1">start_response(</span><span class="s4">'404 Not Found'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'Content-Length'</span><span class="s2">, </span><span class="s4">'9'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s6">b'not '</span><span class="s2">, </span><span class="s6">b'found'</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">TestYield(CommonTestMixin</span><span class="s2">, </span><span class="s1">TestCase):</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">application(env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">path = env[</span><span class="s4">'PATH_INFO'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">path == </span><span class="s4">'/'</span><span class="s1">:</span>
            <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
            <span class="s2">yield </span><span class="s6">b&quot;hello world&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">start_response(</span><span class="s4">'404 Not Found'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
            <span class="s2">yield </span><span class="s6">b&quot;not found&quot;</span>


<span class="s2">class </span><span class="s1">TestBytearray(CommonTestMixin</span><span class="s2">, </span><span class="s1">TestCase):</span>

    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">application(env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">path = env[</span><span class="s4">'PATH_INFO'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">path == </span><span class="s4">'/'</span><span class="s1">:</span>
            <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
            <span class="s2">return </span><span class="s1">[bytearray(</span><span class="s6">b&quot;hello &quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">bytearray(</span><span class="s6">b&quot;world&quot;</span><span class="s1">)]</span>
        <span class="s1">start_response(</span><span class="s4">'404 Not Found'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">[bytearray(</span><span class="s6">b&quot;not found&quot;</span><span class="s1">)]</span>


<span class="s2">class </span><span class="s1">TestMultiLineHeader(TestCase):</span>
    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">application(env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s2">assert </span><span class="s4">&quot;test.submit&quot; </span><span class="s2">in </span><span class="s1">env[</span><span class="s4">&quot;CONTENT_TYPE&quot;</span><span class="s1">]</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s6">b&quot;ok&quot;</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">test_multiline_116(self):</span>
        <span class="s3">&quot;&quot;&quot;issue #116&quot;&quot;&quot;</span>
        <span class="s1">request = </span><span class="s4">'</span><span class="s2">\r\n</span><span class="s4">'</span><span class="s1">.join((</span>
            <span class="s4">'POST / HTTP/1.0'</span><span class="s2">,</span>
            <span class="s4">'Host: localhost'</span><span class="s2">,</span>
            <span class="s4">'Content-Type: multipart/related; boundary=&quot;====XXXX====&quot;;'</span><span class="s2">,</span>
            <span class="s4">' type=&quot;text/xml&quot;;start=&quot;test.submit&quot;'</span><span class="s2">,</span>
            <span class="s4">'Content-Length: 0'</span><span class="s2">,</span>
            <span class="s4">''</span><span class="s2">, </span><span class="s4">''</span><span class="s1">))</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(request)</span>
            <span class="s1">read_http(fd)</span>


<span class="s2">class </span><span class="s1">TestGetArg(TestCase):</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">application(env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">body = env[</span><span class="s4">'wsgi.input'</span><span class="s1">].read(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">PY3:</span>
            <span class="s1">body = body.decode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
        <span class="s1">a = parse_qs(body).get(</span><span class="s4">'a'</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">[(</span><span class="s4">'a is %s, body is %s' </span><span class="s1">% (a</span><span class="s2">, </span><span class="s1">body)).encode(</span><span class="s4">'ascii'</span><span class="s1">)]</span>

    <span class="s2">def </span><span class="s1">test_007_get_arg(self):</span>
        <span class="s0"># define a new handler that does a get_arg as well as a read_body</span>

        <span class="s1">request = </span><span class="s4">'</span><span class="s2">\r\n</span><span class="s4">'</span><span class="s1">.join((</span>
            <span class="s4">'POST / HTTP/1.0'</span><span class="s2">,</span>
            <span class="s4">'Host: localhost'</span><span class="s2">,</span>
            <span class="s4">'Content-Length: 3'</span><span class="s2">,</span>
            <span class="s4">''</span><span class="s2">,</span>
            <span class="s4">'a=a'</span><span class="s1">))</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(request)</span>

            <span class="s0"># send some junk after the actual request</span>
            <span class="s1">fd.write(</span><span class="s4">'01234567890123456789'</span><span class="s1">)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'a is a, body is a=a'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestCloseIter(TestCase):</span>

    <span class="s0"># The *Validator* closes the iterators!</span>
    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">yield </span><span class="s1">bytearray(</span><span class="s6">b&quot;Hello World&quot;</span><span class="s1">)</span>
        <span class="s2">yield </span><span class="s6">b&quot;!&quot;</span>

    <span class="s1">closed = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s1">self.closed += </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">test_close_is_called(self):</span>
        <span class="s1">self.closed = </span><span class="s2">False</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s6">b&quot;Hello World!&quot;</span><span class="s2">, </span><span class="s1">chunks=[</span><span class="s6">b'Hello World'</span><span class="s2">, </span><span class="s6">b'!'</span><span class="s1">])</span>
        <span class="s0"># We got closed exactly once.</span>
        <span class="s1">self.assertEqual(self.closed</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">TestChunkedApp(TestCase):</span>

    <span class="s1">chunks = [</span><span class="s6">b'this'</span><span class="s2">, </span><span class="s6">b'is'</span><span class="s2">, </span><span class="s6">b'chunked'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">body(self):</span>
        <span class="s2">return </span><span class="s6">b''</span><span class="s1">.join(self.chunks)</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">self.assertTrue(env.get(</span><span class="s4">'wsgi.input_terminated'</span><span class="s1">))</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">for </span><span class="s1">chunk </span><span class="s2">in </span><span class="s1">self.chunks:</span>
            <span class="s2">yield </span><span class="s1">chunk</span>

    <span class="s2">def </span><span class="s1">test_chunked_response(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">response = read_http(fd</span><span class="s2">, </span><span class="s1">body=self.body()</span><span class="s2">, </span><span class="s1">chunks=</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s1">response.assertHeader(</span><span class="s4">'Transfer-Encoding'</span><span class="s2">, </span><span class="s4">'chunked'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(response.chunks</span><span class="s2">, </span><span class="s1">self.chunks)</span>

    <span class="s2">def </span><span class="s1">test_no_chunked_http_1_0(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.0</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">response = read_http(fd)</span>
        <span class="s1">self.assertEqual(response.body</span><span class="s2">, </span><span class="s1">self.body())</span>
        <span class="s1">self.assertEqual(response.headers.get(</span><span class="s4">'Transfer-Encoding'</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">content_length = response.headers.get(</span><span class="s4">'Content-Length'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">content_length </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.assertEqual(content_length</span><span class="s2">, </span><span class="s1">str(len(self.body())))</span>


<span class="s2">class </span><span class="s1">TestBigChunks(TestChunkedApp):</span>
    <span class="s1">chunks = [</span><span class="s6">b'a' </span><span class="s1">* </span><span class="s5">8192</span><span class="s1">] * </span><span class="s5">3</span>


<span class="s2">class </span><span class="s1">TestNegativeRead(TestCase):</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">self.assertTrue(env.get(</span><span class="s4">'wsgi.input_terminated'</span><span class="s1">))</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">if </span><span class="s1">env[</span><span class="s4">'PATH_INFO'</span><span class="s1">] == </span><span class="s4">'/read'</span><span class="s1">:</span>
            <span class="s1">data = env[</span><span class="s4">'wsgi.input'</span><span class="s1">].read(-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">[data]</span>

    <span class="s2">def </span><span class="s1">test_negative_chunked_read(self):</span>
        <span class="s1">data = (</span><span class="s6">b'POST /read HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">Host: localhost</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n</span><span class="s6">'</span>
                <span class="s6">b'Transfer-Encoding: chunked</span><span class="s2">\r\n\r\n</span><span class="s6">'</span>
                <span class="s6">b'2</span><span class="s2">\r\n</span><span class="s6">oh</span><span class="s2">\r\n</span><span class="s6">4</span><span class="s2">\r\n </span><span class="s6">hai</span><span class="s2">\r\n</span><span class="s6">0</span><span class="s2">\r\n\r\n</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(data)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'oh hai'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_negative_nonchunked_read(self):</span>
        <span class="s1">data = (</span><span class="s6">b'POST /read HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">Host: localhost</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n</span><span class="s6">'</span>
                <span class="s6">b'Content-Length: 6</span><span class="s2">\r\n\r\n</span><span class="s6">'</span>
                <span class="s6">b'oh hai'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(data)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'oh hai'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestNegativeReadline(TestCase):</span>
    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">application(env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">if </span><span class="s1">env[</span><span class="s4">'PATH_INFO'</span><span class="s1">] == </span><span class="s4">'/readline'</span><span class="s1">:</span>
            <span class="s1">data = env[</span><span class="s4">'wsgi.input'</span><span class="s1">].readline(-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">[data]</span>

    <span class="s2">def </span><span class="s1">test_negative_chunked_readline(self):</span>
        <span class="s1">data = (</span><span class="s6">b'POST /readline HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">Host: localhost</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n</span><span class="s6">'</span>
                <span class="s6">b'Transfer-Encoding: chunked</span><span class="s2">\r\n\r\n</span><span class="s6">'</span>
                <span class="s6">b'2</span><span class="s2">\r\n</span><span class="s6">oh</span><span class="s2">\r\n</span><span class="s6">4</span><span class="s2">\r\n </span><span class="s6">hai</span><span class="s2">\r\n</span><span class="s6">0</span><span class="s2">\r\n\r\n</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(data)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'oh hai'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_negative_nonchunked_readline(self):</span>
        <span class="s1">data = (</span><span class="s6">b'POST /readline HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">Host: localhost</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n</span><span class="s6">'</span>
                <span class="s6">b'Content-Length: 6</span><span class="s2">\r\n\r\n</span><span class="s6">'</span>
                <span class="s6">b'oh hai'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(data)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'oh hai'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestChunkedPost(TestCase):</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">self.assertTrue(env.get(</span><span class="s4">'wsgi.input_terminated'</span><span class="s1">))</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">if </span><span class="s1">env[</span><span class="s4">'PATH_INFO'</span><span class="s1">] == </span><span class="s4">'/a'</span><span class="s1">:</span>
            <span class="s1">data = env[</span><span class="s4">'wsgi.input'</span><span class="s1">].read(</span><span class="s5">6</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">[data]</span>

        <span class="s2">if </span><span class="s1">env[</span><span class="s4">'PATH_INFO'</span><span class="s1">] == </span><span class="s4">'/b'</span><span class="s1">:</span>
            <span class="s1">lines = list(iter(</span><span class="s2">lambda</span><span class="s1">: env[</span><span class="s4">'wsgi.input'</span><span class="s1">].read(</span><span class="s5">6</span><span class="s1">)</span><span class="s2">, </span><span class="s6">b''</span><span class="s1">))</span>
            <span class="s2">return </span><span class="s1">lines</span>

        <span class="s2">if </span><span class="s1">env[</span><span class="s4">'PATH_INFO'</span><span class="s1">] == </span><span class="s4">'/c'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">list(iter(</span><span class="s2">lambda</span><span class="s1">: env[</span><span class="s4">'wsgi.input'</span><span class="s1">].read(</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s6">b''</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_014_chunked_post(self):</span>
        <span class="s1">data = (</span><span class="s6">b'POST /a HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">Host: localhost</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n</span><span class="s6">'</span>
                <span class="s6">b'Transfer-Encoding: chunked</span><span class="s2">\r\n\r\n</span><span class="s6">'</span>
                <span class="s6">b'2</span><span class="s2">\r\n</span><span class="s6">oh</span><span class="s2">\r\n</span><span class="s6">4</span><span class="s2">\r\n </span><span class="s6">hai</span><span class="s2">\r\n</span><span class="s6">0</span><span class="s2">\r\n\r\n</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(data)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'oh hai'</span><span class="s1">)</span>
        <span class="s0"># self.close_opened() # XXX: Why?</span>

        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(data.replace(</span><span class="s6">b'/a'</span><span class="s2">, </span><span class="s6">b'/b'</span><span class="s1">))</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'oh hai'</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(data.replace(</span><span class="s6">b'/a'</span><span class="s2">, </span><span class="s6">b'/c'</span><span class="s1">))</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'oh hai'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_229_incorrect_chunk_no_newline(self):</span>
        <span class="s0"># Giving both a Content-Length and a Transfer-Encoding,</span>
        <span class="s0"># TE is preferred. But if the chunking is bad from the client,</span>
        <span class="s0"># missing its terminating newline,</span>
        <span class="s0"># the server doesn't hang</span>
        <span class="s1">data = (</span><span class="s6">b'POST /a HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">Host: localhost</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n</span><span class="s6">'</span>
                <span class="s6">b'Content-Length: 12</span><span class="s2">\r\n</span><span class="s6">'</span>
                <span class="s6">b'Transfer-Encoding: chunked</span><span class="s2">\r\n\r\n</span><span class="s6">'</span>
                <span class="s6">b'{&quot;hi&quot;: &quot;ho&quot;}'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(data)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">400</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_229_incorrect_chunk_non_hex(self):</span>
        <span class="s0"># Giving both a Content-Length and a Transfer-Encoding,</span>
        <span class="s0"># TE is preferred. But if the chunking is bad from the client,</span>
        <span class="s0"># the server doesn't hang</span>
        <span class="s1">data = (</span><span class="s6">b'POST /a HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">Host: localhost</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n</span><span class="s6">'</span>
                <span class="s6">b'Content-Length: 12</span><span class="s2">\r\n</span><span class="s6">'</span>
                <span class="s6">b'Transfer-Encoding: chunked</span><span class="s2">\r\n\r\n</span><span class="s6">'</span>
                <span class="s6">b'{&quot;hi&quot;: &quot;ho&quot;}</span><span class="s2">\r\n</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(data)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">400</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_229_correct_chunk_quoted_ext(self):</span>
        <span class="s1">data = (</span><span class="s6">b'POST /a HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">Host: localhost</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n</span><span class="s6">'</span>
                <span class="s6">b'Transfer-Encoding: chunked</span><span class="s2">\r\n\r\n</span><span class="s6">'</span>
                <span class="s6">b'2;token=&quot;oh hi&quot;</span><span class="s2">\r\n</span><span class="s6">oh</span><span class="s2">\r\n</span><span class="s6">4</span><span class="s2">\r\n </span><span class="s6">hai</span><span class="s2">\r\n</span><span class="s6">0</span><span class="s2">\r\n\r\n</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(data)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'oh hai'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_229_correct_chunk_token_ext(self):</span>
        <span class="s1">data = (</span><span class="s6">b'POST /a HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">Host: localhost</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n</span><span class="s6">'</span>
                <span class="s6">b'Transfer-Encoding: chunked</span><span class="s2">\r\n\r\n</span><span class="s6">'</span>
                <span class="s6">b'2;token=oh_hi</span><span class="s2">\r\n</span><span class="s6">oh</span><span class="s2">\r\n</span><span class="s6">4</span><span class="s2">\r\n </span><span class="s6">hai</span><span class="s2">\r\n</span><span class="s6">0</span><span class="s2">\r\n\r\n</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(data)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'oh hai'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_229_incorrect_chunk_token_ext_too_long(self):</span>
        <span class="s1">data = (</span><span class="s6">b'POST /a HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">Host: localhost</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n</span><span class="s6">'</span>
                <span class="s6">b'Transfer-Encoding: chunked</span><span class="s2">\r\n\r\n</span><span class="s6">'</span>
                <span class="s6">b'2;token=oh_hi</span><span class="s2">\r\n</span><span class="s6">oh</span><span class="s2">\r\n</span><span class="s6">4</span><span class="s2">\r\n </span><span class="s6">hai</span><span class="s2">\r\n</span><span class="s6">0</span><span class="s2">\r\n\r\n</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s1">data = data.replace(</span><span class="s6">b'oh_hi'</span><span class="s2">, </span><span class="s6">b'_oh_hi' </span><span class="s1">* </span><span class="s5">4000</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(data)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">400</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestUseWrite(TestCase):</span>

    <span class="s1">body = </span><span class="s6">b'abcde'</span>
    <span class="s1">end = </span><span class="s6">b'end'</span>
    <span class="s1">content_length = str(len(body + end))</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s2">if </span><span class="s1">env[</span><span class="s4">'PATH_INFO'</span><span class="s1">] == </span><span class="s4">'/explicit-content-length'</span><span class="s1">:</span>
            <span class="s1">write = start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)</span><span class="s2">,</span>
                                              <span class="s1">(</span><span class="s4">'Content-Length'</span><span class="s2">, </span><span class="s1">self.content_length)])</span>
            <span class="s1">write(self.body)</span>
        <span class="s2">elif </span><span class="s1">env[</span><span class="s4">'PATH_INFO'</span><span class="s1">] == </span><span class="s4">'/no-content-length'</span><span class="s1">:</span>
            <span class="s1">write = start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
            <span class="s1">write(self.body)</span>
        <span class="s2">elif </span><span class="s1">env[</span><span class="s4">'PATH_INFO'</span><span class="s1">] == </span><span class="s4">'/no-content-length-twice'</span><span class="s1">:</span>
            <span class="s1">write = start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
            <span class="s1">write(self.body)</span>
            <span class="s1">write(self.body)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">Exception(</span><span class="s4">'Invalid url'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">[self.end]</span>

    <span class="s2">def </span><span class="s1">test_explicit_content_length(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET /explicit-content-length HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">response = read_http(fd</span><span class="s2">, </span><span class="s1">body=self.body + self.end)</span>
        <span class="s1">response.assertHeader(</span><span class="s4">'Content-Length'</span><span class="s2">, </span><span class="s1">self.content_length)</span>
        <span class="s1">response.assertHeader(</span><span class="s4">'Transfer-Encoding'</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_no_content_length(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET /no-content-length HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">response = read_http(fd</span><span class="s2">, </span><span class="s1">body=self.body + self.end)</span>

        <span class="s1">response.assertHeader(</span><span class="s4">'Content-Length'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">response.assertHeader(</span><span class="s4">'Transfer-Encoding'</span><span class="s2">, </span><span class="s4">'chunked'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_no_content_length_twice(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET /no-content-length-twice HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">response = read_http(fd</span><span class="s2">, </span><span class="s1">body=self.body + self.body + self.end)</span>

        <span class="s1">response.assertHeader(</span><span class="s4">'Content-Length'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">response.assertHeader(</span><span class="s4">'Transfer-Encoding'</span><span class="s2">, </span><span class="s4">'chunked'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(response.chunks</span><span class="s2">, </span><span class="s1">[self.body</span><span class="s2">, </span><span class="s1">self.body</span><span class="s2">, </span><span class="s1">self.end])</span>


<span class="s2">class </span><span class="s1">HttpsTestCase(TestCase):</span>

    <span class="s1">certfile = os.path.join(os.path.dirname(__file__)</span><span class="s2">, </span><span class="s4">'test_server.crt'</span><span class="s1">)</span>
    <span class="s1">keyfile = os.path.join(os.path.dirname(__file__)</span><span class="s2">, </span><span class="s4">'test_server.key'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">init_server(self</span><span class="s2">, </span><span class="s1">application):</span>
        <span class="s1">self.server = pywsgi.WSGIServer((self.listen_addr</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">application</span><span class="s2">,</span>
                                        <span class="s1">certfile=self.certfile</span><span class="s2">, </span><span class="s1">keyfile=self.keyfile)</span>

    <span class="s2">def </span><span class="s1">urlopen(self</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'GET'</span><span class="s2">, </span><span class="s1">post_body=</span><span class="s2">None, </span><span class="s1">**kwargs): </span><span class="s0"># pylint:disable=arguments-differ</span>
        <span class="s2">import </span><span class="s1">ssl</span>
        <span class="s2">with </span><span class="s1">self.connect() </span><span class="s2">as </span><span class="s1">raw_sock:</span>
            <span class="s2">with </span><span class="s1">ssl.wrap_socket(raw_sock) </span><span class="s2">as </span><span class="s1">sock: </span><span class="s0"># pylint:disable=deprecated-method</span>
                <span class="s2">with </span><span class="s1">sock.makefile(bufsize=</span><span class="s5">1</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fd: </span><span class="s0"># pylint:disable=unexpected-keyword-arg</span>
                    <span class="s1">fd.write(</span><span class="s4">'%s / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">' </span><span class="s1">% method)</span>
                    <span class="s2">if </span><span class="s1">post_body </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">fd.write(</span><span class="s4">'Content-Length: %s</span><span class="s2">\r\n\r\n</span><span class="s4">' </span><span class="s1">% len(post_body))</span>
                        <span class="s1">fd.write(post_body)</span>
                        <span class="s2">if </span><span class="s1">kwargs.get(</span><span class="s4">'body'</span><span class="s1">) </span><span class="s2">is None</span><span class="s1">:</span>
                            <span class="s1">kwargs[</span><span class="s4">'body'</span><span class="s1">] = post_body</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">fd.write(</span><span class="s4">'</span><span class="s2">\r\n</span><span class="s4">'</span><span class="s1">)</span>
                    <span class="s1">fd.flush()</span>

                    <span class="s2">return </span><span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s2">assert </span><span class="s1">environ[</span><span class="s4">'wsgi.url_scheme'</span><span class="s1">] == </span><span class="s4">'https'</span><span class="s2">, </span><span class="s1">environ[</span><span class="s4">'wsgi.url_scheme'</span><span class="s1">]</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">[environ[</span><span class="s4">'wsgi.input'</span><span class="s1">].read(</span><span class="s5">10</span><span class="s1">)]</span>


<span class="s2">import </span><span class="s1">gevent.ssl</span>
<span class="s1">HAVE_SSLCONTEXT = getattr(gevent.ssl</span><span class="s2">, </span><span class="s4">'create_default_context'</span><span class="s1">)</span>
<span class="s2">if </span><span class="s1">HAVE_SSLCONTEXT:</span>

    <span class="s2">class </span><span class="s1">HttpsSslContextTestCase(HttpsTestCase):</span>
        <span class="s2">def </span><span class="s1">init_server(self</span><span class="s2">, </span><span class="s1">application):</span>
            <span class="s0"># On 2.7, our certs don't line up with hostname.</span>
            <span class="s0"># If we just use create_default_context as-is, we get</span>
            <span class="s0"># `ValueError: check_hostname requires server_hostname`.</span>
            <span class="s0"># If we set check_hostname to False, we get</span>
            <span class="s0"># `SSLError: [SSL: PEER_DID_NOT_RETURN_A_CERTIFICATE] peer did not return a certificate`</span>
            <span class="s0"># (Neither of which happens in Python 3.) But the unverified context</span>
            <span class="s0"># works both places. See also test___example_servers.py</span>
            <span class="s2">from </span><span class="s1">gevent.ssl </span><span class="s2">import </span><span class="s1">_create_unverified_context </span><span class="s0"># pylint:disable=no-name-in-module</span>
            <span class="s1">context = _create_unverified_context()</span>
            <span class="s1">context.load_cert_chain(certfile=self.certfile</span><span class="s2">, </span><span class="s1">keyfile=self.keyfile)</span>
            <span class="s1">self.server = pywsgi.WSGIServer((self.listen_addr</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                                            <span class="s1">application</span><span class="s2">, </span><span class="s1">ssl_context=context)</span>

<span class="s2">class </span><span class="s1">TestHttps(HttpsTestCase):</span>

    <span class="s2">if </span><span class="s1">hasattr(socket</span><span class="s2">, </span><span class="s4">'ssl'</span><span class="s1">):</span>

        <span class="s2">def </span><span class="s1">test_012_ssl_server(self):</span>
            <span class="s1">result = self.urlopen(method=</span><span class="s4">&quot;POST&quot;</span><span class="s2">, </span><span class="s1">post_body=</span><span class="s4">'abc'</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(result.body</span><span class="s2">, </span><span class="s4">'abc'</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">test_013_empty_return(self):</span>
            <span class="s1">result = self.urlopen()</span>
            <span class="s1">self.assertEqual(result.body</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span>

<span class="s2">if </span><span class="s1">HAVE_SSLCONTEXT:</span>
    <span class="s2">class </span><span class="s1">TestHttpsWithContext(HttpsSslContextTestCase</span><span class="s2">, </span><span class="s1">TestHttps): </span><span class="s0"># pylint:disable=too-many-ancestors</span>
        <span class="s2">pass</span>

<span class="s2">class </span><span class="s1">TestInternational(TestCase):</span>
    <span class="s1">validator = </span><span class="s2">None  </span><span class="s0"># wsgiref.validate.IteratorWrapper([]) does not have __len__</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">path_bytes = </span><span class="s6">b'/</span><span class="s2">\xd0\xbf\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82</span><span class="s6">'</span>
        <span class="s2">if </span><span class="s1">PY3:</span>
            <span class="s0"># Under PY3, the escapes were decoded as latin-1</span>
            <span class="s1">path_bytes = path_bytes.decode(</span><span class="s4">'latin-1'</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(environ[</span><span class="s4">'PATH_INFO'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">path_bytes)</span>
        <span class="s1">self.assertEqual(environ[</span><span class="s4">'QUERY_STRING'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81=%D0%BE%D1%82%D0%B2%D0%B5%D1%82'</span><span class="s1">)</span>
        <span class="s1">start_response(</span><span class="s4">&quot;200 PASSED&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">test(self):</span>
        <span class="s2">with </span><span class="s1">self.connect() </span><span class="s2">as </span><span class="s1">sock:</span>
            <span class="s1">sock.sendall(</span>
                <span class="s6">b'''GET /%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82?%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81=%D0%BE%D1%82%D0%B2%D0%B5%D1%82 HTTP/1.1 
Host: localhost 
Connection: close 
 
'''</span><span class="s1">.replace(</span><span class="s6">b'</span><span class="s2">\n</span><span class="s6">'</span><span class="s2">, </span><span class="s6">b'</span><span class="s2">\r\n</span><span class="s6">'</span><span class="s1">))</span>
            <span class="s2">with </span><span class="s1">sock.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
                <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">reason=</span><span class="s4">'PASSED'</span><span class="s2">, </span><span class="s1">chunks=</span><span class="s2">False, </span><span class="s1">body=</span><span class="s4">''</span><span class="s2">, </span><span class="s1">content_length=</span><span class="s5">0</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestNonLatin1HeaderFromApplication(TestCase):</span>
    <span class="s1">error_fatal = </span><span class="s2">False </span><span class="s0"># Allow sending the exception response, don't kill the greenlet</span>

    <span class="s1">validator = </span><span class="s2">None </span><span class="s0"># Don't validate the application, it's deliberately bad</span>
    <span class="s1">header = </span><span class="s6">b'</span><span class="s2">\xe1\xbd\x8a</span><span class="s6">3' </span><span class="s0"># bomb in utf-8 bytes</span>
    <span class="s1">should_error = PY3 </span><span class="s0"># non-native string under Py3</span>

    <span class="s2">def </span><span class="s1">setUp(self):</span>
        <span class="s1">super(TestNonLatin1HeaderFromApplication</span><span class="s2">, </span><span class="s1">self).setUp()</span>
        <span class="s1">self.errors = []</span>

    <span class="s2">def </span><span class="s1">tearDown(self):</span>
        <span class="s1">self.errors = []</span>
        <span class="s1">super(TestNonLatin1HeaderFromApplication</span><span class="s2">, </span><span class="s1">self).tearDown()</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s0"># We return a header that cannot be encoded in latin-1</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">start_response(</span><span class="s4">&quot;200 PASSED&quot;</span><span class="s2">,</span>
                           <span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">(</span><span class="s4">'Custom-Header'</span><span class="s2">, </span><span class="s1">self.header)])</span>
        <span class="s2">except</span><span class="s1">:</span>
            <span class="s1">self.errors.append(sys.exc_info()[:</span><span class="s5">2</span><span class="s1">])</span>
            <span class="s2">raise</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">test(self):</span>
        <span class="s2">with </span><span class="s1">self.connect() </span><span class="s2">as </span><span class="s1">sock:</span>
            <span class="s1">self.expect_one_error()</span>
            <span class="s1">sock.sendall(</span><span class="s6">b'''GET / HTTP/1.1</span><span class="s2">\r\n\r\n</span><span class="s6">'''</span><span class="s1">)</span>
            <span class="s2">with </span><span class="s1">sock.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
                <span class="s2">if </span><span class="s1">self.should_error:</span>
                    <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">500</span><span class="s2">, </span><span class="s1">reason=</span><span class="s4">'Internal Server Error'</span><span class="s1">)</span>
                    <span class="s1">self.assert_error(where_type=pywsgi.SecureEnviron)</span>
                    <span class="s1">self.assertEqual(len(self.errors)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s1">_</span><span class="s2">, </span><span class="s1">v = self.errors[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">self.assertIsInstance(v</span><span class="s2">, </span><span class="s1">UnicodeError)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">200</span><span class="s2">, </span><span class="s1">reason=</span><span class="s4">'PASSED'</span><span class="s1">)</span>
                    <span class="s1">self.assertEqual(len(self.errors)</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestNonLatin1UnicodeHeaderFromApplication(TestNonLatin1HeaderFromApplication):</span>
    <span class="s0"># Flip-flop of the superclass: Python 3 native string, Python 2 unicode object</span>
    <span class="s1">header = </span><span class="s4">u&quot;</span><span class="s2">\u1f4a</span><span class="s4">3&quot; </span><span class="s0"># bomb in unicode</span>
    <span class="s0"># Error both on py3 and py2. On py2, non-native string. On py3, native string</span>
    <span class="s0"># that cannot be encoded to latin-1</span>
    <span class="s1">should_error = </span><span class="s2">True</span>


<span class="s2">class </span><span class="s1">TestInputReadline(TestCase):</span>
    <span class="s0"># this test relies on the fact that readline() returns '' after it reached EOF</span>
    <span class="s0"># this behaviour is not mandated by WSGI spec, it's just happens that gevent.wsgi behaves like that</span>
    <span class="s0"># as such, this may change in the future</span>

    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">input = environ[</span><span class="s4">'wsgi.input'</span><span class="s1">]</span>
        <span class="s1">lines = []</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">line = input.readline()</span>
            <span class="s2">if not </span><span class="s1">line:</span>
                <span class="s2">break</span>
            <span class="s1">line = line.decode(</span><span class="s4">'ascii'</span><span class="s1">) </span><span class="s2">if </span><span class="s1">PY3 </span><span class="s2">else </span><span class="s1">line</span>
            <span class="s1">lines.append(repr(line) + </span><span class="s4">' '</span><span class="s1">)</span>
        <span class="s1">start_response(</span><span class="s4">'200 hello'</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">return </span><span class="s1">[l.encode(</span><span class="s4">'ascii'</span><span class="s1">) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lines] </span><span class="s2">if </span><span class="s1">PY3 </span><span class="s2">else </span><span class="s1">lines</span>

    <span class="s2">def </span><span class="s1">test(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">content = </span><span class="s4">'hello</span><span class="s2">\n\n</span><span class="s4">world</span><span class="s2">\n</span><span class="s4">123'</span>
            <span class="s1">fd.write(</span><span class="s4">'POST / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n</span><span class="s4">'</span>
                     <span class="s4">'Content-Length: %s</span><span class="s2">\r\n\r\n</span><span class="s4">%s' </span><span class="s1">% (len(content)</span><span class="s2">, </span><span class="s1">content))</span>
            <span class="s1">fd.flush()</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">reason=</span><span class="s4">'hello'</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">&quot;'hello</span><span class="s2">\\</span><span class="s4">n' '</span><span class="s2">\\</span><span class="s4">n' 'world</span><span class="s2">\\</span><span class="s4">n' '123' &quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestInputIter(TestInputReadline):</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">input = environ[</span><span class="s4">'wsgi.input'</span><span class="s1">]</span>
        <span class="s1">lines = []</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">input:</span>
            <span class="s2">if not </span><span class="s1">line:</span>
                <span class="s2">break</span>
            <span class="s1">line = line.decode(</span><span class="s4">'ascii'</span><span class="s1">) </span><span class="s2">if </span><span class="s1">PY3 </span><span class="s2">else </span><span class="s1">line</span>
            <span class="s1">lines.append(repr(line) + </span><span class="s4">' '</span><span class="s1">)</span>
        <span class="s1">start_response(</span><span class="s4">'200 hello'</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">return </span><span class="s1">[l.encode(</span><span class="s4">'ascii'</span><span class="s1">) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lines] </span><span class="s2">if </span><span class="s1">PY3 </span><span class="s2">else </span><span class="s1">lines</span>


<span class="s2">class </span><span class="s1">TestInputReadlines(TestInputReadline):</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">input = environ[</span><span class="s4">'wsgi.input'</span><span class="s1">]</span>
        <span class="s1">lines = [l.decode(</span><span class="s4">'ascii'</span><span class="s1">) </span><span class="s2">if </span><span class="s1">PY3 </span><span class="s2">else </span><span class="s1">l </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">input.readlines()]</span>
        <span class="s1">lines = [repr(line) + </span><span class="s4">' ' </span><span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines]</span>
        <span class="s1">start_response(</span><span class="s4">'200 hello'</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">return </span><span class="s1">[l.encode(</span><span class="s4">'ascii'</span><span class="s1">) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lines] </span><span class="s2">if </span><span class="s1">PY3 </span><span class="s2">else </span><span class="s1">lines</span>


<span class="s2">class </span><span class="s1">TestInputN(TestCase):</span>
    <span class="s0"># testing for this:</span>
    <span class="s0"># File &quot;/home/denis/work/gevent/gevent/pywsgi.py&quot;, line 70, in _do_read</span>
    <span class="s0">#   if length and length &gt; self.content_length - self.position:</span>
    <span class="s0"># TypeError: unsupported operand type(s) for -: 'NoneType' and 'int'</span>

    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">environ[</span><span class="s4">'wsgi.input'</span><span class="s1">].read(</span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">test(self):</span>
        <span class="s1">self.urlopen()</span>


<span class="s2">class </span><span class="s1">TestErrorInApplication(TestCase):</span>

    <span class="s1">error = object()</span>
    <span class="s1">error_fatal = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">self.error = greentest.ExpectedException(</span><span class="s4">'TestError.application'</span><span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">self.error</span>

    <span class="s2">def </span><span class="s1">test(self):</span>
        <span class="s1">self.expect_one_error()</span>
        <span class="s1">self.urlopen(code=</span><span class="s5">500</span><span class="s1">)</span>
        <span class="s1">self.assert_error(greentest.ExpectedException</span><span class="s2">, </span><span class="s1">self.error)</span>


<span class="s2">class </span><span class="s1">TestError_after_start_response(TestErrorInApplication):</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">self.error = greentest.ExpectedException(</span><span class="s4">'TestError_after_start_response.application'</span><span class="s1">)</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">raise </span><span class="s1">self.error</span>


<span class="s2">class </span><span class="s1">TestEmptyYield(TestCase):</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">application(env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">yield </span><span class="s6">b&quot;&quot;</span>
        <span class="s2">yield </span><span class="s6">b&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_err(self):</span>
        <span class="s1">chunks = []</span>

        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>

            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">''</span><span class="s2">, </span><span class="s1">chunks=chunks)</span>

            <span class="s1">garbage = fd.read()</span>
        <span class="s1">self.assertEqual(garbage</span><span class="s2">, </span><span class="s6">b&quot;&quot;</span><span class="s2">, </span><span class="s4">&quot;got garbage: %r&quot; </span><span class="s1">% garbage)</span>


<span class="s2">class </span><span class="s1">TestFirstEmptyYield(TestCase):</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">application(env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">yield </span><span class="s6">b&quot;&quot;</span>
        <span class="s2">yield </span><span class="s6">b&quot;hello&quot;</span>

    <span class="s2">def </span><span class="s1">test_err(self):</span>
        <span class="s1">chunks = [</span><span class="s6">b'hello'</span><span class="s1">]</span>

        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>

            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'hello'</span><span class="s2">, </span><span class="s1">chunks=chunks)</span>

            <span class="s1">garbage = fd.read()</span>
        <span class="s1">self.assertEqual(garbage</span><span class="s2">, </span><span class="s6">b&quot;&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestEmptyYield304(TestCase):</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">application(env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">start_response(</span><span class="s4">'304 Not modified'</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">yield </span><span class="s6">b&quot;&quot;</span>
        <span class="s2">yield </span><span class="s6">b&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_err(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">304</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">''</span><span class="s2">, </span><span class="s1">chunks=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">garbage = fd.read()</span>
        <span class="s1">self.assertEqual(garbage</span><span class="s2">, </span><span class="s6">b&quot;&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestContentLength304(TestCase):</span>
    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">start_response(</span><span class="s4">'304 Not modified'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Length'</span><span class="s2">, </span><span class="s4">'100'</span><span class="s1">)])</span>
        <span class="s2">except </span><span class="s1">AssertionError </span><span class="s2">as </span><span class="s1">ex:</span>
            <span class="s1">start_response(</span><span class="s4">'200 Raised'</span><span class="s2">, </span><span class="s1">[])</span>
            <span class="s2">return </span><span class="s1">ex.args</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s4">'start_response did not fail but it should'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_err(self):</span>
        <span class="s1">body = </span><span class="s4">&quot;Invalid Content-Length for 304 response: '100' (must be absent or zero)&quot;</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>

            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">200</span><span class="s2">, </span><span class="s1">reason=</span><span class="s4">'Raised'</span><span class="s2">, </span><span class="s1">body=body</span><span class="s2">, </span><span class="s1">chunks=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">garbage = fd.read()</span>
        <span class="s1">self.assertEqual(garbage</span><span class="s2">, </span><span class="s6">b&quot;&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestBody304(TestCase):</span>
    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">start_response(</span><span class="s4">'304 Not modified'</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s6">b'body'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">test_err(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s2">with </span><span class="s1">self.assertRaises(AssertionError) </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s1">read_http(fd)</span>
            <span class="s1">ex = exc.exception</span>
            <span class="s1">self.assertEqual(str(ex)</span><span class="s2">, </span><span class="s4">'The 304 response must have no body'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestWrite304(TestCase):</span>
    <span class="s1">validator = </span><span class="s2">None</span>
    <span class="s1">error_raised = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">write = start_response(</span><span class="s4">'304 Not modified'</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s1">self.error_raised = </span><span class="s2">False</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">write(</span><span class="s4">'body'</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">AssertionError </span><span class="s2">as </span><span class="s1">ex:</span>
            <span class="s1">self.error_raised = </span><span class="s2">True</span>
            <span class="s2">raise </span><span class="s1">ExpectedAssertionError(*ex.args)</span>

    <span class="s2">def </span><span class="s1">test_err(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s6">b'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">Host: localhost</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s6">'</span><span class="s1">)</span>
            <span class="s2">with </span><span class="s1">self.assertRaises(AssertionError) </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s1">read_http(fd)</span>
            <span class="s1">ex = exc.exception</span>

        <span class="s1">self.assertEqual(str(ex)</span><span class="s2">, </span><span class="s4">'The 304 response must have no body'</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(self.error_raised</span><span class="s2">, </span><span class="s4">'write() must raise'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestEmptyWrite(TestEmptyYield):</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">application(env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">write = start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s1">write(</span><span class="s6">b&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">write(</span><span class="s6">b&quot;&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">[]</span>


<span class="s2">class </span><span class="s1">BadRequestTests(TestCase):</span>
    <span class="s1">validator = </span><span class="s2">None</span>
    <span class="s0"># pywsgi checks content-length, but wsgi does not</span>
    <span class="s1">content_length = </span><span class="s2">None</span>

    <span class="s2">assert </span><span class="s1">TestCase.handler_class._print_unexpected_exc</span>

    <span class="s2">class </span><span class="s1">handler_class(TestCase.handler_class):</span>
        <span class="s2">def </span><span class="s1">_print_unexpected_exc(self):</span>
            <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s4">&quot;Should not print a traceback&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">self.assertEqual(env[</span><span class="s4">'CONTENT_LENGTH'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.content_length)</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s6">b'hello'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">test_negative_content_length(self):</span>
        <span class="s1">self.content_length = </span><span class="s4">'-100'</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Content-Length: %s</span><span class="s2">\r\n\r\n</span><span class="s4">' </span><span class="s1">% self.content_length)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=(</span><span class="s5">200</span><span class="s2">, </span><span class="s5">400</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_illegal_content_length(self):</span>
        <span class="s1">self.content_length = </span><span class="s4">'abc'</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Content-Length: %s</span><span class="s2">\r\n\r\n</span><span class="s4">' </span><span class="s1">% self.content_length)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=(</span><span class="s5">200</span><span class="s2">, </span><span class="s5">400</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_bad_request_line_with_percent(self):</span>
        <span class="s0"># If the request is invalid and contains Python formatting characters (%)</span>
        <span class="s0"># we don't fail to log the error and we do generate a 400.</span>
        <span class="s0"># https://github.com/gevent/gevent/issues/1708</span>
        <span class="s1">bad_request = </span><span class="s4">'GET / HTTP %</span><span class="s2">\r\n</span><span class="s4">'</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(bad_request)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">400</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">ChunkedInputTests(TestCase):</span>
    <span class="s1">dirt = </span><span class="s4">&quot;&quot;</span>
    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">input = env[</span><span class="s4">'wsgi.input'</span><span class="s1">]</span>
        <span class="s1">response = []</span>

        <span class="s1">pi = env[</span><span class="s4">&quot;PATH_INFO&quot;</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">pi == </span><span class="s4">&quot;/short-read&quot;</span><span class="s1">:</span>
            <span class="s1">d = input.read(</span><span class="s5">10</span><span class="s1">)</span>
            <span class="s1">response = [d]</span>
        <span class="s2">elif </span><span class="s1">pi == </span><span class="s4">&quot;/lines&quot;</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">input:</span>
                <span class="s1">response.append(x)</span>
        <span class="s2">elif </span><span class="s1">pi == </span><span class="s4">&quot;/ping&quot;</span><span class="s1">:</span>
            <span class="s1">input.read(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">response.append(</span><span class="s6">b&quot;pong&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;bad path&quot;</span><span class="s1">)</span>

        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">response</span>

    <span class="s2">def </span><span class="s1">chunk_encode(self</span><span class="s2">, </span><span class="s1">chunks</span><span class="s2">, </span><span class="s1">dirt=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">dirt </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dirt = self.dirt</span>

        <span class="s2">return </span><span class="s1">chunk_encode(chunks</span><span class="s2">, </span><span class="s1">dirt=dirt)</span>

    <span class="s2">def </span><span class="s1">body(self</span><span class="s2">, </span><span class="s1">dirt=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self.chunk_encode([</span><span class="s4">&quot;this&quot;</span><span class="s2">, </span><span class="s4">&quot; is &quot;</span><span class="s2">, </span><span class="s4">&quot;chunked&quot;</span><span class="s2">, </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">line&quot;</span><span class="s2">, </span><span class="s4">&quot; 2&quot;</span><span class="s2">, </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s2">, </span><span class="s4">&quot;line3&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dirt=dirt)</span>

    <span class="s2">def </span><span class="s1">ping(self</span><span class="s2">, </span><span class="s1">fd):</span>
        <span class="s1">fd.write(</span><span class="s4">&quot;GET /ping HTTP/1.1</span><span class="s2">\r\n\r\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">&quot;pong&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">ping_if_possible(self</span><span class="s2">, </span><span class="s1">fd):</span>
        <span class="s1">self.ping(fd)</span>

    <span class="s2">def </span><span class="s1">test_short_read_with_content_length(self):</span>
        <span class="s1">body = self.body()</span>
        <span class="s1">req = </span><span class="s6">b&quot;POST /short-read HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">transfer-encoding: Chunked</span><span class="s2">\r\n</span><span class="s6">Content-Length:1000</span><span class="s2">\r\n\r\n</span><span class="s6">&quot; </span><span class="s1">+ body</span>
        <span class="s2">with </span><span class="s1">self.connect() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s2">with </span><span class="s1">conn.makefile(bufsize=</span><span class="s5">1</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fd: </span><span class="s0"># pylint:disable=unexpected-keyword-arg</span>
                <span class="s1">fd.write(req)</span>
                <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">&quot;this is ch&quot;</span><span class="s1">)</span>

                <span class="s1">self.ping_if_possible(fd)</span>

    <span class="s2">def </span><span class="s1">test_short_read_with_zero_content_length(self):</span>
        <span class="s1">body = self.body()</span>
        <span class="s1">req = </span><span class="s6">b&quot;POST /short-read HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">transfer-encoding: Chunked</span><span class="s2">\r\n</span><span class="s6">Content-Length:0</span><span class="s2">\r\n\r\n</span><span class="s6">&quot; </span><span class="s1">+ body</span>
        <span class="s0">#print(&quot;REQUEST:&quot;, repr(req))</span>

        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(req)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">&quot;this is ch&quot;</span><span class="s1">)</span>

            <span class="s1">self.ping_if_possible(fd)</span>

    <span class="s2">def </span><span class="s1">test_short_read(self):</span>
        <span class="s1">body = self.body()</span>
        <span class="s1">req = </span><span class="s6">b&quot;POST /short-read HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">transfer-encoding: Chunked</span><span class="s2">\r\n\r\n</span><span class="s6">&quot; </span><span class="s1">+ body</span>

        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(req)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">&quot;this is ch&quot;</span><span class="s1">)</span>

            <span class="s1">self.ping_if_possible(fd)</span>

    <span class="s2">def </span><span class="s1">test_dirt(self):</span>
        <span class="s1">body = self.body(dirt=</span><span class="s4">&quot;; here is dirt</span><span class="s2">\0</span><span class="s4">bla&quot;</span><span class="s1">)</span>
        <span class="s1">req = </span><span class="s6">b&quot;POST /ping HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">transfer-encoding: Chunked</span><span class="s2">\r\n\r\n</span><span class="s6">&quot; </span><span class="s1">+ body</span>

        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(req)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">&quot;pong&quot;</span><span class="s1">)</span>

            <span class="s1">self.ping_if_possible(fd)</span>

    <span class="s2">def </span><span class="s1">test_chunked_readline(self):</span>
        <span class="s1">body = self.body()</span>
        <span class="s1">req = </span><span class="s4">&quot;POST /lines HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Content-Length: %s</span><span class="s2">\r\n</span><span class="s4">transfer-encoding: Chunked</span><span class="s2">\r\n\r\n</span><span class="s4">&quot; </span><span class="s1">% (len(body))</span>
        <span class="s1">req = req.encode(</span><span class="s4">'latin-1'</span><span class="s1">)</span>
        <span class="s1">req += body</span>

        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(req)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">'this is chunked</span><span class="s2">\n</span><span class="s4">line 2</span><span class="s2">\n</span><span class="s4">line3'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_close_before_finished(self):</span>
        <span class="s1">self.expect_one_error()</span>
        <span class="s1">body = </span><span class="s6">b'4</span><span class="s2">\r\n</span><span class="s6">thi'</span>
        <span class="s1">req = </span><span class="s6">b&quot;POST /short-read HTTP/1.1</span><span class="s2">\r\n</span><span class="s6">transfer-encoding: Chunked</span><span class="s2">\r\n\r\n</span><span class="s6">&quot; </span><span class="s1">+ body</span>
        <span class="s2">with </span><span class="s1">self.connect() </span><span class="s2">as </span><span class="s1">sock:</span>
            <span class="s2">with </span><span class="s1">sock.makefile(bufsize=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">mode=</span><span class="s4">'wb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fd:</span><span class="s0"># pylint:disable=unexpected-keyword-arg</span>
                <span class="s1">fd.write(req)</span>
                <span class="s1">fd.close()</span>

        <span class="s0"># Python 3 keeps the socket open even though the only</span>
        <span class="s0"># makefile is gone; python 2 closed them both (because there were</span>
        <span class="s0"># no outstanding references to the socket). Closing is essential for the server</span>
        <span class="s0"># to get the message that the read will fail. It's better to be explicit</span>
        <span class="s0"># to avoid a ResourceWarning</span>
        <span class="s1">sock.close()</span>
        <span class="s0"># Under Py2 it still needs to go away, which was implicit before</span>
        <span class="s2">del </span><span class="s1">fd</span>
        <span class="s2">del </span><span class="s1">sock</span>

        <span class="s1">gevent.get_hub().loop.update_now()</span>
        <span class="s1">gevent.sleep(</span><span class="s5">0.01</span><span class="s1">) </span><span class="s0"># timing needed for cpython</span>

        <span class="s2">if </span><span class="s1">greentest.PYPY:</span>
            <span class="s0"># XXX: Something is keeping the socket alive,</span>
            <span class="s0"># by which I mean, the close event is not propagating to the server</span>
            <span class="s0"># and waking up its recv() loop...we are stuck with the three bytes of</span>
            <span class="s0"># 'thi' in the buffer and trying to read the forth. No amount of tinkering</span>
            <span class="s0"># with the timing changes this...the only thing that does is running a</span>
            <span class="s0"># GC and letting some object get collected. Might this be a problem in real life?</span>

            <span class="s2">import </span><span class="s1">gc</span>
            <span class="s1">gc.collect()</span>
            <span class="s1">gevent.sleep(</span><span class="s5">0.01</span><span class="s1">)</span>
            <span class="s1">gevent.get_hub().loop.update_now()</span>
            <span class="s1">gc.collect()</span>
            <span class="s1">gevent.sleep(</span><span class="s5">0.01</span><span class="s1">)</span>

        <span class="s0"># XXX2: Sometimes windows and PyPy/Travis fail to get this error, leading to a test failure.</span>
        <span class="s0"># This would have to be due to the socket being kept around and open,</span>
        <span class="s0"># not closed at the low levels. I haven't seen this locally.</span>
        <span class="s0"># In the PyPy case, I've seen the IOError reported on the console, but not</span>
        <span class="s0"># captured in the variables.</span>
        <span class="s0"># https://travis-ci.org/gevent/gevent/jobs/329232976#L1374</span>
        <span class="s1">self.assert_error(IOError</span><span class="s2">, </span><span class="s4">'unexpected end of file while parsing chunked data'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Expect100ContinueTests(TestCase):</span>
    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">content_length = int(environ[</span><span class="s4">'CONTENT_LENGTH'</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">content_length &gt; </span><span class="s5">1024</span><span class="s1">:</span>
            <span class="s1">start_response(</span><span class="s4">'417 Expectation Failed'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Length'</span><span class="s2">, </span><span class="s4">'7'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s6">b'failure'</span><span class="s1">]</span>

        <span class="s0"># pywsgi did sent a &quot;100 continue&quot; for each read</span>
        <span class="s0"># see http://code.google.com/p/gevent/issues/detail?id=93</span>
        <span class="s1">text = environ[</span><span class="s4">'wsgi.input'</span><span class="s1">].read(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">text += environ[</span><span class="s4">'wsgi.input'</span><span class="s1">].read(content_length - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Length'</span><span class="s2">, </span><span class="s1">str(len(text)))</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">[text]</span>

    <span class="s2">def </span><span class="s1">test_continue(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'PUT / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Content-length: 1025</span><span class="s2">\r\n</span><span class="s4">Expect: 100-continue</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">417</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">&quot;failure&quot;</span><span class="s1">)</span>

            <span class="s1">fd.write(</span><span class="s4">'PUT / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Content-length: 7</span><span class="s2">\r\n</span><span class="s4">Expect: 100-continue</span><span class="s2">\r\n\r\n</span><span class="s4">testing'</span><span class="s1">)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">100</span><span class="s1">)</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">body=</span><span class="s4">&quot;testing&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">MultipleCookieHeadersTest(TestCase):</span>

    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">self.assertEqual(environ[</span><span class="s4">'HTTP_COOKIE'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'name1=&quot;value1&quot;; name2=&quot;value2&quot;'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(environ[</span><span class="s4">'HTTP_COOKIE2'</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'nameA=&quot;valueA&quot;; nameB=&quot;valueB&quot;'</span><span class="s1">)</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">test(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'''GET / HTTP/1.1 
Host: localhost 
Cookie: name1=&quot;value1&quot; 
Cookie2: nameA=&quot;valueA&quot; 
Cookie2: nameB=&quot;valueB&quot; 
Cookie: name2=&quot;value2&quot;</span><span class="s2">\n\n</span><span class="s4">'''</span><span class="s1">.replace(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\r\n</span><span class="s4">'</span><span class="s1">))</span>
            <span class="s1">read_http(fd)</span>


<span class="s2">class </span><span class="s1">TestLeakInput(TestCase):</span>

    <span class="s1">_leak_wsgi_input = </span><span class="s2">None</span>
    <span class="s1">_leak_environ = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">tearDown(self):</span>
        <span class="s1">TestCase.tearDown(self)</span>
        <span class="s1">self._leak_wsgi_input = </span><span class="s2">None</span>
        <span class="s1">self._leak_environ = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">pi = environ[</span><span class="s4">&quot;PATH_INFO&quot;</span><span class="s1">]</span>
        <span class="s1">self._leak_wsgi_input = environ[</span><span class="s4">&quot;wsgi.input&quot;</span><span class="s1">]</span>
        <span class="s1">self._leak_environ = environ</span>
        <span class="s2">if </span><span class="s1">pi == </span><span class="s4">&quot;/leak-frame&quot;</span><span class="s1">:</span>
            <span class="s1">environ[</span><span class="s4">&quot;_leak&quot;</span><span class="s1">] = sys._getframe(</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">text = </span><span class="s6">b&quot;foobar&quot;</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Length'</span><span class="s2">, </span><span class="s1">str(len(text)))</span><span class="s2">, </span><span class="s1">(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">[text]</span>

    <span class="s2">def </span><span class="s1">test_connection_close_leak_simple(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s6">b&quot;GET / HTTP/1.0</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s6">&quot;</span><span class="s1">)</span>
            <span class="s1">d = fd.read()</span>
        <span class="s1">self.assertTrue(d.startswith(</span><span class="s6">b&quot;HTTP/1.1 200 OK&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">d)</span>

    <span class="s2">def </span><span class="s1">test_connection_close_leak_frame(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s6">b&quot;GET /leak-frame HTTP/1.0</span><span class="s2">\r\n</span><span class="s6">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s6">&quot;</span><span class="s1">)</span>
            <span class="s1">d = fd.read()</span>
        <span class="s1">self.assertTrue(d.startswith(</span><span class="s6">b&quot;HTTP/1.1 200 OK&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">d)</span>
        <span class="s1">self._leak_environ.pop(</span><span class="s4">'_leak'</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">TestHTTPResponseSplitting(TestCase):</span>
    <span class="s0"># The validator would prevent the app from doing the</span>
    <span class="s0"># bad things it needs to do</span>
    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s1">status = </span><span class="s4">'200 OK'</span>
    <span class="s1">headers = ()</span>
    <span class="s1">start_exc = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">setUp(self):</span>
        <span class="s1">TestCase.setUp(self)</span>
        <span class="s1">self.start_exc = </span><span class="s2">None</span>
        <span class="s1">self.status = TestHTTPResponseSplitting.status</span>
        <span class="s1">self.headers = TestHTTPResponseSplitting.headers</span>

    <span class="s2">def </span><span class="s1">tearDown(self):</span>
        <span class="s1">TestCase.tearDown(self)</span>
        <span class="s1">self.start_exc = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">start_response(self.status</span><span class="s2">, </span><span class="s1">self.headers)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e: </span><span class="s0"># pylint: disable=broad-except</span>
            <span class="s1">self.start_exc = e</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.start_exc = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">()</span>

    <span class="s2">def </span><span class="s1">_assert_failure(self</span><span class="s2">, </span><span class="s1">message):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.0</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">fd.read()</span>
        <span class="s1">self.assertIsInstance(self.start_exc</span><span class="s2">, </span><span class="s1">ValueError)</span>
        <span class="s1">self.assertEqual(self.start_exc.args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">message)</span>

    <span class="s2">def </span><span class="s1">test_newline_in_status(self):</span>
        <span class="s1">self.status = </span><span class="s4">'200 OK</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n</span><span class="s4">Content-Length: 0</span><span class="s2">\r\n\r\n</span><span class="s4">'</span>
        <span class="s1">self._assert_failure(</span><span class="s4">'carriage return or newline in status'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_newline_in_header_value(self):</span>
        <span class="s1">self.headers = [(</span><span class="s4">'Test'</span><span class="s2">, </span><span class="s4">'Hi</span><span class="s2">\r\n</span><span class="s4">Connection: close'</span><span class="s1">)]</span>
        <span class="s1">self._assert_failure(</span><span class="s4">'carriage return or newline in header value'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_newline_in_header_name(self):</span>
        <span class="s1">self.headers = [(</span><span class="s4">'Test</span><span class="s2">\r\n</span><span class="s4">'</span><span class="s2">, </span><span class="s4">'Hi'</span><span class="s1">)]</span>
        <span class="s1">self._assert_failure(</span><span class="s4">'carriage return or newline in header name'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestInvalidEnviron(TestCase):</span>
    <span class="s1">validator = </span><span class="s2">None</span>
    <span class="s0"># check that WSGIServer does not insert any default values for CONTENT_LENGTH</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">environ.items():</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'CONTENT_LENGTH'</span><span class="s2">, </span><span class="s4">'CONTENT_TYPE'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">key.startswith(</span><span class="s4">'HTTP_'</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">key != </span><span class="s4">'HTTP_HOST'</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ExpectedAssertionError(</span><span class="s4">'Unexpected environment variable: %s=%r' </span><span class="s1">% (</span>
                        <span class="s1">key</span><span class="s2">, </span><span class="s1">value))</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">test(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.0</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">read_http(fd)</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">read_http(fd)</span>


<span class="s2">class </span><span class="s1">TestInvalidHeadersDropped(TestCase):</span>
    <span class="s1">validator = </span><span class="s2">None</span>
    <span class="s0"># check that invalid headers with a _ are dropped</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">self.assertNotIn(</span><span class="s4">'HTTP_X_AUTH_USER'</span><span class="s2">, </span><span class="s1">environ)</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">test(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.0</span><span class="s2">\r\n</span><span class="s4">x-auth_user: bob</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">read_http(fd)</span>


<span class="s2">class </span><span class="s1">TestHandlerSubclass(TestCase):</span>

    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s2">class </span><span class="s1">handler_class(TestCase.handler_class):</span>

        <span class="s2">def </span><span class="s1">read_requestline(self):</span>
            <span class="s1">data = self.rfile.read(</span><span class="s5">7</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">data[</span><span class="s5">0</span><span class="s1">] == </span><span class="s6">b'&lt;'</span><span class="s1">[</span><span class="s5">0</span><span class="s1">]: </span><span class="s0"># py3: indexing bytes returns ints. sigh.</span>
                <span class="s0"># Returning nothing stops handle_one_request()</span>
                <span class="s0"># Note that closing or even deleting self.socket() here</span>
                <span class="s0"># can lead to the read side throwing Connection Reset By Peer,</span>
                <span class="s0"># depending on the Python version and OS</span>
                <span class="s1">data += self.rfile.read(</span><span class="s5">15</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">data.lower() == </span><span class="s6">b'&lt;policy-file-request/&gt;'</span><span class="s1">:</span>
                    <span class="s1">self.socket.sendall(</span><span class="s6">b'HELLO'</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.log_error(</span><span class="s4">'Invalid request: %r'</span><span class="s2">, </span><span class="s1">data)</span>
                <span class="s2">return None</span>
            <span class="s2">return </span><span class="s1">data + self.rfile.readline()</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[])</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">test(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s6">b'&lt;policy-file-request/&gt;</span><span class="s2">\x00</span><span class="s6">'</span><span class="s1">)</span>
            <span class="s1">fd.flush() </span><span class="s0"># flush() is needed on PyPy, apparently it buffers slightly differently</span>
            <span class="s1">self.assertEqual(fd.read()</span><span class="s2">, </span><span class="s6">b'HELLO'</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: close</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">fd.flush()</span>
            <span class="s1">read_http(fd)</span>

        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s0"># Trigger an error</span>
            <span class="s1">fd.write(</span><span class="s4">'&lt;policy-file-XXXuest/&gt;</span><span class="s2">\x00</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s1">fd.flush()</span>
            <span class="s1">self.assertEqual(fd.read()</span><span class="s2">, </span><span class="s6">b''</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestErrorAfterChunk(TestCase):</span>
    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">application(env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">yield </span><span class="s6">b&quot;hello&quot;</span>
        <span class="s2">raise </span><span class="s1">greentest.ExpectedException(</span><span class="s4">'TestErrorAfterChunk'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test(self):</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">self.expect_one_error()</span>
            <span class="s1">fd.write(</span><span class="s4">'GET / HTTP/1.1</span><span class="s2">\r\n</span><span class="s4">Host: localhost</span><span class="s2">\r\n</span><span class="s4">Connection: keep-alive</span><span class="s2">\r\n\r\n</span><span class="s4">'</span><span class="s1">)</span>
            <span class="s2">with </span><span class="s1">self.assertRaises(ValueError):</span>
                <span class="s1">read_http(fd)</span>
        <span class="s1">self.assert_error(greentest.ExpectedException)</span>


<span class="s2">def </span><span class="s1">chunk_encode(chunks</span><span class="s2">, </span><span class="s1">dirt=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">dirt </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">dirt = </span><span class="s4">&quot;&quot;</span>

    <span class="s1">b = </span><span class="s6">b&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">chunks:</span>
        <span class="s1">x = </span><span class="s4">&quot;%x%s</span><span class="s2">\r\n</span><span class="s4">%s</span><span class="s2">\r\n</span><span class="s4">&quot; </span><span class="s1">% (len(c)</span><span class="s2">, </span><span class="s1">dirt</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">b += x.encode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">b</span>


<span class="s2">class </span><span class="s1">TestInputRaw(greentest.BaseTestCase):</span>
    <span class="s2">def </span><span class="s1">make_input(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">content_length=</span><span class="s2">None, </span><span class="s1">chunked_input=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">list):</span>
            <span class="s1">data = chunk_encode(data)</span>
            <span class="s1">chunked_input = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">PY3:</span>
            <span class="s1">data = data.encode(</span><span class="s4">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">Input(StringIO(data)</span><span class="s2">, </span><span class="s1">content_length=content_length</span><span class="s2">, </span><span class="s1">chunked_input=chunked_input)</span>

    <span class="s2">if </span><span class="s1">PY3:</span>
        <span class="s2">def </span><span class="s1">assertEqual(self</span><span class="s2">, </span><span class="s1">first</span><span class="s2">, </span><span class="s1">second</span><span class="s2">, </span><span class="s1">msg=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">isinstance(second</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">second = second.encode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
            <span class="s1">super(TestInputRaw</span><span class="s2">, </span><span class="s1">self).assertEqual(first</span><span class="s2">, </span><span class="s1">second</span><span class="s2">, </span><span class="s1">msg)</span>

    <span class="s2">def </span><span class="s1">test_short_post(self):</span>
        <span class="s1">i = self.make_input(</span><span class="s4">&quot;1&quot;</span><span class="s2">, </span><span class="s1">content_length=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(IOError</span><span class="s2">, </span><span class="s1">i.read)</span>

    <span class="s2">def </span><span class="s1">test_short_post_read_with_length(self):</span>
        <span class="s1">i = self.make_input(</span><span class="s4">&quot;1&quot;</span><span class="s2">, </span><span class="s1">content_length=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(IOError</span><span class="s2">, </span><span class="s1">i.read</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_short_post_readline(self):</span>
        <span class="s1">i = self.make_input(</span><span class="s4">&quot;1&quot;</span><span class="s2">, </span><span class="s1">content_length=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(IOError</span><span class="s2">, </span><span class="s1">i.readline)</span>

    <span class="s2">def </span><span class="s1">test_post(self):</span>
        <span class="s1">i = self.make_input(</span><span class="s4">&quot;12&quot;</span><span class="s2">, </span><span class="s1">content_length=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">data = i.read()</span>
        <span class="s1">self.assertEqual(data</span><span class="s2">, </span><span class="s4">&quot;12&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_post_read_with_length(self):</span>
        <span class="s1">i = self.make_input(</span><span class="s4">&quot;12&quot;</span><span class="s2">, </span><span class="s1">content_length=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">data = i.read(</span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(data</span><span class="s2">, </span><span class="s4">&quot;12&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_chunked(self):</span>
        <span class="s1">i = self.make_input([</span><span class="s4">&quot;1&quot;</span><span class="s2">, </span><span class="s4">&quot;2&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">])</span>
        <span class="s1">data = i.read()</span>
        <span class="s1">self.assertEqual(data</span><span class="s2">, </span><span class="s4">&quot;12&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_chunked_read_with_length(self):</span>
        <span class="s1">i = self.make_input([</span><span class="s4">&quot;1&quot;</span><span class="s2">, </span><span class="s4">&quot;2&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">])</span>
        <span class="s1">data = i.read(</span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(data</span><span class="s2">, </span><span class="s4">&quot;12&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_chunked_missing_chunk(self):</span>
        <span class="s1">i = self.make_input([</span><span class="s4">&quot;1&quot;</span><span class="s2">, </span><span class="s4">&quot;2&quot;</span><span class="s1">])</span>
        <span class="s1">self.assertRaises(IOError</span><span class="s2">, </span><span class="s1">i.read)</span>

    <span class="s2">def </span><span class="s1">test_chunked_missing_chunk_read_with_length(self):</span>
        <span class="s1">i = self.make_input([</span><span class="s4">&quot;1&quot;</span><span class="s2">, </span><span class="s4">&quot;2&quot;</span><span class="s1">])</span>
        <span class="s1">self.assertRaises(IOError</span><span class="s2">, </span><span class="s1">i.read</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_chunked_missing_chunk_readline(self):</span>
        <span class="s1">i = self.make_input([</span><span class="s4">&quot;1&quot;</span><span class="s2">, </span><span class="s4">&quot;2&quot;</span><span class="s1">])</span>
        <span class="s1">self.assertRaises(IOError</span><span class="s2">, </span><span class="s1">i.readline)</span>

    <span class="s2">def </span><span class="s1">test_chunked_short_chunk(self):</span>
        <span class="s1">i = self.make_input(</span><span class="s4">&quot;2</span><span class="s2">\r\n</span><span class="s4">1&quot;</span><span class="s2">, </span><span class="s1">chunked_input=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(IOError</span><span class="s2">, </span><span class="s1">i.read)</span>

    <span class="s2">def </span><span class="s1">test_chunked_short_chunk_read_with_length(self):</span>
        <span class="s1">i = self.make_input(</span><span class="s4">&quot;2</span><span class="s2">\r\n</span><span class="s4">1&quot;</span><span class="s2">, </span><span class="s1">chunked_input=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(IOError</span><span class="s2">, </span><span class="s1">i.read</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_chunked_short_chunk_readline(self):</span>
        <span class="s1">i = self.make_input(</span><span class="s4">&quot;2</span><span class="s2">\r\n</span><span class="s4">1&quot;</span><span class="s2">, </span><span class="s1">chunked_input=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(IOError</span><span class="s2">, </span><span class="s1">i.readline)</span>

    <span class="s2">def </span><span class="s1">test_32bit_overflow(self):</span>
        <span class="s0"># https://github.com/gevent/gevent/issues/289</span>
        <span class="s0"># Should not raise an OverflowError on Python 2</span>
        <span class="s1">data = </span><span class="s6">b'asdf</span><span class="s2">\n</span><span class="s6">ghij</span><span class="s2">\n</span><span class="s6">'</span>
        <span class="s1">long_data = </span><span class="s6">b'a' </span><span class="s1">* (pywsgi.MAX_REQUEST_LINE + </span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">long_data += </span><span class="s6">b'</span><span class="s2">\n</span><span class="s6">'</span>
        <span class="s1">data = data + long_data</span>
        <span class="s1">partial_data = </span><span class="s6">b'qjk</span><span class="s2">\n</span><span class="s6">' </span><span class="s0"># Note terminating \n</span>
        <span class="s1">n = </span><span class="s5">25 </span><span class="s1">* </span><span class="s5">1000000000</span>
        <span class="s2">if </span><span class="s1">hasattr(n</span><span class="s2">, </span><span class="s4">'bit_length'</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(n.bit_length()</span><span class="s2">, </span><span class="s5">35</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">PY3 </span><span class="s2">and not </span><span class="s1">PYPY:</span>
            <span class="s0"># Make sure we have the impl we think we do</span>
            <span class="s1">self.assertRaises(OverflowError</span><span class="s2">, </span><span class="s1">StringIO(data).readline</span><span class="s2">, </span><span class="s1">n)</span>

        <span class="s1">i = self.make_input(data</span><span class="s2">, </span><span class="s1">content_length=n)</span>
        <span class="s0"># No size hint, but we have too large a content_length to fit</span>
        <span class="s1">self.assertEqual(i.readline()</span><span class="s2">, </span><span class="s6">b'asdf</span><span class="s2">\n</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s0"># Large size hint</span>
        <span class="s1">self.assertEqual(i.readline(n)</span><span class="s2">, </span><span class="s6">b'ghij</span><span class="s2">\n</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(i.readline(n)</span><span class="s2">, </span><span class="s1">long_data)</span>

        <span class="s0"># Now again with the real content length, assuring we can't read past it</span>
        <span class="s1">i = self.make_input(data + partial_data</span><span class="s2">, </span><span class="s1">content_length=len(data) + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(i.readline()</span><span class="s2">, </span><span class="s6">b'asdf</span><span class="s2">\n</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(i.readline(n)</span><span class="s2">, </span><span class="s6">b'ghij</span><span class="s2">\n</span><span class="s6">'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(i.readline(n)</span><span class="s2">, </span><span class="s1">long_data)</span>
        <span class="s0"># Now we've reached content_length so we shouldn't be able to</span>
        <span class="s0"># read anymore except the one byte remaining</span>
        <span class="s1">self.assertEqual(i.readline(n)</span><span class="s2">, </span><span class="s6">b'q'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Test414(TestCase):</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">application(env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s4">'should not get there'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test(self):</span>
        <span class="s1">longline = </span><span class="s4">'x' </span><span class="s1">* </span><span class="s5">20000</span>
        <span class="s2">with </span><span class="s1">self.makefile() </span><span class="s2">as </span><span class="s1">fd:</span>
            <span class="s1">fd.write((</span><span class="s4">'''GET /%s HTTP/1.0</span><span class="s2">\r\n</span><span class="s4">Hello: world</span><span class="s2">\r\n\r\n</span><span class="s4">''' </span><span class="s1">% longline).encode(</span><span class="s4">'latin-1'</span><span class="s1">))</span>
            <span class="s1">read_http(fd</span><span class="s2">, </span><span class="s1">code=</span><span class="s5">414</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestLogging(TestCase):</span>

    <span class="s0"># Something that gets wrapped in a LoggingLogAdapter</span>
    <span class="s2">class </span><span class="s1">Logger(object):</span>
        <span class="s1">accessed = </span><span class="s2">None</span>
        <span class="s1">logged = </span><span class="s2">None</span>
        <span class="s1">thing = </span><span class="s2">None</span>

        <span class="s2">def </span><span class="s1">log(self</span><span class="s2">, </span><span class="s1">level</span><span class="s2">, </span><span class="s1">msg):</span>
            <span class="s1">self.logged = (level</span><span class="s2">, </span><span class="s1">msg)</span>

        <span class="s2">def </span><span class="s1">access(self</span><span class="s2">, </span><span class="s1">msg):</span>
            <span class="s1">self.accessed = msg</span>

        <span class="s2">def </span><span class="s1">get_thing(self):</span>
            <span class="s2">return </span><span class="s1">self.thing</span>

    <span class="s2">def </span><span class="s1">init_logger(self):</span>
        <span class="s2">return </span><span class="s1">self.Logger()</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">application(env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s6">b'hello'</span><span class="s1">]</span>

    <span class="s0"># Tests for issue #663</span>

    <span class="s2">def </span><span class="s1">test_proxy_methods_on_log(self):</span>
        <span class="s0"># An object that looks like a logger gets wrapped</span>
        <span class="s0"># with a proxy that</span>
        <span class="s1">self.assertTrue(isinstance(self.server.log</span><span class="s2">, </span><span class="s1">pywsgi.LoggingLogAdapter))</span>
        <span class="s1">self.server.log.access(</span><span class="s4">&quot;access&quot;</span><span class="s1">)</span>
        <span class="s1">self.server.log.write(</span><span class="s4">&quot;write&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(self.server.log.accessed</span><span class="s2">, </span><span class="s4">&quot;access&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(self.server.log.logged</span><span class="s2">, </span><span class="s1">(</span><span class="s5">20</span><span class="s2">, </span><span class="s4">&quot;write&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_set_attributes(self):</span>
        <span class="s0"># Not defined by the wrapper, it goes to the logger</span>
        <span class="s1">self.server.log.thing = </span><span class="s5">42</span>
        <span class="s1">self.assertEqual(self.server.log.get_thing()</span><span class="s2">, </span><span class="s5">42</span><span class="s1">)</span>

        <span class="s2">del </span><span class="s1">self.server.log.thing</span>
        <span class="s1">self.assertEqual(self.server.log.get_thing()</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_status_log(self):</span>
        <span class="s0"># Issue 664: Make sure we format the status line as a string</span>
        <span class="s1">self.urlopen()</span>
        <span class="s1">msg = self.server.log.logged[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">self.assertTrue(</span><span class="s4">'&quot;GET / HTTP/1.1&quot; 200 ' </span><span class="s2">in </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">msg)</span>

        <span class="s0"># Issue 756: Make sure we don't throw a newline on the end</span>
        <span class="s1">self.assertTrue(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">' </span><span class="s2">not in </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">msg)</span>

<span class="s2">class </span><span class="s1">TestEnviron(TestCase):</span>

    <span class="s0"># The wsgiref validator asserts type(environ) is dict.</span>
    <span class="s0"># https://mail.python.org/pipermail/web-sig/2016-March/005455.html</span>
    <span class="s1">validator = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">init_server(self</span><span class="s2">, </span><span class="s1">application):</span>
        <span class="s1">super(TestEnviron</span><span class="s2">, </span><span class="s1">self).init_server(application)</span>
        <span class="s1">self.server.environ_class = pywsgi.SecureEnviron</span>

    <span class="s2">def </span><span class="s1">application(self</span><span class="s2">, </span><span class="s1">env</span><span class="s2">, </span><span class="s1">start_response):</span>
        <span class="s1">self.assertIsInstance(env</span><span class="s2">, </span><span class="s1">pywsgi.SecureEnviron)</span>
        <span class="s1">start_response(</span><span class="s4">'200 OK'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">'Content-Type'</span><span class="s2">, </span><span class="s4">'text/plain'</span><span class="s1">)])</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">test_environ_is_secure_by_default(self):</span>
        <span class="s1">self.urlopen()</span>

    <span class="s2">def </span><span class="s1">test_default_secure_repr(self):</span>
        <span class="s1">environ = pywsgi.SecureEnviron()</span>
        <span class="s1">self.assertIn(</span><span class="s4">'&lt;pywsgi.SecureEnviron dict (keys: 0) at'</span><span class="s2">, </span><span class="s1">repr(environ))</span>
        <span class="s1">self.assertIn(</span><span class="s4">'&lt;pywsgi.SecureEnviron dict (keys: 0) at'</span><span class="s2">, </span><span class="s1">str(environ))</span>

        <span class="s1">environ[</span><span class="s4">'key'</span><span class="s1">] = </span><span class="s4">'value'</span>
        <span class="s1">self.assertIn(</span><span class="s4">'&lt;pywsgi.SecureEnviron dict (keys: 1) at'</span><span class="s2">, </span><span class="s1">repr(environ))</span>
        <span class="s1">self.assertIn(</span><span class="s4">'&lt;pywsgi.SecureEnviron dict (keys: 1) at'</span><span class="s2">, </span><span class="s1">str(environ))</span>

        <span class="s1">environ.secure_repr = </span><span class="s2">False</span>
        <span class="s1">self.assertEqual(str({</span><span class="s4">'key'</span><span class="s1">: </span><span class="s4">'value'</span><span class="s1">})</span><span class="s2">, </span><span class="s1">str(environ))</span>
        <span class="s1">self.assertEqual(repr({</span><span class="s4">'key'</span><span class="s1">: </span><span class="s4">'value'</span><span class="s1">})</span><span class="s2">, </span><span class="s1">repr(environ))</span>

        <span class="s2">del </span><span class="s1">environ.secure_repr</span>

        <span class="s1">environ.whitelist_keys = (</span><span class="s4">'missing value'</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(str({</span><span class="s4">'key'</span><span class="s1">: </span><span class="s4">&quot;&lt;MASKED&gt;&quot;</span><span class="s1">})</span><span class="s2">, </span><span class="s1">str(environ))</span>
        <span class="s1">self.assertEqual(repr({</span><span class="s4">'key'</span><span class="s1">: </span><span class="s4">&quot;&lt;MASKED&gt;&quot;</span><span class="s1">})</span><span class="s2">, </span><span class="s1">repr(environ))</span>

        <span class="s1">environ.whitelist_keys = (</span><span class="s4">'key'</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(str({</span><span class="s4">'key'</span><span class="s1">: </span><span class="s4">'value'</span><span class="s1">})</span><span class="s2">, </span><span class="s1">str(environ))</span>
        <span class="s1">self.assertEqual(repr({</span><span class="s4">'key'</span><span class="s1">: </span><span class="s4">'value'</span><span class="s1">})</span><span class="s2">, </span><span class="s1">repr(environ))</span>

        <span class="s2">del </span><span class="s1">environ.whitelist_keys</span>

    <span class="s2">def </span><span class="s1">test_override_class_defaults(self):</span>
        <span class="s2">class </span><span class="s1">EnvironClass(pywsgi.SecureEnviron):</span>
            <span class="s1">__slots__ = ()</span>

        <span class="s1">environ = EnvironClass()</span>

        <span class="s1">self.assertTrue(environ.secure_repr)</span>
        <span class="s1">EnvironClass.default_secure_repr = </span><span class="s2">False</span>
        <span class="s1">self.assertFalse(environ.secure_repr)</span>

        <span class="s1">self.assertEqual(str({})</span><span class="s2">, </span><span class="s1">str(environ))</span>
        <span class="s1">self.assertEqual(repr({})</span><span class="s2">, </span><span class="s1">repr(environ))</span>

        <span class="s1">EnvironClass.default_secure_repr = </span><span class="s2">True</span>
        <span class="s1">EnvironClass.default_whitelist_keys = (</span><span class="s4">'key'</span><span class="s2">,</span><span class="s1">)</span>

        <span class="s1">environ[</span><span class="s4">'key'</span><span class="s1">] = </span><span class="s5">1</span>
        <span class="s1">self.assertEqual(str({</span><span class="s4">'key'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">})</span><span class="s2">, </span><span class="s1">str(environ))</span>
        <span class="s1">self.assertEqual(repr({</span><span class="s4">'key'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">})</span><span class="s2">, </span><span class="s1">repr(environ))</span>

        <span class="s0"># Clean up for leaktests</span>
        <span class="s2">del </span><span class="s1">environ</span>
        <span class="s2">del </span><span class="s1">EnvironClass</span>
        <span class="s2">import </span><span class="s1">gc; gc.collect()</span>


    <span class="s2">def </span><span class="s1">test_copy_still_secure(self):</span>
        <span class="s2">for </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">(pywsgi.Environ</span><span class="s2">, </span><span class="s1">pywsgi.SecureEnviron):</span>
            <span class="s1">self.assertIsInstance(cls().copy()</span><span class="s2">, </span><span class="s1">cls)</span>

    <span class="s2">def </span><span class="s1">test_pickle_copy_returns_dict(self):</span>
        <span class="s0"># Anything going through copy.copy/pickle should</span>
        <span class="s0"># return the same pickle that a dict would.</span>
        <span class="s2">import </span><span class="s1">pickle</span>
        <span class="s2">import </span><span class="s1">json</span>

        <span class="s2">for </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">(pywsgi.Environ</span><span class="s2">, </span><span class="s1">pywsgi.SecureEnviron):</span>
            <span class="s1">bltin = {</span><span class="s4">'key'</span><span class="s1">: </span><span class="s4">'value'</span><span class="s1">}</span>
            <span class="s1">env = cls(bltin)</span>
            <span class="s1">self.assertIsInstance(env</span><span class="s2">, </span><span class="s1">cls)</span>
            <span class="s1">self.assertEqual(bltin</span><span class="s2">, </span><span class="s1">env)</span>
            <span class="s1">self.assertEqual(env</span><span class="s2">, </span><span class="s1">bltin)</span>

            <span class="s2">for </span><span class="s1">protocol </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">pickle.HIGHEST_PROTOCOL + </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s0"># It's impossible to get a subclass of dict to pickle</span>
                <span class="s0"># identically, but it can restore identically</span>
                <span class="s1">env_dump = pickle.dumps(env</span><span class="s2">, </span><span class="s1">protocol)</span>
                <span class="s1">self.assertNotIn(</span><span class="s6">b'Environ'</span><span class="s2">, </span><span class="s1">env_dump)</span>
                <span class="s1">loaded = pickle.loads(env_dump)</span>
                <span class="s1">self.assertEqual(type(loaded)</span><span class="s2">, </span><span class="s1">dict)</span>

            <span class="s1">self.assertEqual(json.dumps(bltin)</span><span class="s2">, </span><span class="s1">json.dumps(env))</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s4">'__main__'</span><span class="s1">:</span>
    <span class="s1">greentest.main()</span>
</pre>
</body>
</html>