<html>
<head>
<title>socketserver.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
socketserver.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Generic socket server classes. 
 
This module tries to capture the various aspects of defining a server: 
 
For socket-based servers: 
 
- address family: 
        - AF_INET{,6}: IP (Internet Protocol) sockets (default) 
        - AF_UNIX: Unix domain sockets 
        - others, e.g. AF_DECNET are conceivable (see &lt;socket.h&gt; 
- socket type: 
        - SOCK_STREAM (reliable stream, e.g. TCP) 
        - SOCK_DGRAM (datagrams, e.g. UDP) 
 
For request-based servers (including socket-based): 
 
- client address verification before further looking at the request 
        (This is actually a hook for any processing that needs to look 
         at the request before anything else, e.g. logging) 
- how to handle multiple requests: 
        - synchronous (one request is handled at a time) 
        - forking (each request is handled by a new process) 
        - threading (each request is handled by a new thread) 
 
The classes in this module favor the server type that is simplest to 
write: a synchronous TCP/IP server.  This is bad class design, but 
save some typing.  (There's also the issue that a deep class hierarchy 
slows down method lookups.) 
 
There are five classes in an inheritance diagram, four of which represent 
synchronous servers of four types: 
 
        +------------+ 
        | BaseServer | 
        +------------+ 
              | 
              v 
        +-----------+        +------------------+ 
        | TCPServer |-------&gt;| UnixStreamServer | 
        +-----------+        +------------------+ 
              | 
              v 
        +-----------+        +--------------------+ 
        | UDPServer |-------&gt;| UnixDatagramServer | 
        +-----------+        +--------------------+ 
 
Note that UnixDatagramServer derives from UDPServer, not from 
UnixStreamServer -- the only difference between an IP and a Unix 
stream server is the address family, which is simply repeated in both 
unix server classes. 
 
Forking and threading versions of each type of server can be created 
using the ForkingMixIn and ThreadingMixIn mix-in classes.  For 
instance, a threading UDP server class is created as follows: 
 
        class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass 
 
The Mix-in class must come first, since it overrides a method defined 
in UDPServer! Setting the various member variables also changes 
the behavior of the underlying server mechanism. 
 
To implement a service, you must derive a class from 
BaseRequestHandler and redefine its handle() method.  You can then run 
various versions of the service by combining one of the server classes 
with your request handler class. 
 
The request handler class must be different for datagram or stream 
services.  This can be hidden by using the request handler 
subclasses StreamRequestHandler or DatagramRequestHandler. 
 
Of course, you still have to use your head! 
 
For instance, it makes no sense to use a forking server if the service 
contains state in memory that can be modified by requests (since the 
modifications in the child process would never reach the initial state 
kept in the parent process and passed to each child).  In this case, 
you can use a threading server, but you will probably have to use 
locks to avoid two requests that come in nearly simultaneous to apply 
conflicting changes to the server state. 
 
On the other hand, if you are building e.g. an HTTP server, where all 
data is stored externally (e.g. in the file system), a synchronous 
class will essentially render the service &quot;deaf&quot; while one request is 
being handled -- which may be for a very long time if a client is slow 
to read all the data it has requested.  Here a threading or forking 
server is appropriate. 
 
In some cases, it may be appropriate to process part of a request 
synchronously, but to finish processing in a forked child depending on 
the request data.  This can be implemented by using a synchronous 
server and doing an explicit fork in the request handler class 
handle() method. 
 
Another approach to handling multiple simultaneous requests in an 
environment that supports neither threads nor fork (or where these are 
too expensive or inappropriate for the service) is to maintain an 
explicit table of partially finished requests and to use select() to 
decide which request to work on next (or whether to handle a new 
incoming request).  This is particularly important for stream services 
where each client can potentially be connected for a long time (if 
threads or subprocesses cannot be used). 
 
Future work: 
- Standard classes for Sun RPC (which uses either UDP or TCP) 
- Standard mix-in classes to implement various authentication 
  and encryption schemes 
- Standard framework for select-based multiplexing 
 
XXX Open problems: 
- What to do with out-of-band data? 
 
BaseServer: 
- split generic &quot;request&quot; functionality out into BaseServer class. 
  Copyright (C) 2000  Luke Kenneth Casson Leighton &lt;lkcl@samba.org&gt; 
 
  example: read entries from a SQL database (requires overriding 
  get_request() to return a table entry from the database). 
  entry is processed by a RequestHandlerClass. 
 
&quot;&quot;&quot;</span>

<span class="s2"># Author of the BaseServer patch: Luke Kenneth Casson Leighton</span>

<span class="s2"># XXX Warning!</span>
<span class="s2"># There is a test suite for this module, but it cannot be run by the</span>
<span class="s2"># standard regression test.</span>
<span class="s2"># To run it manually, run Lib/test/test_socketserver.py.</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">(absolute_import</span><span class="s3">, </span><span class="s1">print_function)</span>

<span class="s1">__version__ = </span><span class="s4">&quot;0.4&quot;</span>


<span class="s3">import </span><span class="s1">socket</span>
<span class="s3">import </span><span class="s1">select</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">import </span><span class="s1">threading</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">import </span><span class="s1">dummy_threading </span><span class="s3">as </span><span class="s1">threading</span>

<span class="s1">__all__ = [</span><span class="s4">&quot;TCPServer&quot;</span><span class="s3">,</span><span class="s4">&quot;UDPServer&quot;</span><span class="s3">,</span><span class="s4">&quot;ForkingUDPServer&quot;</span><span class="s3">,</span><span class="s4">&quot;ForkingTCPServer&quot;</span><span class="s3">,</span>
           <span class="s4">&quot;ThreadingUDPServer&quot;</span><span class="s3">,</span><span class="s4">&quot;ThreadingTCPServer&quot;</span><span class="s3">,</span><span class="s4">&quot;BaseRequestHandler&quot;</span><span class="s3">,</span>
           <span class="s4">&quot;StreamRequestHandler&quot;</span><span class="s3">,</span><span class="s4">&quot;DatagramRequestHandler&quot;</span><span class="s3">,</span>
           <span class="s4">&quot;ThreadingMixIn&quot;</span><span class="s3">, </span><span class="s4">&quot;ForkingMixIn&quot;</span><span class="s1">]</span>
<span class="s3">if </span><span class="s1">hasattr(socket</span><span class="s3">, </span><span class="s4">&quot;AF_UNIX&quot;</span><span class="s1">):</span>
    <span class="s1">__all__.extend([</span><span class="s4">&quot;UnixStreamServer&quot;</span><span class="s3">,</span><span class="s4">&quot;UnixDatagramServer&quot;</span><span class="s3">,</span>
                    <span class="s4">&quot;ThreadingUnixStreamServer&quot;</span><span class="s3">,</span>
                    <span class="s4">&quot;ThreadingUnixDatagramServer&quot;</span><span class="s1">])</span>

<span class="s3">def </span><span class="s1">_eintr_retry(func</span><span class="s3">, </span><span class="s1">*args):</span>
    <span class="s0">&quot;&quot;&quot;restart a system call interrupted by EINTR&quot;&quot;&quot;</span>
    <span class="s3">while True</span><span class="s1">:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">func(*args)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">if </span><span class="s1">e.errno != errno.EINTR:</span>
                <span class="s3">raise</span>

<span class="s3">class </span><span class="s1">BaseServer(object):</span>

    <span class="s0">&quot;&quot;&quot;Base class for server classes. 
 
    Methods for the caller: 
 
    - __init__(server_address, RequestHandlerClass) 
    - serve_forever(poll_interval=0.5) 
    - shutdown() 
    - handle_request()  # if you do not use serve_forever() 
    - fileno() -&gt; int   # for select() 
 
    Methods that may be overridden: 
 
    - server_bind() 
    - server_activate() 
    - get_request() -&gt; request, client_address 
    - handle_timeout() 
    - verify_request(request, client_address) 
    - server_close() 
    - process_request(request, client_address) 
    - shutdown_request(request) 
    - close_request(request) 
    - service_actions() 
    - handle_error() 
 
    Methods for derived classes: 
 
    - finish_request(request, client_address) 
 
    Class variables that may be overridden by derived classes or 
    instances: 
 
    - timeout 
    - address_family 
    - socket_type 
    - allow_reuse_address 
 
    Instance variables: 
 
    - RequestHandlerClass 
    - socket 
 
    &quot;&quot;&quot;</span>

    <span class="s1">timeout = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">server_address</span><span class="s3">, </span><span class="s1">RequestHandlerClass):</span>
        <span class="s0">&quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span>
        <span class="s1">self.server_address = server_address</span>
        <span class="s1">self.RequestHandlerClass = RequestHandlerClass</span>
        <span class="s1">self.__is_shut_down = threading.Event()</span>
        <span class="s1">self.__shutdown_request = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">server_activate(self):</span>
        <span class="s0">&quot;&quot;&quot;Called by constructor to activate the server. 
 
        May be overridden. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">serve_forever(self</span><span class="s3">, </span><span class="s1">poll_interval=</span><span class="s5">0.5</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Handle one request at a time until shutdown. 
 
        Polls for shutdown every poll_interval seconds. Ignores 
        self.timeout. If you need to do periodic tasks, do them in 
        another thread. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.__is_shut_down.clear()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">while not </span><span class="s1">self.__shutdown_request:</span>
                <span class="s2"># XXX: Consider using another file descriptor or</span>
                <span class="s2"># connecting to the socket to wake this up instead of</span>
                <span class="s2"># polling. Polling reduces our responsiveness to a</span>
                <span class="s2"># shutdown request and wastes cpu at all other times.</span>
                <span class="s1">r</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">e = _eintr_retry(select.select</span><span class="s3">, </span><span class="s1">[self]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">,</span>
                                       <span class="s1">poll_interval)</span>
                <span class="s3">if </span><span class="s1">self </span><span class="s3">in </span><span class="s1">r:</span>
                    <span class="s1">self._handle_request_noblock()</span>

                <span class="s1">self.service_actions()</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">self.__shutdown_request = </span><span class="s3">False</span>
            <span class="s1">self.__is_shut_down.set()</span>

    <span class="s3">def </span><span class="s1">shutdown(self):</span>
        <span class="s0">&quot;&quot;&quot;Stops the serve_forever loop. 
 
        Blocks until the loop has finished. This must be called while 
        serve_forever() is running in another thread, or it will 
        deadlock. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.__shutdown_request = </span><span class="s3">True</span>
        <span class="s1">self.__is_shut_down.wait()</span>

    <span class="s3">def </span><span class="s1">service_actions(self):</span>
        <span class="s0">&quot;&quot;&quot;Called by the serve_forever() loop. 
 
        May be overridden by a subclass / Mixin to implement any code that 
        needs to be run during the loop. 
        &quot;&quot;&quot;</span>
        <span class="s3">pass</span>

    <span class="s2"># The distinction between handling, getting, processing and</span>
    <span class="s2"># finishing a request is fairly arbitrary.  Remember:</span>
    <span class="s2">#</span>
    <span class="s2"># - handle_request() is the top-level call.  It calls</span>
    <span class="s2">#   select, get_request(), verify_request() and process_request()</span>
    <span class="s2"># - get_request() is different for stream or datagram sockets</span>
    <span class="s2"># - process_request() is the place that may fork a new process</span>
    <span class="s2">#   or create a new thread to finish the request</span>
    <span class="s2"># - finish_request() instantiates the request handler class;</span>
    <span class="s2">#   this constructor will handle the request all by itself</span>

    <span class="s3">def </span><span class="s1">handle_request(self):</span>
        <span class="s0">&quot;&quot;&quot;Handle one request, possibly blocking. 
 
        Respects self.timeout. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Support people who used socket.settimeout() to escape</span>
        <span class="s2"># handle_request before self.timeout was available.</span>
        <span class="s1">timeout = self.socket.gettimeout()</span>
        <span class="s3">if </span><span class="s1">timeout </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">timeout = self.timeout</span>
        <span class="s3">elif </span><span class="s1">self.timeout </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">timeout = min(timeout</span><span class="s3">, </span><span class="s1">self.timeout)</span>
        <span class="s1">fd_sets = _eintr_retry(select.select</span><span class="s3">, </span><span class="s1">[self]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">timeout)</span>
        <span class="s3">if not </span><span class="s1">fd_sets[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">self.handle_timeout()</span>
            <span class="s3">return</span>
        <span class="s1">self._handle_request_noblock()</span>

    <span class="s3">def </span><span class="s1">_handle_request_noblock(self):</span>
        <span class="s0">&quot;&quot;&quot;Handle one request, without blocking. 
 
        I assume that select.select has returned that the socket is 
        readable before this function was called, so there should be 
        no risk of blocking in get_request(). 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">request</span><span class="s3">, </span><span class="s1">client_address = self.get_request()</span>
        <span class="s3">except </span><span class="s1">socket.error:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">self.verify_request(request</span><span class="s3">, </span><span class="s1">client_address):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.process_request(request</span><span class="s3">, </span><span class="s1">client_address)</span>
            <span class="s3">except</span><span class="s1">:</span>
                <span class="s1">self.handle_error(request</span><span class="s3">, </span><span class="s1">client_address)</span>
                <span class="s1">self.shutdown_request(request)</span>

    <span class="s3">def </span><span class="s1">handle_timeout(self):</span>
        <span class="s0">&quot;&quot;&quot;Called if no new request arrives within self.timeout. 
 
        Overridden by ForkingMixIn. 
        &quot;&quot;&quot;</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">verify_request(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">client_address):</span>
        <span class="s0">&quot;&quot;&quot;Verify the request.  May be overridden. 
 
        Return True if we should proceed with this request. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">process_request(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">client_address):</span>
        <span class="s0">&quot;&quot;&quot;Call finish_request. 
 
        Overridden by ForkingMixIn and ThreadingMixIn. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.finish_request(request</span><span class="s3">, </span><span class="s1">client_address)</span>
        <span class="s1">self.shutdown_request(request)</span>

    <span class="s3">def </span><span class="s1">server_close(self):</span>
        <span class="s0">&quot;&quot;&quot;Called to clean-up the server. 
 
        May be overridden. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">finish_request(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">client_address):</span>
        <span class="s0">&quot;&quot;&quot;Finish one request by instantiating RequestHandlerClass.&quot;&quot;&quot;</span>
        <span class="s1">self.RequestHandlerClass(request</span><span class="s3">, </span><span class="s1">client_address</span><span class="s3">, </span><span class="s1">self)</span>

    <span class="s3">def </span><span class="s1">shutdown_request(self</span><span class="s3">, </span><span class="s1">request):</span>
        <span class="s0">&quot;&quot;&quot;Called to shutdown and close an individual request.&quot;&quot;&quot;</span>
        <span class="s1">self.close_request(request)</span>

    <span class="s3">def </span><span class="s1">close_request(self</span><span class="s3">, </span><span class="s1">request):</span>
        <span class="s0">&quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot;</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">handle_error(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">client_address):</span>
        <span class="s0">&quot;&quot;&quot;Handle an error gracefully.  May be overridden. 
 
        The default is to print a traceback and continue. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">print(</span><span class="s4">'-'</span><span class="s1">*</span><span class="s5">40</span><span class="s1">)</span>
        <span class="s1">print(</span><span class="s4">'Exception happened during processing of request from'</span><span class="s3">, </span><span class="s1">end=</span><span class="s4">' '</span><span class="s1">)</span>
        <span class="s1">print(client_address)</span>
        <span class="s3">import </span><span class="s1">traceback</span>
        <span class="s1">traceback.print_exc() </span><span class="s2"># XXX But this goes to stderr!</span>
        <span class="s1">print(</span><span class="s4">'-'</span><span class="s1">*</span><span class="s5">40</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TCPServer(BaseServer):</span>

    <span class="s0">&quot;&quot;&quot;Base class for various socket-based server classes. 
 
    Defaults to synchronous IP stream (i.e., TCP). 
 
    Methods for the caller: 
 
    - __init__(server_address, RequestHandlerClass, bind_and_activate=True) 
    - serve_forever(poll_interval=0.5) 
    - shutdown() 
    - handle_request()  # if you don't use serve_forever() 
    - fileno() -&gt; int   # for select() 
 
    Methods that may be overridden: 
 
    - server_bind() 
    - server_activate() 
    - get_request() -&gt; request, client_address 
    - handle_timeout() 
    - verify_request(request, client_address) 
    - process_request(request, client_address) 
    - shutdown_request(request) 
    - close_request(request) 
    - handle_error() 
 
    Methods for derived classes: 
 
    - finish_request(request, client_address) 
 
    Class variables that may be overridden by derived classes or 
    instances: 
 
    - timeout 
    - address_family 
    - socket_type 
    - request_queue_size (only for stream sockets) 
    - allow_reuse_address 
 
    Instance variables: 
 
    - server_address 
    - RequestHandlerClass 
    - socket 
 
    &quot;&quot;&quot;</span>

    <span class="s1">address_family = socket.AF_INET</span>

    <span class="s1">socket_type = socket.SOCK_STREAM</span>

    <span class="s1">request_queue_size = </span><span class="s5">5</span>

    <span class="s1">allow_reuse_address = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">server_address</span><span class="s3">, </span><span class="s1">RequestHandlerClass</span><span class="s3">, </span><span class="s1">bind_and_activate=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span>
        <span class="s1">BaseServer.__init__(self</span><span class="s3">, </span><span class="s1">server_address</span><span class="s3">, </span><span class="s1">RequestHandlerClass)</span>
        <span class="s1">self.socket = socket.socket(self.address_family</span><span class="s3">,</span>
                                    <span class="s1">self.socket_type)</span>
        <span class="s3">if </span><span class="s1">bind_and_activate:</span>
            <span class="s1">self.server_bind()</span>
            <span class="s1">self.server_activate()</span>

    <span class="s3">def </span><span class="s1">server_bind(self):</span>
        <span class="s0">&quot;&quot;&quot;Called by constructor to bind the socket. 
 
        May be overridden. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.allow_reuse_address:</span>
            <span class="s1">self.socket.setsockopt(socket.SOL_SOCKET</span><span class="s3">, </span><span class="s1">socket.SO_REUSEADDR</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.socket.bind(self.server_address)</span>
        <span class="s1">self.server_address = self.socket.getsockname()</span>

    <span class="s3">def </span><span class="s1">server_activate(self):</span>
        <span class="s0">&quot;&quot;&quot;Called by constructor to activate the server. 
 
        May be overridden. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.socket.listen(self.request_queue_size)</span>

    <span class="s3">def </span><span class="s1">server_close(self):</span>
        <span class="s0">&quot;&quot;&quot;Called to clean-up the server. 
 
        May be overridden. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.socket.close()</span>

    <span class="s3">def </span><span class="s1">fileno(self):</span>
        <span class="s0">&quot;&quot;&quot;Return socket file number. 
 
        Interface required by select(). 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.socket.fileno()</span>

    <span class="s3">def </span><span class="s1">get_request(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the request and client address from the socket. 
 
        May be overridden. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.socket.accept()</span>

    <span class="s3">def </span><span class="s1">shutdown_request(self</span><span class="s3">, </span><span class="s1">request):</span>
        <span class="s0">&quot;&quot;&quot;Called to shutdown and close an individual request.&quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s2">#explicitly shutdown.  socket.close() merely releases</span>
            <span class="s2">#the socket and waits for GC to perform the actual close.</span>
            <span class="s1">request.shutdown(socket.SHUT_WR)</span>
        <span class="s3">except </span><span class="s1">socket.error:</span>
            <span class="s3">pass </span><span class="s2">#some platforms may raise ENOTCONN here</span>
        <span class="s1">self.close_request(request)</span>

    <span class="s3">def </span><span class="s1">close_request(self</span><span class="s3">, </span><span class="s1">request):</span>
        <span class="s0">&quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot;</span>
        <span class="s1">request.close()</span>


<span class="s3">class </span><span class="s1">UDPServer(TCPServer):</span>

    <span class="s0">&quot;&quot;&quot;UDP server class.&quot;&quot;&quot;</span>

    <span class="s1">allow_reuse_address = </span><span class="s3">False</span>

    <span class="s1">socket_type = socket.SOCK_DGRAM</span>

    <span class="s1">max_packet_size = </span><span class="s5">8192</span>

    <span class="s3">def </span><span class="s1">get_request(self):</span>
        <span class="s1">data</span><span class="s3">, </span><span class="s1">client_addr = self.socket.recvfrom(self.max_packet_size)</span>
        <span class="s3">return </span><span class="s1">(data</span><span class="s3">, </span><span class="s1">self.socket)</span><span class="s3">, </span><span class="s1">client_addr</span>

    <span class="s3">def </span><span class="s1">server_activate(self):</span>
        <span class="s2"># No need to call listen() for UDP.</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">shutdown_request(self</span><span class="s3">, </span><span class="s1">request):</span>
        <span class="s2"># No need to shutdown anything.</span>
        <span class="s1">self.close_request(request)</span>

    <span class="s3">def </span><span class="s1">close_request(self</span><span class="s3">, </span><span class="s1">request):</span>
        <span class="s2"># No need to close anything.</span>
        <span class="s3">pass</span>

<span class="s3">class </span><span class="s1">ForkingMixIn(object):</span>

    <span class="s0">&quot;&quot;&quot;Mix-in class to handle each request in a new process.&quot;&quot;&quot;</span>

    <span class="s1">timeout = </span><span class="s5">300</span>
    <span class="s1">active_children = </span><span class="s3">None</span>
    <span class="s1">max_children = </span><span class="s5">40</span>

    <span class="s3">def </span><span class="s1">collect_children(self):</span>
        <span class="s0">&quot;&quot;&quot;Internal routine to wait for children that have exited.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.active_children </span><span class="s3">is None</span><span class="s1">: </span><span class="s3">return</span>
        <span class="s3">while </span><span class="s1">len(self.active_children) &gt;= self.max_children:</span>
            <span class="s2"># XXX: This will wait for any child process, not just ones</span>
            <span class="s2"># spawned by this library. This could confuse other</span>
            <span class="s2"># libraries that expect to be able to wait for their own</span>
            <span class="s2"># children.</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">pid</span><span class="s3">, </span><span class="s1">status = os.waitpid(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">os.error:</span>
                <span class="s1">pid = </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">pid </span><span class="s3">not in </span><span class="s1">self.active_children: </span><span class="s3">continue</span>
            <span class="s1">self.active_children.remove(pid)</span>

        <span class="s2"># XXX: This loop runs more system calls than it ought</span>
        <span class="s2"># to. There should be a way to put the active_children into a</span>
        <span class="s2"># process group and then use os.waitpid(-pgid) to wait for any</span>
        <span class="s2"># of that set, but I couldn't find a way to allocate pgids</span>
        <span class="s2"># that couldn't collide.</span>
        <span class="s3">for </span><span class="s1">child </span><span class="s3">in </span><span class="s1">self.active_children:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">pid</span><span class="s3">, </span><span class="s1">status = os.waitpid(child</span><span class="s3">, </span><span class="s1">os.WNOHANG)</span>
            <span class="s3">except </span><span class="s1">os.error:</span>
                <span class="s1">pid = </span><span class="s3">None</span>
            <span class="s3">if not </span><span class="s1">pid: </span><span class="s3">continue</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.active_children.remove(pid)</span>
            <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'%s. x=%d and list=%r' </span><span class="s1">% (e.message</span><span class="s3">, </span><span class="s1">pid</span><span class="s3">,</span>
                                                           <span class="s1">self.active_children))</span>

    <span class="s3">def </span><span class="s1">handle_timeout(self):</span>
        <span class="s0">&quot;&quot;&quot;Wait for zombies after self.timeout seconds of inactivity. 
 
        May be extended, do not override. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.collect_children()</span>

    <span class="s3">def </span><span class="s1">service_actions(self):</span>
        <span class="s0">&quot;&quot;&quot;Collect the zombie child processes regularly in the ForkingMixIn. 
 
        service_actions is called in the BaseServer's serve_forver loop. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.collect_children()</span>

    <span class="s3">def </span><span class="s1">process_request(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">client_address):</span>
        <span class="s0">&quot;&quot;&quot;Fork a new subprocess to process the request.&quot;&quot;&quot;</span>
        <span class="s1">pid = os.fork()</span>
        <span class="s3">if </span><span class="s1">pid:</span>
            <span class="s2"># Parent process</span>
            <span class="s3">if </span><span class="s1">self.active_children </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">self.active_children = []</span>
            <span class="s1">self.active_children.append(pid)</span>
            <span class="s1">self.close_request(request)</span>
            <span class="s3">return</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># Child process.</span>
            <span class="s2"># This must never return, hence os._exit()!</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.finish_request(request</span><span class="s3">, </span><span class="s1">client_address)</span>
                <span class="s1">self.shutdown_request(request)</span>
                <span class="s1">os._exit(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s3">except</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">self.handle_error(request</span><span class="s3">, </span><span class="s1">client_address)</span>
                    <span class="s1">self.shutdown_request(request)</span>
                <span class="s3">finally</span><span class="s1">:</span>
                    <span class="s1">os._exit(</span><span class="s5">1</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">ThreadingMixIn(object):</span>
    <span class="s0">&quot;&quot;&quot;Mix-in class to handle each request in a new thread.&quot;&quot;&quot;</span>

    <span class="s2"># Decides how threads will act upon termination of the</span>
    <span class="s2"># main process</span>
    <span class="s1">daemon_threads = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">process_request_thread(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">client_address):</span>
        <span class="s0">&quot;&quot;&quot;Same as in BaseServer but as a thread. 
 
        In addition, exception handling is done here. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.finish_request(request</span><span class="s3">, </span><span class="s1">client_address)</span>
            <span class="s1">self.shutdown_request(request)</span>
        <span class="s3">except</span><span class="s1">:</span>
            <span class="s1">self.handle_error(request</span><span class="s3">, </span><span class="s1">client_address)</span>
            <span class="s1">self.shutdown_request(request)</span>

    <span class="s3">def </span><span class="s1">process_request(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">client_address):</span>
        <span class="s0">&quot;&quot;&quot;Start a new thread to process the request.&quot;&quot;&quot;</span>
        <span class="s1">t = threading.Thread(target = self.process_request_thread</span><span class="s3">,</span>
                             <span class="s1">args = (request</span><span class="s3">, </span><span class="s1">client_address))</span>
        <span class="s1">t.daemon = self.daemon_threads</span>
        <span class="s1">t.start()</span>


<span class="s3">class </span><span class="s1">ForkingUDPServer(ForkingMixIn</span><span class="s3">, </span><span class="s1">UDPServer): </span><span class="s3">pass</span>
<span class="s3">class </span><span class="s1">ForkingTCPServer(ForkingMixIn</span><span class="s3">, </span><span class="s1">TCPServer): </span><span class="s3">pass</span>

<span class="s3">class </span><span class="s1">ThreadingUDPServer(ThreadingMixIn</span><span class="s3">, </span><span class="s1">UDPServer): </span><span class="s3">pass</span>
<span class="s3">class </span><span class="s1">ThreadingTCPServer(ThreadingMixIn</span><span class="s3">, </span><span class="s1">TCPServer): </span><span class="s3">pass</span>

<span class="s3">if </span><span class="s1">hasattr(socket</span><span class="s3">, </span><span class="s4">'AF_UNIX'</span><span class="s1">):</span>

    <span class="s3">class </span><span class="s1">UnixStreamServer(TCPServer):</span>
        <span class="s1">address_family = socket.AF_UNIX</span>

    <span class="s3">class </span><span class="s1">UnixDatagramServer(UDPServer):</span>
        <span class="s1">address_family = socket.AF_UNIX</span>

    <span class="s3">class </span><span class="s1">ThreadingUnixStreamServer(ThreadingMixIn</span><span class="s3">, </span><span class="s1">UnixStreamServer): </span><span class="s3">pass</span>

    <span class="s3">class </span><span class="s1">ThreadingUnixDatagramServer(ThreadingMixIn</span><span class="s3">, </span><span class="s1">UnixDatagramServer): </span><span class="s3">pass</span>

<span class="s3">class </span><span class="s1">BaseRequestHandler(object):</span>

    <span class="s0">&quot;&quot;&quot;Base class for request handler classes. 
 
    This class is instantiated for each request to be handled.  The 
    constructor sets the instance variables request, client_address 
    and server, and then calls the handle() method.  To implement a 
    specific service, all you need to do is to derive a class which 
    defines a handle() method. 
 
    The handle() method can find the request as self.request, the 
    client address as self.client_address, and the server (in case it 
    needs access to per-server information) as self.server.  Since a 
    separate instance is created for each request, the handle() method 
    can define arbitrary other instance variariables. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">client_address</span><span class="s3">, </span><span class="s1">server):</span>
        <span class="s1">self.request = request</span>
        <span class="s1">self.client_address = client_address</span>
        <span class="s1">self.server = server</span>
        <span class="s1">self.setup()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.handle()</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">self.finish()</span>

    <span class="s3">def </span><span class="s1">setup(self):</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">handle(self):</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">finish(self):</span>
        <span class="s3">pass</span>


<span class="s2"># The following two classes make it possible to use the same service</span>
<span class="s2"># class for stream or datagram servers.</span>
<span class="s2"># Each class sets up these instance variables:</span>
<span class="s2"># - rfile: a file object from which receives the request is read</span>
<span class="s2"># - wfile: a file object to which the reply is written</span>
<span class="s2"># When the handle() method returns, wfile is flushed properly</span>


<span class="s3">class </span><span class="s1">StreamRequestHandler(BaseRequestHandler):</span>

    <span class="s0">&quot;&quot;&quot;Define self.rfile and self.wfile for stream sockets.&quot;&quot;&quot;</span>

    <span class="s2"># Default buffer sizes for rfile, wfile.</span>
    <span class="s2"># We default rfile to buffered because otherwise it could be</span>
    <span class="s2"># really slow for large data (a getc() call per byte); we make</span>
    <span class="s2"># wfile unbuffered because (a) often after a write() we want to</span>
    <span class="s2"># read and we need to flush the line; (b) big writes to unbuffered</span>
    <span class="s2"># files are typically optimized by stdio even when big reads</span>
    <span class="s2"># aren't.</span>
    <span class="s1">rbufsize = -</span><span class="s5">1</span>
    <span class="s1">wbufsize = </span><span class="s5">0</span>

    <span class="s2"># A timeout to apply to the request socket, if not None.</span>
    <span class="s1">timeout = </span><span class="s3">None</span>

    <span class="s2"># Disable nagle algorithm for this socket, if True.</span>
    <span class="s2"># Use only when wbufsize != 0, to avoid small packets.</span>
    <span class="s1">disable_nagle_algorithm = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">setup(self):</span>
        <span class="s1">self.connection = self.request</span>
        <span class="s3">if </span><span class="s1">self.timeout </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.connection.settimeout(self.timeout)</span>
        <span class="s3">if </span><span class="s1">self.disable_nagle_algorithm:</span>
            <span class="s1">self.connection.setsockopt(socket.IPPROTO_TCP</span><span class="s3">,</span>
                                       <span class="s1">socket.TCP_NODELAY</span><span class="s3">, True</span><span class="s1">)</span>
        <span class="s1">self.rfile = self.connection.makefile(</span><span class="s4">'rb'</span><span class="s3">, </span><span class="s1">self.rbufsize)</span>
        <span class="s1">self.wfile = self.connection.makefile(</span><span class="s4">'wb'</span><span class="s3">, </span><span class="s1">self.wbufsize)</span>

    <span class="s3">def </span><span class="s1">finish(self):</span>
        <span class="s3">if not </span><span class="s1">self.wfile.closed:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">self.wfile.flush()</span>
            <span class="s3">except </span><span class="s1">socket.error:</span>
                <span class="s2"># An final socket error may have occurred here, such as</span>
                <span class="s2"># the local error ECONNABORTED.</span>
                <span class="s3">pass</span>
        <span class="s1">self.wfile.close()</span>
        <span class="s1">self.rfile.close()</span>


<span class="s3">class </span><span class="s1">DatagramRequestHandler(BaseRequestHandler):</span>

    <span class="s2"># XXX Regrettably, I cannot get this working on Linux;</span>
    <span class="s2"># s.recvfrom() doesn't return a meaningful client address.</span>

    <span class="s0">&quot;&quot;&quot;Define self.rfile and self.wfile for datagram sockets.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">setup(self):</span>
        <span class="s3">from </span><span class="s1">io </span><span class="s3">import </span><span class="s1">BytesIO</span>
        <span class="s1">self.packet</span><span class="s3">, </span><span class="s1">self.socket = self.request</span>
        <span class="s1">self.rfile = BytesIO(self.packet)</span>
        <span class="s1">self.wfile = BytesIO()</span>

    <span class="s3">def </span><span class="s1">finish(self):</span>
        <span class="s1">self.socket.sendto(self.wfile.getvalue()</span><span class="s3">, </span><span class="s1">self.client_address)</span>
</pre>
</body>
</html>