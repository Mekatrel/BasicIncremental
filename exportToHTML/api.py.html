<html>
<head>
<title>api.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
api.py</font>
</center></td></tr></table>
<pre><span class="s0">#-----------------------------------------------------------------------------</span>
<span class="s0"># Copyright (c) 2005-2021, PyInstaller Development Team.</span>
<span class="s0">#</span>
<span class="s0"># Distributed under the terms of the GNU General Public License (version 2</span>
<span class="s0"># or later) with exception for distributing the bootloader.</span>
<span class="s0">#</span>
<span class="s0"># The full license is in the file COPYING.txt, distributed with this software.</span>
<span class="s0">#</span>
<span class="s0"># SPDX-License-Identifier: (GPL-2.0-or-later WITH Bootloader-exception)</span>
<span class="s0">#-----------------------------------------------------------------------------</span>
<span class="s2">&quot;&quot;&quot; 
This module contains classes that are available for the .spec files. 
 
Spec file is generated by PyInstaller. The generated code from .spec file 
is a way how PyInstaller does the dependency analysis and creates executable. 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">subprocess</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">import </span><span class="s1">pprint</span>
<span class="s3">import </span><span class="s1">shutil</span>
<span class="s3">from </span><span class="s1">operator </span><span class="s3">import </span><span class="s1">itemgetter</span>

<span class="s3">from </span><span class="s1">PyInstaller </span><span class="s3">import </span><span class="s1">HOMEPATH</span><span class="s3">, </span><span class="s1">PLATFORM</span>
<span class="s3">from </span><span class="s1">PyInstaller </span><span class="s3">import </span><span class="s1">log </span><span class="s3">as </span><span class="s1">logging</span>
<span class="s3">from </span><span class="s1">PyInstaller.archive.writers </span><span class="s3">import </span><span class="s1">CArchiveWriter</span><span class="s3">, </span><span class="s1">ZlibArchiveWriter</span>
<span class="s3">from </span><span class="s1">PyInstaller.building.datastruct </span><span class="s3">import </span><span class="s1">TOC</span><span class="s3">, </span><span class="s1">Target</span><span class="s3">, </span><span class="s1">_check_guts_eq</span>
<span class="s3">from </span><span class="s1">PyInstaller.building.utils </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">_check_guts_toc</span><span class="s3">, </span><span class="s1">_make_clean_directory</span><span class="s3">, </span><span class="s1">_rmtree</span><span class="s3">, </span><span class="s1">add_suffix_to_extension</span><span class="s3">, </span><span class="s1">checkCache</span><span class="s3">, </span><span class="s1">get_code_object</span><span class="s3">,</span>
    <span class="s1">strip_paths_in_code</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">PyInstaller.compat </span><span class="s3">import </span><span class="s1">(is_cygwin</span><span class="s3">, </span><span class="s1">is_darwin</span><span class="s3">, </span><span class="s1">is_linux</span><span class="s3">, </span><span class="s1">is_win)</span>
<span class="s3">from </span><span class="s1">PyInstaller.depend </span><span class="s3">import </span><span class="s1">bindepend</span>
<span class="s3">from </span><span class="s1">PyInstaller.depend.analysis </span><span class="s3">import </span><span class="s1">get_bootstrap_modules</span>
<span class="s3">from </span><span class="s1">PyInstaller.depend.utils </span><span class="s3">import </span><span class="s1">is_path_to_egg</span>
<span class="s3">from </span><span class="s1">PyInstaller.utils </span><span class="s3">import </span><span class="s1">misc</span>

<span class="s1">logger = logging.getLogger(__name__)</span>

<span class="s3">if </span><span class="s1">is_win:</span>
    <span class="s3">from </span><span class="s1">PyInstaller.utils.win32 </span><span class="s3">import </span><span class="s1">(icon</span><span class="s3">, </span><span class="s1">versioninfo</span><span class="s3">, </span><span class="s1">winmanifest</span><span class="s3">, </span><span class="s1">winresource</span><span class="s3">, </span><span class="s1">winutils)</span>

<span class="s3">if </span><span class="s1">is_darwin:</span>
    <span class="s3">import </span><span class="s1">PyInstaller.utils.osx </span><span class="s3">as </span><span class="s1">osxutils</span>


<span class="s3">class </span><span class="s1">PYZ(Target):</span>
    <span class="s2">&quot;&quot;&quot; 
    Creates a ZlibArchive that contains all pure Python modules. 
    &quot;&quot;&quot;</span>
    <span class="s1">typ = </span><span class="s4">'PYZ'</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*tocs</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        tocs 
                One or more TOCs (Tables of Contents), normally an Analysis.pure. 
 
                If this TOC has an attribute `_code_cache`, this is expected to be a dict of module code objects 
                from ModuleGraph. 
 
        kwargs 
            Possible keyword arguments: 
 
            name 
                A filename for the .pyz. Normally not needed, as the generated name will do fine. 
            cipher 
                The block cipher that will be used to encrypt Python bytecode. 
        &quot;&quot;&quot;</span>

        <span class="s3">from </span><span class="s1">PyInstaller.config </span><span class="s3">import </span><span class="s1">CONF</span>
        <span class="s1">Target.__init__(self)</span>
        <span class="s1">name = kwargs.get(</span><span class="s4">'name'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">cipher = kwargs.get(</span><span class="s4">'cipher'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.toc = TOC()</span>
        <span class="s0"># If available, use code objects directly from ModuleGraph to speed up PyInstaller.</span>
        <span class="s1">self.code_dict = {}</span>
        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">tocs:</span>
            <span class="s1">self.toc.extend(t)</span>
            <span class="s1">self.code_dict.update(getattr(t</span><span class="s3">, </span><span class="s4">'_code_cache'</span><span class="s3">, </span><span class="s1">{}))</span>

        <span class="s1">self.name = name</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.name = os.path.splitext(self.tocfilename)[</span><span class="s5">0</span><span class="s1">] + </span><span class="s4">'.pyz'</span>
        <span class="s0"># PyInstaller bootstrapping modules.</span>
        <span class="s1">self.dependencies = get_bootstrap_modules()</span>
        <span class="s0"># Bundle the crypto key.</span>
        <span class="s1">self.cipher = cipher</span>
        <span class="s3">if </span><span class="s1">cipher:</span>
            <span class="s1">key_file = (</span><span class="s4">'pyimod00_crypto_key'</span><span class="s3">, </span><span class="s1">os.path.join(CONF[</span><span class="s4">'workpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'pyimod00_crypto_key.pyc'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">'PYMODULE'</span><span class="s1">)</span>
            <span class="s0"># Insert the key as the first module in the list. The key module contains just variables and does not depend</span>
            <span class="s0"># on other modules.</span>
            <span class="s1">self.dependencies.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">key_file)</span>
        <span class="s0"># Compile the top-level modules so that they end up in the CArchive and can be imported by the bootstrap script.</span>
        <span class="s1">self.dependencies = misc.compile_py_files(self.dependencies</span><span class="s3">, </span><span class="s1">CONF[</span><span class="s4">'workpath'</span><span class="s1">])</span>
        <span class="s1">self.__postinit__()</span>

    <span class="s1">_GUTS = (  </span><span class="s0"># input parameters</span>
        <span class="s1">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'toc'</span><span class="s3">, </span><span class="s1">_check_guts_toc)</span><span class="s3">,  </span><span class="s0"># todo: pyc=1</span>
        <span class="s0"># no calculated/analysed values</span>
    <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_check_guts(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">last_build):</span>
        <span class="s3">if </span><span class="s1">Target._check_guts(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">last_build):</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">assemble(self):</span>
        <span class="s1">logger.info(</span><span class="s4">&quot;Building PYZ (ZlibArchive) %s&quot;</span><span class="s3">, </span><span class="s1">self.name)</span>
        <span class="s0"># Do not bundle PyInstaller bootstrap modules into PYZ archive.</span>
        <span class="s1">toc = self.toc - self.dependencies</span>
        <span class="s3">for </span><span class="s1">entry </span><span class="s3">in </span><span class="s1">toc[:]:</span>
            <span class="s3">if not </span><span class="s1">entry[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">self.code_dict </span><span class="s3">and </span><span class="s1">entry[</span><span class="s5">2</span><span class="s1">] == </span><span class="s4">'PYMODULE'</span><span class="s1">:</span>
                <span class="s0"># For some reason the code-object that modulegraph created is unavailable. Re-create it.</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">self.code_dict[entry[</span><span class="s5">0</span><span class="s1">]] = get_code_object(entry[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">entry[</span><span class="s5">1</span><span class="s1">])</span>
                <span class="s3">except </span><span class="s1">SyntaxError:</span>
                    <span class="s0"># Exclude the module in case this is code meant for a newer Python version.</span>
                    <span class="s1">toc.remove(entry)</span>
        <span class="s0"># Sort content alphabetically to support reproducible builds.</span>
        <span class="s1">toc.sort()</span>

        <span class="s0"># Remove leading parts of paths in code objects.</span>
        <span class="s1">self.code_dict = {key: strip_paths_in_code(code) </span><span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">code </span><span class="s3">in </span><span class="s1">self.code_dict.items()}</span>

        <span class="s1">ZlibArchiveWriter(self.name</span><span class="s3">, </span><span class="s1">toc</span><span class="s3">, </span><span class="s1">code_dict=self.code_dict</span><span class="s3">, </span><span class="s1">cipher=self.cipher)</span>
        <span class="s1">logger.info(</span><span class="s4">&quot;Building PYZ (ZlibArchive) %s completed successfully.&quot;</span><span class="s3">, </span><span class="s1">self.name)</span>


<span class="s3">class </span><span class="s1">PKG(Target):</span>
    <span class="s2">&quot;&quot;&quot; 
    Creates a CArchive. CArchive is the data structure that is embedded into the executable. This data structure allows 
    to include various read-only data in a single-file deployment. 
    &quot;&quot;&quot;</span>
    <span class="s1">typ = </span><span class="s4">'PKG'</span>
    <span class="s1">xformdict = {</span>
        <span class="s4">'PYMODULE'</span><span class="s1">: </span><span class="s4">'m'</span><span class="s3">,</span>
        <span class="s4">'PYSOURCE'</span><span class="s1">: </span><span class="s4">'s'</span><span class="s3">,</span>
        <span class="s4">'EXTENSION'</span><span class="s1">: </span><span class="s4">'b'</span><span class="s3">,</span>
        <span class="s4">'PYZ'</span><span class="s1">: </span><span class="s4">'z'</span><span class="s3">,</span>
        <span class="s4">'PKG'</span><span class="s1">: </span><span class="s4">'a'</span><span class="s3">,</span>
        <span class="s4">'DATA'</span><span class="s1">: </span><span class="s4">'x'</span><span class="s3">,</span>
        <span class="s4">'BINARY'</span><span class="s1">: </span><span class="s4">'b'</span><span class="s3">,</span>
        <span class="s4">'ZIPFILE'</span><span class="s1">: </span><span class="s4">'Z'</span><span class="s3">,</span>
        <span class="s4">'EXECUTABLE'</span><span class="s1">: </span><span class="s4">'b'</span><span class="s3">,</span>
        <span class="s4">'DEPENDENCY'</span><span class="s1">: </span><span class="s4">'d'</span><span class="s3">,</span>
        <span class="s4">'SPLASH'</span><span class="s1">: </span><span class="s4">'l'</span>
    <span class="s1">}</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">toc</span><span class="s3">,</span>
        <span class="s1">name=</span><span class="s3">None,</span>
        <span class="s1">cdict=</span><span class="s3">None,</span>
        <span class="s1">exclude_binaries=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">strip_binaries=</span><span class="s3">False,</span>
        <span class="s1">upx_binaries=</span><span class="s3">False,</span>
        <span class="s1">upx_exclude=</span><span class="s3">None,</span>
        <span class="s1">target_arch=</span><span class="s3">None,</span>
        <span class="s1">codesign_identity=</span><span class="s3">None,</span>
        <span class="s1">entitlements_file=</span><span class="s3">None</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        toc 
                A TOC (Table of Contents) 
        name 
                An optional filename for the PKG. 
        cdict 
                Dictionary that specifies compression by typecode. For Example, PYZ is left uncompressed so that it 
                can be accessed inside the PKG. The default uses sensible values. If zlib is not available, no 
                compression is used. 
        exclude_binaries 
                If True, EXTENSIONs and BINARYs will be left out of the PKG, and forwarded to its container (usually 
                a COLLECT). 
        strip_binaries 
                If True, use 'strip' command to reduce the size of binary files. 
        upx_binaries 
        &quot;&quot;&quot;</span>
        <span class="s1">Target.__init__(self)</span>
        <span class="s1">self.toc = toc</span>
        <span class="s1">self.cdict = cdict</span>
        <span class="s1">self.name = name</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.name = os.path.splitext(self.tocfilename)[</span><span class="s5">0</span><span class="s1">] + </span><span class="s4">'.pkg'</span>
        <span class="s1">self.exclude_binaries = exclude_binaries</span>
        <span class="s1">self.strip_binaries = strip_binaries</span>
        <span class="s1">self.upx_binaries = upx_binaries</span>
        <span class="s1">self.upx_exclude = upx_exclude </span><span class="s3">or </span><span class="s1">[]</span>
        <span class="s1">self.target_arch = target_arch</span>
        <span class="s1">self.codesign_identity = codesign_identity</span>
        <span class="s1">self.entitlements_file = entitlements_file</span>
        <span class="s0"># This dict tells PyInstaller what items embedded in the executable should be compressed.</span>
        <span class="s3">if </span><span class="s1">self.cdict </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.cdict = {</span>
                <span class="s4">'EXTENSION'</span><span class="s1">: COMPRESSED</span><span class="s3">,</span>
                <span class="s4">'DATA'</span><span class="s1">: COMPRESSED</span><span class="s3">,</span>
                <span class="s4">'BINARY'</span><span class="s1">: COMPRESSED</span><span class="s3">,</span>
                <span class="s4">'EXECUTABLE'</span><span class="s1">: COMPRESSED</span><span class="s3">,</span>
                <span class="s4">'PYSOURCE'</span><span class="s1">: COMPRESSED</span><span class="s3">,</span>
                <span class="s4">'PYMODULE'</span><span class="s1">: COMPRESSED</span><span class="s3">,</span>
                <span class="s4">'SPLASH'</span><span class="s1">: COMPRESSED</span><span class="s3">,</span>
                <span class="s0"># Do not compress PYZ as a whole. Single modules are compressed when creating PYZ archive.</span>
                <span class="s4">'PYZ'</span><span class="s1">: UNCOMPRESSED</span>
            <span class="s1">}</span>
        <span class="s1">self.__postinit__()</span>

    <span class="s1">_GUTS = (  </span><span class="s0"># input parameters</span>
        <span class="s1">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'cdict'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'toc'</span><span class="s3">, </span><span class="s1">_check_guts_toc)</span><span class="s3">,  </span><span class="s0"># list unchanged and no newer files</span>
        <span class="s1">(</span><span class="s4">'exclude_binaries'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'strip_binaries'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'upx_binaries'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'upx_exclude'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'target_arch'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'codesign_identity'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'entitlements_file'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s0"># no calculated/analysed values</span>
    <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_check_guts(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">last_build):</span>
        <span class="s3">if </span><span class="s1">Target._check_guts(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">last_build):</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">assemble(self):</span>
        <span class="s1">logger.info(</span><span class="s4">&quot;Building PKG (CArchive) %s&quot;</span><span class="s3">, </span><span class="s1">os.path.basename(self.name))</span>
        <span class="s1">trash = []</span>
        <span class="s1">mytoc = []</span>
        <span class="s1">srctoc = []</span>
        <span class="s1">seen_inms = {}</span>
        <span class="s1">seen_fnms = {}</span>
        <span class="s1">seen_fnms_typ = {}</span>
        <span class="s0"># 'inm'  - relative filename inside a CArchive</span>
        <span class="s0"># 'fnm'  - absolute filename as it is on the file system.</span>
        <span class="s3">for </span><span class="s1">inm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">typ </span><span class="s3">in </span><span class="s1">self.toc:</span>
            <span class="s0"># Adjust name for extensions, if applicable</span>
            <span class="s1">inm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">typ = add_suffix_to_extension(inm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">typ)</span>
            <span class="s0"># Ensure filename 'fnm' is not None or empty string. Otherwise, it will fail when 'typ' is OPTION.</span>
            <span class="s3">if </span><span class="s1">fnm </span><span class="s3">and not </span><span class="s1">os.path.isfile(fnm) </span><span class="s3">and </span><span class="s1">is_path_to_egg(fnm):</span>
                <span class="s0"># File is contained within python egg; it is added with the egg.</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">typ </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'BINARY'</span><span class="s3">, </span><span class="s4">'EXTENSION'</span><span class="s3">, </span><span class="s4">'DEPENDENCY'</span><span class="s1">):</span>
                <span class="s3">if </span><span class="s1">self.exclude_binaries </span><span class="s3">and </span><span class="s1">typ == </span><span class="s4">'EXTENSION'</span><span class="s1">:</span>
                    <span class="s1">self.dependencies.append((inm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">typ))</span>
                <span class="s3">elif not </span><span class="s1">self.exclude_binaries </span><span class="s3">or </span><span class="s1">typ == </span><span class="s4">'DEPENDENCY'</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">typ == </span><span class="s4">'BINARY'</span><span class="s1">:</span>
                        <span class="s0"># Avoid importing the same binary extension twice. This might happen if they come from different</span>
                        <span class="s0"># sources (eg. once from binary dependence, and once from direct import).</span>
                        <span class="s3">if </span><span class="s1">inm </span><span class="s3">in </span><span class="s1">seen_inms:</span>
                            <span class="s1">logger.warning(</span><span class="s4">'Two binaries added with the same internal name.'</span><span class="s1">)</span>
                            <span class="s1">logger.warning(pprint.pformat((inm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">typ)))</span>
                            <span class="s1">logger.warning(</span><span class="s4">'was placed previously at'</span><span class="s1">)</span>
                            <span class="s1">logger.warning(pprint.pformat((inm</span><span class="s3">, </span><span class="s1">seen_inms[inm]</span><span class="s3">, </span><span class="s1">seen_fnms_typ[seen_inms[inm]])))</span>
                            <span class="s1">logger.warning(</span><span class="s4">'Skipping %s.' </span><span class="s1">% fnm)</span>
                            <span class="s3">continue</span>

                        <span class="s0"># Warn if the same binary extension was included with multiple internal names</span>
                        <span class="s3">if </span><span class="s1">fnm </span><span class="s3">in </span><span class="s1">seen_fnms:</span>
                            <span class="s1">logger.warning(</span><span class="s4">'One binary added with two internal names.'</span><span class="s1">)</span>
                            <span class="s1">logger.warning(pprint.pformat((inm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">typ)))</span>
                            <span class="s1">logger.warning(</span><span class="s4">'was placed previously at'</span><span class="s1">)</span>
                            <span class="s1">logger.warning(pprint.pformat((seen_fnms[fnm]</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">seen_fnms_typ[fnm])))</span>
                    <span class="s1">seen_inms[inm] = fnm</span>
                    <span class="s1">seen_fnms[fnm] = inm</span>
                    <span class="s1">seen_fnms_typ[fnm] = typ</span>

                    <span class="s1">fnm = checkCache(</span>
                        <span class="s1">fnm</span><span class="s3">,</span>
                        <span class="s1">strip=self.strip_binaries</span><span class="s3">,</span>
                        <span class="s1">upx=self.upx_binaries</span><span class="s3">,</span>
                        <span class="s1">upx_exclude=self.upx_exclude</span><span class="s3">,</span>
                        <span class="s1">dist_nm=inm</span><span class="s3">,</span>
                        <span class="s1">target_arch=self.target_arch</span><span class="s3">,</span>
                        <span class="s1">codesign_identity=self.codesign_identity</span><span class="s3">,</span>
                        <span class="s1">entitlements_file=self.entitlements_file</span><span class="s3">,</span>
                        <span class="s1">strict_arch_validation=(typ == </span><span class="s4">'EXTENSION'</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">)</span>

                    <span class="s1">mytoc.append((inm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">self.cdict.get(typ</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">self.xformdict.get(typ</span><span class="s3">, </span><span class="s4">'b'</span><span class="s1">)))</span>
            <span class="s3">elif </span><span class="s1">typ == </span><span class="s4">'OPTION'</span><span class="s1">:</span>
                <span class="s1">mytoc.append((inm</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s4">'o'</span><span class="s1">))</span>
            <span class="s3">elif </span><span class="s1">typ </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'PYSOURCE'</span><span class="s3">, </span><span class="s4">'PYMODULE'</span><span class="s1">):</span>
                <span class="s0"># collect sourcefiles and module in a toc of it's own which will not be sorted.</span>
                <span class="s1">srctoc.append((inm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">self.cdict[typ]</span><span class="s3">, </span><span class="s1">self.xformdict[typ]))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">mytoc.append((inm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">self.cdict.get(typ</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">self.xformdict.get(typ</span><span class="s3">, </span><span class="s4">'b'</span><span class="s1">)))</span>

        <span class="s0"># Bootloader has to know the name of Python library. Pass python libname to CArchive.</span>
        <span class="s1">pylib_name = os.path.basename(bindepend.get_python_library_path())</span>

        <span class="s0"># Sort content alphabetically by type and name to support reproducible builds.</span>
        <span class="s1">mytoc.sort(key=itemgetter(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span>
        <span class="s0"># Do *not* sort modules and scripts, as their order is important.</span>
        <span class="s0"># TODO: Think about having all modules first and then all scripts.</span>
        <span class="s1">CArchiveWriter(self.name</span><span class="s3">, </span><span class="s1">srctoc + mytoc</span><span class="s3">, </span><span class="s1">pylib_name=pylib_name)</span>

        <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">trash:</span>
            <span class="s1">os.remove(item)</span>
        <span class="s1">logger.info(</span><span class="s4">&quot;Building PKG (CArchive) %s completed successfully.&quot;</span><span class="s3">, </span><span class="s1">os.path.basename(self.name))</span>


<span class="s3">class </span><span class="s1">EXE(Target):</span>
    <span class="s2">&quot;&quot;&quot; 
    Creates the final executable of the frozen app. This bundles all necessary files together. 
    &quot;&quot;&quot;</span>
    <span class="s1">typ = </span><span class="s4">'EXECUTABLE'</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        args 
                One or more arguments that are either TOCs Targets. 
        kwargs 
            Possible keyword arguments: 
 
            bootloader_ignore_signals 
                Non-Windows only. If True, the bootloader process will ignore all ignorable signals. If False (default), 
                it will forward all signals to the child process. Useful in situations where for example a supervisor 
                process signals both the bootloader and the child (e.g., via a process group) to avoid signalling the 
                child twice. 
            console 
                On Windows or Mac OS governs whether to use the console executable or the windowed executable. Always 
                True on Linux/Unix (always console executable - it does not matter there). 
            disable_windowed_traceback 
                Disable traceback dump of unhandled exception in windowed (noconsole) mode (Windows and macOS only), 
                and instead display a message that this feature is disabled. 
            debug 
                Setting to True gives you progress messages from the executable (for console=False there will be 
                annoying MessageBoxes on Windows). 
            name 
                The filename for the executable. On Windows suffix '.exe' is appended. 
            exclude_binaries 
                Forwarded to the PKG the EXE builds. 
            icon 
                Windows and Mac OS only. icon='myicon.ico' to use an icon file or icon='notepad.exe,0' to grab an icon 
                resource. Defaults to use PyInstaller's console or windowed icon. Use icon=`NONE` to not add any icon. 
            version 
                Windows only. version='myversion.txt'. Use grab_version.py to get a version resource from an executable 
                and then edit the output to create your own. (The syntax of version resources is so arcane that I would 
                not attempt to write one from scratch). 
            uac_admin 
                Windows only. Setting to True creates a Manifest with will request elevation upon application start. 
            uac_uiaccess 
                Windows only. Setting to True allows an elevated application to work with Remote Desktop. 
            embed_manifest 
                Windows only. Setting to True (the default) embeds the manifest into the executable. Setting to False 
                generates an external .exe.manifest file. Applicable only in onedir mode (exclude_binaries=True); in 
                onefile mode (exclude_binaries=False), the manifest is always embedded in the executable, regardless 
                of this option. 
            target_arch 
                macOS only. Used to explicitly specify the target architecture; either single-arch ('x86_64' or 'arm64') 
                or 'universal2'. Used in checks that the collected binaries contain the requires arch slice(s) and/or 
                to convert fat binaries into thin ones as necessary. If not specified (default), a single-arch build 
                corresponding to running architecture is assumed. 
            codesign_identity 
                macOS only. Use the provided identity to sign collected binaries and the generated executable. If 
                signing identity is not provided, ad-hoc signing is performed. 
            entitlements_file 
                macOS only. Optional path to entitlements file to use with code signing of collected binaries 
                (--entitlements option to codesign utility). 
        &quot;&quot;&quot;</span>
        <span class="s3">from </span><span class="s1">PyInstaller.config </span><span class="s3">import </span><span class="s1">CONF</span>
        <span class="s1">Target.__init__(self)</span>

        <span class="s0"># Available options for EXE in .spec files.</span>
        <span class="s1">self.exclude_binaries = kwargs.get(</span><span class="s4">'exclude_binaries'</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s1">self.bootloader_ignore_signals = kwargs.get(</span><span class="s4">'bootloader_ignore_signals'</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s1">self.console = kwargs.get(</span><span class="s4">'console'</span><span class="s3">, True</span><span class="s1">)</span>
        <span class="s1">self.disable_windowed_traceback = kwargs.get(</span><span class="s4">'disable_windowed_traceback'</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s1">self.debug = kwargs.get(</span><span class="s4">'debug'</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s1">self.name = kwargs.get(</span><span class="s4">'name'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.icon = kwargs.get(</span><span class="s4">'icon'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.versrsrc = kwargs.get(</span><span class="s4">'version'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.manifest = kwargs.get(</span><span class="s4">'manifest'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.embed_manifest = kwargs.get(</span><span class="s4">'embed_manifest'</span><span class="s3">, True</span><span class="s1">)</span>
        <span class="s1">self.resources = kwargs.get(</span><span class="s4">'resources'</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s1">self.strip = kwargs.get(</span><span class="s4">'strip'</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s1">self.upx_exclude = kwargs.get(</span><span class="s4">&quot;upx_exclude&quot;</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s1">self.runtime_tmpdir = kwargs.get(</span><span class="s4">'runtime_tmpdir'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s0"># If ``append_pkg`` is false, the archive will not be appended to the exe, but copied beside it.</span>
        <span class="s1">self.append_pkg = kwargs.get(</span><span class="s4">'append_pkg'</span><span class="s3">, True</span><span class="s1">)</span>

        <span class="s0"># On Windows allows the exe to request admin privileges.</span>
        <span class="s1">self.uac_admin = kwargs.get(</span><span class="s4">'uac_admin'</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s1">self.uac_uiaccess = kwargs.get(</span><span class="s4">'uac_uiaccess'</span><span class="s3">, False</span><span class="s1">)</span>

        <span class="s0"># Target architecture (macOS only)</span>
        <span class="s1">self.target_arch = kwargs.get(</span><span class="s4">'target_arch'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">is_darwin:</span>
            <span class="s3">if </span><span class="s1">self.target_arch </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">import </span><span class="s1">platform</span>
                <span class="s1">self.target_arch = platform.machine()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">assert </span><span class="s1">self.target_arch </span><span class="s3">in </span><span class="s1">{</span><span class="s4">'x86_64'</span><span class="s3">, </span><span class="s4">'arm64'</span><span class="s3">, </span><span class="s4">'universal2'</span><span class="s1">}</span><span class="s3">, </span><span class="s1">\</span>
                    <span class="s4">f&quot;Unsupported target arch: </span><span class="s3">{</span><span class="s1">self.target_arch</span><span class="s3">}</span><span class="s4">&quot;</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;EXE target arch: %s&quot;</span><span class="s3">, </span><span class="s1">self.target_arch)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.target_arch = </span><span class="s3">None  </span><span class="s0"># explicitly disable</span>

        <span class="s0"># Code signing identity (macOS only)</span>
        <span class="s1">self.codesign_identity = kwargs.get(</span><span class="s4">'codesign_identity'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">is_darwin:</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Code signing identity: %s&quot;</span><span class="s3">, </span><span class="s1">self.codesign_identity)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.codesign_identity = </span><span class="s3">None  </span><span class="s0"># explicitly disable</span>
        <span class="s0"># Code signing entitlements</span>
        <span class="s1">self.entitlements_file = kwargs.get(</span><span class="s4">'entitlements_file'</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">CONF[</span><span class="s4">'hasUPX'</span><span class="s1">]:</span>
            <span class="s1">self.upx = kwargs.get(</span><span class="s4">'upx'</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.upx = </span><span class="s3">False</span>

        <span class="s0"># Old .spec format included in 'name' the path where to put created app. New format includes only exename.</span>
        <span class="s0">#</span>
        <span class="s0"># Ignore fullpath in the 'name' and prepend DISTPATH or WORKPATH.</span>
        <span class="s0"># DISTPATH - onefile</span>
        <span class="s0"># WORKPATH - onedir</span>
        <span class="s3">if </span><span class="s1">self.exclude_binaries:</span>
            <span class="s0"># onedir mode - create executable in WORKPATH.</span>
            <span class="s1">self.name = os.path.join(CONF[</span><span class="s4">'workpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">os.path.basename(self.name))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># onefile mode - create executable in DISTPATH.</span>
            <span class="s1">self.name = os.path.join(CONF[</span><span class="s4">'distpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">os.path.basename(self.name))</span>

        <span class="s0"># Old .spec format included on Windows in 'name' .exe suffix.</span>
        <span class="s3">if </span><span class="s1">is_win </span><span class="s3">or </span><span class="s1">is_cygwin:</span>
            <span class="s0"># Append .exe suffix if it is not already there.</span>
            <span class="s3">if not </span><span class="s1">self.name.endswith(</span><span class="s4">'.exe'</span><span class="s1">):</span>
                <span class="s1">self.name += </span><span class="s4">'.exe'</span>
            <span class="s1">base_name = os.path.splitext(os.path.basename(self.name))[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">base_name = os.path.basename(self.name)</span>
        <span class="s0"># Create the CArchive PKG in WORKPATH. When instancing PKG(), set name so that guts check can test whether the</span>
        <span class="s0"># file already exists.</span>
        <span class="s1">self.pkgname = os.path.join(CONF[</span><span class="s4">'workpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">base_name + </span><span class="s4">'.pkg'</span><span class="s1">)</span>

        <span class="s1">self.toc = TOC()</span>

        <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">args:</span>
            <span class="s3">if </span><span class="s1">isinstance(arg</span><span class="s3">, </span><span class="s1">TOC):</span>
                <span class="s1">self.toc.extend(arg)</span>
            <span class="s3">elif </span><span class="s1">isinstance(arg</span><span class="s3">, </span><span class="s1">Target):</span>
                <span class="s1">self.toc.append((os.path.basename(arg.name)</span><span class="s3">, </span><span class="s1">arg.name</span><span class="s3">, </span><span class="s1">arg.typ))</span>
                <span class="s1">self.toc.extend(arg.dependencies)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.toc.extend(arg)</span>

        <span class="s3">if </span><span class="s1">self.runtime_tmpdir </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.toc.append((</span><span class="s4">&quot;pyi-runtime-tmpdir &quot; </span><span class="s1">+ self.runtime_tmpdir</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s4">&quot;OPTION&quot;</span><span class="s1">))</span>

        <span class="s3">if </span><span class="s1">self.bootloader_ignore_signals:</span>
            <span class="s0"># no value; presence means &quot;true&quot;</span>
            <span class="s1">self.toc.append((</span><span class="s4">&quot;pyi-bootloader-ignore-signals&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s4">&quot;OPTION&quot;</span><span class="s1">))</span>

        <span class="s3">if </span><span class="s1">self.disable_windowed_traceback:</span>
            <span class="s0"># no value; presence means &quot;true&quot;</span>
            <span class="s1">self.toc.append((</span><span class="s4">&quot;pyi-disable-windowed-traceback&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s4">&quot;OPTION&quot;</span><span class="s1">))</span>

        <span class="s3">if </span><span class="s1">is_win:</span>
            <span class="s3">if not </span><span class="s1">self.exclude_binaries:</span>
                <span class="s0"># onefile mode forces embed_manifest=True</span>
                <span class="s3">if not </span><span class="s1">self.embed_manifest:</span>
                    <span class="s1">logger.warning(</span><span class="s4">&quot;Ignoring embed_manifest=False setting in onefile mode!&quot;</span><span class="s1">)</span>
                <span class="s1">self.embed_manifest = </span><span class="s3">True</span>
            <span class="s3">if not </span><span class="s1">self.icon:</span>
                <span class="s0"># --icon not specified; use default from bootloader folder</span>
                <span class="s3">if </span><span class="s1">self.console:</span>
                    <span class="s1">ico = </span><span class="s4">'icon-console.ico'</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">ico = </span><span class="s4">'icon-windowed.ico'</span>
                <span class="s1">self.icon = os.path.join(os.path.dirname(os.path.dirname(__file__))</span><span class="s3">, </span><span class="s4">'bootloader'</span><span class="s3">, </span><span class="s4">'images'</span><span class="s3">, </span><span class="s1">ico)</span>
            <span class="s1">filename = os.path.join(CONF[</span><span class="s4">'workpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">CONF[</span><span class="s4">'specnm'</span><span class="s1">] + </span><span class="s4">&quot;.exe.manifest&quot;</span><span class="s1">)</span>
            <span class="s1">self.manifest = winmanifest.create_manifest(</span>
                <span class="s1">filename</span><span class="s3">, </span><span class="s1">self.manifest</span><span class="s3">, </span><span class="s1">self.console</span><span class="s3">, </span><span class="s1">self.uac_admin</span><span class="s3">, </span><span class="s1">self.uac_uiaccess</span>
            <span class="s1">)</span>

            <span class="s1">manifest_filename = os.path.basename(self.name) + </span><span class="s4">&quot;.manifest&quot;</span>

            <span class="s0"># If external manifest file is requested (supported only in onedir mode), add the file to the TOC in order</span>
            <span class="s0"># for it to be collected as an external manifest file. Otherwise, the assembly pipeline will embed the</span>
            <span class="s0"># manifest into the executable later on.</span>
            <span class="s3">if not </span><span class="s1">self.embed_manifest:</span>
                <span class="s1">self.toc.append((manifest_filename</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s4">'BINARY'</span><span class="s1">))</span>

            <span class="s3">if </span><span class="s1">self.versrsrc:</span>
                <span class="s3">if not </span><span class="s1">isinstance(self.versrsrc</span><span class="s3">, </span><span class="s1">versioninfo.VSVersionInfo) </span><span class="s3">and not </span><span class="s1">os.path.isabs(self.versrsrc):</span>
                    <span class="s0"># relative version-info path is relative to spec file</span>
                    <span class="s1">self.versrsrc = os.path.join(CONF[</span><span class="s4">'specpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.versrsrc)</span>

        <span class="s1">self.pkg = PKG(</span>
            <span class="s1">self.toc</span><span class="s3">,</span>
            <span class="s1">name=self.pkgname</span><span class="s3">,</span>
            <span class="s1">cdict=kwargs.get(</span><span class="s4">'cdict'</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">exclude_binaries=self.exclude_binaries</span><span class="s3">,</span>
            <span class="s1">strip_binaries=self.strip</span><span class="s3">,</span>
            <span class="s1">upx_binaries=self.upx</span><span class="s3">,</span>
            <span class="s1">upx_exclude=self.upx_exclude</span><span class="s3">,</span>
            <span class="s1">target_arch=self.target_arch</span><span class="s3">,</span>
            <span class="s1">codesign_identity=self.codesign_identity</span><span class="s3">,</span>
            <span class="s1">entitlements_file=self.entitlements_file</span>
        <span class="s1">)</span>
        <span class="s1">self.dependencies = self.pkg.dependencies</span>

        <span class="s0"># Get the path of the bootloader and store it in a TOC, so it can be checked for being changed.</span>
        <span class="s1">exe = self._bootloader_file(</span><span class="s4">'run'</span><span class="s3">, </span><span class="s4">'.exe' </span><span class="s3">if </span><span class="s1">is_win </span><span class="s3">or </span><span class="s1">is_cygwin </span><span class="s3">else </span><span class="s4">''</span><span class="s1">)</span>
        <span class="s1">self.exefiles = TOC([(os.path.basename(exe)</span><span class="s3">, </span><span class="s1">exe</span><span class="s3">, </span><span class="s4">'EXECUTABLE'</span><span class="s1">)])</span>

        <span class="s1">self.__postinit__()</span>

    <span class="s1">_GUTS = (  </span><span class="s0"># input parameters</span>
        <span class="s1">(</span><span class="s4">'name'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'console'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'debug'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'exclude_binaries'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'icon'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'versrsrc'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'uac_admin'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'uac_uiaccess'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'manifest'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'embed_manifest'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'append_pkg'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'target_arch'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'codesign_identity'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'entitlements_file'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s0"># for the case the directory ius shared between platforms:</span>
        <span class="s1">(</span><span class="s4">'pkgname'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'toc'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'resources'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'strip'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'upx'</span><span class="s3">, </span><span class="s1">_check_guts_eq)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s4">'mtm'</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,  </span><span class="s0"># checked below</span>
        <span class="s0"># no calculated/analysed values</span>
        <span class="s1">(</span><span class="s4">'exefiles'</span><span class="s3">, </span><span class="s1">_check_guts_toc)</span><span class="s3">,</span>
    <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_check_guts(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">last_build):</span>
        <span class="s3">if not </span><span class="s1">os.path.exists(self.name):</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Rebuilding %s because %s missing&quot;</span><span class="s3">, </span><span class="s1">self.tocbasename</span><span class="s3">, </span><span class="s1">os.path.basename(self.name))</span>
            <span class="s3">return </span><span class="s5">1</span>
        <span class="s3">if not </span><span class="s1">self.append_pkg </span><span class="s3">and not </span><span class="s1">os.path.exists(self.pkgname):</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Rebuilding because %s missing&quot;</span><span class="s3">, </span><span class="s1">os.path.basename(self.pkgname))</span>
            <span class="s3">return </span><span class="s5">1</span>

        <span class="s3">if </span><span class="s1">Target._check_guts(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">last_build):</span>
            <span class="s3">return True</span>

        <span class="s3">if </span><span class="s1">(data[</span><span class="s4">'versrsrc'</span><span class="s1">] </span><span class="s3">or </span><span class="s1">data[</span><span class="s4">'resources'</span><span class="s1">]) </span><span class="s3">and not </span><span class="s1">is_win:</span>
            <span class="s0"># todo: really ignore :-)</span>
            <span class="s1">logger.warning(</span><span class="s4">'ignoring version, manifest and resources, platform not capable'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">data[</span><span class="s4">'icon'</span><span class="s1">] </span><span class="s3">and not </span><span class="s1">(is_win </span><span class="s3">or </span><span class="s1">is_darwin):</span>
            <span class="s1">logger.warning(</span><span class="s4">'ignoring icon, platform not capable'</span><span class="s1">)</span>

        <span class="s1">mtm = data[</span><span class="s4">'mtm'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">mtm != misc.mtime(self.name):</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Rebuilding %s because mtimes don't match&quot;</span><span class="s3">, </span><span class="s1">self.tocbasename)</span>
            <span class="s3">return True</span>
        <span class="s3">if </span><span class="s1">mtm &lt; misc.mtime(self.pkg.tocfilename):</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Rebuilding %s because pkg is more recent&quot;</span><span class="s3">, </span><span class="s1">self.tocbasename)</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_bootloader_file(self</span><span class="s3">, </span><span class="s1">exe</span><span class="s3">, </span><span class="s1">extension=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Pick up the right bootloader file - debug, console, windowed. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Having console/windowed bootloader makes sense only on Windows and Mac OS.</span>
        <span class="s3">if </span><span class="s1">is_win </span><span class="s3">or </span><span class="s1">is_darwin:</span>
            <span class="s3">if not </span><span class="s1">self.console:</span>
                <span class="s1">exe = exe + </span><span class="s4">'w'</span>
        <span class="s0"># There are two types of bootloaders:</span>
        <span class="s0"># run     - release, no verbose messages in console.</span>
        <span class="s0"># run_d   - contains verbose messages in console.</span>
        <span class="s3">if </span><span class="s1">self.debug:</span>
            <span class="s1">exe = exe + </span><span class="s4">'_d'</span>
        <span class="s3">if </span><span class="s1">extension:</span>
            <span class="s1">exe = exe + extension</span>
        <span class="s1">bootloader_file = os.path.join(HOMEPATH</span><span class="s3">, </span><span class="s4">'PyInstaller'</span><span class="s3">, </span><span class="s4">'bootloader'</span><span class="s3">, </span><span class="s1">PLATFORM</span><span class="s3">, </span><span class="s1">exe)</span>
        <span class="s1">logger.info(</span><span class="s4">'Bootloader %s' </span><span class="s1">% bootloader_file)</span>
        <span class="s3">return </span><span class="s1">bootloader_file</span>

    <span class="s3">def </span><span class="s1">assemble(self):</span>
        <span class="s3">from </span><span class="s1">PyInstaller.config </span><span class="s3">import </span><span class="s1">CONF</span>

        <span class="s0"># On Windows, we must never create a file with a .exe suffix that we then have to (re)write to (see #6467).</span>
        <span class="s0"># Any intermediate/temporary file must have an alternative suffix.</span>
        <span class="s1">build_name = self.name + </span><span class="s4">'.notanexecutable' </span><span class="s3">if </span><span class="s1">is_win </span><span class="s3">or </span><span class="s1">is_cygwin </span><span class="s3">else </span><span class="s1">self.name</span>

        <span class="s1">logger.info(</span><span class="s4">&quot;Building EXE from %s&quot;</span><span class="s3">, </span><span class="s1">self.tocbasename)</span>
        <span class="s3">if </span><span class="s1">os.path.exists(self.name):</span>
            <span class="s3">if </span><span class="s1">os.path.isdir(self.name):</span>
                <span class="s1">_rmtree(self.name)  </span><span class="s0"># will prompt for confirmation if --noconfirm is not given</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">os.remove(self.name)</span>
        <span class="s3">if not </span><span class="s1">os.path.exists(os.path.dirname(self.name)):</span>
            <span class="s1">os.makedirs(os.path.dirname(self.name))</span>
        <span class="s1">exe = self.exefiles[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]  </span><span class="s0"># pathname of bootloader</span>
        <span class="s3">if not </span><span class="s1">os.path.exists(exe):</span>
            <span class="s3">raise </span><span class="s1">SystemExit(_MISSING_BOOTLOADER_ERRORMSG)</span>

        <span class="s0"># Step 1: copy the bootloader file, and perform any operations that need to be done prior to appending the PKG.</span>
        <span class="s1">logger.info(</span><span class="s4">&quot;Copying bootloader EXE to %s&quot;</span><span class="s3">, </span><span class="s1">build_name)</span>
        <span class="s1">self._copyfile(exe</span><span class="s3">, </span><span class="s1">build_name)</span>
        <span class="s1">os.chmod(build_name</span><span class="s3">, </span><span class="s5">0o755</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">is_win:</span>
            <span class="s0"># First, remove all resources from the file. This ensures that no manifest is embedded, even if bootloader</span>
            <span class="s0"># was compiled with a toolchain that forcibly embeds a default manifest (e.g., mingw toolchain from msys2).</span>
            <span class="s1">winresource.RemoveAllResources(build_name)</span>
            <span class="s0"># Embed icon.</span>
            <span class="s3">if </span><span class="s1">self.icon != </span><span class="s4">&quot;NONE&quot;</span><span class="s1">:</span>
                <span class="s1">logger.info(</span><span class="s4">&quot;Copying icon to EXE&quot;</span><span class="s1">)</span>
                <span class="s1">icon.CopyIcons(build_name</span><span class="s3">, </span><span class="s1">self.icon)</span>
            <span class="s0"># Embed version info.</span>
            <span class="s3">if </span><span class="s1">self.versrsrc:</span>
                <span class="s1">logger.info(</span><span class="s4">&quot;Copying version information to EXE&quot;</span><span class="s1">)</span>
                <span class="s1">versioninfo.SetVersion(build_name</span><span class="s3">, </span><span class="s1">self.versrsrc)</span>
            <span class="s0"># Embed other resources.</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Copying %d resources to EXE&quot;</span><span class="s3">, </span><span class="s1">len(self.resources))</span>
            <span class="s3">for </span><span class="s1">res </span><span class="s3">in </span><span class="s1">self.resources:</span>
                <span class="s1">res = res.split(</span><span class="s4">&quot;,&quot;</span><span class="s1">)</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">len(res)):</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">res[i] = int(res[i])</span>
                    <span class="s3">except </span><span class="s1">ValueError:</span>
                        <span class="s3">pass</span>
                <span class="s1">resfile = res[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s3">if not </span><span class="s1">os.path.isabs(resfile):</span>
                    <span class="s1">resfile = os.path.join(CONF[</span><span class="s4">'specpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">resfile)</span>
                <span class="s1">restype = resname = reslang = </span><span class="s3">None</span>
                <span class="s3">if </span><span class="s1">len(res) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">restype = res[</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s3">if </span><span class="s1">len(res) &gt; </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s1">resname = res[</span><span class="s5">2</span><span class="s1">]</span>
                <span class="s3">if </span><span class="s1">len(res) &gt; </span><span class="s5">3</span><span class="s1">:</span>
                    <span class="s1">reslang = res[</span><span class="s5">3</span><span class="s1">]</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">winresource.UpdateResourcesFromResFile(</span>
                        <span class="s1">build_name</span><span class="s3">, </span><span class="s1">resfile</span><span class="s3">, </span><span class="s1">[restype </span><span class="s3">or </span><span class="s4">&quot;*&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[resname </span><span class="s3">or </span><span class="s4">&quot;*&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[reslang </span><span class="s3">or </span><span class="s4">&quot;*&quot;</span><span class="s1">]</span>
                    <span class="s1">)</span>
                <span class="s3">except </span><span class="s1">winresource.pywintypes.error </span><span class="s3">as </span><span class="s1">exc:</span>
                    <span class="s3">if </span><span class="s1">exc.args[</span><span class="s5">0</span><span class="s1">] != winresource.ERROR_BAD_EXE_FORMAT:</span>
                        <span class="s1">logger.error(</span>
                            <span class="s4">&quot;Error while updating resources in %s from resource file %s!&quot;</span><span class="s3">,</span>
                            <span class="s1">build_name</span><span class="s3">,</span>
                            <span class="s1">resfile</span><span class="s3">,</span>
                            <span class="s1">exc_info=</span><span class="s5">1</span>
                        <span class="s1">)</span>
                        <span class="s3">continue</span>

                    <span class="s0"># Handle the case where the file contains no resources, and is intended as a single resource to be</span>
                    <span class="s0"># added to the exe.</span>
                    <span class="s3">if not </span><span class="s1">restype </span><span class="s3">or not </span><span class="s1">resname:</span>
                        <span class="s1">logger.error(</span><span class="s4">&quot;Resource type and/or name not specified!&quot;</span><span class="s1">)</span>
                        <span class="s3">continue</span>
                    <span class="s3">if </span><span class="s4">&quot;*&quot; </span><span class="s3">in </span><span class="s1">(restype</span><span class="s3">, </span><span class="s1">resname):</span>
                        <span class="s1">logger.error(</span>
                            <span class="s4">&quot;No wildcards allowed for resource type and name when the source file does not contain &quot;</span>
                            <span class="s4">&quot;any resources!&quot;</span>
                        <span class="s1">)</span>
                        <span class="s3">continue</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">winresource.UpdateResourcesFromDataFile(build_name</span><span class="s3">, </span><span class="s1">resfile</span><span class="s3">, </span><span class="s1">restype</span><span class="s3">, </span><span class="s1">[resname]</span><span class="s3">, </span><span class="s1">[reslang </span><span class="s3">or </span><span class="s5">0</span><span class="s1">])</span>
                    <span class="s3">except </span><span class="s1">winresource.pywintypes.error:</span>
                        <span class="s1">logger.error(</span>
                            <span class="s4">&quot;Error while updating resource %s %s in %s from data file %s!&quot;</span><span class="s3">,</span>
                            <span class="s1">restype</span><span class="s3">,</span>
                            <span class="s1">resname</span><span class="s3">,</span>
                            <span class="s1">build_name</span><span class="s3">,</span>
                            <span class="s1">resfile</span><span class="s3">,</span>
                            <span class="s1">exc_info=</span><span class="s5">1</span>
                        <span class="s1">)</span>
            <span class="s0"># Embed the manifest into the executable.</span>
            <span class="s3">if </span><span class="s1">self.embed_manifest:</span>
                <span class="s1">logger.info(</span><span class="s4">&quot;Emedding manifest in EXE&quot;</span><span class="s1">)</span>
                <span class="s1">self.manifest.update_resources(build_name</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s3">elif </span><span class="s1">is_darwin:</span>
            <span class="s0"># Convert bootloader to the target arch</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Converting EXE to target arch (%s)&quot;</span><span class="s3">, </span><span class="s1">self.target_arch)</span>
            <span class="s1">osxutils.binary_to_target_arch(build_name</span><span class="s3">, </span><span class="s1">self.target_arch</span><span class="s3">, </span><span class="s1">display_name=</span><span class="s4">'Bootloader EXE'</span><span class="s1">)</span>

        <span class="s0"># Step 2: append the PKG, if necessary</span>
        <span class="s3">if </span><span class="s1">self.append_pkg:</span>
            <span class="s1">append_file = self.pkg.name  </span><span class="s0"># Append PKG</span>
            <span class="s1">append_type = </span><span class="s4">'PKG archive'  </span><span class="s0"># For debug messages</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># In onefile mode, copy the stand-alone PKG next to the executable. In onedir, this will be done by the</span>
            <span class="s0"># COLLECT() target.</span>
            <span class="s3">if not </span><span class="s1">self.exclude_binaries:</span>
                <span class="s1">pkg_dst = os.path.join(os.path.dirname(build_name)</span><span class="s3">, </span><span class="s1">os.path.basename(self.pkgname))</span>
                <span class="s1">logger.info(</span><span class="s4">&quot;Copying stand-alone PKG archive from %s to %s&quot;</span><span class="s3">, </span><span class="s1">self.pkg.name</span><span class="s3">, </span><span class="s1">pkg_dst)</span>
                <span class="s1">self._copyfile(self.pkg.name</span><span class="s3">, </span><span class="s1">pkg_dst)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">logger.info(</span><span class="s4">&quot;Stand-alone PKG archive will be handled by COLLECT&quot;</span><span class="s1">)</span>

            <span class="s0"># The bootloader requires package side-loading to be explicitly enabled, which is done by embedding custom</span>
            <span class="s0"># signature to the executable. This extra signature ensures that the sideload-enabled executable is at least</span>
            <span class="s0"># slightly different from the stock bootloader executables, which should prevent antivirus programs from</span>
            <span class="s0"># flagging our stock bootloaders due to sideload-enabled applications in the wild.</span>

            <span class="s0"># Write to temporary file</span>
            <span class="s1">pkgsig_file = self.pkg.name + </span><span class="s4">'.sig'</span>
            <span class="s3">with </span><span class="s1">open(pkgsig_file</span><span class="s3">, </span><span class="s4">&quot;wb&quot;</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
                <span class="s0"># 8-byte MAGIC; slightly changed PKG MAGIC pattern</span>
                <span class="s1">f.write(</span><span class="s6">b'MEI</span><span class="s3">\015\013\012\013\016</span><span class="s6">'</span><span class="s1">)</span>

            <span class="s1">append_file = pkgsig_file  </span><span class="s0"># Append PKG-SIG</span>
            <span class="s1">append_type = </span><span class="s4">'PKG sideload signature'  </span><span class="s0"># For debug messages</span>

        <span class="s3">if </span><span class="s1">is_linux:</span>
            <span class="s0"># Linux: append data into custom ELF section using objcopy.</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Appending %s to custom ELF section in EXE&quot;</span><span class="s3">, </span><span class="s1">append_type)</span>
            <span class="s1">cmd = [</span><span class="s4">'objcopy'</span><span class="s3">, </span><span class="s4">'--add-section'</span><span class="s3">, </span><span class="s4">f'pydata=</span><span class="s3">{</span><span class="s1">append_file</span><span class="s3">}</span><span class="s4">'</span><span class="s3">, </span><span class="s1">build_name]</span>
            <span class="s1">p = subprocess.run(cmd</span><span class="s3">, </span><span class="s1">stderr=subprocess.STDOUT</span><span class="s3">, </span><span class="s1">stdout=subprocess.PIPE</span><span class="s3">, </span><span class="s1">universal_newlines=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">p.returncode:</span>
                <span class="s3">raise </span><span class="s1">SystemError(</span><span class="s4">f&quot;objcopy Failure: </span><span class="s3">{</span><span class="s1">p.returncode</span><span class="s3">} {</span><span class="s1">p.stdout</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s3">elif </span><span class="s1">is_darwin:</span>
            <span class="s0"># macOS: remove signature, append data, and fix-up headers so that the appended data appears to be part of</span>
            <span class="s0"># the executable (which is required by strict validation during code-signing).</span>

            <span class="s0"># Strip signatures from all arch slices. Strictly speaking, we need to remove signature (if present) from</span>
            <span class="s0"># the last slice, because we will be appending data to it. When building universal2 bootloaders natively on</span>
            <span class="s0"># macOS, only arm64 slices have a (dummy) signature. However, when cross-compiling with osxcross, we seem to</span>
            <span class="s0"># get dummy signatures on both x86_64 and arm64 slices. While the former should not have any impact, it does</span>
            <span class="s0"># seem to cause issues with further binary signing using real identity. Therefore, we remove all signatures</span>
            <span class="s0"># and re-sign the binary using dummy signature once the data is appended.</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Removing signature(s) from EXE&quot;</span><span class="s1">)</span>
            <span class="s1">osxutils.remove_signature_from_binary(build_name)</span>

            <span class="s0"># Append the data</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Appending %s to EXE&quot;</span><span class="s3">, </span><span class="s1">append_type)</span>
            <span class="s3">with </span><span class="s1">open(build_name</span><span class="s3">, </span><span class="s4">'ab'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">outf:</span>
                <span class="s3">with </span><span class="s1">open(append_file</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">inf:</span>
                    <span class="s1">shutil.copyfileobj(inf</span><span class="s3">, </span><span class="s1">outf</span><span class="s3">, </span><span class="s1">length=</span><span class="s5">64 </span><span class="s1">* </span><span class="s5">1024</span><span class="s1">)</span>

            <span class="s0"># Fix Mach-O headers</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Fixing EXE headers for code signing&quot;</span><span class="s1">)</span>
            <span class="s1">osxutils.fix_exe_for_code_signing(build_name)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Fall back to just appending data at the end of the file</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Appending %s to EXE&quot;</span><span class="s3">, </span><span class="s1">append_type)</span>
            <span class="s3">with </span><span class="s1">open(build_name</span><span class="s3">, </span><span class="s4">'ab'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">outf:</span>
                <span class="s3">with </span><span class="s1">open(append_file</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">inf:</span>
                    <span class="s1">shutil.copyfileobj(inf</span><span class="s3">, </span><span class="s1">outf</span><span class="s3">, </span><span class="s1">length=</span><span class="s5">64 </span><span class="s1">* </span><span class="s5">1024</span><span class="s1">)</span>

        <span class="s0"># Step 3: post-processing</span>
        <span class="s3">if </span><span class="s1">is_win:</span>
            <span class="s0"># Set checksum to appease antiviral software. Also set build timestamp to current time to increase entropy</span>
            <span class="s0"># (but honor SOURCE_DATE_EPOCH environment variable for reproducible builds).</span>
            <span class="s1">build_timestamp = int(os.environ.get(</span><span class="s4">'SOURCE_DATE_EPOCH'</span><span class="s3">, </span><span class="s1">time.time()))</span>
            <span class="s1">winutils.fixup_exe_headers(build_name</span><span class="s3">, </span><span class="s1">build_timestamp)</span>
        <span class="s3">elif </span><span class="s1">is_darwin:</span>
            <span class="s0"># If the version of macOS SDK used to build bootloader exceeds that of macOS SDK used to built Python</span>
            <span class="s0"># library (and, by extension, bundled Tcl/Tk libraries), force the version declared by the frozen executable</span>
            <span class="s0"># to match that of the Python library.</span>
            <span class="s0"># Having macOS attempt to enable new features (based on SDK version) for frozen application has no benefit</span>
            <span class="s0"># if the Python library does not support them as well.</span>
            <span class="s0"># On the other hand, there seem to be UI issues in tkinter due to failed or partial enablement of dark mode</span>
            <span class="s0"># (i.e., the bootloader executable being built against SDK 10.14 or later, which causes macOS to enable dark</span>
            <span class="s0"># mode, and Tk libraries being built against an earlier SDK version that does not support the dark mode).</span>
            <span class="s0"># With python.org Intel macOS installers, this manifests as black Tk windows and UI elements (see issue</span>
            <span class="s0"># #5827), while in Anaconda python, it may result in white text on bright background.</span>
            <span class="s1">pylib_version = osxutils.get_macos_sdk_version(bindepend.get_python_library_path())</span>
            <span class="s1">exe_version = osxutils.get_macos_sdk_version(build_name)</span>
            <span class="s3">if </span><span class="s1">pylib_version &lt; exe_version:</span>
                <span class="s1">logger.info(</span>
                    <span class="s4">&quot;Rewriting the executable's macOS SDK version (%d.%d.%d) to match the SDK version of the Python &quot;</span>
                    <span class="s4">&quot;library (%d.%d.%d) in order to avoid inconsistent behavior and potential UI issues in the &quot;</span>
                    <span class="s4">&quot;frozen application.&quot;</span><span class="s3">, </span><span class="s1">*exe_version</span><span class="s3">, </span><span class="s1">*pylib_version</span>
                <span class="s1">)</span>
                <span class="s1">osxutils.set_macos_sdk_version(build_name</span><span class="s3">, </span><span class="s1">*pylib_version)</span>

            <span class="s0"># Re-sign the binary (either ad-hoc or using real identity, if provided).</span>
            <span class="s1">logger.info(</span><span class="s4">&quot;Re-signing the EXE&quot;</span><span class="s1">)</span>
            <span class="s1">osxutils.sign_binary(build_name</span><span class="s3">, </span><span class="s1">self.codesign_identity</span><span class="s3">, </span><span class="s1">self.entitlements_file)</span>

        <span class="s0"># Ensure executable flag is set</span>
        <span class="s1">os.chmod(build_name</span><span class="s3">, </span><span class="s5">0o755</span><span class="s1">)</span>
        <span class="s0"># Get mtime for storing into the guts</span>
        <span class="s1">self.mtm = misc.mtime(build_name)</span>
        <span class="s3">if </span><span class="s1">build_name != self.name:</span>
            <span class="s1">os.rename(build_name</span><span class="s3">, </span><span class="s1">self.name)</span>
        <span class="s1">logger.info(</span><span class="s4">&quot;Building EXE from %s completed successfully.&quot;</span><span class="s3">, </span><span class="s1">self.tocbasename)</span>

    <span class="s3">def </span><span class="s1">_copyfile(self</span><span class="s3">, </span><span class="s1">infile</span><span class="s3">, </span><span class="s1">outfile):</span>
        <span class="s3">with </span><span class="s1">open(infile</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">infh:</span>
            <span class="s3">with </span><span class="s1">open(outfile</span><span class="s3">, </span><span class="s4">'wb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">outfh:</span>
                <span class="s1">shutil.copyfileobj(infh</span><span class="s3">, </span><span class="s1">outfh</span><span class="s3">, </span><span class="s1">length=</span><span class="s5">64 </span><span class="s1">* </span><span class="s5">1024</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">COLLECT(Target):</span>
    <span class="s2">&quot;&quot;&quot; 
    In one-dir mode creates the output folder with all necessary files. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kws):</span>
        <span class="s2">&quot;&quot;&quot; 
        args 
                One or more arguments that are either TOCs Targets. 
        kws 
            Possible keyword arguments: 
 
                name 
                    The name of the directory to be built. 
        &quot;&quot;&quot;</span>
        <span class="s3">from </span><span class="s1">PyInstaller.config </span><span class="s3">import </span><span class="s1">CONF</span>
        <span class="s1">Target.__init__(self)</span>
        <span class="s1">self.strip_binaries = kws.get(</span><span class="s4">'strip'</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s1">self.upx_exclude = kws.get(</span><span class="s4">&quot;upx_exclude&quot;</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s1">self.console = </span><span class="s3">True</span>
        <span class="s1">self.target_arch = </span><span class="s3">None</span>
        <span class="s1">self.codesign_identity = </span><span class="s3">None</span>
        <span class="s1">self.entitlements_file = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">CONF[</span><span class="s4">'hasUPX'</span><span class="s1">]:</span>
            <span class="s1">self.upx_binaries = kws.get(</span><span class="s4">'upx'</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.upx_binaries = </span><span class="s3">False</span>

        <span class="s1">self.name = kws.get(</span><span class="s4">'name'</span><span class="s1">)</span>
        <span class="s0"># Old .spec format included in 'name' the path where to collect files for the created app. app. New format</span>
        <span class="s0"># includes only directory name.</span>
        <span class="s0">#</span>
        <span class="s0"># The 'name' directory is created in DISTPATH and necessary files are then collected to this directory.</span>
        <span class="s1">self.name = os.path.join(CONF[</span><span class="s4">'distpath'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">os.path.basename(self.name))</span>

        <span class="s1">self.toc = TOC()</span>
        <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">args:</span>
            <span class="s3">if </span><span class="s1">isinstance(arg</span><span class="s3">, </span><span class="s1">TOC):</span>
                <span class="s1">self.toc.extend(arg)</span>
            <span class="s3">elif </span><span class="s1">isinstance(arg</span><span class="s3">, </span><span class="s1">Target):</span>
                <span class="s1">self.toc.append((os.path.basename(arg.name)</span><span class="s3">, </span><span class="s1">arg.name</span><span class="s3">, </span><span class="s1">arg.typ))</span>
                <span class="s3">if </span><span class="s1">isinstance(arg</span><span class="s3">, </span><span class="s1">EXE):</span>
                    <span class="s1">self.console = arg.console</span>
                    <span class="s1">self.target_arch = arg.target_arch</span>
                    <span class="s1">self.codesign_identity = arg.codesign_identity</span>
                    <span class="s1">self.entitlements_file = arg.entitlements_file</span>
                    <span class="s3">for </span><span class="s1">tocnm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">typ </span><span class="s3">in </span><span class="s1">arg.toc:</span>
                        <span class="s3">if </span><span class="s1">tocnm == os.path.basename(arg.name) + </span><span class="s4">&quot;.manifest&quot;</span><span class="s1">:</span>
                            <span class="s1">self.toc.append((tocnm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">typ))</span>
                    <span class="s3">if not </span><span class="s1">arg.append_pkg:</span>
                        <span class="s1">self.toc.append((os.path.basename(arg.pkgname)</span><span class="s3">, </span><span class="s1">arg.pkgname</span><span class="s3">, </span><span class="s4">'PKG'</span><span class="s1">))</span>
                <span class="s1">self.toc.extend(arg.dependencies)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.toc.extend(arg)</span>
        <span class="s1">self.__postinit__()</span>

    <span class="s1">_GUTS = (</span>
        <span class="s0"># COLLECT always builds, just want the toc to be written out</span>
        <span class="s1">(</span><span class="s4">'toc'</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_check_guts(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">last_build):</span>
        <span class="s0"># COLLECT always needs to be executed, since it will clean the output directory anyway to make sure there is no</span>
        <span class="s0"># existing cruft accumulating</span>
        <span class="s3">return </span><span class="s5">1</span>

    <span class="s3">def </span><span class="s1">assemble(self):</span>
        <span class="s1">_make_clean_directory(self.name)</span>
        <span class="s1">logger.info(</span><span class="s4">&quot;Building COLLECT %s&quot;</span><span class="s3">, </span><span class="s1">self.tocbasename)</span>
        <span class="s3">for </span><span class="s1">inm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">typ </span><span class="s3">in </span><span class="s1">self.toc:</span>
            <span class="s0"># Adjust name for extensions, if applicable</span>
            <span class="s1">inm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">typ = add_suffix_to_extension(inm</span><span class="s3">, </span><span class="s1">fnm</span><span class="s3">, </span><span class="s1">typ)</span>
            <span class="s3">if not </span><span class="s1">os.path.exists(fnm) </span><span class="s3">or not </span><span class="s1">os.path.isfile(fnm) </span><span class="s3">and </span><span class="s1">is_path_to_egg(fnm):</span>
                <span class="s0"># File is contained within python egg; it is added with the egg.</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">os.pardir </span><span class="s3">in </span><span class="s1">os.path.normpath(inm).split(os.sep) </span><span class="s3">or </span><span class="s1">os.path.isabs(inm):</span>
                <span class="s3">raise </span><span class="s1">SystemExit(</span><span class="s4">'Security-Alert: try to store file outside of dist-directory. Aborting. %r' </span><span class="s1">% inm)</span>
            <span class="s1">tofnm = os.path.join(self.name</span><span class="s3">, </span><span class="s1">inm)</span>
            <span class="s1">todir = os.path.dirname(tofnm)</span>
            <span class="s3">if not </span><span class="s1">os.path.exists(todir):</span>
                <span class="s1">os.makedirs(todir)</span>
            <span class="s3">elif not </span><span class="s1">os.path.isdir(todir):</span>
                <span class="s3">raise </span><span class="s1">SystemExit(</span>
                    <span class="s4">&quot;Pyinstaller needs to make a directory at %r, but there already exists a file at that path!&quot; </span><span class="s1">% todir</span>
                <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">typ </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'EXTENSION'</span><span class="s3">, </span><span class="s4">'BINARY'</span><span class="s1">):</span>
                <span class="s1">fnm = checkCache(</span>
                    <span class="s1">fnm</span><span class="s3">,</span>
                    <span class="s1">strip=self.strip_binaries</span><span class="s3">,</span>
                    <span class="s1">upx=self.upx_binaries</span><span class="s3">,</span>
                    <span class="s1">upx_exclude=self.upx_exclude</span><span class="s3">,</span>
                    <span class="s1">dist_nm=inm</span><span class="s3">,</span>
                    <span class="s1">target_arch=self.target_arch</span><span class="s3">,</span>
                    <span class="s1">codesign_identity=self.codesign_identity</span><span class="s3">,</span>
                    <span class="s1">entitlements_file=self.entitlements_file</span><span class="s3">,</span>
                    <span class="s1">strict_arch_validation=(typ == </span><span class="s4">'EXTENSION'</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">typ != </span><span class="s4">'DEPENDENCY'</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">os.path.isdir(fnm):</span>
                    <span class="s0"># Because shutil.copy2() is the default copy function for shutil.copytree, this will also copy file</span>
                    <span class="s0"># metadata.</span>
                    <span class="s1">shutil.copytree(fnm</span><span class="s3">, </span><span class="s1">tofnm)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">shutil.copy(fnm</span><span class="s3">, </span><span class="s1">tofnm)</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">shutil.copystat(fnm</span><span class="s3">, </span><span class="s1">tofnm)</span>
                <span class="s3">except </span><span class="s1">OSError:</span>
                    <span class="s1">logger.warning(</span><span class="s4">&quot;failed to copy flags of %s&quot;</span><span class="s3">, </span><span class="s1">fnm)</span>
            <span class="s3">if </span><span class="s1">typ </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'EXTENSION'</span><span class="s3">, </span><span class="s4">'BINARY'</span><span class="s1">):</span>
                <span class="s1">os.chmod(tofnm</span><span class="s3">, </span><span class="s5">0o755</span><span class="s1">)</span>
        <span class="s1">logger.info(</span><span class="s4">&quot;Building COLLECT %s completed successfully.&quot;</span><span class="s3">, </span><span class="s1">self.tocbasename)</span>


<span class="s3">class </span><span class="s1">MERGE(object):</span>
    <span class="s2">&quot;&quot;&quot; 
    Merge repeated dependencies from other executables into the first executable. Data and binary files are then 
    present only once and some disk space is thus reduced. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s2">&quot;&quot;&quot; 
        Repeated dependencies are then present only once in the first executable in the 'args' list. Other 
        executables depend on the first one. Other executables have to extract necessary files from the first 
        executable. 
 
        args  dependencies in a list of (Analysis, id, filename) tuples. 
              Replace id with the correct filename. 
        &quot;&quot;&quot;</span>
        <span class="s0"># The first Analysis object with all dependencies.</span>
        <span class="s0"># Any item from the first executable cannot be removed.</span>
        <span class="s1">self._main = </span><span class="s3">None</span>

        <span class="s1">self._dependencies = {}</span>

        <span class="s1">self._id_to_path = {}</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">p </span><span class="s3">in </span><span class="s1">args:</span>
            <span class="s1">self._id_to_path[os.path.normcase(i)] = p</span>

        <span class="s0"># Get the longest common path</span>
        <span class="s1">common_prefix = os.path.commonprefix([os.path.normcase(os.path.abspath(a.scripts[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">])) </span><span class="s3">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">args])</span>
        <span class="s1">self._common_prefix = os.path.dirname(common_prefix)</span>
        <span class="s3">if </span><span class="s1">self._common_prefix[-</span><span class="s5">1</span><span class="s1">] != os.sep:</span>
            <span class="s1">self._common_prefix += os.sep</span>
        <span class="s1">logger.info(</span><span class="s4">&quot;Common prefix: %s&quot;</span><span class="s3">, </span><span class="s1">self._common_prefix)</span>

        <span class="s1">self._merge_dependencies(args)</span>

    <span class="s3">def </span><span class="s1">_merge_dependencies(self</span><span class="s3">, </span><span class="s1">args):</span>
        <span class="s2">&quot;&quot;&quot; 
        Filter shared dependencies to be only in first executable. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">analysis</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">args:</span>
            <span class="s1">path = os.path.normcase(os.path.abspath(analysis.scripts[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]))</span>
            <span class="s1">path = path.replace(self._common_prefix</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">path = os.path.splitext(path)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">os.path.normcase(path) </span><span class="s3">in </span><span class="s1">self._id_to_path:</span>
                <span class="s1">path = self._id_to_path[os.path.normcase(path)]</span>
            <span class="s1">self._set_dependencies(analysis</span><span class="s3">, </span><span class="s1">path)</span>

    <span class="s3">def </span><span class="s1">_set_dependencies(self</span><span class="s3">, </span><span class="s1">analysis</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s2">&quot;&quot;&quot; 
        Synchronize the Analysis result with the needed dependencies. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">toc </span><span class="s3">in </span><span class="s1">(analysis.binaries</span><span class="s3">, </span><span class="s1">analysis.datas):</span>
            <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">tpl </span><span class="s3">in </span><span class="s1">enumerate(toc):</span>
                <span class="s3">if not </span><span class="s1">tpl[</span><span class="s5">1</span><span class="s1">] </span><span class="s3">in </span><span class="s1">self._dependencies:</span>
                    <span class="s1">logger.debug(</span><span class="s4">&quot;Adding dependency %s located in %s&quot;</span><span class="s3">, </span><span class="s1">tpl[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">path)</span>
                    <span class="s1">self._dependencies[tpl[</span><span class="s5">1</span><span class="s1">]] = path</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">dep_path = self._get_relative_path(path</span><span class="s3">, </span><span class="s1">self._dependencies[tpl[</span><span class="s5">1</span><span class="s1">]])</span>
                    <span class="s0"># Ignore references that point to the origin package. This can happen if the same resource is listed</span>
                    <span class="s0"># multiple times in TOCs (e.g., once as binary and once as data).</span>
                    <span class="s3">if </span><span class="s1">dep_path.endswith(path):</span>
                        <span class="s1">logger.debug(</span>
                            <span class="s4">&quot;Ignoring self-reference of %s for %s, located in %s - duplicated TOC entry?&quot;</span><span class="s3">, </span><span class="s1">tpl[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">path</span><span class="s3">,</span>
                            <span class="s1">dep_path</span>
                        <span class="s1">)</span>
                        <span class="s0"># Clear the entry as it is a duplicate.</span>
                        <span class="s1">toc[i] = (</span><span class="s3">None, None, None</span><span class="s1">)</span>
                        <span class="s3">continue</span>
                    <span class="s1">logger.debug(</span><span class="s4">&quot;Referencing %s to be a dependency for %s, located in %s&quot;</span><span class="s3">, </span><span class="s1">tpl[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">dep_path)</span>
                    <span class="s0"># Determine the path relative to dep_path (i.e, within the target directory) from the 'name'</span>
                    <span class="s0"># component of the TOC tuple. If entry is EXTENSION, then the relative path needs to be</span>
                    <span class="s0"># reconstructed from the name components.</span>
                    <span class="s3">if </span><span class="s1">tpl[</span><span class="s5">2</span><span class="s1">] == </span><span class="s4">'EXTENSION'</span><span class="s1">:</span>
                        <span class="s0"># Split on os.path.sep first, to handle additional path prefix (e.g., lib-dynload)</span>
                        <span class="s1">ext_components = tpl[</span><span class="s5">0</span><span class="s1">].split(os.path.sep)</span>
                        <span class="s1">ext_components = ext_components[:-</span><span class="s5">1</span><span class="s1">] + ext_components[-</span><span class="s5">1</span><span class="s1">].split(</span><span class="s4">'.'</span><span class="s1">)[:-</span><span class="s5">1</span><span class="s1">]</span>
                        <span class="s3">if </span><span class="s1">ext_components:</span>
                            <span class="s1">rel_path = os.path.join(*ext_components)</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s1">rel_path = </span><span class="s4">''</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">rel_path = os.path.dirname(tpl[</span><span class="s5">0</span><span class="s1">])</span>
                    <span class="s0"># Take filename from 'path' (second component of TOC tuple); this way, we don't need to worry about</span>
                    <span class="s0"># suffix of extensions.</span>
                    <span class="s1">filename = os.path.basename(tpl[</span><span class="s5">1</span><span class="s1">])</span>
                    <span class="s0"># Construct the full file path relative to dep_path...</span>
                    <span class="s1">filename = os.path.join(rel_path</span><span class="s3">, </span><span class="s1">filename)</span>
                    <span class="s0"># ...and use it in new DEPENDENCY entry</span>
                    <span class="s1">analysis.dependencies.append((</span><span class="s4">&quot;:&quot;</span><span class="s1">.join((dep_path</span><span class="s3">, </span><span class="s1">filename))</span><span class="s3">, </span><span class="s1">tpl[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;DEPENDENCY&quot;</span><span class="s1">))</span>
                    <span class="s1">toc[i] = (</span><span class="s3">None, None, None</span><span class="s1">)</span>
            <span class="s0"># Clean the list</span>
            <span class="s1">toc[:] = [tpl </span><span class="s3">for </span><span class="s1">tpl </span><span class="s3">in </span><span class="s1">toc </span><span class="s3">if </span><span class="s1">tpl != (</span><span class="s3">None, None, None</span><span class="s1">)]</span>

    <span class="s0"># TODO: use pathlib.Path.relative_to() instead.</span>
    <span class="s3">def </span><span class="s1">_get_relative_path(self</span><span class="s3">, </span><span class="s1">startpath</span><span class="s3">, </span><span class="s1">topath):</span>
        <span class="s1">start = startpath.split(os.sep)[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">start = [</span><span class="s4">'..'</span><span class="s1">] * len(start)</span>
        <span class="s3">if </span><span class="s1">start:</span>
            <span class="s1">start.append(topath)</span>
            <span class="s3">return </span><span class="s1">os.sep.join(start)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">topath</span>


<span class="s1">UNCOMPRESSED = </span><span class="s5">0</span>
<span class="s1">COMPRESSED = </span><span class="s5">1</span>

<span class="s1">_MISSING_BOOTLOADER_ERRORMSG = </span><span class="s4">&quot;&quot;&quot;Fatal error: PyInstaller does not include a pre-compiled bootloader for your 
platform. For more details and instructions how to build the bootloader see 
&lt;https://pyinstaller.readthedocs.io/en/stable/bootloader-building.html&gt;&quot;&quot;&quot;</span>
</pre>
</body>
</html>