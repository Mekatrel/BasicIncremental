<html>
<head>
<title>safe.tcl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
safe.tcl</font>
</center></td></tr></table>
<pre><span class="s0"># safe.tcl --</span>
<span class="s0">#</span>
<span class="s0"># This file provide a safe loading/sourcing mechanism for safe interpreters.</span>
<span class="s0"># It implements a virtual path mecanism to hide the real pathnames from the</span>
<span class="s0"># slave. It runs in a master interpreter and sets up data structure and</span>
<span class="s0"># aliases that will be invoked when used from a slave interpreter.</span>
<span class="s0">#</span>
<span class="s0"># See the safe.n man page for details.</span>
<span class="s0">#</span>
<span class="s0"># Copyright (c) 1996-1997 Sun Microsystems, Inc.</span>
<span class="s0">#</span>
<span class="s0"># See the file &quot;license.terms&quot; for information on usage and redistribution of</span>
<span class="s0"># this file, and for a DISCLAIMER OF ALL WARRANTIES.</span>

<span class="s0">#</span>
<span class="s0"># The implementation is based on namespaces. These naming conventions are</span>
<span class="s0"># followed:</span>
<span class="s0"># Private procs starts with uppercase.</span>
<span class="s0"># Public  procs are exported and starts with lowercase</span>
<span class="s0">#</span>

<span class="s0"># Needed utilities package</span>
<span class="s0">package require opt 0.4.1</span>

<span class="s0"># Create the safe namespace</span>
<span class="s0">namespace eval ::safe {</span>
    <span class="s0"># Exported API:</span>
    <span class="s0">namespace export interpCreate interpInit interpConfigure interpDelete \</span>
	<span class="s0">interpAddToAccessPath interpFindInAccessPath setLogCmd</span>
<span class="s0">}</span>

<span class="s0"># Helper function to resolve the dual way of specifying staticsok (either</span>
<span class="s0"># by -noStatics or -statics 0)</span>
<span class="s0">proc ::safe::InterpStatics {} {</span>
    <span class="s0">foreach v {Args statics noStatics} {</span>
	<span class="s0">upvar $v $v</span>
    <span class="s0">}</span>
    <span class="s0">set flag [::tcl::OptProcArgGiven -noStatics]</span>
    <span class="s0">if {$flag &amp;&amp; (!$noStatics == !$statics)</span>
	<span class="s0">&amp;&amp; ([::tcl::OptProcArgGiven -statics])} {</span>
	<span class="s0">return -code error\</span>
	    <span class="s0">&quot;conflicting values given for -statics and -noStatics&quot;</span>
    <span class="s0">}</span>
    <span class="s0">if {$flag} {</span>
	<span class="s0">return [expr {!$noStatics}]</span>
    <span class="s0">} else {</span>
	<span class="s0">return $statics</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0"># Helper function to resolve the dual way of specifying nested loading</span>
<span class="s0"># (either by -nestedLoadOk or -nested 1)</span>
<span class="s0">proc ::safe::InterpNested {} {</span>
    <span class="s0">foreach v {Args nested nestedLoadOk} {</span>
	<span class="s0">upvar $v $v</span>
    <span class="s0">}</span>
    <span class="s0">set flag [::tcl::OptProcArgGiven -nestedLoadOk]</span>
    <span class="s0"># note that the test here is the opposite of the &quot;InterpStatics&quot; one</span>
    <span class="s0"># (it is not -noNested... because of the wanted default value)</span>
    <span class="s0">if {$flag &amp;&amp; (!$nestedLoadOk != !$nested)</span>
	<span class="s0">&amp;&amp; ([::tcl::OptProcArgGiven -nested])} {</span>
	<span class="s0">return -code error\</span>
	    <span class="s0">&quot;conflicting values given for -nested and -nestedLoadOk&quot;</span>
    <span class="s0">}</span>
    <span class="s0">if {$flag} {</span>
	<span class="s0"># another difference with &quot;InterpStatics&quot;</span>
	<span class="s0">return $nestedLoadOk</span>
    <span class="s0">} else {</span>
	<span class="s0">return $nested</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">####</span>
<span class="s0">#</span>
<span class="s0">#  API entry points that needs argument parsing :</span>
<span class="s0">#</span>
<span class="s0">####</span>

<span class="s0"># Interface/entry point function and front end for &quot;Create&quot;</span>
<span class="s0">proc ::safe::interpCreate {args} {</span>
    <span class="s0">set Args [::tcl::OptKeyParse ::safe::interpCreate $args]</span>
    <span class="s0">InterpCreate $slave $accessPath \</span>
	<span class="s0">[InterpStatics] [InterpNested] $deleteHook</span>
<span class="s0">}</span>

<span class="s0">proc ::safe::interpInit {args} {</span>
    <span class="s0">set Args [::tcl::OptKeyParse ::safe::interpIC $args]</span>
    <span class="s0">if {![::interp exists $slave]} {</span>
	<span class="s0">return -code error &quot;\&quot;$slave\&quot; is not an interpreter&quot;</span>
    <span class="s0">}</span>
    <span class="s0">InterpInit $slave $accessPath \</span>
	<span class="s0">[InterpStatics] [InterpNested] $deleteHook</span>
<span class="s0">}</span>

<span class="s0"># Check that the given slave is &quot;one of us&quot;</span>
<span class="s0">proc ::safe::CheckInterp {slave} {</span>
    <span class="s0">namespace upvar ::safe S$slave state</span>
    <span class="s0">if {![info exists state] || ![::interp exists $slave]} {</span>
	<span class="s0">return -code error \</span>
	    <span class="s0">&quot;\&quot;$slave\&quot; is not an interpreter managed by ::safe::&quot;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0"># Interface/entry point function and front end for &quot;Configure&quot;.  This code</span>
<span class="s0"># is awfully pedestrian because it would need more coupling and support</span>
<span class="s0"># between the way we store the configuration values in safe::interp's and</span>
<span class="s0"># the Opt package. Obviously we would like an OptConfigure to avoid</span>
<span class="s0"># duplicating all this code everywhere.</span>
<span class="s0"># -&gt; TODO (the app should share or access easily the program/value stored</span>
<span class="s0"># by opt)</span>

<span class="s0"># This is even more complicated by the boolean flags with no values that</span>
<span class="s0"># we had the bad idea to support for the sake of user simplicity in</span>
<span class="s0"># create/init but which makes life hard in configure...</span>
<span class="s0"># So this will be hopefully written and some integrated with opt1.0</span>
<span class="s0"># (hopefully for tcl8.1 ?)</span>
<span class="s0">proc ::safe::interpConfigure {args} {</span>
    <span class="s0">switch [llength $args] {</span>
	<span class="s0">1 {</span>
	    <span class="s0"># If we have exactly 1 argument the semantic is to return all</span>
	    <span class="s0"># the current configuration. We still call OptKeyParse though</span>
	    <span class="s0"># we know that &quot;slave&quot; is our given argument because it also</span>
	    <span class="s0"># checks for the &quot;-help&quot; option.</span>
	    <span class="s0">set Args [::tcl::OptKeyParse ::safe::interpIC $args]</span>
	    <span class="s0">CheckInterp $slave</span>
	    <span class="s0">namespace upvar ::safe S$slave state</span>

	    <span class="s0">return [join [list \</span>
		<span class="s0">[list -accessPath $state(access_path)] \</span>
		<span class="s0">[list -statics    $state(staticsok)]   \</span>
		<span class="s0">[list -nested     $state(nestedok)]    \</span>
	        <span class="s0">[list -deleteHook $state(cleanupHook)]]]</span>
	<span class="s0">}</span>
	<span class="s0">2 {</span>
	    <span class="s0"># If we have exactly 2 arguments the semantic is a &quot;configure</span>
	    <span class="s0"># get&quot;</span>
	    <span class="s0">lassign $args slave arg</span>

	    <span class="s0"># get the flag sub program (we 'know' about Opt's internal</span>
	    <span class="s0"># representation of data)</span>
	    <span class="s0">set desc [lindex [::tcl::OptKeyGetDesc ::safe::interpIC] 2]</span>
	    <span class="s0">set hits [::tcl::OptHits desc $arg]</span>
	    <span class="s0">if {$hits &gt; 1} {</span>
		<span class="s0">return -code error [::tcl::OptAmbigous $desc $arg]</span>
	    <span class="s0">} elseif {$hits == 0} {</span>
		<span class="s0">return -code error [::tcl::OptFlagUsage $desc $arg]</span>
	    <span class="s0">}</span>
	    <span class="s0">CheckInterp $slave</span>
	    <span class="s0">namespace upvar ::safe S$slave state</span>

	    <span class="s0">set item [::tcl::OptCurDesc $desc]</span>
	    <span class="s0">set name [::tcl::OptName $item]</span>
	    <span class="s0">switch -exact -- $name {</span>
		<span class="s0">-accessPath {</span>
		    <span class="s0">return [list -accessPath $state(access_path)]</span>
		<span class="s0">}</span>
		<span class="s0">-statics    {</span>
		    <span class="s0">return [list -statics $state(staticsok)]</span>
		<span class="s0">}</span>
		<span class="s0">-nested     {</span>
		    <span class="s0">return [list -nested $state(nestedok)]</span>
		<span class="s0">}</span>
		<span class="s0">-deleteHook {</span>
		    <span class="s0">return [list -deleteHook $state(cleanupHook)]</span>
		<span class="s0">}</span>
		<span class="s0">-noStatics {</span>
		    <span class="s0"># it is most probably a set in fact but we would need</span>
		    <span class="s0"># then to jump to the set part and it is not *sure*</span>
		    <span class="s0"># that it is a set action that the user want, so force</span>
		    <span class="s0"># it to use the unambigous -statics ?value? instead:</span>
		    <span class="s0">return -code error\</span>
			<span class="s0">&quot;ambigous query (get or set -noStatics ?)\</span>
				<span class="s0">use -statics instead&quot;</span>
		<span class="s0">}</span>
		<span class="s0">-nestedLoadOk {</span>
		    <span class="s0">return -code error\</span>
			<span class="s0">&quot;ambigous query (get or set -nestedLoadOk ?)\</span>
				<span class="s0">use -nested instead&quot;</span>
		<span class="s0">}</span>
		<span class="s0">default {</span>
		    <span class="s0">return -code error &quot;unknown flag $name (bug)&quot;</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">default {</span>
	    <span class="s0"># Otherwise we want to parse the arguments like init and</span>
	    <span class="s0"># create did</span>
	    <span class="s0">set Args [::tcl::OptKeyParse ::safe::interpIC $args]</span>
	    <span class="s0">CheckInterp $slave</span>
	    <span class="s0">namespace upvar ::safe S$slave state</span>

	    <span class="s0"># Get the current (and not the default) values of whatever has</span>
	    <span class="s0"># not been given:</span>
	    <span class="s0">if {![::tcl::OptProcArgGiven -accessPath]} {</span>
		<span class="s0">set doreset 1</span>
		<span class="s0">set accessPath $state(access_path)</span>
	    <span class="s0">} else {</span>
		<span class="s0">set doreset 0</span>
	    <span class="s0">}</span>
	    <span class="s0">if {</span>
		<span class="s0">![::tcl::OptProcArgGiven -statics]</span>
		<span class="s0">&amp;&amp; ![::tcl::OptProcArgGiven -noStatics]</span>
	    <span class="s0">} then {</span>
		<span class="s0">set statics    $state(staticsok)</span>
	    <span class="s0">} else {</span>
		<span class="s0">set statics    [InterpStatics]</span>
	    <span class="s0">}</span>
	    <span class="s0">if {</span>
		<span class="s0">[::tcl::OptProcArgGiven -nested] ||</span>
		<span class="s0">[::tcl::OptProcArgGiven -nestedLoadOk]</span>
	    <span class="s0">} then {</span>
		<span class="s0">set nested     [InterpNested]</span>
	    <span class="s0">} else {</span>
		<span class="s0">set nested     $state(nestedok)</span>
	    <span class="s0">}</span>
	    <span class="s0">if {![::tcl::OptProcArgGiven -deleteHook]} {</span>
		<span class="s0">set deleteHook $state(cleanupHook)</span>
	    <span class="s0">}</span>
	    <span class="s0"># we can now reconfigure :</span>
	    <span class="s0">InterpSetConfig $slave $accessPath $statics $nested $deleteHook</span>
	    <span class="s0"># auto_reset the slave (to completly synch the new access_path)</span>
	    <span class="s0">if {$doreset} {</span>
		<span class="s0">if {[catch {::interp eval $slave {auto_reset}} msg]} {</span>
		    <span class="s0">Log $slave &quot;auto_reset failed: $msg&quot;</span>
		<span class="s0">} else {</span>
		    <span class="s0">Log $slave &quot;successful auto_reset&quot; NOTICE</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">####</span>
<span class="s0">#</span>
<span class="s0">#  Functions that actually implements the exported APIs</span>
<span class="s0">#</span>
<span class="s0">####</span>

<span class="s0">#</span>
<span class="s0"># safe::InterpCreate : doing the real job</span>
<span class="s0">#</span>
<span class="s0"># This procedure creates a safe slave and initializes it with the safe</span>
<span class="s0"># base aliases.</span>
<span class="s0"># NB: slave name must be simple alphanumeric string, no spaces, no (), no</span>
<span class="s0"># {},...  {because the state array is stored as part of the name}</span>
<span class="s0">#</span>
<span class="s0"># Returns the slave name.</span>
<span class="s0">#</span>
<span class="s0"># Optional Arguments :</span>
<span class="s0"># + slave name : if empty, generated name will be used</span>
<span class="s0"># + access_path: path list controlling where load/source can occur,</span>
<span class="s0">#                if empty: the master auto_path will be used.</span>
<span class="s0"># + staticsok  : flag, if 0 :no static package can be loaded (load {} Xxx)</span>
<span class="s0">#                      if 1 :static packages are ok.</span>
<span class="s0"># + nestedok: flag, if 0 :no loading to sub-sub interps (load xx xx sub)</span>
<span class="s0">#                      if 1 : multiple levels are ok.</span>

<span class="s0"># use the full name and no indent so auto_mkIndex can find us</span>
<span class="s0">proc ::safe::InterpCreate {</span>
			   <span class="s0">slave</span>
			   <span class="s0">access_path</span>
			   <span class="s0">staticsok</span>
			   <span class="s0">nestedok</span>
			   <span class="s0">deletehook</span>
		       <span class="s0">} {</span>
    <span class="s0"># Create the slave.</span>
    <span class="s0">if {$slave ne &quot;&quot;} {</span>
	<span class="s0">::interp create -safe $slave</span>
    <span class="s0">} else {</span>
	<span class="s0"># empty argument: generate slave name</span>
	<span class="s0">set slave [::interp create -safe]</span>
    <span class="s0">}</span>
    <span class="s0">Log $slave &quot;Created&quot; NOTICE</span>

    <span class="s0"># Initialize it. (returns slave name)</span>
    <span class="s0">InterpInit $slave $access_path $staticsok $nestedok $deletehook</span>
<span class="s0">}</span>

<span class="s0">#</span>
<span class="s0"># InterpSetConfig (was setAccessPath) :</span>
<span class="s0">#    Sets up slave virtual auto_path and corresponding structure within</span>
<span class="s0">#    the master. Also sets the tcl_library in the slave to be the first</span>
<span class="s0">#    directory in the path.</span>
<span class="s0">#    NB: If you change the path after the slave has been initialized you</span>
<span class="s0">#    probably need to call &quot;auto_reset&quot; in the slave in order that it gets</span>
<span class="s0">#    the right auto_index() array values.</span>

<span class="s0">proc ::safe::InterpSetConfig {slave access_path staticsok nestedok deletehook} {</span>
    <span class="s0">global auto_path</span>

    <span class="s0"># determine and store the access path if empty</span>
    <span class="s0">if {$access_path eq &quot;&quot;} {</span>
	<span class="s0">set access_path $auto_path</span>

	<span class="s0"># Make sure that tcl_library is in auto_path and at the first</span>
	<span class="s0"># position (needed by setAccessPath)</span>
	<span class="s0">set where [lsearch -exact $access_path [info library]]</span>
	<span class="s0">if {$where == -1} {</span>
	    <span class="s0"># not found, add it.</span>
	    <span class="s0">set access_path [linsert $access_path 0 [info library]]</span>
	    <span class="s0">Log $slave &quot;tcl_library was not in auto_path,\</span>
			<span class="s0">added it to slave's access_path&quot; NOTICE</span>
	<span class="s0">} elseif {$where != 0} {</span>
	    <span class="s0"># not first, move it first</span>
	    <span class="s0">set access_path [linsert \</span>
				 <span class="s0">[lreplace $access_path $where $where] \</span>
				 <span class="s0">0 [info library]]</span>
	    <span class="s0">Log $slave &quot;tcl_libray was not in first in auto_path,\</span>
			<span class="s0">moved it to front of slave's access_path&quot; NOTICE</span>
	<span class="s0">}</span>

	<span class="s0"># Add 1st level sub dirs (will searched by auto loading from tcl</span>
	<span class="s0"># code in the slave using glob and thus fail, so we add them here</span>
	<span class="s0"># so by default it works the same).</span>
	<span class="s0">set access_path [AddSubDirs $access_path]</span>
    <span class="s0">}</span>

    <span class="s0">Log $slave &quot;Setting accessPath=($access_path) staticsok=$staticsok\</span>
		<span class="s0">nestedok=$nestedok deletehook=($deletehook)&quot; NOTICE</span>

    <span class="s0">namespace upvar ::safe S$slave state</span>

    <span class="s0"># clear old autopath if it existed</span>
    <span class="s0"># build new one</span>
    <span class="s0"># Extend the access list with the paths used to look for Tcl Modules.</span>
    <span class="s0"># We save the virtual form separately as well, as syncing it with the</span>
    <span class="s0"># slave has to be defered until the necessary commands are present for</span>
    <span class="s0"># setup.</span>

    <span class="s0">set norm_access_path  {}</span>
    <span class="s0">set slave_access_path {}</span>
    <span class="s0">set map_access_path   {}</span>
    <span class="s0">set remap_access_path {}</span>
    <span class="s0">set slave_tm_path     {}</span>

    <span class="s0">set i 0</span>
    <span class="s0">foreach dir $access_path {</span>
	<span class="s0">set token [PathToken $i]</span>
	<span class="s0">lappend slave_access_path  $token</span>
	<span class="s0">lappend map_access_path    $token $dir</span>
	<span class="s0">lappend remap_access_path  $dir $token</span>
	<span class="s0">lappend norm_access_path   [file normalize $dir]</span>
	<span class="s0">incr i</span>
    <span class="s0">}</span>

    <span class="s0">set morepaths [::tcl::tm::list]</span>
    <span class="s0">while {[llength $morepaths]} {</span>
	<span class="s0">set addpaths $morepaths</span>
	<span class="s0">set morepaths {}</span>

	<span class="s0">foreach dir $addpaths {</span>
	    <span class="s0"># Prevent the addition of dirs on the tm list to the</span>
	    <span class="s0"># result if they are already known.</span>
	    <span class="s0">if {[dict exists $remap_access_path $dir]} {</span>
		<span class="s0">continue</span>
	    <span class="s0">}</span>

	    <span class="s0">set token [PathToken $i]</span>
	    <span class="s0">lappend access_path        $dir</span>
	    <span class="s0">lappend slave_access_path  $token</span>
	    <span class="s0">lappend map_access_path    $token $dir</span>
	    <span class="s0">lappend remap_access_path  $dir $token</span>
	    <span class="s0">lappend norm_access_path   [file normalize $dir]</span>
	    <span class="s0">lappend slave_tm_path $token</span>
	    <span class="s0">incr i</span>

	    <span class="s0"># [Bug 2854929]</span>
	    <span class="s0"># Recursively find deeper paths which may contain</span>
	    <span class="s0"># modules. Required to handle modules with names like</span>
	    <span class="s0"># 'platform::shell', which translate into</span>
	    <span class="s0"># 'platform/shell-X.tm', i.e arbitrarily deep</span>
	    <span class="s0"># subdirectories.</span>
	    <span class="s0">lappend morepaths {*}[glob -nocomplain -directory $dir -type d *]</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">set state(access_path)       $access_path</span>
    <span class="s0">set state(access_path,map)   $map_access_path</span>
    <span class="s0">set state(access_path,remap) $remap_access_path</span>
    <span class="s0">set state(access_path,norm)  $norm_access_path</span>
    <span class="s0">set state(access_path,slave) $slave_access_path</span>
    <span class="s0">set state(tm_path_slave)     $slave_tm_path</span>
    <span class="s0">set state(staticsok)         $staticsok</span>
    <span class="s0">set state(nestedok)          $nestedok</span>
    <span class="s0">set state(cleanupHook)       $deletehook</span>

    <span class="s0">SyncAccessPath $slave</span>
<span class="s0">}</span>

<span class="s0">#</span>
<span class="s0">#</span>
<span class="s0"># FindInAccessPath:</span>
<span class="s0">#    Search for a real directory and returns its virtual Id (including the</span>
<span class="s0">#    &quot;$&quot;)</span>
<span class="s0">proc ::safe::interpFindInAccessPath {slave path} {</span>
    <span class="s0">namespace upvar ::safe S$slave state</span>

    <span class="s0">if {![dict exists $state(access_path,remap) $path]} {</span>
	<span class="s0">return -code error &quot;$path not found in access path $access_path&quot;</span>
    <span class="s0">}</span>

    <span class="s0">return [dict get $state(access_path,remap) $path]</span>
<span class="s0">}</span>

<span class="s0">#</span>
<span class="s0"># addToAccessPath:</span>
<span class="s0">#    add (if needed) a real directory to access path and return its</span>
<span class="s0">#    virtual token (including the &quot;$&quot;).</span>
<span class="s0">proc ::safe::interpAddToAccessPath {slave path} {</span>
    <span class="s0"># first check if the directory is already in there</span>
    <span class="s0"># (inlined interpFindInAccessPath).</span>
    <span class="s0">namespace upvar ::safe S$slave state</span>

    <span class="s0">if {[dict exists $state(access_path,remap) $path]} {</span>
	<span class="s0">return [dict get $state(access_path,remap) $path]</span>
    <span class="s0">}</span>

    <span class="s0"># new one, add it:</span>
    <span class="s0">set token [PathToken [llength $state(access_path)]]</span>

    <span class="s0">lappend state(access_path)       $path</span>
    <span class="s0">lappend state(access_path,slave) $token</span>
    <span class="s0">lappend state(access_path,map)   $token $path</span>
    <span class="s0">lappend state(access_path,remap) $path $token</span>
    <span class="s0">lappend state(access_path,norm)  [file normalize $path]</span>

    <span class="s0">SyncAccessPath $slave</span>
    <span class="s0">return $token</span>
<span class="s0">}</span>

<span class="s0"># This procedure applies the initializations to an already existing</span>
<span class="s0"># interpreter. It is useful when you want to install the safe base aliases</span>
<span class="s0"># into a preexisting safe interpreter.</span>
<span class="s0">proc ::safe::InterpInit {</span>
			 <span class="s0">slave</span>
			 <span class="s0">access_path</span>
			 <span class="s0">staticsok</span>
			 <span class="s0">nestedok</span>
			 <span class="s0">deletehook</span>
		     <span class="s0">} {</span>
    <span class="s0"># Configure will generate an access_path when access_path is empty.</span>
    <span class="s0">InterpSetConfig $slave $access_path $staticsok $nestedok $deletehook</span>

    <span class="s0"># NB we need to add [namespace current], aliases are always absolute</span>
    <span class="s0"># paths.</span>

    <span class="s0"># These aliases let the slave load files to define new commands</span>
    <span class="s0"># This alias lets the slave use the encoding names, convertfrom,</span>
    <span class="s0"># convertto, and system, but not &quot;encoding system &lt;name&gt;&quot; to set the</span>
    <span class="s0"># system encoding.</span>
    <span class="s0"># Handling Tcl Modules, we need a restricted form of Glob.</span>
    <span class="s0"># This alias interposes on the 'exit' command and cleanly terminates</span>
    <span class="s0"># the slave.</span>

    <span class="s0">foreach {command alias} {</span>
	<span class="s0">source   AliasSource</span>
	<span class="s0">load     AliasLoad</span>
	<span class="s0">encoding AliasEncoding</span>
	<span class="s0">exit     interpDelete</span>
	<span class="s0">glob     AliasGlob</span>
    <span class="s0">} {</span>
	<span class="s0">::interp alias $slave $command {} [namespace current]::$alias $slave</span>
    <span class="s0">}</span>

    <span class="s0"># This alias lets the slave have access to a subset of the 'file'</span>
    <span class="s0"># command functionality.</span>

    <span class="s0">::interp expose $slave file</span>
    <span class="s0">foreach subcommand {dirname extension rootname tail} {</span>
	<span class="s0">::interp alias $slave ::tcl::file::$subcommand {} \</span>
	    <span class="s0">::safe::AliasFileSubcommand $slave $subcommand</span>
    <span class="s0">}</span>
    <span class="s0">foreach subcommand {</span>
	<span class="s0">atime attributes copy delete executable exists isdirectory isfile</span>
	<span class="s0">link lstat mtime mkdir nativename normalize owned readable readlink</span>
	<span class="s0">rename size stat tempfile type volumes writable</span>
    <span class="s0">} {</span>
	<span class="s0">::interp alias $slave ::tcl::file::$subcommand {} \</span>
	    <span class="s0">::safe::BadSubcommand $slave file $subcommand</span>
    <span class="s0">}</span>

    <span class="s0"># Subcommands of info</span>
    <span class="s0">foreach {subcommand alias} {</span>
	<span class="s0">nameofexecutable   AliasExeName</span>
    <span class="s0">} {</span>
	<span class="s0">::interp alias $slave ::tcl::info::$subcommand \</span>
	    <span class="s0">{} [namespace current]::$alias $slave</span>
    <span class="s0">}</span>

    <span class="s0"># The allowed slave variables already have been set by Tcl_MakeSafe(3)</span>

    <span class="s0"># Source init.tcl and tm.tcl into the slave, to get auto_load and</span>
    <span class="s0"># other procedures defined:</span>

    <span class="s0">if {[catch {::interp eval $slave {</span>
	<span class="s0">source [file join $tcl_library init.tcl]</span>
    <span class="s0">}} msg opt]} {</span>
	<span class="s0">Log $slave &quot;can't source init.tcl ($msg)&quot;</span>
	<span class="s0">return -options $opt &quot;can't source init.tcl into slave $slave ($msg)&quot;</span>
    <span class="s0">}</span>

    <span class="s0">if {[catch {::interp eval $slave {</span>
	<span class="s0">source [file join $tcl_library tm.tcl]</span>
    <span class="s0">}} msg opt]} {</span>
	<span class="s0">Log $slave &quot;can't source tm.tcl ($msg)&quot;</span>
	<span class="s0">return -options $opt &quot;can't source tm.tcl into slave $slave ($msg)&quot;</span>
    <span class="s0">}</span>

    <span class="s0"># Sync the paths used to search for Tcl modules. This can be done only</span>
    <span class="s0"># now, after tm.tcl was loaded.</span>
    <span class="s0">namespace upvar ::safe S$slave state</span>
    <span class="s0">if {[llength $state(tm_path_slave)] &gt; 0} {</span>
	<span class="s0">::interp eval $slave [list \</span>
		<span class="s0">::tcl::tm::add {*}[lreverse $state(tm_path_slave)]]</span>
    <span class="s0">}</span>
    <span class="s0">return $slave</span>
<span class="s0">}</span>

<span class="s0"># Add (only if needed, avoid duplicates) 1 level of sub directories to an</span>
<span class="s0"># existing path list.  Also removes non directories from the returned</span>
<span class="s0"># list.</span>
<span class="s0">proc ::safe::AddSubDirs {pathList} {</span>
    <span class="s0">set res {}</span>
    <span class="s0">foreach dir $pathList {</span>
	<span class="s0">if {[file isdirectory $dir]} {</span>
	    <span class="s0"># check that we don't have it yet as a children of a previous</span>
	    <span class="s0"># dir</span>
	    <span class="s0">if {$dir ni $res} {</span>
		<span class="s0">lappend res $dir</span>
	    <span class="s0">}</span>
	    <span class="s0">foreach sub [glob -directory $dir -nocomplain *] {</span>
		<span class="s0">if {[file isdirectory $sub] &amp;&amp; ($sub ni $res)} {</span>
		    <span class="s0"># new sub dir, add it !</span>
		    <span class="s0">lappend res $sub</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">return $res</span>
<span class="s0">}</span>

<span class="s0"># This procedure deletes a safe slave managed by Safe Tcl and cleans up</span>
<span class="s0"># associated state:</span>

<span class="s0">proc ::safe::interpDelete {slave} {</span>
    <span class="s0">Log $slave &quot;About to delete&quot; NOTICE</span>

    <span class="s0">namespace upvar ::safe S$slave state</span>

    <span class="s0"># If the slave has a cleanup hook registered, call it.  Check the</span>
    <span class="s0"># existance because we might be called to delete an interp which has</span>
    <span class="s0"># not been registered with us at all</span>

    <span class="s0">if {[info exists state(cleanupHook)]} {</span>
	<span class="s0">set hook $state(cleanupHook)</span>
	<span class="s0">if {[llength $hook]} {</span>
	    <span class="s0"># remove the hook now, otherwise if the hook calls us somehow,</span>
	    <span class="s0"># we'll loop</span>
	    <span class="s0">unset state(cleanupHook)</span>
	    <span class="s0">try {</span>
		<span class="s0">{*}$hook $slave</span>
	    <span class="s0">} on error err {</span>
		<span class="s0">Log $slave &quot;Delete hook error ($err)&quot;</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Discard the global array of state associated with the slave, and</span>
    <span class="s0"># delete the interpreter.</span>

    <span class="s0">if {[info exists state]} {</span>
	<span class="s0">unset state</span>
    <span class="s0">}</span>

    <span class="s0"># if we have been called twice, the interp might have been deleted</span>
    <span class="s0"># already</span>
    <span class="s0">if {[::interp exists $slave]} {</span>
	<span class="s0">::interp delete $slave</span>
	<span class="s0">Log $slave &quot;Deleted&quot; NOTICE</span>
    <span class="s0">}</span>

    <span class="s0">return</span>
<span class="s0">}</span>

<span class="s0"># Set (or get) the logging mecanism</span>

<span class="s0">proc ::safe::setLogCmd {args} {</span>
    <span class="s0">variable Log</span>
    <span class="s0">set la [llength $args]</span>
    <span class="s0">if {$la == 0} {</span>
	<span class="s0">return $Log</span>
    <span class="s0">} elseif {$la == 1} {</span>
	<span class="s0">set Log [lindex $args 0]</span>
    <span class="s0">} else {</span>
	<span class="s0">set Log $args</span>
    <span class="s0">}</span>

    <span class="s0">if {$Log eq &quot;&quot;} {</span>
	<span class="s0"># Disable logging completely. Calls to it will be compiled out</span>
	<span class="s0"># of all users.</span>
	<span class="s0">proc ::safe::Log {args} {}</span>
    <span class="s0">} else {</span>
	<span class="s0"># Activate logging, define proper command.</span>

	<span class="s0">proc ::safe::Log {slave msg {type ERROR}} {</span>
	    <span class="s0">variable Log</span>
	    <span class="s0">{*}$Log &quot;$type for slave $slave : $msg&quot;</span>
	    <span class="s0">return</span>
	<span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0"># ------------------- END OF PUBLIC METHODS ------------</span>

<span class="s0">#</span>
<span class="s0"># Sets the slave auto_path to the master recorded value.  Also sets</span>
<span class="s0"># tcl_library to the first token of the virtual path.</span>
<span class="s0">#</span>
<span class="s0">proc ::safe::SyncAccessPath {slave} {</span>
    <span class="s0">namespace upvar ::safe S$slave state</span>

    <span class="s0">set slave_access_path $state(access_path,slave)</span>
    <span class="s0">::interp eval $slave [list set auto_path $slave_access_path]</span>

    <span class="s0">Log $slave &quot;auto_path in $slave has been set to $slave_access_path&quot;\</span>
	<span class="s0">NOTICE</span>

    <span class="s0"># This code assumes that info library is the first element in the</span>
    <span class="s0"># list of auto_path's. See -&gt; InterpSetConfig for the code which</span>
    <span class="s0"># ensures this condition.</span>

    <span class="s0">::interp eval $slave [list \</span>
	      <span class="s0">set tcl_library [lindex $slave_access_path 0]]</span>
<span class="s0">}</span>

<span class="s0"># Returns the virtual token for directory number N.</span>
<span class="s0">proc ::safe::PathToken {n} {</span>
    <span class="s0"># We need to have a &quot;:&quot; in the token string so [file join] on the</span>
    <span class="s0"># mac won't turn it into a relative path.</span>
    <span class="s0">return &quot;\$p(:$n:)&quot; ;# Form tested by case 7.2</span>
<span class="s0">}</span>

<span class="s0">#</span>
<span class="s0"># translate virtual path into real path</span>
<span class="s0">#</span>
<span class="s0">proc ::safe::TranslatePath {slave path} {</span>
    <span class="s0">namespace upvar ::safe S$slave state</span>

    <span class="s0"># somehow strip the namespaces 'functionality' out (the danger is that</span>
    <span class="s0"># we would strip valid macintosh &quot;../&quot; queries... :</span>
    <span class="s0">if {[string match &quot;*::*&quot; $path] || [string match &quot;*..*&quot; $path]} {</span>
	<span class="s0">return -code error &quot;invalid characters in path $path&quot;</span>
    <span class="s0">}</span>

    <span class="s0"># Use a cached map instead of computed local vars and subst.</span>

    <span class="s0">return [string map $state(access_path,map) $path]</span>
<span class="s0">}</span>

<span class="s0"># file name control (limit access to files/resources that should be a</span>
<span class="s0"># valid tcl source file)</span>
<span class="s0">proc ::safe::CheckFileName {slave file} {</span>
    <span class="s0"># This used to limit what can be sourced to &quot;.tcl&quot; and forbid files</span>
    <span class="s0"># with more than 1 dot and longer than 14 chars, but I changed that</span>
    <span class="s0"># for 8.4 as a safe interp has enough internal protection already to</span>
    <span class="s0"># allow sourcing anything. - hobbs</span>

    <span class="s0">if {![file exists $file]} {</span>
	<span class="s0"># don't tell the file path</span>
	<span class="s0">return -code error &quot;no such file or directory&quot;</span>
    <span class="s0">}</span>

    <span class="s0">if {![file readable $file]} {</span>
	<span class="s0"># don't tell the file path</span>
	<span class="s0">return -code error &quot;not readable&quot;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0"># AliasFileSubcommand handles selected subcommands of [file] in safe</span>
<span class="s0"># interpreters that are *almost* safe. In particular, it just acts to</span>
<span class="s0"># prevent discovery of what home directories exist.</span>

<span class="s0">proc ::safe::AliasFileSubcommand {slave subcommand name} {</span>
    <span class="s0">if {[string match ~* $name]} {</span>
	<span class="s0">set name ./$name</span>
    <span class="s0">}</span>
    <span class="s0">tailcall ::interp invokehidden $slave tcl:file:$subcommand $name</span>
<span class="s0">}</span>

<span class="s0"># AliasGlob is the target of the &quot;glob&quot; alias in safe interpreters.</span>

<span class="s0">proc ::safe::AliasGlob {slave args} {</span>
    <span class="s0">Log $slave &quot;GLOB ! $args&quot; NOTICE</span>
    <span class="s0">set cmd {}</span>
    <span class="s0">set at 0</span>
    <span class="s0">array set got {</span>
	<span class="s0">-directory 0</span>
	<span class="s0">-nocomplain 0</span>
	<span class="s0">-join 0</span>
	<span class="s0">-tails 0</span>
	<span class="s0">-- 0</span>
    <span class="s0">}</span>

    <span class="s0">if {$::tcl_platform(platform) eq &quot;windows&quot;} {</span>
	<span class="s0">set dirPartRE {^(.*)[\\/]([^\\/]*)$}</span>
    <span class="s0">} else {</span>
	<span class="s0">set dirPartRE {^(.*)/([^/]*)$}</span>
    <span class="s0">}</span>

    <span class="s0">set dir        {}</span>
    <span class="s0">set virtualdir {}</span>

    <span class="s0">while {$at &lt; [llength $args]} {</span>
	<span class="s0">switch -glob -- [set opt [lindex $args $at]] {</span>
	    <span class="s0">-nocomplain - -- - -join - -tails {</span>
		<span class="s0">lappend cmd $opt</span>
		<span class="s0">set got($opt) 1</span>
		<span class="s0">incr at</span>
	    <span class="s0">}</span>
	    <span class="s0">-types - -type {</span>
		<span class="s0">lappend cmd -types [lindex $args [incr at]]</span>
		<span class="s0">incr at</span>
	    <span class="s0">}</span>
	    <span class="s0">-directory {</span>
		<span class="s0">if {$got($opt)} {</span>
		    <span class="s0">return -code error \</span>
			<span class="s0">{&quot;-directory&quot; cannot be used with &quot;-path&quot;}</span>
		<span class="s0">}</span>
		<span class="s0">set got($opt) 1</span>
		<span class="s0">set virtualdir [lindex $args [incr at]]</span>
		<span class="s0">incr at</span>
	    <span class="s0">}</span>
	    <span class="s0">pkgIndex.tcl {</span>
		<span class="s0"># Oops, this is globbing a subdirectory in regular package</span>
		<span class="s0"># search. That is not wanted. Abort, handler does catch</span>
		<span class="s0"># already (because glob was not defined before). See</span>
		<span class="s0"># package.tcl, lines 484ff in tclPkgUnknown.</span>
		<span class="s0">return -code error &quot;unknown command glob&quot;</span>
	    <span class="s0">}</span>
	    <span class="s0">-* {</span>
		<span class="s0">Log $slave &quot;Safe base rejecting glob option '$opt'&quot;</span>
		<span class="s0">return -code error &quot;Safe base rejecting glob option '$opt'&quot;</span>
	    <span class="s0">}</span>
	    <span class="s0">default {</span>
		<span class="s0">break</span>
	    <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">if {$got(--)} break</span>
    <span class="s0">}</span>

    <span class="s0"># Get the real path from the virtual one and check that the path is in the</span>
    <span class="s0"># access path of that slave. Done after basic argument processing so that</span>
    <span class="s0"># we know if -nocomplain is set.</span>
    <span class="s0">if {$got(-directory)} {</span>
	<span class="s0">try {</span>
	    <span class="s0">set dir [TranslatePath $slave $virtualdir]</span>
	    <span class="s0">DirInAccessPath $slave $dir</span>
	<span class="s0">} on error msg {</span>
	    <span class="s0">Log $slave $msg</span>
	    <span class="s0">if {$got(-nocomplain)} return</span>
	    <span class="s0">return -code error &quot;permission denied&quot;</span>
	<span class="s0">}</span>
	<span class="s0">lappend cmd -directory $dir</span>
    <span class="s0">}</span>

    <span class="s0"># Apply the -join semantics ourselves</span>
    <span class="s0">if {$got(-join)} {</span>
	<span class="s0">set args [lreplace $args $at end [join [lrange $args $at end] &quot;/&quot;]]</span>
    <span class="s0">}</span>

    <span class="s0"># Process remaining pattern arguments</span>
    <span class="s0">set firstPattern [llength $cmd]</span>
    <span class="s0">foreach opt [lrange $args $at end] {</span>
	<span class="s0">if {![regexp $dirPartRE $opt -&gt; thedir thefile]} {</span>
	    <span class="s0">set thedir .</span>
	<span class="s0">} elseif {[string match ~* $thedir]} {</span>
	    <span class="s0">set thedir ./$thedir</span>
	<span class="s0">}</span>
	<span class="s0">if {$thedir eq &quot;*&quot; &amp;&amp;</span>
		<span class="s0">($thefile eq &quot;pkgIndex.tcl&quot; || $thefile eq &quot;*.tm&quot;)} {</span>
	    <span class="s0">set mapped 0</span>
	    <span class="s0">foreach d [glob -directory [TranslatePath $slave $virtualdir] \</span>
			   <span class="s0">-types d -tails *] {</span>
		<span class="s0">catch {</span>
		    <span class="s0">DirInAccessPath $slave \</span>
			<span class="s0">[TranslatePath $slave [file join $virtualdir $d]]</span>
		    <span class="s0">lappend cmd [file join $d $thefile]</span>
		    <span class="s0">set mapped 1</span>
		<span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s0">if {$mapped} continue</span>
	<span class="s0">}</span>
	<span class="s0">try {</span>
	    <span class="s0">DirInAccessPath $slave [TranslatePath $slave \</span>
		    <span class="s0">[file join $virtualdir $thedir]]</span>
	<span class="s0">} on error msg {</span>
	    <span class="s0">Log $slave $msg</span>
	    <span class="s0">if {$got(-nocomplain)} continue</span>
	    <span class="s0">return -code error &quot;permission denied&quot;</span>
	<span class="s0">}</span>
	<span class="s0">lappend cmd $opt</span>
    <span class="s0">}</span>

    <span class="s0">Log $slave &quot;GLOB = $cmd&quot; NOTICE</span>

    <span class="s0">if {$got(-nocomplain) &amp;&amp; [llength $cmd] eq $firstPattern} {</span>
	<span class="s0">return</span>
    <span class="s0">}</span>
    <span class="s0">try {</span>
	<span class="s0">set entries [::interp invokehidden $slave glob {*}$cmd]</span>
    <span class="s0">} on error msg {</span>
	<span class="s0">Log $slave $msg</span>
	<span class="s0">return -code error &quot;script error&quot;</span>
    <span class="s0">}</span>

    <span class="s0">Log $slave &quot;GLOB &lt; $entries&quot; NOTICE</span>

    <span class="s0"># Translate path back to what the slave should see.</span>
    <span class="s0">set res {}</span>
    <span class="s0">set l [string length $dir]</span>
    <span class="s0">foreach p $entries {</span>
	<span class="s0">if {[string equal -length $l $dir $p]} {</span>
	    <span class="s0">set p [string replace $p 0 [expr {$l-1}] $virtualdir]</span>
	<span class="s0">}</span>
	<span class="s0">lappend res $p</span>
    <span class="s0">}</span>

    <span class="s0">Log $slave &quot;GLOB &gt; $res&quot; NOTICE</span>
    <span class="s0">return $res</span>
<span class="s0">}</span>

<span class="s0"># AliasSource is the target of the &quot;source&quot; alias in safe interpreters.</span>

<span class="s0">proc ::safe::AliasSource {slave args} {</span>
    <span class="s0">set argc [llength $args]</span>
    <span class="s0"># Extended for handling of Tcl Modules to allow not only &quot;source</span>
    <span class="s0"># filename&quot;, but &quot;source -encoding E filename&quot; as well.</span>
    <span class="s0">if {[lindex $args 0] eq &quot;-encoding&quot;} {</span>
	<span class="s0">incr argc -2</span>
	<span class="s0">set encoding [lindex $args 1]</span>
	<span class="s0">set at 2</span>
	<span class="s0">if {$encoding eq &quot;identity&quot;} {</span>
	    <span class="s0">Log $slave &quot;attempt to use the identity encoding&quot;</span>
	    <span class="s0">return -code error &quot;permission denied&quot;</span>
	<span class="s0">}</span>
    <span class="s0">} else {</span>
	<span class="s0">set at 0</span>
	<span class="s0">set encoding {}</span>
    <span class="s0">}</span>
    <span class="s0">if {$argc != 1} {</span>
	<span class="s0">set msg &quot;wrong # args: should be \&quot;source ?-encoding E? fileName\&quot;&quot;</span>
	<span class="s0">Log $slave &quot;$msg ($args)&quot;</span>
	<span class="s0">return -code error $msg</span>
    <span class="s0">}</span>
    <span class="s0">set file [lindex $args $at]</span>

    <span class="s0"># get the real path from the virtual one.</span>
    <span class="s0">if {[catch {</span>
	<span class="s0">set realfile [TranslatePath $slave $file]</span>
    <span class="s0">} msg]} {</span>
	<span class="s0">Log $slave $msg</span>
	<span class="s0">return -code error &quot;permission denied&quot;</span>
    <span class="s0">}</span>

    <span class="s0"># check that the path is in the access path of that slave</span>
    <span class="s0">if {[catch {</span>
	<span class="s0">FileInAccessPath $slave $realfile</span>
    <span class="s0">} msg]} {</span>
	<span class="s0">Log $slave $msg</span>
	<span class="s0">return -code error &quot;permission denied&quot;</span>
    <span class="s0">}</span>

    <span class="s0"># do the checks on the filename :</span>
    <span class="s0">if {[catch {</span>
	<span class="s0">CheckFileName $slave $realfile</span>
    <span class="s0">} msg]} {</span>
	<span class="s0">Log $slave &quot;$realfile:$msg&quot;</span>
	<span class="s0">return -code error $msg</span>
    <span class="s0">}</span>

    <span class="s0"># Passed all the tests, lets source it. Note that we do this all manually</span>
    <span class="s0"># because we want to control [info script] in the slave so information</span>
    <span class="s0"># doesn't leak so much. [Bug 2913625]</span>
    <span class="s0">set old [::interp eval $slave {info script}]</span>
    <span class="s0">set replacementMsg &quot;script error&quot;</span>
    <span class="s0">set code [catch {</span>
	<span class="s0">set f [open $realfile]</span>
	<span class="s0">fconfigure $f -eofchar \032</span>
	<span class="s0">if {$encoding ne &quot;&quot;} {</span>
	    <span class="s0">fconfigure $f -encoding $encoding</span>
	<span class="s0">}</span>
	<span class="s0">set contents [read $f]</span>
	<span class="s0">close $f</span>
	<span class="s0">::interp eval $slave [list info script $file]</span>
    <span class="s0">} msg opt]</span>
    <span class="s0">if {$code == 0} {</span>
	<span class="s0">set code [catch {::interp eval $slave $contents} msg opt]</span>
	<span class="s0">set replacementMsg $msg</span>
    <span class="s0">}</span>
    <span class="s0">catch {interp eval $slave [list info script $old]}</span>
    <span class="s0"># Note that all non-errors are fine result codes from [source], so we must</span>
    <span class="s0"># take a little care to do it properly. [Bug 2923613]</span>
    <span class="s0">if {$code == 1} {</span>
	<span class="s0">Log $slave $msg</span>
	<span class="s0">return -code error $replacementMsg</span>
    <span class="s0">}</span>
    <span class="s0">return -code $code -options $opt $msg</span>
<span class="s0">}</span>

<span class="s0"># AliasLoad is the target of the &quot;load&quot; alias in safe interpreters.</span>

<span class="s0">proc ::safe::AliasLoad {slave file args} {</span>
    <span class="s0">set argc [llength $args]</span>
    <span class="s0">if {$argc &gt; 2} {</span>
	<span class="s0">set msg &quot;load error: too many arguments&quot;</span>
	<span class="s0">Log $slave &quot;$msg ($argc) {$file $args}&quot;</span>
	<span class="s0">return -code error $msg</span>
    <span class="s0">}</span>

    <span class="s0"># package name (can be empty if file is not).</span>
    <span class="s0">set package [lindex $args 0]</span>

    <span class="s0">namespace upvar ::safe S$slave state</span>

    <span class="s0"># Determine where to load. load use a relative interp path and {}</span>
    <span class="s0"># means self, so we can directly and safely use passed arg.</span>
    <span class="s0">set target [lindex $args 1]</span>
    <span class="s0">if {$target ne &quot;&quot;} {</span>
	<span class="s0"># we will try to load into a sub sub interp; check that we want to</span>
	<span class="s0"># authorize that.</span>
	<span class="s0">if {!$state(nestedok)} {</span>
	    <span class="s0">Log $slave &quot;loading to a sub interp (nestedok)\</span>
			<span class="s0">disabled (trying to load $package to $target)&quot;</span>
	    <span class="s0">return -code error &quot;permission denied (nested load)&quot;</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0"># Determine what kind of load is requested</span>
    <span class="s0">if {$file eq &quot;&quot;} {</span>
	<span class="s0"># static package loading</span>
	<span class="s0">if {$package eq &quot;&quot;} {</span>
	    <span class="s0">set msg &quot;load error: empty filename and no package name&quot;</span>
	    <span class="s0">Log $slave $msg</span>
	    <span class="s0">return -code error $msg</span>
	<span class="s0">}</span>
	<span class="s0">if {!$state(staticsok)} {</span>
	    <span class="s0">Log $slave &quot;static packages loading disabled\</span>
			<span class="s0">(trying to load $package to $target)&quot;</span>
	    <span class="s0">return -code error &quot;permission denied (static package)&quot;</span>
	<span class="s0">}</span>
    <span class="s0">} else {</span>
	<span class="s0"># file loading</span>

	<span class="s0"># get the real path from the virtual one.</span>
	<span class="s0">try {</span>
	    <span class="s0">set file [TranslatePath $slave $file]</span>
	<span class="s0">} on error msg {</span>
	    <span class="s0">Log $slave $msg</span>
	    <span class="s0">return -code error &quot;permission denied&quot;</span>
	<span class="s0">}</span>

	<span class="s0"># check the translated path</span>
	<span class="s0">try {</span>
	    <span class="s0">FileInAccessPath $slave $file</span>
	<span class="s0">} on error msg {</span>
	    <span class="s0">Log $slave $msg</span>
	    <span class="s0">return -code error &quot;permission denied (path)&quot;</span>
	<span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">try {</span>
	<span class="s0">return [::interp invokehidden $slave load $file $package $target]</span>
    <span class="s0">} on error msg {</span>
	<span class="s0">Log $slave $msg</span>
	<span class="s0">return -code error $msg</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0"># FileInAccessPath raises an error if the file is not found in the list of</span>
<span class="s0"># directories contained in the (master side recorded) slave's access path.</span>

<span class="s0"># the security here relies on &quot;file dirname&quot; answering the proper</span>
<span class="s0"># result... needs checking ?</span>
<span class="s0">proc ::safe::FileInAccessPath {slave file} {</span>
    <span class="s0">namespace upvar ::safe S$slave state</span>
    <span class="s0">set access_path $state(access_path)</span>

    <span class="s0">if {[file isdirectory $file]} {</span>
	<span class="s0">return -code error &quot;\&quot;$file\&quot;: is a directory&quot;</span>
    <span class="s0">}</span>
    <span class="s0">set parent [file dirname $file]</span>

    <span class="s0"># Normalize paths for comparison since lsearch knows nothing of</span>
    <span class="s0"># potential pathname anomalies.</span>
    <span class="s0">set norm_parent [file normalize $parent]</span>

    <span class="s0">namespace upvar ::safe S$slave state</span>
    <span class="s0">if {$norm_parent ni $state(access_path,norm)} {</span>
	<span class="s0">return -code error &quot;\&quot;$file\&quot;: not in access_path&quot;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">proc ::safe::DirInAccessPath {slave dir} {</span>
    <span class="s0">namespace upvar ::safe S$slave state</span>
    <span class="s0">set access_path $state(access_path)</span>

    <span class="s0">if {[file isfile $dir]} {</span>
	<span class="s0">return -code error &quot;\&quot;$dir\&quot;: is a file&quot;</span>
    <span class="s0">}</span>

    <span class="s0"># Normalize paths for comparison since lsearch knows nothing of</span>
    <span class="s0"># potential pathname anomalies.</span>
    <span class="s0">set norm_dir [file normalize $dir]</span>

    <span class="s0">namespace upvar ::safe S$slave state</span>
    <span class="s0">if {$norm_dir ni $state(access_path,norm)} {</span>
	<span class="s0">return -code error &quot;\&quot;$dir\&quot;: not in access_path&quot;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0"># This procedure is used to report an attempt to use an unsafe member of an</span>
<span class="s0"># ensemble command.</span>

<span class="s0">proc ::safe::BadSubcommand {slave command subcommand args} {</span>
    <span class="s0">set msg &quot;not allowed to invoke subcommand $subcommand of $command&quot;</span>
    <span class="s0">Log $slave $msg</span>
    <span class="s0">return -code error -errorcode {TCL SAFE SUBCOMMAND} $msg</span>
<span class="s0">}</span>

<span class="s0"># AliasEncoding is the target of the &quot;encoding&quot; alias in safe interpreters.</span>

<span class="s0">proc ::safe::AliasEncoding {slave option args} {</span>
    <span class="s0"># Note that [encoding dirs] is not supported in safe slaves at all</span>
    <span class="s0">set subcommands {convertfrom convertto names system}</span>
    <span class="s0">try {</span>
	<span class="s0">set option [tcl::prefix match -error [list -level 1 -errorcode \</span>
		<span class="s0">[list TCL LOOKUP INDEX option $option]] $subcommands $option]</span>
	<span class="s0"># Special case: [encoding system] ok, but [encoding system foo] not</span>
	<span class="s0">if {$option eq &quot;system&quot; &amp;&amp; [llength $args]} {</span>
	    <span class="s0">return -code error -errorcode {TCL WRONGARGS} \</span>
		<span class="s0">&quot;wrong # args: should be \&quot;encoding system\&quot;&quot;</span>
	<span class="s0">}</span>
    <span class="s0">} on error {msg options} {</span>
	<span class="s0">Log $slave $msg</span>
	<span class="s0">return -options $options $msg</span>
    <span class="s0">}</span>
    <span class="s0">tailcall ::interp invokehidden $slave encoding $option {*}$args</span>
<span class="s0">}</span>

<span class="s0"># Various minor hiding of platform features. [Bug 2913625]</span>

<span class="s0">proc ::safe::AliasExeName {slave} {</span>
    <span class="s0">return &quot;&quot;</span>
<span class="s0">}</span>

<span class="s0">proc ::safe::Setup {} {</span>
    <span class="s0">####</span>
    <span class="s0">#</span>
    <span class="s0"># Setup the arguments parsing</span>
    <span class="s0">#</span>
    <span class="s0">####</span>

    <span class="s0"># Share the descriptions</span>
    <span class="s0">set temp [::tcl::OptKeyRegister {</span>
	<span class="s0">{-accessPath -list {} &quot;access path for the slave&quot;}</span>
	<span class="s0">{-noStatics &quot;prevent loading of statically linked pkgs&quot;}</span>
	<span class="s0">{-statics true &quot;loading of statically linked pkgs&quot;}</span>
	<span class="s0">{-nestedLoadOk &quot;allow nested loading&quot;}</span>
	<span class="s0">{-nested false &quot;nested loading&quot;}</span>
	<span class="s0">{-deleteHook -script {} &quot;delete hook&quot;}</span>
    <span class="s0">}]</span>

    <span class="s0"># create case (slave is optional)</span>
    <span class="s0">::tcl::OptKeyRegister {</span>
	<span class="s0">{?slave? -name {} &quot;name of the slave (optional)&quot;}</span>
    <span class="s0">} ::safe::interpCreate</span>

    <span class="s0"># adding the flags sub programs to the command program (relying on Opt's</span>
    <span class="s0"># internal implementation details)</span>
    <span class="s0">lappend ::tcl::OptDesc(::safe::interpCreate) $::tcl::OptDesc($temp)</span>

    <span class="s0"># init and configure (slave is needed)</span>
    <span class="s0">::tcl::OptKeyRegister {</span>
	<span class="s0">{slave -name {} &quot;name of the slave&quot;}</span>
    <span class="s0">} ::safe::interpIC</span>

    <span class="s0"># adding the flags sub programs to the command program (relying on Opt's</span>
    <span class="s0"># internal implementation details)</span>
    <span class="s0">lappend ::tcl::OptDesc(::safe::interpIC) $::tcl::OptDesc($temp)</span>

    <span class="s0"># temp not needed anymore</span>
    <span class="s0">::tcl::OptKeyDelete $temp</span>

    <span class="s0">####</span>
    <span class="s0">#</span>
    <span class="s0"># Default: No logging.</span>
    <span class="s0">#</span>
    <span class="s0">####</span>

    <span class="s0">setLogCmd {}</span>

    <span class="s0"># Log eventually.</span>
    <span class="s0"># To enable error logging, set Log to {puts stderr} for instance,</span>
    <span class="s0"># via setLogCmd.</span>
    <span class="s0">return</span>
<span class="s0">}</span>

<span class="s0">namespace eval ::safe {</span>
    <span class="s0"># internal variables</span>

    <span class="s0"># Log command, set via 'setLogCmd'. Logging is disabled when empty.</span>
    <span class="s0">variable Log {}</span>

    <span class="s0"># The package maintains a state array per slave interp under its</span>
    <span class="s0"># control. The name of this array is S&lt;interp-name&gt;. This array is</span>
    <span class="s0"># brought into scope where needed, using 'namespace upvar'. The S</span>
    <span class="s0"># prefix is used to avoid that a slave interp called &quot;Log&quot; smashes</span>
    <span class="s0"># the &quot;Log&quot; variable.</span>
    <span class="s0">#</span>
    <span class="s0"># The array's elements are:</span>
    <span class="s0">#</span>
    <span class="s0"># access_path       : List of paths accessible to the slave.</span>
    <span class="s0"># access_path,norm  : Ditto, in normalized form.</span>
    <span class="s0"># access_path,slave : Ditto, as the path tokens as seen by the slave.</span>
    <span class="s0"># access_path,map   : dict ( token -&gt; path )</span>
    <span class="s0"># access_path,remap : dict ( path -&gt; token )</span>
    <span class="s0"># tm_path_slave     : List of TM root directories, as tokens seen by the slave.</span>
    <span class="s0"># staticsok         : Value of option -statics</span>
    <span class="s0"># nestedok          : Value of option -nested</span>
    <span class="s0"># cleanupHook       : Value of option -deleteHook</span>
<span class="s0">}</span>

<span class="s0">::safe::Setup</span>
</pre>
</body>
</html>