<html>
<head>
<title>lock_tests.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lock_tests.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Various tests for synchronization primitives. 
&quot;&quot;&quot;</span>
<span class="s2"># pylint:disable=no-member,abstract-method</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">thread </span><span class="s3">import </span><span class="s1">start_new_thread</span><span class="s3">, </span><span class="s1">get_ident</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">from </span><span class="s1">_thread </span><span class="s3">import </span><span class="s1">start_new_thread</span><span class="s3">, </span><span class="s1">get_ident</span>
<span class="s3">import </span><span class="s1">threading</span>
<span class="s3">import </span><span class="s1">unittest</span>

<span class="s3">from </span><span class="s1">gevent.testing </span><span class="s3">import </span><span class="s1">support</span>
<span class="s3">from </span><span class="s1">gevent.testing.testcase </span><span class="s3">import </span><span class="s1">TimeAssertMixin</span>

<span class="s3">def </span><span class="s1">_wait():</span>
    <span class="s2"># A crude wait/yield function not relying on synchronization primitives.</span>
    <span class="s1">time.sleep(</span><span class="s4">0.01</span><span class="s1">)</span>

<span class="s3">class </span><span class="s1">Bunch(object):</span>
    <span class="s0">&quot;&quot;&quot; 
    A bunch of threads. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">wait_before_exit=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a bunch of `n` threads running the same function `f`. 
        If `wait_before_exit` is True, the threads won't terminate until 
        do_finish() is called. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.f = f</span>
        <span class="s1">self.n = n</span>
        <span class="s1">self.started = []</span>
        <span class="s1">self.finished = []</span>
        <span class="s1">self._can_exit = </span><span class="s3">not </span><span class="s1">wait_before_exit</span>
        <span class="s3">def </span><span class="s1">task():</span>
            <span class="s1">tid = get_ident()</span>
            <span class="s1">self.started.append(tid)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">f()</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s1">self.finished.append(tid)</span>
                <span class="s3">while not </span><span class="s1">self._can_exit:</span>
                    <span class="s1">_wait()</span>
        <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(n):</span>
            <span class="s1">start_new_thread(task</span><span class="s3">, </span><span class="s1">())</span>

    <span class="s3">def </span><span class="s1">wait_for_started(self):</span>
        <span class="s3">while </span><span class="s1">len(self.started) &lt; self.n:</span>
            <span class="s1">_wait()</span>

    <span class="s3">def </span><span class="s1">wait_for_finished(self):</span>
        <span class="s3">while </span><span class="s1">len(self.finished) &lt; self.n:</span>
            <span class="s1">_wait()</span>

    <span class="s3">def </span><span class="s1">do_finish(self):</span>
        <span class="s1">self._can_exit = </span><span class="s3">True</span>


<span class="s3">class </span><span class="s1">BaseTestCase(TimeAssertMixin</span><span class="s3">, </span><span class="s1">unittest.TestCase):</span>
    <span class="s3">def </span><span class="s1">setUp(self):</span>
        <span class="s1">self._threads = support.threading_setup()</span>

    <span class="s3">def </span><span class="s1">tearDown(self):</span>
        <span class="s1">support.threading_cleanup(*self._threads)</span>
        <span class="s1">support.reap_children()</span>


<span class="s3">class </span><span class="s1">BaseLockTests(BaseTestCase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests for both recursive and non-recursive locks. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">locktype(self):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">test_constructor(self):</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s3">del </span><span class="s1">lock</span>

    <span class="s3">def </span><span class="s1">test_acquire_destroy(self):</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s1">lock.acquire()</span>
        <span class="s3">del </span><span class="s1">lock</span>

    <span class="s3">def </span><span class="s1">test_acquire_release(self):</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s1">lock.acquire()</span>
        <span class="s1">lock.release()</span>
        <span class="s3">del </span><span class="s1">lock</span>

    <span class="s3">def </span><span class="s1">test_try_acquire(self):</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s1">self.assertTrue(lock.acquire(</span><span class="s3">False</span><span class="s1">))</span>
        <span class="s1">lock.release()</span>

    <span class="s3">def </span><span class="s1">test_try_acquire_contended(self):</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s1">lock.acquire()</span>
        <span class="s1">result = []</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">result.append(lock.acquire(</span><span class="s3">False</span><span class="s1">))</span>
        <span class="s1">Bunch(f</span><span class="s3">, </span><span class="s4">1</span><span class="s1">).wait_for_finished()</span>
        <span class="s1">self.assertFalse(result[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">lock.release()</span>

    <span class="s3">def </span><span class="s1">test_acquire_contended(self):</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s1">lock.acquire()</span>
        <span class="s1">N = </span><span class="s4">5</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">lock.acquire()</span>
            <span class="s1">lock.release()</span>

        <span class="s1">b = Bunch(f</span><span class="s3">, </span><span class="s1">N)</span>
        <span class="s1">b.wait_for_started()</span>
        <span class="s1">_wait()</span>
        <span class="s1">self.assertEqual(len(b.finished)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">lock.release()</span>
        <span class="s1">b.wait_for_finished()</span>
        <span class="s1">self.assertEqual(len(b.finished)</span><span class="s3">, </span><span class="s1">N)</span>

    <span class="s3">def </span><span class="s1">test_with(self):</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">lock.acquire()</span>
            <span class="s1">lock.release()</span>
        <span class="s3">def </span><span class="s1">_with(err=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">with </span><span class="s1">lock:</span>
                <span class="s3">if </span><span class="s1">err </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">err </span><span class="s2"># pylint:disable=raising-bad-type</span>
        <span class="s1">_with()</span>
        <span class="s2"># Check the lock is unacquired</span>
        <span class="s1">Bunch(f</span><span class="s3">, </span><span class="s4">1</span><span class="s1">).wait_for_finished()</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s3">, </span><span class="s1">_with</span><span class="s3">, </span><span class="s1">TypeError)</span>
        <span class="s2"># Check the lock is unacquired</span>
        <span class="s1">Bunch(f</span><span class="s3">, </span><span class="s4">1</span><span class="s1">).wait_for_finished()</span>

    <span class="s3">def </span><span class="s1">test_thread_leak(self):</span>
        <span class="s2"># The lock shouldn't leak a Thread instance when used from a foreign</span>
        <span class="s2"># (non-threading) thread.</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">lock.acquire()</span>
            <span class="s1">lock.release()</span>
        <span class="s1">n = len(threading.enumerate())</span>
        <span class="s2"># We run many threads in the hope that existing threads ids won't</span>
        <span class="s2"># be recycled.</span>
        <span class="s1">Bunch(f</span><span class="s3">, </span><span class="s4">15</span><span class="s1">).wait_for_finished()</span>
        <span class="s1">self.assertEqual(n</span><span class="s3">, </span><span class="s1">len(threading.enumerate()))</span>


<span class="s3">class </span><span class="s1">LockTests(BaseLockTests): </span><span class="s2"># pylint:disable=abstract-method</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests for non-recursive, weak locks 
    (which can be acquired and released from different threads). 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">test_reacquire(self):</span>
        <span class="s2"># Lock needs to be released before re-acquiring.</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s1">phase = []</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">lock.acquire()</span>
            <span class="s1">phase.append(</span><span class="s3">None</span><span class="s1">)</span>
            <span class="s1">lock.acquire()</span>
            <span class="s1">phase.append(</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">start_new_thread(f</span><span class="s3">, </span><span class="s1">())</span>
        <span class="s3">while not </span><span class="s1">phase:</span>
            <span class="s1">_wait()</span>
        <span class="s1">_wait()</span>
        <span class="s1">self.assertEqual(len(phase)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">lock.release()</span>
        <span class="s3">while </span><span class="s1">len(phase) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">_wait()</span>
        <span class="s1">self.assertEqual(len(phase)</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_different_thread(self):</span>
        <span class="s2"># Lock can be released from a different thread.</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s1">lock.acquire()</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">lock.release()</span>
        <span class="s1">b = Bunch(f</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">b.wait_for_finished()</span>
        <span class="s1">lock.acquire()</span>
        <span class="s1">lock.release()</span>


<span class="s3">class </span><span class="s1">RLockTests(BaseLockTests):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests for recursive locks. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">test_reacquire(self):</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s1">lock.acquire()</span>
        <span class="s1">lock.acquire()</span>
        <span class="s1">lock.release()</span>
        <span class="s1">lock.acquire()</span>
        <span class="s1">lock.release()</span>
        <span class="s1">lock.release()</span>

    <span class="s3">def </span><span class="s1">test_release_unacquired(self):</span>
        <span class="s2"># Cannot release an unacquired lock</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s1">self.assertRaises(RuntimeError</span><span class="s3">, </span><span class="s1">lock.release)</span>
        <span class="s1">lock.acquire()</span>
        <span class="s1">lock.acquire()</span>
        <span class="s1">lock.release()</span>
        <span class="s1">lock.acquire()</span>
        <span class="s1">lock.release()</span>
        <span class="s1">lock.release()</span>
        <span class="s1">self.assertRaises(RuntimeError</span><span class="s3">, </span><span class="s1">lock.release)</span>

    <span class="s3">def </span><span class="s1">test_different_thread(self):</span>
        <span class="s2"># Cannot release from a different thread</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">lock.acquire()</span>
        <span class="s1">b = Bunch(f</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, True</span><span class="s1">)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.assertRaises(RuntimeError</span><span class="s3">, </span><span class="s1">lock.release)</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">b.do_finish()</span>

    <span class="s3">def </span><span class="s1">test__is_owned(self):</span>
        <span class="s1">lock = self.locktype()</span>
        <span class="s1">self.assertFalse(lock._is_owned())</span>
        <span class="s1">lock.acquire()</span>
        <span class="s1">self.assertTrue(lock._is_owned())</span>
        <span class="s1">lock.acquire()</span>
        <span class="s1">self.assertTrue(lock._is_owned())</span>
        <span class="s1">result = []</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">result.append(lock._is_owned())</span>
        <span class="s1">Bunch(f</span><span class="s3">, </span><span class="s4">1</span><span class="s1">).wait_for_finished()</span>
        <span class="s1">self.assertFalse(result[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">lock.release()</span>
        <span class="s1">self.assertTrue(lock._is_owned())</span>
        <span class="s1">lock.release()</span>
        <span class="s1">self.assertFalse(lock._is_owned())</span>


<span class="s3">class </span><span class="s1">EventTests(BaseTestCase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests for Event objects. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">eventtype(self):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">test_is_set(self):</span>
        <span class="s1">evt = self.eventtype()</span>
        <span class="s1">self.assertFalse(evt.is_set())</span>
        <span class="s1">evt.set()</span>
        <span class="s1">self.assertTrue(evt.is_set())</span>
        <span class="s1">evt.set()</span>
        <span class="s1">self.assertTrue(evt.is_set())</span>
        <span class="s1">evt.clear()</span>
        <span class="s1">self.assertFalse(evt.is_set())</span>
        <span class="s1">evt.clear()</span>
        <span class="s1">self.assertFalse(evt.is_set())</span>

    <span class="s3">def </span><span class="s1">_check_notify(self</span><span class="s3">, </span><span class="s1">evt):</span>
        <span class="s2"># All threads get notified</span>
        <span class="s1">N = </span><span class="s4">5</span>
        <span class="s1">results1 = []</span>
        <span class="s1">results2 = []</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">evt.wait()</span>
            <span class="s1">results1.append(evt.is_set())</span>
            <span class="s1">evt.wait()</span>
            <span class="s1">results2.append(evt.is_set())</span>
        <span class="s1">b = Bunch(f</span><span class="s3">, </span><span class="s1">N)</span>
        <span class="s1">b.wait_for_started()</span>
        <span class="s1">_wait()</span>
        <span class="s1">self.assertEqual(len(results1)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">evt.set()</span>
        <span class="s1">b.wait_for_finished()</span>
        <span class="s1">self.assertEqual(results1</span><span class="s3">, </span><span class="s1">[</span><span class="s3">True</span><span class="s1">] * N)</span>
        <span class="s1">self.assertEqual(results2</span><span class="s3">, </span><span class="s1">[</span><span class="s3">True</span><span class="s1">] * N)</span>

    <span class="s3">def </span><span class="s1">test_notify(self):</span>
        <span class="s1">evt = self.eventtype()</span>
        <span class="s1">self._check_notify(evt)</span>
        <span class="s2"># Another time, after an explicit clear()</span>
        <span class="s1">evt.set()</span>
        <span class="s1">evt.clear()</span>
        <span class="s1">self._check_notify(evt)</span>

    <span class="s3">def </span><span class="s1">test_timeout(self):</span>
        <span class="s1">evt = self.eventtype()</span>
        <span class="s1">results1 = []</span>
        <span class="s1">results2 = []</span>
        <span class="s1">N = </span><span class="s4">5</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">evt.wait(</span><span class="s4">0.0</span><span class="s1">)</span>
            <span class="s1">results1.append(evt.is_set())</span>
            <span class="s1">t1 = time.time()</span>
            <span class="s1">evt.wait(</span><span class="s4">0.2</span><span class="s1">)</span>
            <span class="s1">r = evt.is_set()</span>
            <span class="s1">t2 = time.time()</span>
            <span class="s1">results2.append((r</span><span class="s3">, </span><span class="s1">t2 - t1))</span>
        <span class="s1">Bunch(f</span><span class="s3">, </span><span class="s1">N).wait_for_finished()</span>
        <span class="s1">self.assertEqual(results1</span><span class="s3">, </span><span class="s1">[</span><span class="s3">False</span><span class="s1">] * N)</span>
        <span class="s3">for </span><span class="s1">r</span><span class="s3">, </span><span class="s1">dt </span><span class="s3">in </span><span class="s1">results2:</span>
            <span class="s1">self.assertFalse(r)</span>
            <span class="s1">self.assertTimeWithinRange(dt</span><span class="s3">, </span><span class="s4">0.18</span><span class="s3">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s2"># The event is set</span>
        <span class="s1">results1 = []</span>
        <span class="s1">results2 = []</span>
        <span class="s1">evt.set()</span>
        <span class="s1">Bunch(f</span><span class="s3">, </span><span class="s1">N).wait_for_finished()</span>
        <span class="s1">self.assertEqual(results1</span><span class="s3">, </span><span class="s1">[</span><span class="s3">True</span><span class="s1">] * N)</span>
        <span class="s3">for </span><span class="s1">r</span><span class="s3">, </span><span class="s1">dt </span><span class="s3">in </span><span class="s1">results2:</span>
            <span class="s1">self.assertTrue(r)</span>


<span class="s3">class </span><span class="s1">ConditionTests(BaseTestCase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests for condition variables. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">condtype(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">test_acquire(self):</span>
        <span class="s1">cond = self.condtype()</span>
        <span class="s2"># Be default we have an RLock: the condition can be acquired multiple</span>
        <span class="s2"># times.</span>
        <span class="s2"># pylint:disable=consider-using-with</span>
        <span class="s1">cond.acquire()</span>
        <span class="s1">cond.acquire()</span>
        <span class="s1">cond.release()</span>
        <span class="s1">cond.release()</span>
        <span class="s1">lock = threading.Lock()</span>
        <span class="s1">cond = self.condtype(lock)</span>
        <span class="s1">cond.acquire()</span>
        <span class="s1">self.assertFalse(lock.acquire(</span><span class="s3">False</span><span class="s1">))</span>
        <span class="s1">cond.release()</span>
        <span class="s1">self.assertTrue(lock.acquire(</span><span class="s3">False</span><span class="s1">))</span>
        <span class="s1">self.assertFalse(cond.acquire(</span><span class="s3">False</span><span class="s1">))</span>
        <span class="s1">lock.release()</span>
        <span class="s3">with </span><span class="s1">cond:</span>
            <span class="s1">self.assertFalse(lock.acquire(</span><span class="s3">False</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_unacquired_wait(self):</span>
        <span class="s1">cond = self.condtype()</span>
        <span class="s1">self.assertRaises(RuntimeError</span><span class="s3">, </span><span class="s1">cond.wait)</span>

    <span class="s3">def </span><span class="s1">test_unacquired_notify(self):</span>
        <span class="s1">cond = self.condtype()</span>
        <span class="s1">self.assertRaises(RuntimeError</span><span class="s3">, </span><span class="s1">cond.notify)</span>

    <span class="s3">def </span><span class="s1">_check_notify(self</span><span class="s3">, </span><span class="s1">cond):</span>
        <span class="s1">N = </span><span class="s4">5</span>
        <span class="s1">results1 = []</span>
        <span class="s1">results2 = []</span>
        <span class="s1">phase_num = </span><span class="s4">0</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">cond.acquire()</span>
            <span class="s1">cond.wait()</span>
            <span class="s1">cond.release()</span>
            <span class="s1">results1.append(phase_num)</span>
            <span class="s1">cond.acquire()</span>
            <span class="s1">cond.wait()</span>
            <span class="s1">cond.release()</span>
            <span class="s1">results2.append(phase_num)</span>
        <span class="s1">b = Bunch(f</span><span class="s3">, </span><span class="s1">N)</span>
        <span class="s1">b.wait_for_started()</span>
        <span class="s1">_wait()</span>
        <span class="s1">self.assertEqual(results1</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s2"># Notify 3 threads at first</span>
        <span class="s1">cond.acquire()</span>
        <span class="s1">cond.notify(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">_wait()</span>
        <span class="s1">phase_num = </span><span class="s4">1</span>
        <span class="s1">cond.release()</span>
        <span class="s3">while </span><span class="s1">len(results1) &lt; </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s1">_wait()</span>
        <span class="s1">self.assertEqual(results1</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">] * </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(results2</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s2"># Notify 5 threads: they might be in their first or second wait</span>
        <span class="s1">cond.acquire()</span>
        <span class="s1">cond.notify(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">_wait()</span>
        <span class="s1">phase_num = </span><span class="s4">2</span>
        <span class="s1">cond.release()</span>
        <span class="s3">while </span><span class="s1">len(results1) + len(results2) &lt; </span><span class="s4">8</span><span class="s1">:</span>
            <span class="s1">_wait()</span>
        <span class="s1">self.assertEqual(results1</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s4">2</span><span class="s1">] * </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(results2</span><span class="s3">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">] * </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s2"># Notify all threads: they are all in their second wait</span>
        <span class="s1">cond.acquire()</span>
        <span class="s1">cond.notify_all()</span>
        <span class="s1">_wait()</span>
        <span class="s1">phase_num = </span><span class="s4">3</span>
        <span class="s1">cond.release()</span>
        <span class="s3">while </span><span class="s1">len(results2) &lt; </span><span class="s4">5</span><span class="s1">:</span>
            <span class="s1">_wait()</span>
        <span class="s1">self.assertEqual(results1</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s4">2</span><span class="s1">] * </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(results2</span><span class="s3">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s4">3</span><span class="s1">] * </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">b.wait_for_finished()</span>

    <span class="s3">def </span><span class="s1">test_notify(self):</span>
        <span class="s1">cond = self.condtype()</span>
        <span class="s1">self._check_notify(cond)</span>
        <span class="s2"># A second time, to check internal state is still ok.</span>
        <span class="s1">self._check_notify(cond)</span>

    <span class="s3">def </span><span class="s1">test_timeout(self):</span>
        <span class="s1">cond = self.condtype()</span>
        <span class="s1">results = []</span>
        <span class="s1">N = </span><span class="s4">5</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">cond.acquire()</span>
            <span class="s1">t1 = time.time()</span>
            <span class="s1">cond.wait(</span><span class="s4">0.2</span><span class="s1">)</span>
            <span class="s1">t2 = time.time()</span>
            <span class="s1">cond.release()</span>
            <span class="s1">results.append(t2 - t1)</span>
        <span class="s1">Bunch(f</span><span class="s3">, </span><span class="s1">N).wait_for_finished()</span>
        <span class="s1">self.assertEqual(len(results)</span><span class="s3">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">dt </span><span class="s3">in </span><span class="s1">results:</span>
            <span class="s2"># XXX: libuv sometimes produces 0.19958</span>
            <span class="s1">self.assertTimeWithinRange(dt</span><span class="s3">, </span><span class="s4">0.19</span><span class="s3">, </span><span class="s4">2.0</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">BaseSemaphoreTests(BaseTestCase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Common tests for {bounded, unbounded} semaphore objects. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">semtype(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">test_constructor(self):</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">self.semtype</span><span class="s3">, </span><span class="s1">value=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2"># Py3 doesn't have sys.maxint</span>
        <span class="s1">self.assertRaises((ValueError</span><span class="s3">, </span><span class="s1">OverflowError)</span><span class="s3">, </span><span class="s1">self.semtype</span><span class="s3">,</span>
                          <span class="s1">value=-getattr(sys</span><span class="s3">, </span><span class="s5">'maxint'</span><span class="s3">, </span><span class="s1">getattr(sys</span><span class="s3">, </span><span class="s5">'maxsize'</span><span class="s3">, None</span><span class="s1">)))</span>

    <span class="s3">def </span><span class="s1">test_acquire(self):</span>
        <span class="s1">sem = self.semtype(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">sem.acquire()</span>
        <span class="s1">sem.release()</span>
        <span class="s1">sem = self.semtype(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">sem.acquire()</span>
        <span class="s1">sem.acquire()</span>
        <span class="s1">sem.release()</span>
        <span class="s1">sem.release()</span>

    <span class="s3">def </span><span class="s1">test_acquire_destroy(self):</span>
        <span class="s1">sem = self.semtype()</span>
        <span class="s1">sem.acquire()</span>
        <span class="s3">del </span><span class="s1">sem</span>

    <span class="s3">def </span><span class="s1">test_acquire_contended(self):</span>
        <span class="s1">sem = self.semtype(</span><span class="s4">7</span><span class="s1">)</span>
        <span class="s1">sem.acquire()</span>
        <span class="s2">#N = 10</span>
        <span class="s1">results1 = []</span>
        <span class="s1">results2 = []</span>
        <span class="s1">phase_num = </span><span class="s4">0</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">sem.acquire()</span>
            <span class="s1">results1.append(phase_num)</span>
            <span class="s1">sem.acquire()</span>
            <span class="s1">results2.append(phase_num)</span>
        <span class="s1">b = Bunch(f</span><span class="s3">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">b.wait_for_started()</span>
        <span class="s3">while </span><span class="s1">len(results1) + len(results2) &lt; </span><span class="s4">6</span><span class="s1">:</span>
            <span class="s1">_wait()</span>
        <span class="s1">self.assertEqual(results1 + results2</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">phase_num = </span><span class="s4">1</span>
        <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">7</span><span class="s1">):</span>
            <span class="s1">sem.release()</span>
        <span class="s3">while </span><span class="s1">len(results1) + len(results2) &lt; </span><span class="s4">13</span><span class="s1">:</span>
            <span class="s1">_wait()</span>
        <span class="s1">self.assertEqual(sorted(results1 + results2)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">6 </span><span class="s1">+ [</span><span class="s4">1</span><span class="s1">] * </span><span class="s4">7</span><span class="s1">)</span>
        <span class="s1">phase_num = </span><span class="s4">2</span>
        <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">6</span><span class="s1">):</span>
            <span class="s1">sem.release()</span>
        <span class="s3">while </span><span class="s1">len(results1) + len(results2) &lt; </span><span class="s4">19</span><span class="s1">:</span>
            <span class="s1">_wait()</span>
        <span class="s1">self.assertEqual(sorted(results1 + results2)</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">6 </span><span class="s1">+ [</span><span class="s4">1</span><span class="s1">] * </span><span class="s4">7 </span><span class="s1">+ [</span><span class="s4">2</span><span class="s1">] * </span><span class="s4">6</span><span class="s1">)</span>
        <span class="s2"># The semaphore is still locked</span>
        <span class="s1">self.assertFalse(sem.acquire(</span><span class="s3">False</span><span class="s1">))</span>
        <span class="s2"># Final release, to let the last thread finish</span>
        <span class="s1">sem.release()</span>
        <span class="s1">b.wait_for_finished()</span>

    <span class="s3">def </span><span class="s1">test_try_acquire(self):</span>
        <span class="s1">sem = self.semtype(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(sem.acquire(</span><span class="s3">False</span><span class="s1">))</span>
        <span class="s1">self.assertTrue(sem.acquire(</span><span class="s3">False</span><span class="s1">))</span>
        <span class="s1">self.assertFalse(sem.acquire(</span><span class="s3">False</span><span class="s1">))</span>
        <span class="s1">sem.release()</span>
        <span class="s1">self.assertTrue(sem.acquire(</span><span class="s3">False</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_try_acquire_contended(self):</span>
        <span class="s1">sem = self.semtype(</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">sem.acquire()</span>
        <span class="s1">results = []</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">results.append(sem.acquire(</span><span class="s3">False</span><span class="s1">))</span>
            <span class="s1">results.append(sem.acquire(</span><span class="s3">False</span><span class="s1">))</span>
        <span class="s1">Bunch(f</span><span class="s3">, </span><span class="s4">5</span><span class="s1">).wait_for_finished()</span>
        <span class="s2"># There can be a thread switch between acquiring the semaphore and</span>
        <span class="s2"># appending the result, therefore results will not necessarily be</span>
        <span class="s2"># ordered.</span>
        <span class="s1">self.assertEqual(sorted(results)</span><span class="s3">, </span><span class="s1">[</span><span class="s3">False</span><span class="s1">] * </span><span class="s4">7 </span><span class="s1">+ [</span><span class="s3">True</span><span class="s1">] *  </span><span class="s4">3</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_default_value(self):</span>
        <span class="s2"># The default initial value is 1.</span>
        <span class="s1">sem = self.semtype()</span>
        <span class="s1">sem.acquire()</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">sem.acquire()</span>
            <span class="s1">sem.release()</span>
        <span class="s1">b = Bunch(f</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">b.wait_for_started()</span>
        <span class="s1">_wait()</span>
        <span class="s1">self.assertFalse(b.finished)</span>
        <span class="s1">sem.release()</span>
        <span class="s1">b.wait_for_finished()</span>

    <span class="s3">def </span><span class="s1">test_with(self):</span>
        <span class="s1">sem = self.semtype(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s3">def </span><span class="s1">_with(err=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">with </span><span class="s1">sem:</span>
                <span class="s1">self.assertTrue(sem.acquire(</span><span class="s3">False</span><span class="s1">))</span>
                <span class="s1">sem.release()</span>
                <span class="s3">with </span><span class="s1">sem:</span>
                    <span class="s1">self.assertFalse(sem.acquire(</span><span class="s3">False</span><span class="s1">))</span>
                    <span class="s3">if </span><span class="s1">err:</span>
                        <span class="s3">raise </span><span class="s1">err </span><span class="s2"># pylint:disable=raising-bad-type</span>
        <span class="s1">_with()</span>
        <span class="s1">self.assertTrue(sem.acquire(</span><span class="s3">False</span><span class="s1">))</span>
        <span class="s1">sem.release()</span>
        <span class="s1">self.assertRaises(TypeError</span><span class="s3">, </span><span class="s1">_with</span><span class="s3">, </span><span class="s1">TypeError)</span>
        <span class="s1">self.assertTrue(sem.acquire(</span><span class="s3">False</span><span class="s1">))</span>
        <span class="s1">sem.release()</span>

<span class="s3">class </span><span class="s1">SemaphoreTests(BaseSemaphoreTests):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests for unbounded semaphores. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">test_release_unacquired(self):</span>
        <span class="s2"># Unbounded releases are allowed and increment the semaphore's value</span>
        <span class="s1">sem = self.semtype(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">sem.release()</span>
        <span class="s1">sem.acquire()</span>
        <span class="s1">sem.acquire()</span>
        <span class="s1">sem.release()</span>


<span class="s3">class </span><span class="s1">BoundedSemaphoreTests(BaseSemaphoreTests):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests for bounded semaphores. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">test_release_unacquired(self):</span>
        <span class="s2"># Cannot go past the initial value</span>
        <span class="s1">sem = self.semtype()</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">sem.release)</span>
        <span class="s1">sem.acquire()</span>
        <span class="s1">sem.release()</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s3">, </span><span class="s1">sem.release)</span>

<span class="s3">class </span><span class="s1">BarrierTests(BaseTestCase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests for Barrier objects. 
    &quot;&quot;&quot;</span>
    <span class="s1">N = </span><span class="s4">5</span>
    <span class="s1">defaultTimeout = </span><span class="s4">2.0</span>

    <span class="s3">def </span><span class="s1">setUp(self):</span>
        <span class="s1">self.barrier = self.barriertype(self.N</span><span class="s3">, </span><span class="s1">timeout=self.defaultTimeout)</span>
    <span class="s3">def </span><span class="s1">tearDown(self):</span>
        <span class="s1">self.barrier.abort()</span>

    <span class="s3">def </span><span class="s1">run_threads(self</span><span class="s3">, </span><span class="s1">f):</span>
        <span class="s1">b = Bunch(f</span><span class="s3">, </span><span class="s1">self.N-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">f()</span>
        <span class="s1">b.wait_for_finished()</span>

    <span class="s3">def </span><span class="s1">multipass(self</span><span class="s3">, </span><span class="s1">results</span><span class="s3">, </span><span class="s1">n):</span>
        <span class="s1">m = self.barrier.parties</span>
        <span class="s1">self.assertEqual(m</span><span class="s3">, </span><span class="s1">self.N)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n):</span>
            <span class="s1">results[</span><span class="s4">0</span><span class="s1">].append(</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(len(results[</span><span class="s4">1</span><span class="s1">])</span><span class="s3">, </span><span class="s1">i * m)</span>
            <span class="s1">self.barrier.wait()</span>
            <span class="s1">results[</span><span class="s4">1</span><span class="s1">].append(</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(len(results[</span><span class="s4">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">(i + </span><span class="s4">1</span><span class="s1">) * m)</span>
            <span class="s1">self.barrier.wait()</span>
        <span class="s1">self.assertEqual(self.barrier.n_waiting</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(self.barrier.broken)</span>

    <span class="s3">def </span><span class="s1">test_barrier(self</span><span class="s3">, </span><span class="s1">passes=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test that a barrier is passed in lockstep 
        &quot;&quot;&quot;</span>
        <span class="s1">results = [[]</span><span class="s3">, </span><span class="s1">[]]</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">self.multipass(results</span><span class="s3">, </span><span class="s1">passes)</span>
        <span class="s1">self.run_threads(f)</span>

    <span class="s3">def </span><span class="s1">test_barrier_10(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test that a barrier works for 10 consecutive runs 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.test_barrier(</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_wait_return(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        test the return value from barrier.wait 
        &quot;&quot;&quot;</span>
        <span class="s1">results = []</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">r = self.barrier.wait()</span>
            <span class="s1">results.append(r)</span>

        <span class="s1">self.run_threads(f)</span>
        <span class="s1">self.assertEqual(sum(results)</span><span class="s3">, </span><span class="s1">sum(range(self.N)))</span>

    <span class="s3">def </span><span class="s1">test_action(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test the 'action' callback 
        &quot;&quot;&quot;</span>
        <span class="s1">results = []</span>
        <span class="s3">def </span><span class="s1">action():</span>
            <span class="s1">results.append(</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">barrier = self.barriertype(self.N</span><span class="s3">, </span><span class="s1">action)</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">barrier.wait()</span>
            <span class="s1">self.assertEqual(len(results)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">self.run_threads(f)</span>

    <span class="s3">def </span><span class="s1">test_abort(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test that an abort will put the barrier in a broken state 
        &quot;&quot;&quot;</span>
        <span class="s1">results1 = []</span>
        <span class="s1">results2 = []</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">i = self.barrier.wait()</span>
                <span class="s3">if </span><span class="s1">i == self.N//</span><span class="s4">2</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">RuntimeError</span>
                <span class="s1">self.barrier.wait()</span>
                <span class="s1">results1.append(</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">threading.BrokenBarrierError:</span>
                <span class="s1">results2.append(</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">RuntimeError:</span>
                <span class="s1">self.barrier.abort()</span>

        <span class="s1">self.run_threads(f)</span>
        <span class="s1">self.assertEqual(len(results1)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(results2)</span><span class="s3">, </span><span class="s1">self.N-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(self.barrier.broken)</span>

    <span class="s3">def </span><span class="s1">test_reset(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test that a 'reset' on a barrier frees the waiting threads 
        &quot;&quot;&quot;</span>
        <span class="s1">results1 = []</span>
        <span class="s1">results2 = []</span>
        <span class="s1">results3 = []</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">i = self.barrier.wait()</span>
            <span class="s3">if </span><span class="s1">i == self.N//</span><span class="s4">2</span><span class="s1">:</span>
                <span class="s2"># Wait until the other threads are all in the barrier.</span>
                <span class="s3">while </span><span class="s1">self.barrier.n_waiting &lt; self.N-</span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">time.sleep(</span><span class="s4">0.001</span><span class="s1">)</span>
                <span class="s1">self.barrier.reset()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">self.barrier.wait()</span>
                    <span class="s1">results1.append(</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s3">except </span><span class="s1">threading.BrokenBarrierError:</span>
                    <span class="s1">results2.append(</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s2"># Now, pass the barrier again</span>
            <span class="s1">self.barrier.wait()</span>
            <span class="s1">results3.append(</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">self.run_threads(f)</span>
        <span class="s1">self.assertEqual(len(results1)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(results2)</span><span class="s3">, </span><span class="s1">self.N-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(results3)</span><span class="s3">, </span><span class="s1">self.N)</span>


    <span class="s3">def </span><span class="s1">test_abort_and_reset(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test that a barrier can be reset after being broken. 
        &quot;&quot;&quot;</span>
        <span class="s1">results1 = []</span>
        <span class="s1">results2 = []</span>
        <span class="s1">results3 = []</span>
        <span class="s1">barrier2 = self.barriertype(self.N)</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">i = self.barrier.wait()</span>
                <span class="s3">if </span><span class="s1">i == self.N//</span><span class="s4">2</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">RuntimeError</span>
                <span class="s1">self.barrier.wait()</span>
                <span class="s1">results1.append(</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">threading.BrokenBarrierError:</span>
                <span class="s1">results2.append(</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">RuntimeError:</span>
                <span class="s1">self.barrier.abort()</span>

            <span class="s2"># Synchronize and reset the barrier.  Must synchronize first so</span>
            <span class="s2"># that everyone has left it when we reset, and after so that no</span>
            <span class="s2"># one enters it before the reset.</span>
            <span class="s3">if </span><span class="s1">barrier2.wait() == self.N//</span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">self.barrier.reset()</span>
            <span class="s1">barrier2.wait()</span>
            <span class="s1">self.barrier.wait()</span>
            <span class="s1">results3.append(</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">self.run_threads(f)</span>
        <span class="s1">self.assertEqual(len(results1)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(results2)</span><span class="s3">, </span><span class="s1">self.N-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(results3)</span><span class="s3">, </span><span class="s1">self.N)</span>

    <span class="s3">def </span><span class="s1">test_timeout(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test wait(timeout) 
        &quot;&quot;&quot;</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">i = self.barrier.wait()</span>
            <span class="s3">if </span><span class="s1">i == self.N // </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s2"># One thread is late!</span>
                <span class="s1">time.sleep(</span><span class="s4">1.0</span><span class="s1">)</span>
            <span class="s2"># Default timeout is 2.0, so this is shorter.</span>
            <span class="s1">self.assertRaises(threading.BrokenBarrierError</span><span class="s3">,</span>
                              <span class="s1">self.barrier.wait</span><span class="s3">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">self.run_threads(f)</span>

    <span class="s3">def </span><span class="s1">test_default_timeout(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test the barrier's default timeout 
        &quot;&quot;&quot;</span>
        <span class="s2"># create a barrier with a low default timeout</span>
        <span class="s1">barrier = self.barriertype(self.N</span><span class="s3">, </span><span class="s1">timeout=</span><span class="s4">0.3</span><span class="s1">)</span>
        <span class="s3">def </span><span class="s1">f():</span>
            <span class="s1">i = barrier.wait()</span>
            <span class="s3">if </span><span class="s1">i == self.N // </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s2"># One thread is later than the default timeout of 0.3s.</span>
                <span class="s1">time.sleep(</span><span class="s4">1.0</span><span class="s1">)</span>
            <span class="s1">self.assertRaises(threading.BrokenBarrierError</span><span class="s3">, </span><span class="s1">barrier.wait)</span>
        <span class="s1">self.run_threads(f)</span>

    <span class="s3">def </span><span class="s1">test_single_thread(self):</span>
        <span class="s1">b = self.barriertype(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">b.wait()</span>
        <span class="s1">b.wait()</span>


<span class="s3">if </span><span class="s1">__name__ == </span><span class="s5">'__main__'</span><span class="s1">:</span>
    <span class="s1">print(</span><span class="s5">&quot;This module contains no tests; it is used by other test cases like test_threading_2&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>