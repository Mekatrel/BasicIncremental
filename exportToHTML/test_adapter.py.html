<html>
<head>
<title>test_adapter.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_adapter.py</font>
</center></td></tr></table>
<pre><span class="s0">##############################################################################</span>
<span class="s0">#</span>
<span class="s0"># Copyright (c) 2003 Zope Foundation and Contributors.</span>
<span class="s0"># All Rights Reserved.</span>
<span class="s0">#</span>
<span class="s0"># This software is subject to the provisions of the Zope Public License,</span>
<span class="s0"># Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY AND ALL EXPRESS OR IMPLIED</span>
<span class="s0"># WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="s0"># WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS</span>
<span class="s0"># FOR A PARTICULAR PURPOSE.</span>
<span class="s0">#</span>
<span class="s0">##############################################################################</span>
<span class="s2">&quot;&quot;&quot;Adapter registry tests 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">unittest</span>

<span class="s3">from </span><span class="s1">zope.interface.tests </span><span class="s3">import </span><span class="s1">OptimizationTestMixin</span>

<span class="s0"># pylint:disable=inherit-non-class,protected-access,too-many-lines</span>
<span class="s0"># pylint:disable=attribute-defined-outside-init,blacklisted-name</span>

<span class="s3">def </span><span class="s1">_makeInterfaces():</span>
    <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>

    <span class="s3">class </span><span class="s1">IB0(Interface):</span>
        <span class="s3">pass</span>
    <span class="s3">class </span><span class="s1">IB1(IB0):</span>
        <span class="s3">pass</span>
    <span class="s3">class </span><span class="s1">IB2(IB0):</span>
        <span class="s3">pass</span>
    <span class="s3">class </span><span class="s1">IB3(IB2</span><span class="s3">, </span><span class="s1">IB1):</span>
        <span class="s3">pass</span>
    <span class="s3">class </span><span class="s1">IB4(IB1</span><span class="s3">, </span><span class="s1">IB2):</span>
        <span class="s3">pass</span>

    <span class="s3">class </span><span class="s1">IF0(Interface):</span>
        <span class="s3">pass</span>
    <span class="s3">class </span><span class="s1">IF1(IF0):</span>
        <span class="s3">pass</span>

    <span class="s3">class </span><span class="s1">IR0(Interface):</span>
        <span class="s3">pass</span>
    <span class="s3">class </span><span class="s1">IR1(IR0):</span>
        <span class="s3">pass</span>

    <span class="s3">return </span><span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1</span>


<span class="s0"># Custom types to use as part of the AdapterRegistry data structures.</span>
<span class="s0"># Our custom types do strict type checking to make sure</span>
<span class="s0"># types propagate through the data tree as expected.</span>
<span class="s3">class </span><span class="s1">CustomDataTypeBase(object):</span>
    <span class="s1">_data = </span><span class="s3">None</span>
    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">return </span><span class="s1">self._data[name]</span>

    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s1">self._data[name] = value</span>

    <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">del </span><span class="s1">self._data[name]</span>

    <span class="s3">def </span><span class="s1">__len__(self):</span>
        <span class="s3">return </span><span class="s1">len(self._data)</span>

    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">return </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self._data</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">other </span><span class="s3">is </span><span class="s1">self:</span>
            <span class="s3">return True</span>
        <span class="s0"># pylint:disable=unidiomatic-typecheck</span>
        <span class="s3">if </span><span class="s1">type(other) != type(self):</span>
            <span class="s3">return False</span>
        <span class="s3">return </span><span class="s1">other._data == self._data</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s1">repr(self._data)</span>

<span class="s3">class </span><span class="s1">CustomMapping(CustomDataTypeBase):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">other=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self._data = {}</span>
        <span class="s3">if </span><span class="s1">other:</span>
            <span class="s1">self._data.update(other)</span>
        <span class="s1">self.get = self._data.get</span>
        <span class="s1">self.items = self._data.items</span>


<span class="s3">class </span><span class="s1">CustomSequence(CustomDataTypeBase):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">other=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self._data = []</span>
        <span class="s3">if </span><span class="s1">other:</span>
            <span class="s1">self._data.extend(other)</span>
        <span class="s1">self.append = self._data.append</span>

<span class="s3">class </span><span class="s1">CustomLeafSequence(CustomSequence):</span>
    <span class="s3">pass</span>

<span class="s3">class </span><span class="s1">CustomProvided(CustomMapping):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">BaseAdapterRegistryTests(unittest.TestCase):</span>

    <span class="s1">maxDiff = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">_getBaseAdapterRegistry(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">BaseAdapterRegistry</span>
        <span class="s3">return </span><span class="s1">BaseAdapterRegistry</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s1">BaseAdapterRegistry = self._getBaseAdapterRegistry()</span>
        <span class="s3">class </span><span class="s1">_CUT(BaseAdapterRegistry):</span>
            <span class="s3">class </span><span class="s1">LookupClass(object):</span>
                <span class="s1">_changed = _extendors = ()</span>
                <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">reg):</span>
                    <span class="s3">pass</span>
                <span class="s3">def </span><span class="s1">changed(self</span><span class="s3">, </span><span class="s1">orig):</span>
                    <span class="s1">self._changed += (orig</span><span class="s3">,</span><span class="s1">)</span>
                <span class="s3">def </span><span class="s1">add_extendor(self</span><span class="s3">, </span><span class="s1">provided):</span>
                    <span class="s1">self._extendors += (provided</span><span class="s3">,</span><span class="s1">)</span>
                <span class="s3">def </span><span class="s1">remove_extendor(self</span><span class="s3">, </span><span class="s1">provided):</span>
                    <span class="s1">self._extendors = tuple([x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self._extendors</span>
                                             <span class="s3">if </span><span class="s1">x != provided])</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">BaseAdapterRegistry._delegated:</span>
            <span class="s1">setattr(_CUT.LookupClass</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">object())</span>
        <span class="s3">return </span><span class="s1">_CUT</span>

    <span class="s3">def </span><span class="s1">_makeOne(self):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()()</span>

    <span class="s3">def </span><span class="s1">_getMappingType(self):</span>
        <span class="s3">return </span><span class="s1">dict</span>

    <span class="s3">def </span><span class="s1">_getProvidedType(self):</span>
        <span class="s3">return </span><span class="s1">dict</span>

    <span class="s3">def </span><span class="s1">_getMutableListType(self):</span>
        <span class="s3">return </span><span class="s1">list</span>

    <span class="s3">def </span><span class="s1">_getLeafSequenceType(self):</span>
        <span class="s3">return </span><span class="s1">tuple</span>

    <span class="s3">def </span><span class="s1">test_lookup_delegation(self):</span>
        <span class="s1">CUT = self._getTargetClass()</span>
        <span class="s1">registry = CUT()</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">CUT._delegated:</span>
            <span class="s1">self.assertIs(getattr(registry</span><span class="s3">, </span><span class="s1">name)</span><span class="s3">, </span><span class="s1">getattr(registry._v_lookup</span><span class="s3">, </span><span class="s1">name))</span>

    <span class="s3">def </span><span class="s1">test__generation_on_first_creation(self):</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s0"># Bumped to 1 in BaseAdapterRegistry.__init__</span>
        <span class="s1">self.assertEqual(registry._generation</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__generation_after_calling_changed(self):</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">orig = object()</span>
        <span class="s1">registry.changed(orig)</span>
        <span class="s0"># Bumped to 1 in BaseAdapterRegistry.__init__</span>
        <span class="s1">self.assertEqual(registry._generation</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(registry._v_lookup._changed</span><span class="s3">, </span><span class="s1">(registry</span><span class="s3">, </span><span class="s1">orig</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test__generation_after_changing___bases__(self):</span>
        <span class="s3">class </span><span class="s1">_Base(object):</span>
            <span class="s3">pass</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.__bases__ = (_Base</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(registry._generation</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_check_basic_types_of_adapters(self</span><span class="s3">, </span><span class="s1">registry</span><span class="s3">, </span><span class="s1">expected_order=</span><span class="s4">2</span><span class="s1">):</span>
        <span class="s1">self.assertEqual(len(registry._adapters)</span><span class="s3">, </span><span class="s1">expected_order) </span><span class="s0"># order 0 and order 1</span>
        <span class="s1">self.assertIsInstance(registry._adapters</span><span class="s3">, </span><span class="s1">self._getMutableListType())</span>
        <span class="s1">MT = self._getMappingType()</span>
        <span class="s3">for </span><span class="s1">mapping </span><span class="s3">in </span><span class="s1">registry._adapters:</span>
            <span class="s1">self.assertIsInstance(mapping</span><span class="s3">, </span><span class="s1">MT)</span>
        <span class="s1">self.assertEqual(registry._adapters[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT())</span>
        <span class="s1">self.assertIsInstance(registry._adapters[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT)</span>
        <span class="s1">self.assertEqual(len(registry._adapters[expected_order - </span><span class="s4">1</span><span class="s1">])</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_check_basic_types_of_subscribers(self</span><span class="s3">, </span><span class="s1">registry</span><span class="s3">, </span><span class="s1">expected_order=</span><span class="s4">2</span><span class="s1">):</span>
        <span class="s1">self.assertEqual(len(registry._subscribers)</span><span class="s3">, </span><span class="s1">expected_order) </span><span class="s0"># order 0 and order 1</span>
        <span class="s1">self.assertIsInstance(registry._subscribers</span><span class="s3">, </span><span class="s1">self._getMutableListType())</span>
        <span class="s1">MT = self._getMappingType()</span>
        <span class="s3">for </span><span class="s1">mapping </span><span class="s3">in </span><span class="s1">registry._subscribers:</span>
            <span class="s1">self.assertIsInstance(mapping</span><span class="s3">, </span><span class="s1">MT)</span>
        <span class="s3">if </span><span class="s1">expected_order:</span>
            <span class="s1">self.assertEqual(registry._subscribers[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT())</span>
            <span class="s1">self.assertIsInstance(registry._subscribers[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT)</span>
            <span class="s1">self.assertEqual(len(registry._subscribers[expected_order - </span><span class="s4">1</span><span class="s1">])</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_register(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.register([IB0]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(registry.registered([IB0]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">''</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(registry._generation</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self._check_basic_types_of_adapters(registry)</span>
        <span class="s1">MT = self._getMappingType()</span>
        <span class="s1">self.assertEqual(registry._adapters[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT({</span>
            <span class="s1">IB0: MT({</span>
                <span class="s1">IR0: MT({</span><span class="s5">''</span><span class="s1">: </span><span class="s5">'A1'</span><span class="s1">})</span>
            <span class="s1">})</span>
        <span class="s1">}))</span>
        <span class="s1">PT = self._getProvidedType()</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT({</span>
            <span class="s1">IR0: </span><span class="s4">1</span>
        <span class="s1">}))</span>

        <span class="s1">registered = list(registry.allRegistrations())</span>
        <span class="s1">self.assertEqual(registered</span><span class="s3">, </span><span class="s1">[(</span>
            <span class="s1">(IB0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s0"># required</span>
            <span class="s1">IR0</span><span class="s3">, </span><span class="s0"># provided</span>
            <span class="s5">''</span><span class="s3">, </span><span class="s0"># name</span>
            <span class="s5">'A1' </span><span class="s0"># value</span>
        <span class="s1">)])</span>

    <span class="s3">def </span><span class="s1">test_register_multiple_allRegistrations(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s0"># Use several different depths and several different names</span>
        <span class="s1">registry.register([]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">registry.register([]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'name1'</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">)</span>

        <span class="s1">registry.register([IB0]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">registry.register([IB0]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'name2'</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">)</span>
        <span class="s1">registry.register([IB0]</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A3'</span><span class="s1">)</span>
        <span class="s1">registry.register([IB0]</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">'name3'</span><span class="s3">, </span><span class="s5">'A4'</span><span class="s1">)</span>

        <span class="s1">registry.register([IB0</span><span class="s3">, </span><span class="s1">IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">registry.register([IB0</span><span class="s3">, </span><span class="s1">IB2]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'name2'</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">)</span>
        <span class="s1">registry.register([IB0</span><span class="s3">, </span><span class="s1">IB2]</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">'name4'</span><span class="s3">, </span><span class="s5">'A4'</span><span class="s1">)</span>
        <span class="s1">registry.register([IB0</span><span class="s3">, </span><span class="s1">IB3]</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A3'</span><span class="s1">)</span>

        <span class="s3">def </span><span class="s1">build_adapters(L</span><span class="s3">, </span><span class="s1">MT):</span>
            <span class="s3">return </span><span class="s1">L([</span>
                <span class="s0"># 0</span>
                <span class="s1">MT({</span>
                    <span class="s1">IR0: MT({</span>
                        <span class="s5">''</span><span class="s1">: </span><span class="s5">'A1'</span><span class="s3">,</span>
                        <span class="s5">'name1'</span><span class="s1">: </span><span class="s5">'A2'</span>
                    <span class="s1">})</span>
                <span class="s1">})</span><span class="s3">,</span>
                <span class="s0"># 1</span>
                <span class="s1">MT({</span>
                    <span class="s1">IB0: MT({</span>
                        <span class="s1">IR0: MT({</span>
                            <span class="s5">''</span><span class="s1">: </span><span class="s5">'A1'</span><span class="s3">,</span>
                            <span class="s5">'name2'</span><span class="s1">: </span><span class="s5">'A2'</span>
                        <span class="s1">})</span><span class="s3">,</span>
                        <span class="s1">IR1: MT({</span>
                            <span class="s5">''</span><span class="s1">: </span><span class="s5">'A3'</span><span class="s3">,</span>
                            <span class="s5">'name3'</span><span class="s1">: </span><span class="s5">'A4'</span>
                        <span class="s1">})</span>
                    <span class="s1">})</span>
                <span class="s1">})</span><span class="s3">,</span>
                <span class="s0"># 3</span>
                <span class="s1">MT({</span>
                    <span class="s1">IB0: MT({</span>
                        <span class="s1">IB1: MT({</span>
                            <span class="s1">IR0: MT({</span><span class="s5">''</span><span class="s1">: </span><span class="s5">'A1'</span><span class="s1">})</span>
                        <span class="s1">})</span><span class="s3">,</span>
                        <span class="s1">IB2: MT({</span>
                            <span class="s1">IR0: MT({</span><span class="s5">'name2'</span><span class="s1">: </span><span class="s5">'A2'</span><span class="s1">})</span><span class="s3">,</span>
                            <span class="s1">IR1: MT({</span><span class="s5">'name4'</span><span class="s1">: </span><span class="s5">'A4'</span><span class="s1">})</span><span class="s3">,</span>
                        <span class="s1">})</span><span class="s3">,</span>
                        <span class="s1">IB3: MT({</span>
                            <span class="s1">IR1: MT({</span><span class="s5">''</span><span class="s1">: </span><span class="s5">'A3'</span><span class="s1">})</span>
                        <span class="s1">})</span>
                    <span class="s1">})</span><span class="s3">,</span>
                <span class="s1">})</span><span class="s3">,</span>
            <span class="s1">])</span>

        <span class="s1">self.assertEqual(registry._adapters</span><span class="s3">,</span>
                         <span class="s1">build_adapters(L=self._getMutableListType()</span><span class="s3">,</span>
                                        <span class="s1">MT=self._getMappingType()))</span>

        <span class="s1">registered = sorted(registry.allRegistrations())</span>
        <span class="s1">self.assertEqual(registered</span><span class="s3">, </span><span class="s1">[</span>
            <span class="s1">(()</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(()</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'name1'</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'name2'</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A3'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">'name3'</span><span class="s3">, </span><span class="s5">'A4'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">, </span><span class="s1">IB1)</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">, </span><span class="s1">IB2)</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'name2'</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">, </span><span class="s1">IB2)</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">'name4'</span><span class="s3">, </span><span class="s5">'A4'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">, </span><span class="s1">IB3)</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A3'</span><span class="s1">)</span>
        <span class="s1">])</span>

        <span class="s0"># We can duplicate to another object.</span>
        <span class="s1">registry2 = self._makeOne()</span>
        <span class="s3">for </span><span class="s1">args </span><span class="s3">in </span><span class="s1">registered:</span>
            <span class="s1">registry2.register(*args)</span>

        <span class="s1">self.assertEqual(registry2._adapters</span><span class="s3">, </span><span class="s1">registry._adapters)</span>
        <span class="s1">self.assertEqual(registry2._provided</span><span class="s3">, </span><span class="s1">registry._provided)</span>

        <span class="s0"># We can change the types and rebuild the data structures.</span>
        <span class="s1">registry._mappingType = CustomMapping</span>
        <span class="s1">registry._leafSequenceType = CustomLeafSequence</span>
        <span class="s1">registry._sequenceType = CustomSequence</span>
        <span class="s1">registry._providedType = CustomProvided</span>
        <span class="s3">def </span><span class="s1">addValue(existing</span><span class="s3">, </span><span class="s1">new):</span>
            <span class="s1">existing = existing </span><span class="s3">if </span><span class="s1">existing </span><span class="s3">is not None else </span><span class="s1">CustomLeafSequence()</span>
            <span class="s1">existing.append(new)</span>
            <span class="s3">return </span><span class="s1">existing</span>
        <span class="s1">registry._addValueToLeaf = addValue</span>

        <span class="s1">registry.rebuild()</span>

        <span class="s1">self.assertEqual(registry._adapters</span><span class="s3">,</span>
                         <span class="s1">build_adapters(</span>
                             <span class="s1">L=CustomSequence</span><span class="s3">,</span>
                             <span class="s1">MT=CustomMapping</span>
                         <span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_register_with_invalid_name(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s3">with </span><span class="s1">self.assertRaises(ValueError):</span>
            <span class="s1">registry.register([IB0]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_register_with_value_None_unregisters(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.register([</span><span class="s3">None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">registry.register([</span><span class="s3">None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(registry._adapters)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertIsInstance(registry._adapters</span><span class="s3">, </span><span class="s1">self._getMutableListType())</span>
        <span class="s1">registered = list(registry.allRegistrations())</span>
        <span class="s1">self.assertEqual(registered</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_register_with_same_value(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">_value = object()</span>
        <span class="s1">registry.register([</span><span class="s3">None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s1">_value)</span>
        <span class="s1">_before = registry._generation</span>
        <span class="s1">registry.register([</span><span class="s3">None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s1">_value)</span>
        <span class="s1">self.assertEqual(registry._generation</span><span class="s3">, </span><span class="s1">_before) </span><span class="s0"># skipped changed()</span>
        <span class="s1">self._check_basic_types_of_adapters(registry)</span>
        <span class="s1">MT = self._getMappingType()</span>
        <span class="s1">self.assertEqual(registry._adapters[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT(</span>
            <span class="s1">{</span>
                <span class="s1">Interface: MT(</span>
                    <span class="s1">{</span>
                        <span class="s1">IR0: MT({</span><span class="s5">''</span><span class="s1">: _value})</span>
                    <span class="s1">}</span>
                <span class="s1">)</span>
            <span class="s1">}</span>
        <span class="s1">))</span>
        <span class="s1">registered = list(registry.allRegistrations())</span>
        <span class="s1">self.assertEqual(registered</span><span class="s3">, </span><span class="s1">[(</span>
            <span class="s1">(Interface</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s0"># required</span>
            <span class="s1">IR0</span><span class="s3">, </span><span class="s0"># provided</span>
            <span class="s5">''</span><span class="s3">, </span><span class="s0"># name</span>
            <span class="s1">_value </span><span class="s0"># value</span>
        <span class="s1">)])</span>


    <span class="s3">def </span><span class="s1">test_registered_empty(self):</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">self.assertEqual(registry.registered([</span><span class="s3">None</span><span class="s1">]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">registered = list(registry.allRegistrations())</span>
        <span class="s1">self.assertEqual(registered</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_registered_non_empty_miss(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.register([IB1]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(registry.registered([IB2]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_registered_non_empty_hit(self):</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.register([</span><span class="s3">None</span><span class="s1">]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(registry.registered([</span><span class="s3">None</span><span class="s1">]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_unregister_empty(self):</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.unregister([</span><span class="s3">None</span><span class="s1">]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">) </span><span class="s0"># doesn't raise</span>
        <span class="s1">self.assertEqual(registry.registered([</span><span class="s3">None</span><span class="s1">]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(registry._provided)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_unregister_non_empty_miss_on_required(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.register([IB1]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">registry.unregister([IB2]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">) </span><span class="s0"># doesn't raise</span>
        <span class="s1">self.assertEqual(registry.registered([IB1]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">self._check_basic_types_of_adapters(registry)</span>
        <span class="s1">MT = self._getMappingType()</span>
        <span class="s1">self.assertEqual(registry._adapters[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT(</span>
            <span class="s1">{</span>
                <span class="s1">IB1: MT(</span>
                    <span class="s1">{</span>
                        <span class="s3">None</span><span class="s1">: MT({</span><span class="s5">''</span><span class="s1">: </span><span class="s5">'A1'</span><span class="s1">})</span>
                    <span class="s1">}</span>
                <span class="s1">)</span>
            <span class="s1">}</span>
        <span class="s1">))</span>
        <span class="s1">PT = self._getProvidedType()</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT({</span>
            <span class="s3">None</span><span class="s1">: </span><span class="s4">1</span>
        <span class="s1">}))</span>

    <span class="s3">def </span><span class="s1">test_unregister_non_empty_miss_on_name(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.register([IB1]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">registry.unregister([IB1]</span><span class="s3">, None, </span><span class="s5">'nonesuch'</span><span class="s1">) </span><span class="s0"># doesn't raise</span>
        <span class="s1">self.assertEqual(registry.registered([IB1]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">self._check_basic_types_of_adapters(registry)</span>
        <span class="s1">MT = self._getMappingType()</span>
        <span class="s1">self.assertEqual(registry._adapters[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT(</span>
            <span class="s1">{</span>
                <span class="s1">IB1: MT(</span>
                    <span class="s1">{</span>
                        <span class="s3">None</span><span class="s1">: MT({</span><span class="s5">''</span><span class="s1">: </span><span class="s5">'A1'</span><span class="s1">})</span>
                    <span class="s1">}</span>
                <span class="s1">)</span>
            <span class="s1">}</span>
        <span class="s1">))</span>
        <span class="s1">PT = self._getProvidedType()</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT({</span>
            <span class="s3">None</span><span class="s1">: </span><span class="s4">1</span>
        <span class="s1">}))</span>

    <span class="s3">def </span><span class="s1">test_unregister_with_value_not_None_miss(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">orig = object()</span>
        <span class="s1">nomatch = object()</span>
        <span class="s1">registry.register([IB1]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s3">, </span><span class="s1">orig)</span>
        <span class="s1">registry.unregister([IB1]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s3">, </span><span class="s1">nomatch) </span><span class="s0">#doesn't raise</span>
        <span class="s1">self.assertIs(registry.registered([IB1]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">)</span><span class="s3">, </span><span class="s1">orig)</span>

    <span class="s3">def </span><span class="s1">test_unregister_hit_clears_empty_subcomponents(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">one = object()</span>
        <span class="s1">another = object()</span>
        <span class="s1">registry.register([IB1</span><span class="s3">, </span><span class="s1">IB2]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s3">, </span><span class="s1">one)</span>
        <span class="s1">registry.register([IB1</span><span class="s3">, </span><span class="s1">IB3]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s3">, </span><span class="s1">another)</span>
        <span class="s1">self._check_basic_types_of_adapters(registry</span><span class="s3">, </span><span class="s1">expected_order=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">self.assertIn(IB2</span><span class="s3">, </span><span class="s1">registry._adapters[</span><span class="s4">2</span><span class="s1">][IB1])</span>
        <span class="s1">self.assertIn(IB3</span><span class="s3">, </span><span class="s1">registry._adapters[</span><span class="s4">2</span><span class="s1">][IB1])</span>
        <span class="s1">MT = self._getMappingType()</span>
        <span class="s1">self.assertEqual(registry._adapters[</span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT(</span>
            <span class="s1">{</span>
                <span class="s1">IB1: MT(</span>
                    <span class="s1">{</span>
                        <span class="s1">IB2: MT({</span><span class="s3">None</span><span class="s1">: MT({</span><span class="s5">''</span><span class="s1">: one})})</span><span class="s3">,</span>
                        <span class="s1">IB3: MT({</span><span class="s3">None</span><span class="s1">: MT({</span><span class="s5">''</span><span class="s1">: another})})</span>
                    <span class="s1">}</span>
                <span class="s1">)</span>
            <span class="s1">}</span>
        <span class="s1">))</span>
        <span class="s1">PT = self._getProvidedType()</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT({</span>
            <span class="s3">None</span><span class="s1">: </span><span class="s4">2</span>
        <span class="s1">}))</span>

        <span class="s1">registry.unregister([IB1</span><span class="s3">, </span><span class="s1">IB3]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s3">, </span><span class="s1">another)</span>
        <span class="s1">self.assertIn(IB2</span><span class="s3">, </span><span class="s1">registry._adapters[</span><span class="s4">2</span><span class="s1">][IB1])</span>
        <span class="s1">self.assertNotIn(IB3</span><span class="s3">, </span><span class="s1">registry._adapters[</span><span class="s4">2</span><span class="s1">][IB1])</span>
        <span class="s1">self.assertEqual(registry._adapters[</span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT(</span>
            <span class="s1">{</span>
                <span class="s1">IB1: MT(</span>
                    <span class="s1">{</span>
                        <span class="s1">IB2: MT({</span><span class="s3">None</span><span class="s1">: MT({</span><span class="s5">''</span><span class="s1">: one})})</span><span class="s3">,</span>
                    <span class="s1">}</span>
                <span class="s1">)</span>
            <span class="s1">}</span>
        <span class="s1">))</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT({</span>
            <span class="s3">None</span><span class="s1">: </span><span class="s4">1</span>
        <span class="s1">}))</span>

    <span class="s3">def </span><span class="s1">test_unsubscribe_empty(self):</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.unsubscribe([</span><span class="s3">None</span><span class="s1">]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">) </span><span class="s0">#doesn't raise</span>
        <span class="s1">self.assertEqual(registry.registered([</span><span class="s3">None</span><span class="s1">]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self._check_basic_types_of_subscribers(registry</span><span class="s3">, </span><span class="s1">expected_order=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_unsubscribe_hit(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">orig = object()</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, None, </span><span class="s1">orig)</span>
        <span class="s1">MT = self._getMappingType()</span>
        <span class="s1">L = self._getLeafSequenceType()</span>
        <span class="s1">PT = self._getProvidedType()</span>
        <span class="s1">self._check_basic_types_of_subscribers(registry)</span>
        <span class="s1">self.assertEqual(registry._subscribers[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT({</span>
            <span class="s1">IB1: MT({</span>
                <span class="s3">None</span><span class="s1">: MT({</span>
                    <span class="s5">''</span><span class="s1">: L((orig</span><span class="s3">,</span><span class="s1">))</span>
                <span class="s1">})</span>
            <span class="s1">})</span>
        <span class="s1">}))</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT({}))</span>
        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, None, </span><span class="s1">orig) </span><span class="s0">#doesn't raise</span>
        <span class="s1">self.assertEqual(len(registry._subscribers)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT({}))</span>

    <span class="s3">def </span><span class="s1">assertLeafIdentity(self</span><span class="s3">, </span><span class="s1">leaf1</span><span class="s3">, </span><span class="s1">leaf2):</span>
        <span class="s2">&quot;&quot;&quot; 
        Implementations may choose to use new, immutable objects 
        instead of mutating existing subscriber leaf objects, or vice versa. 
 
        The default implementation uses immutable tuples, so they are never 
        the same. Other implementations may use persistent lists so they should be 
        the same and mutated in place. Subclasses testing this behaviour need to 
        override this method. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.assertIsNot(leaf1</span><span class="s3">, </span><span class="s1">leaf2)</span>

    <span class="s3">def </span><span class="s1">test_unsubscribe_after_multiple(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">first = object()</span>
        <span class="s1">second = object()</span>
        <span class="s1">third = object()</span>
        <span class="s1">fourth = object()</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, None, </span><span class="s1">first)</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, None, </span><span class="s1">second)</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">third)</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">fourth)</span>
        <span class="s1">self._check_basic_types_of_subscribers(registry</span><span class="s3">, </span><span class="s1">expected_order=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">MT = self._getMappingType()</span>
        <span class="s1">L = self._getLeafSequenceType()</span>
        <span class="s1">PT = self._getProvidedType()</span>
        <span class="s1">self.assertEqual(registry._subscribers[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT({</span>
            <span class="s1">IB1: MT({</span>
                <span class="s3">None</span><span class="s1">: MT({</span><span class="s5">''</span><span class="s1">: L((first</span><span class="s3">, </span><span class="s1">second))})</span><span class="s3">,</span>
                <span class="s1">IR0: MT({</span><span class="s5">''</span><span class="s1">: L((third</span><span class="s3">, </span><span class="s1">fourth))})</span><span class="s3">,</span>
            <span class="s1">})</span>
        <span class="s1">}))</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT({</span>
            <span class="s1">IR0: </span><span class="s4">2</span>
        <span class="s1">}))</span>
        <span class="s0"># The leaf objects may or may not stay the same as they are unsubscribed,</span>
        <span class="s0"># depending on the implementation</span>
        <span class="s1">IR0_leaf_orig = registry._subscribers[</span><span class="s4">1</span><span class="s1">][IB1][IR0][</span><span class="s5">''</span><span class="s1">]</span>
        <span class="s1">Non_leaf_orig = registry._subscribers[</span><span class="s4">1</span><span class="s1">][IB1][</span><span class="s3">None</span><span class="s1">][</span><span class="s5">''</span><span class="s1">]</span>

        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, None, </span><span class="s1">first)</span>
        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">third)</span>

        <span class="s1">self.assertEqual(registry._subscribers[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT({</span>
            <span class="s1">IB1: MT({</span>
                <span class="s3">None</span><span class="s1">: MT({</span><span class="s5">''</span><span class="s1">: L((second</span><span class="s3">,</span><span class="s1">))})</span><span class="s3">,</span>
                <span class="s1">IR0: MT({</span><span class="s5">''</span><span class="s1">: L((fourth</span><span class="s3">,</span><span class="s1">))})</span><span class="s3">,</span>
            <span class="s1">})</span>
        <span class="s1">}))</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT({</span>
            <span class="s1">IR0: </span><span class="s4">1</span>
        <span class="s1">}))</span>
        <span class="s1">IR0_leaf_new = registry._subscribers[</span><span class="s4">1</span><span class="s1">][IB1][IR0][</span><span class="s5">''</span><span class="s1">]</span>
        <span class="s1">Non_leaf_new = registry._subscribers[</span><span class="s4">1</span><span class="s1">][IB1][</span><span class="s3">None</span><span class="s1">][</span><span class="s5">''</span><span class="s1">]</span>

        <span class="s1">self.assertLeafIdentity(IR0_leaf_orig</span><span class="s3">, </span><span class="s1">IR0_leaf_new)</span>
        <span class="s1">self.assertLeafIdentity(Non_leaf_orig</span><span class="s3">, </span><span class="s1">Non_leaf_new)</span>

        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, None, </span><span class="s1">second)</span>
        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">fourth)</span>
        <span class="s1">self.assertEqual(len(registry._subscribers)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(registry._provided)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_subscribe_unsubscribe_identical_objects_provided(self):</span>
        <span class="s0"># https://github.com/zopefoundation/zope.interface/issues/227</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">first = object()</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">first)</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">first)</span>

        <span class="s1">MT = self._getMappingType()</span>
        <span class="s1">L = self._getLeafSequenceType()</span>
        <span class="s1">PT = self._getProvidedType()</span>
        <span class="s1">self.assertEqual(registry._subscribers[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT({</span>
            <span class="s1">IB1: MT({</span>
                <span class="s1">IR0: MT({</span><span class="s5">''</span><span class="s1">: L((first</span><span class="s3">, </span><span class="s1">first))})</span><span class="s3">,</span>
            <span class="s1">})</span>
        <span class="s1">}))</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT({</span>
            <span class="s1">IR0: </span><span class="s4">2</span>
        <span class="s1">}))</span>

        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">first)</span>
        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">first)</span>
        <span class="s1">self.assertEqual(len(registry._subscribers)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT())</span>

    <span class="s3">def </span><span class="s1">test_subscribe_unsubscribe_nonequal_objects_provided(self):</span>
        <span class="s0"># https://github.com/zopefoundation/zope.interface/issues/227</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">first = object()</span>
        <span class="s1">second = object()</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">first)</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">second)</span>

        <span class="s1">MT = self._getMappingType()</span>
        <span class="s1">L = self._getLeafSequenceType()</span>
        <span class="s1">PT = self._getProvidedType()</span>
        <span class="s1">self.assertEqual(registry._subscribers[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT({</span>
            <span class="s1">IB1: MT({</span>
                <span class="s1">IR0: MT({</span><span class="s5">''</span><span class="s1">: L((first</span><span class="s3">, </span><span class="s1">second))})</span><span class="s3">,</span>
            <span class="s1">})</span>
        <span class="s1">}))</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT({</span>
            <span class="s1">IR0: </span><span class="s4">2</span>
        <span class="s1">}))</span>

        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">first)</span>
        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">second)</span>
        <span class="s1">self.assertEqual(len(registry._subscribers)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">, </span><span class="s1">PT())</span>

    <span class="s3">def </span><span class="s1">test_subscribed_empty(self):</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">self.assertIsNone(registry.subscribed([</span><span class="s3">None</span><span class="s1">]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">))</span>
        <span class="s1">subscribed = list(registry.allSubscriptions())</span>
        <span class="s1">self.assertEqual(subscribed</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test_subscribed_non_empty_miss(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s0"># Mismatch required</span>
        <span class="s1">self.assertIsNone(registry.subscribed([IB2]</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s5">''</span><span class="s1">))</span>
        <span class="s0"># Mismatch provided</span>
        <span class="s1">self.assertIsNone(registry.subscribed([IB1]</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s5">''</span><span class="s1">))</span>
        <span class="s0"># Mismatch value</span>
        <span class="s1">self.assertIsNone(registry.subscribed([IB1]</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s5">''</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test_subscribed_non_empty_hit(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.subscribe([IB0]</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(registry.subscribed([IB0]</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_unsubscribe_w_None_after_multiple(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">first = object()</span>
        <span class="s1">second = object()</span>

        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, None, </span><span class="s1">first)</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, None, </span><span class="s1">second)</span>
        <span class="s1">self._check_basic_types_of_subscribers(registry</span><span class="s3">, </span><span class="s1">expected_order=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(registry._subscribers)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_unsubscribe_non_empty_miss_on_required(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, None, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">self._check_basic_types_of_subscribers(registry</span><span class="s3">, </span><span class="s1">expected_order=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">registry.unsubscribe([IB2]</span><span class="s3">, None, </span><span class="s5">''</span><span class="s1">) </span><span class="s0"># doesn't raise</span>
        <span class="s1">self.assertEqual(len(registry._subscribers)</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">MT = self._getMappingType()</span>
        <span class="s1">L = self._getLeafSequenceType()</span>
        <span class="s1">self.assertEqual(registry._subscribers[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT({</span>
            <span class="s1">IB1: MT({</span>
                <span class="s3">None</span><span class="s1">: MT({</span><span class="s5">''</span><span class="s1">: L((</span><span class="s5">'A1'</span><span class="s3">,</span><span class="s1">))})</span><span class="s3">,</span>
            <span class="s1">})</span>
        <span class="s1">}))</span>

    <span class="s3">def </span><span class="s1">test_unsubscribe_non_empty_miss_on_value(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, None, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">self._check_basic_types_of_subscribers(registry</span><span class="s3">, </span><span class="s1">expected_order=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, None, </span><span class="s5">'A2'</span><span class="s1">) </span><span class="s0"># doesn't raise</span>
        <span class="s1">self.assertEqual(len(registry._subscribers)</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">MT = self._getMappingType()</span>
        <span class="s1">L = self._getLeafSequenceType()</span>
        <span class="s1">self.assertEqual(registry._subscribers[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">MT({</span>
            <span class="s1">IB1: MT({</span>
                <span class="s3">None</span><span class="s1">: MT({</span><span class="s5">''</span><span class="s1">: L((</span><span class="s5">'A1'</span><span class="s3">,</span><span class="s1">))})</span><span class="s3">,</span>
            <span class="s1">})</span>
        <span class="s1">}))</span>

    <span class="s3">def </span><span class="s1">test_unsubscribe_with_value_not_None_miss(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">orig = object()</span>
        <span class="s1">nomatch = object()</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, None, </span><span class="s1">orig)</span>
        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, None, </span><span class="s1">nomatch) </span><span class="s0">#doesn't raise</span>
        <span class="s1">self.assertEqual(len(registry._subscribers)</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_instance_method_notify_target(self):</span>
        <span class="s1">self.fail(</span><span class="s5">&quot;Example method, not intended to be called.&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_unsubscribe_instance_method(self):</span>
        <span class="s0"># Checking that the values are compared by equality, not identity</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">self.assertEqual(len(registry._subscribers)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">registry.subscribe([IB1]</span><span class="s3">, None, </span><span class="s1">self._instance_method_notify_target)</span>
        <span class="s1">registry.unsubscribe([IB1]</span><span class="s3">, None, </span><span class="s1">self._instance_method_notify_target)</span>
        <span class="s1">self.assertEqual(len(registry._subscribers)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_subscribe_multiple_allRegistrations(self):</span>
        <span class="s1">IB0</span><span class="s3">, </span><span class="s1">IB1</span><span class="s3">, </span><span class="s1">IB2</span><span class="s3">, </span><span class="s1">IB3</span><span class="s3">, </span><span class="s1">IB4</span><span class="s3">, </span><span class="s1">IF0</span><span class="s3">, </span><span class="s1">IF1</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s1">IR1 = _makeInterfaces() </span><span class="s0"># pylint:disable=unused-variable</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s0"># Use several different depths and several different values</span>
        <span class="s1">registry.subscribe([]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">registry.subscribe([]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">)</span>

        <span class="s1">registry.subscribe([IB0]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">registry.subscribe([IB0]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">)</span>
        <span class="s1">registry.subscribe([IB0]</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">'A3'</span><span class="s1">)</span>
        <span class="s1">registry.subscribe([IB0]</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">'A4'</span><span class="s1">)</span>

        <span class="s1">registry.subscribe([IB0</span><span class="s3">, </span><span class="s1">IB1]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span>
        <span class="s1">registry.subscribe([IB0</span><span class="s3">, </span><span class="s1">IB2]</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">)</span>
        <span class="s1">registry.subscribe([IB0</span><span class="s3">, </span><span class="s1">IB2]</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">'A4'</span><span class="s1">)</span>
        <span class="s1">registry.subscribe([IB0</span><span class="s3">, </span><span class="s1">IB3]</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">'A3'</span><span class="s1">)</span>


        <span class="s3">def </span><span class="s1">build_subscribers(L</span><span class="s3">, </span><span class="s1">F</span><span class="s3">, </span><span class="s1">MT):</span>
            <span class="s3">return </span><span class="s1">L([</span>
                <span class="s0"># 0</span>
                <span class="s1">MT({</span>
                    <span class="s1">IR0: MT({</span>
                        <span class="s5">''</span><span class="s1">: F([</span><span class="s5">'A1'</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">])</span>
                    <span class="s1">})</span>
                <span class="s1">})</span><span class="s3">,</span>
                <span class="s0"># 1</span>
                <span class="s1">MT({</span>
                    <span class="s1">IB0: MT({</span>
                        <span class="s1">IR0: MT({</span>
                            <span class="s5">''</span><span class="s1">: F([</span><span class="s5">'A1'</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">])</span>
                        <span class="s1">})</span><span class="s3">,</span>
                        <span class="s1">IR1: MT({</span>
                            <span class="s5">''</span><span class="s1">: F([</span><span class="s5">'A3'</span><span class="s3">, </span><span class="s5">'A4'</span><span class="s1">])</span>
                        <span class="s1">})</span>
                    <span class="s1">})</span>
                <span class="s1">})</span><span class="s3">,</span>
                <span class="s0"># 3</span>
                <span class="s1">MT({</span>
                    <span class="s1">IB0: MT({</span>
                        <span class="s1">IB1: MT({</span>
                            <span class="s1">IR0: MT({</span><span class="s5">''</span><span class="s1">: F([</span><span class="s5">'A1'</span><span class="s1">])})</span>
                        <span class="s1">})</span><span class="s3">,</span>
                        <span class="s1">IB2: MT({</span>
                            <span class="s1">IR0: MT({</span><span class="s5">''</span><span class="s1">: F([</span><span class="s5">'A2'</span><span class="s1">])})</span><span class="s3">,</span>
                            <span class="s1">IR1: MT({</span><span class="s5">''</span><span class="s1">: F([</span><span class="s5">'A4'</span><span class="s1">])})</span><span class="s3">,</span>
                        <span class="s1">})</span><span class="s3">,</span>
                        <span class="s1">IB3: MT({</span>
                            <span class="s1">IR1: MT({</span><span class="s5">''</span><span class="s1">: F([</span><span class="s5">'A3'</span><span class="s1">])})</span>
                        <span class="s1">})</span>
                    <span class="s1">})</span><span class="s3">,</span>
                <span class="s1">})</span><span class="s3">,</span>
            <span class="s1">])</span>

        <span class="s1">self.assertEqual(registry._subscribers</span><span class="s3">,</span>
                         <span class="s1">build_subscribers(</span>
                             <span class="s1">L=self._getMutableListType()</span><span class="s3">,</span>
                             <span class="s1">F=self._getLeafSequenceType()</span><span class="s3">,</span>
                             <span class="s1">MT=self._getMappingType()</span>
                         <span class="s1">))</span>

        <span class="s3">def </span><span class="s1">build_provided(P):</span>
            <span class="s3">return </span><span class="s1">P({</span>
                <span class="s1">IR0: </span><span class="s4">6</span><span class="s3">,</span>
                <span class="s1">IR1: </span><span class="s4">4</span><span class="s3">,</span>
            <span class="s1">})</span>


        <span class="s1">self.assertEqual(registry._provided</span><span class="s3">,</span>
                         <span class="s1">build_provided(P=self._getProvidedType()))</span>

        <span class="s1">registered = sorted(registry.allSubscriptions())</span>
        <span class="s1">self.assertEqual(registered</span><span class="s3">, </span><span class="s1">[</span>
            <span class="s1">(()</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(()</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">'A3'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">'A4'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">, </span><span class="s1">IB1)</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'A1'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">, </span><span class="s1">IB2)</span><span class="s3">, </span><span class="s1">IR0</span><span class="s3">, </span><span class="s5">'A2'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">, </span><span class="s1">IB2)</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">'A4'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">((IB0</span><span class="s3">, </span><span class="s1">IB3)</span><span class="s3">, </span><span class="s1">IR1</span><span class="s3">, </span><span class="s5">'A3'</span><span class="s1">)</span>
        <span class="s1">])</span>

        <span class="s0"># We can duplicate this to another object</span>
        <span class="s1">registry2 = self._makeOne()</span>
        <span class="s3">for </span><span class="s1">args </span><span class="s3">in </span><span class="s1">registered:</span>
            <span class="s1">registry2.subscribe(*args)</span>

        <span class="s1">self.assertEqual(registry2._subscribers</span><span class="s3">, </span><span class="s1">registry._subscribers)</span>
        <span class="s1">self.assertEqual(registry2._provided</span><span class="s3">, </span><span class="s1">registry._provided)</span>

        <span class="s0"># We can change the types and rebuild the data structures.</span>
        <span class="s1">registry._mappingType = CustomMapping</span>
        <span class="s1">registry._leafSequenceType = CustomLeafSequence</span>
        <span class="s1">registry._sequenceType = CustomSequence</span>
        <span class="s1">registry._providedType = CustomProvided</span>
        <span class="s3">def </span><span class="s1">addValue(existing</span><span class="s3">, </span><span class="s1">new):</span>
            <span class="s1">existing = existing </span><span class="s3">if </span><span class="s1">existing </span><span class="s3">is not None else </span><span class="s1">CustomLeafSequence()</span>
            <span class="s1">existing.append(new)</span>
            <span class="s3">return </span><span class="s1">existing</span>
        <span class="s1">registry._addValueToLeaf = addValue</span>

        <span class="s1">registry.rebuild()</span>

        <span class="s1">self.assertEqual(registry._subscribers</span><span class="s3">,</span>
                         <span class="s1">build_subscribers(</span>
                             <span class="s1">L=CustomSequence</span><span class="s3">,</span>
                             <span class="s1">F=CustomLeafSequence</span><span class="s3">,</span>
                             <span class="s1">MT=CustomMapping</span>
                         <span class="s1">))</span>


<span class="s3">class </span><span class="s1">CustomTypesBaseAdapterRegistryTests(BaseAdapterRegistryTests):</span>
    <span class="s2">&quot;&quot;&quot; 
    This class may be extended by other packages to test their own 
    adapter registries that use custom types. (So be cautious about 
    breaking changes.) 
 
    One known user is ``zope.component.persistentregistry``. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">_getMappingType(self):</span>
        <span class="s3">return </span><span class="s1">CustomMapping</span>

    <span class="s3">def </span><span class="s1">_getProvidedType(self):</span>
        <span class="s3">return </span><span class="s1">CustomProvided</span>

    <span class="s3">def </span><span class="s1">_getMutableListType(self):</span>
        <span class="s3">return </span><span class="s1">CustomSequence</span>

    <span class="s3">def </span><span class="s1">_getLeafSequenceType(self):</span>
        <span class="s3">return </span><span class="s1">CustomLeafSequence</span>

    <span class="s3">def </span><span class="s1">_getBaseAdapterRegistry(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">BaseAdapterRegistry</span>
        <span class="s3">class </span><span class="s1">CustomAdapterRegistry(BaseAdapterRegistry):</span>
            <span class="s1">_mappingType = self._getMappingType()</span>
            <span class="s1">_sequenceType = self._getMutableListType()</span>
            <span class="s1">_leafSequenceType = self._getLeafSequenceType()</span>
            <span class="s1">_providedType = self._getProvidedType()</span>

            <span class="s3">def </span><span class="s1">_addValueToLeaf(self</span><span class="s3">, </span><span class="s1">existing_leaf_sequence</span><span class="s3">, </span><span class="s1">new_item):</span>
                <span class="s3">if not </span><span class="s1">existing_leaf_sequence:</span>
                    <span class="s1">existing_leaf_sequence = self._leafSequenceType()</span>
                <span class="s1">existing_leaf_sequence.append(new_item)</span>
                <span class="s3">return </span><span class="s1">existing_leaf_sequence</span>

            <span class="s3">def </span><span class="s1">_removeValueFromLeaf(self</span><span class="s3">, </span><span class="s1">existing_leaf_sequence</span><span class="s3">, </span><span class="s1">to_remove):</span>
                <span class="s1">without_removed = BaseAdapterRegistry._removeValueFromLeaf(</span>
                    <span class="s1">self</span><span class="s3">,</span>
                    <span class="s1">existing_leaf_sequence</span><span class="s3">,</span>
                    <span class="s1">to_remove)</span>
                <span class="s1">existing_leaf_sequence[:] = without_removed</span>
                <span class="s3">assert </span><span class="s1">to_remove </span><span class="s3">not in </span><span class="s1">existing_leaf_sequence</span>
                <span class="s3">return </span><span class="s1">existing_leaf_sequence</span>

        <span class="s3">return </span><span class="s1">CustomAdapterRegistry</span>

    <span class="s3">def </span><span class="s1">assertLeafIdentity(self</span><span class="s3">, </span><span class="s1">leaf1</span><span class="s3">, </span><span class="s1">leaf2):</span>
        <span class="s1">self.assertIs(leaf1</span><span class="s3">, </span><span class="s1">leaf2)</span>


<span class="s3">class </span><span class="s1">LookupBaseFallbackTests(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getFallbackClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">LookupBaseFallback </span><span class="s0"># pylint:disable=no-name-in-module</span>
        <span class="s3">return </span><span class="s1">LookupBaseFallback</span>

    <span class="s1">_getTargetClass = _getFallbackClass</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">uc_lookup=</span><span class="s3">None, </span><span class="s1">uc_lookupAll=</span><span class="s3">None,</span>
                 <span class="s1">uc_subscriptions=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># pylint:disable=function-redefined</span>
        <span class="s3">if </span><span class="s1">uc_lookup </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">def </span><span class="s1">uc_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
                <span class="s3">pass</span>
        <span class="s3">if </span><span class="s1">uc_lookupAll </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">def </span><span class="s1">uc_lookupAll(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided):</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError()</span>
        <span class="s3">if </span><span class="s1">uc_subscriptions </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">def </span><span class="s1">uc_subscriptions(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided):</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError()</span>
        <span class="s3">class </span><span class="s1">Derived(self._getTargetClass()):</span>
            <span class="s1">_uncached_lookup = uc_lookup</span>
            <span class="s1">_uncached_lookupAll = uc_lookupAll</span>
            <span class="s1">_uncached_subscriptions = uc_subscriptions</span>
        <span class="s3">return </span><span class="s1">Derived()</span>

    <span class="s3">def </span><span class="s1">test_lookup_w_invalid_name(self):</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">self.fail(</span><span class="s5">&quot;This should never be called&quot;</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s3">with </span><span class="s1">self.assertRaises(ValueError):</span>
            <span class="s1">lb.lookup((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s1">object())</span>

    <span class="s3">def </span><span class="s1">test_lookup_miss_no_default(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>

        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIsNone(found)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>

    <span class="s3">def </span><span class="s1">test_lookup_miss_w_default(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">_default = object()</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>

        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>

    <span class="s3">def </span><span class="s1">test_lookup_not_cached(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">_results = [a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c]</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>
            <span class="s3">return </span><span class="s1">_results.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>
        <span class="s1">self.assertEqual(_results</span><span class="s3">, </span><span class="s1">[b</span><span class="s3">, </span><span class="s1">c])</span>

    <span class="s3">def </span><span class="s1">test_lookup_cached(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">_results = [a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c]</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>
            <span class="s3">return </span><span class="s1">_results.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>
        <span class="s1">self.assertEqual(_results</span><span class="s3">, </span><span class="s1">[b</span><span class="s3">, </span><span class="s1">c])</span>

    <span class="s3">def </span><span class="s1">test_lookup_not_cached_multi_required(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">_results = [a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c]</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>
            <span class="s3">return </span><span class="s1">_results.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'D'</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'D'</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>
        <span class="s1">self.assertEqual(_results</span><span class="s3">, </span><span class="s1">[b</span><span class="s3">, </span><span class="s1">c])</span>

    <span class="s3">def </span><span class="s1">test_lookup_cached_multi_required(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">_results = [a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c]</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>
            <span class="s3">return </span><span class="s1">_results.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'D'</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'D'</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'D'</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>
        <span class="s1">self.assertEqual(_results</span><span class="s3">, </span><span class="s1">[b</span><span class="s3">, </span><span class="s1">c])</span>

    <span class="s3">def </span><span class="s1">test_lookup_not_cached_after_changed(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">_results = [a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c]</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>
            <span class="s3">return </span><span class="s1">_results.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">lb.changed(lb)</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">b)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">,</span>
                         <span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>
        <span class="s1">self.assertEqual(_results</span><span class="s3">, </span><span class="s1">[c])</span>

    <span class="s3">def </span><span class="s1">test_lookup1_w_invalid_name(self):</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">self.fail(</span><span class="s5">&quot;This should never be called&quot;</span><span class="s1">)</span>

        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s3">with </span><span class="s1">self.assertRaises(ValueError):</span>
            <span class="s1">lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s1">object())</span>

    <span class="s3">def </span><span class="s1">test_lookup1_miss_no_default(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>

        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIsNone(found)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>

    <span class="s3">def </span><span class="s1">test_lookup1_miss_w_default(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">_default = object()</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>

        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>

    <span class="s3">def </span><span class="s1">test_lookup1_miss_w_default_negative_cache(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">_default = object()</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>

        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">found = lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>

    <span class="s3">def </span><span class="s1">test_lookup1_not_cached(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">_results = [a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c]</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>
            <span class="s3">return </span><span class="s1">_results.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>
        <span class="s1">self.assertEqual(_results</span><span class="s3">, </span><span class="s1">[b</span><span class="s3">, </span><span class="s1">c])</span>

    <span class="s3">def </span><span class="s1">test_lookup1_cached(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">_results = [a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c]</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>
            <span class="s3">return </span><span class="s1">_results.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">found = lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>
        <span class="s1">self.assertEqual(_results</span><span class="s3">, </span><span class="s1">[b</span><span class="s3">, </span><span class="s1">c])</span>

    <span class="s3">def </span><span class="s1">test_lookup1_not_cached_after_changed(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">_results = [a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c]</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>
            <span class="s3">return </span><span class="s1">_results.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">lb.changed(lb)</span>
        <span class="s1">found = lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">b)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">,</span>
                         <span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>
        <span class="s1">self.assertEqual(_results</span><span class="s3">, </span><span class="s1">[c])</span>

    <span class="s3">def </span><span class="s1">test_adapter_hook_w_invalid_name(self):</span>
        <span class="s1">req</span><span class="s3">, </span><span class="s1">prv = object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">lb = self._makeOne()</span>
        <span class="s3">with </span><span class="s1">self.assertRaises(ValueError):</span>
            <span class="s1">lb.adapter_hook(prv</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">object())</span>

    <span class="s3">def </span><span class="s1">test_adapter_hook_miss_no_default(self):</span>
        <span class="s1">req</span><span class="s3">, </span><span class="s1">prv = object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">lb = self._makeOne()</span>
        <span class="s1">found = lb.adapter_hook(prv</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s5">''</span><span class="s1">)</span>
        <span class="s1">self.assertIsNone(found)</span>

    <span class="s3">def </span><span class="s1">test_adapter_hook_miss_w_default(self):</span>
        <span class="s1">req</span><span class="s3">, </span><span class="s1">prv</span><span class="s3">, </span><span class="s1">_default = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">lb = self._makeOne()</span>
        <span class="s1">found = lb.adapter_hook(prv</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s5">''</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">_default)</span>

    <span class="s3">def </span><span class="s1">test_adapter_hook_hit_factory_returns_None(self):</span>
        <span class="s1">_f_called_with = []</span>
        <span class="s3">def </span><span class="s1">_factory(context):</span>
            <span class="s1">_f_called_with.append(context)</span>

        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s3">return </span><span class="s1">_factory</span>
        <span class="s1">req</span><span class="s3">, </span><span class="s1">prv</span><span class="s3">, </span><span class="s1">_default = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">adapted = lb.adapter_hook(prv</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(adapted</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertEqual(_f_called_with</span><span class="s3">, </span><span class="s1">[req])</span>

    <span class="s3">def </span><span class="s1">test_adapter_hook_hit_factory_returns_adapter(self):</span>
        <span class="s1">_f_called_with = []</span>
        <span class="s1">_adapter = object()</span>
        <span class="s3">def </span><span class="s1">_factory(context):</span>
            <span class="s1">_f_called_with.append(context)</span>
            <span class="s3">return </span><span class="s1">_adapter</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s3">return </span><span class="s1">_factory</span>
        <span class="s1">req</span><span class="s3">, </span><span class="s1">prv</span><span class="s3">, </span><span class="s1">_default = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">adapted = lb.adapter_hook(prv</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(adapted</span><span class="s3">, </span><span class="s1">_adapter)</span>
        <span class="s1">self.assertEqual(_f_called_with</span><span class="s3">, </span><span class="s1">[req])</span>

    <span class="s3">def </span><span class="s1">test_adapter_hook_super_unwraps(self):</span>
        <span class="s1">_f_called_with = []</span>
        <span class="s3">def </span><span class="s1">_factory(context):</span>
            <span class="s1">_f_called_with.append(context)</span>
            <span class="s3">return </span><span class="s1">context</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name=</span><span class="s5">''</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">_factory</span>
        <span class="s1">required = super(LookupBaseFallbackTests</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s1">provided = object()</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">adapted = lb.adapter_hook(provided</span><span class="s3">, </span><span class="s1">required)</span>
        <span class="s1">self.assertIs(adapted</span><span class="s3">, </span><span class="s1">self)</span>
        <span class="s1">self.assertEqual(_f_called_with</span><span class="s3">, </span><span class="s1">[self])</span>

    <span class="s3">def </span><span class="s1">test_queryAdapter(self):</span>
        <span class="s1">_f_called_with = []</span>
        <span class="s1">_adapter = object()</span>
        <span class="s3">def </span><span class="s1">_factory(context):</span>
            <span class="s1">_f_called_with.append(context)</span>
            <span class="s3">return </span><span class="s1">_adapter</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s3">return </span><span class="s1">_factory</span>
        <span class="s1">req</span><span class="s3">, </span><span class="s1">prv</span><span class="s3">, </span><span class="s1">_default = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">lb = self._makeOne(uc_lookup=_lookup)</span>
        <span class="s1">adapted = lb.queryAdapter(req</span><span class="s3">, </span><span class="s1">prv</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(adapted</span><span class="s3">, </span><span class="s1">_adapter)</span>
        <span class="s1">self.assertEqual(_f_called_with</span><span class="s3">, </span><span class="s1">[req])</span>

    <span class="s3">def </span><span class="s1">test_lookupAll_uncached(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">_results = [object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()]</span>
        <span class="s3">def </span><span class="s1">_lookupAll(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided))</span>
            <span class="s3">return </span><span class="s1">tuple(_results)</span>
        <span class="s1">lb = self._makeOne(uc_lookupAll=_lookupAll)</span>
        <span class="s1">found = lb.lookupAll(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(found</span><span class="s3">, </span><span class="s1">tuple(_results))</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)])</span>

    <span class="s3">def </span><span class="s1">test_lookupAll_cached(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">_results = [object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()]</span>
        <span class="s3">def </span><span class="s1">_lookupAll(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided))</span>
            <span class="s3">return </span><span class="s1">tuple(_results)</span>
        <span class="s1">lb = self._makeOne(uc_lookupAll=_lookupAll)</span>
        <span class="s1">found = lb.lookupAll(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)</span>
        <span class="s1">found = lb.lookupAll(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(found</span><span class="s3">, </span><span class="s1">tuple(_results))</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)])</span>

    <span class="s3">def </span><span class="s1">test_subscriptions_uncached(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">_results = [object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()]</span>
        <span class="s3">def </span><span class="s1">_subscriptions(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided))</span>
            <span class="s3">return </span><span class="s1">tuple(_results)</span>
        <span class="s1">lb = self._makeOne(uc_subscriptions=_subscriptions)</span>
        <span class="s1">found = lb.subscriptions(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(found</span><span class="s3">, </span><span class="s1">tuple(_results))</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)])</span>

    <span class="s3">def </span><span class="s1">test_subscriptions_cached(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">_results = [object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()]</span>
        <span class="s3">def </span><span class="s1">_subscriptions(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided))</span>
            <span class="s3">return </span><span class="s1">tuple(_results)</span>
        <span class="s1">lb = self._makeOne(uc_subscriptions=_subscriptions)</span>
        <span class="s1">found = lb.subscriptions(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)</span>
        <span class="s1">found = lb.subscriptions(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(found</span><span class="s3">, </span><span class="s1">tuple(_results))</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)])</span>


<span class="s3">class </span><span class="s1">LookupBaseTests(LookupBaseFallbackTests</span><span class="s3">,</span>
                      <span class="s1">OptimizationTestMixin):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">LookupBase</span>
        <span class="s3">return </span><span class="s1">LookupBase</span>


<span class="s3">class </span><span class="s1">VerifyingBaseFallbackTests(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getFallbackClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">VerifyingBaseFallback </span><span class="s0"># pylint:disable=no-name-in-module</span>
        <span class="s3">return </span><span class="s1">VerifyingBaseFallback</span>

    <span class="s1">_getTargetClass = _getFallbackClass</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">registry</span><span class="s3">, </span><span class="s1">uc_lookup=</span><span class="s3">None, </span><span class="s1">uc_lookupAll=</span><span class="s3">None,</span>
                 <span class="s1">uc_subscriptions=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># pylint:disable=function-redefined</span>
        <span class="s3">if </span><span class="s1">uc_lookup </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">def </span><span class="s1">uc_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError()</span>
        <span class="s3">if </span><span class="s1">uc_lookupAll </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">def </span><span class="s1">uc_lookupAll(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided):</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError()</span>
        <span class="s3">if </span><span class="s1">uc_subscriptions </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">def </span><span class="s1">uc_subscriptions(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided):</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError()</span>
        <span class="s3">class </span><span class="s1">Derived(self._getTargetClass()):</span>
            <span class="s1">_uncached_lookup = uc_lookup</span>
            <span class="s1">_uncached_lookupAll = uc_lookupAll</span>
            <span class="s1">_uncached_subscriptions = uc_subscriptions</span>
            <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">registry):</span>
                <span class="s1">super(Derived</span><span class="s3">, </span><span class="s1">self).__init__()</span>
                <span class="s1">self._registry = registry</span>
        <span class="s1">derived = Derived(registry)</span>
        <span class="s1">derived.changed(derived) </span><span class="s0"># init. '_verify_ro' / '_verify_generations'</span>
        <span class="s3">return </span><span class="s1">derived</span>

    <span class="s3">def </span><span class="s1">_makeRegistry(self</span><span class="s3">, </span><span class="s1">depth):</span>
        <span class="s3">class </span><span class="s1">WithGeneration(object):</span>
            <span class="s1">_generation = </span><span class="s4">1</span>
        <span class="s3">class </span><span class="s1">Registry:</span>
            <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">depth):</span>
                <span class="s1">self.ro = [WithGeneration() </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(depth)]</span>
        <span class="s3">return </span><span class="s1">Registry(depth)</span>

    <span class="s3">def </span><span class="s1">test_lookup(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">_results = [a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c]</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>
            <span class="s3">return </span><span class="s1">_results.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">reg = self._makeRegistry(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(reg</span><span class="s3">, </span><span class="s1">uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>
        <span class="s1">self.assertEqual(_results</span><span class="s3">, </span><span class="s1">[b</span><span class="s3">, </span><span class="s1">c])</span>
        <span class="s1">reg.ro[</span><span class="s4">1</span><span class="s1">]._generation += </span><span class="s4">1</span>
        <span class="s1">found = lb.lookup((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">b)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">,</span>
                         <span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>
        <span class="s1">self.assertEqual(_results</span><span class="s3">, </span><span class="s1">[c])</span>

    <span class="s3">def </span><span class="s1">test_lookup1(self):</span>
        <span class="s1">_called_with = []</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">_results = [a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c]</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">_called_with.append((required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name))</span>
            <span class="s3">return </span><span class="s1">_results.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">reg = self._makeRegistry(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(reg</span><span class="s3">, </span><span class="s1">uc_lookup=_lookup)</span>
        <span class="s1">found = lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">found = lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>
        <span class="s1">self.assertEqual(_results</span><span class="s3">, </span><span class="s1">[b</span><span class="s3">, </span><span class="s1">c])</span>
        <span class="s1">reg.ro[</span><span class="s4">1</span><span class="s1">]._generation += </span><span class="s4">1</span>
        <span class="s1">found = lb.lookup1(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span>
        <span class="s1">self.assertIs(found</span><span class="s3">, </span><span class="s1">b)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">,</span>
                         <span class="s1">[((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">((</span><span class="s5">'A'</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">, </span><span class="s5">'C'</span><span class="s1">)])</span>
        <span class="s1">self.assertEqual(_results</span><span class="s3">, </span><span class="s1">[c])</span>

    <span class="s3">def </span><span class="s1">test_adapter_hook(self):</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">_c = [object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()]</span>
        <span class="s3">def </span><span class="s1">_factory1(context):</span>
            <span class="s3">return </span><span class="s1">a</span>
        <span class="s3">def </span><span class="s1">_factory2(context):</span>
            <span class="s3">return </span><span class="s1">b</span>
        <span class="s3">def </span><span class="s1">_factory3(context):</span>
            <span class="s1">self.fail(</span><span class="s5">&quot;This should never be called&quot;</span><span class="s1">)</span>
        <span class="s1">_factories = [_factory1</span><span class="s3">, </span><span class="s1">_factory2</span><span class="s3">, </span><span class="s1">_factory3]</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s3">return </span><span class="s1">_factories.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">req</span><span class="s3">, </span><span class="s1">prv</span><span class="s3">, </span><span class="s1">_default = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">reg = self._makeRegistry(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(reg</span><span class="s3">, </span><span class="s1">uc_lookup=_lookup)</span>
        <span class="s1">adapted = lb.adapter_hook(prv</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(adapted</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">adapted = lb.adapter_hook(prv</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(adapted</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">reg.ro[</span><span class="s4">1</span><span class="s1">]._generation += </span><span class="s4">1</span>
        <span class="s1">adapted = lb.adapter_hook(prv</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(adapted</span><span class="s3">, </span><span class="s1">b)</span>

    <span class="s3">def </span><span class="s1">test_queryAdapter(self):</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">_c = [object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()]</span>
        <span class="s3">def </span><span class="s1">_factory1(context):</span>
            <span class="s3">return </span><span class="s1">a</span>
        <span class="s3">def </span><span class="s1">_factory2(context):</span>
            <span class="s3">return </span><span class="s1">b</span>
        <span class="s3">def </span><span class="s1">_factory3(context):</span>
            <span class="s1">self.fail(</span><span class="s5">&quot;This should never be called&quot;</span><span class="s1">)</span>
        <span class="s1">_factories = [_factory1</span><span class="s3">, </span><span class="s1">_factory2</span><span class="s3">, </span><span class="s1">_factory3]</span>
        <span class="s3">def </span><span class="s1">_lookup(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s3">return </span><span class="s1">_factories.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">req</span><span class="s3">, </span><span class="s1">prv</span><span class="s3">, </span><span class="s1">_default = object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s1">reg = self._makeRegistry(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(reg</span><span class="s3">, </span><span class="s1">uc_lookup=_lookup)</span>
        <span class="s1">adapted = lb.queryAdapter(req</span><span class="s3">, </span><span class="s1">prv</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(adapted</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">adapted = lb.queryAdapter(req</span><span class="s3">, </span><span class="s1">prv</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(adapted</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">reg.ro[</span><span class="s4">1</span><span class="s1">]._generation += </span><span class="s4">1</span>
        <span class="s1">adapted = lb.adapter_hook(prv</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s5">'C'</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertIs(adapted</span><span class="s3">, </span><span class="s1">b)</span>

    <span class="s3">def </span><span class="s1">test_lookupAll(self):</span>
        <span class="s1">_results_1 = [object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()]</span>
        <span class="s1">_results_2 = [object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()]</span>
        <span class="s1">_results = [_results_1</span><span class="s3">, </span><span class="s1">_results_2]</span>
        <span class="s3">def </span><span class="s1">_lookupAll(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided):</span>
            <span class="s3">return </span><span class="s1">tuple(_results.pop(</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">reg = self._makeRegistry(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(reg</span><span class="s3">, </span><span class="s1">uc_lookupAll=_lookupAll)</span>
        <span class="s1">found = lb.lookupAll(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(found</span><span class="s3">, </span><span class="s1">tuple(_results_1))</span>
        <span class="s1">found = lb.lookupAll(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(found</span><span class="s3">, </span><span class="s1">tuple(_results_1))</span>
        <span class="s1">reg.ro[</span><span class="s4">1</span><span class="s1">]._generation += </span><span class="s4">1</span>
        <span class="s1">found = lb.lookupAll(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(found</span><span class="s3">, </span><span class="s1">tuple(_results_2))</span>

    <span class="s3">def </span><span class="s1">test_subscriptions(self):</span>
        <span class="s1">_results_1 = [object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()]</span>
        <span class="s1">_results_2 = [object()</span><span class="s3">, </span><span class="s1">object()</span><span class="s3">, </span><span class="s1">object()]</span>
        <span class="s1">_results = [_results_1</span><span class="s3">, </span><span class="s1">_results_2]</span>
        <span class="s3">def </span><span class="s1">_subscriptions(self</span><span class="s3">, </span><span class="s1">required</span><span class="s3">, </span><span class="s1">provided):</span>
            <span class="s3">return </span><span class="s1">tuple(_results.pop(</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">reg = self._makeRegistry(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">lb = self._makeOne(reg</span><span class="s3">, </span><span class="s1">uc_subscriptions=_subscriptions)</span>
        <span class="s1">found = lb.subscriptions(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(found</span><span class="s3">, </span><span class="s1">tuple(_results_1))</span>
        <span class="s1">found = lb.subscriptions(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(found</span><span class="s3">, </span><span class="s1">tuple(_results_1))</span>
        <span class="s1">reg.ro[</span><span class="s4">1</span><span class="s1">]._generation += </span><span class="s4">1</span>
        <span class="s1">found = lb.subscriptions(</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(found</span><span class="s3">, </span><span class="s1">tuple(_results_2))</span>


<span class="s3">class </span><span class="s1">VerifyingBaseTests(VerifyingBaseFallbackTests</span><span class="s3">,</span>
                         <span class="s1">OptimizationTestMixin):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">VerifyingBase</span>
        <span class="s3">return </span><span class="s1">VerifyingBase</span>


<span class="s3">class </span><span class="s1">AdapterLookupBaseTests(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">AdapterLookupBase</span>
        <span class="s3">return </span><span class="s1">AdapterLookupBase</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">registry):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(registry)</span>

    <span class="s3">def </span><span class="s1">_makeSubregistry(self</span><span class="s3">, </span><span class="s1">*provided):</span>
        <span class="s3">class </span><span class="s1">Subregistry:</span>
            <span class="s3">def </span><span class="s1">__init__(self):</span>
                <span class="s1">self._adapters = []</span>
                <span class="s1">self._subscribers = []</span>
        <span class="s3">return </span><span class="s1">Subregistry()</span>

    <span class="s3">def </span><span class="s1">_makeRegistry(self</span><span class="s3">, </span><span class="s1">*provided):</span>
        <span class="s3">class </span><span class="s1">Registry:</span>
            <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">provided):</span>
                <span class="s1">self._provided = provided</span>
                <span class="s1">self.ro = []</span>
        <span class="s3">return </span><span class="s1">Registry(provided)</span>

    <span class="s3">def </span><span class="s1">test_ctor_empty_registry(self):</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">self.assertEqual(alb._extendors</span><span class="s3">, </span><span class="s1">{})</span>

    <span class="s3">def </span><span class="s1">test_ctor_w_registry_provided(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">self.assertEqual(sorted(alb._extendors.keys())</span><span class="s3">,</span>
                         <span class="s1">sorted([IBar</span><span class="s3">, </span><span class="s1">IFoo</span><span class="s3">, </span><span class="s1">Interface]))</span>
        <span class="s1">self.assertEqual(alb._extendors[IFoo]</span><span class="s3">, </span><span class="s1">[IFoo</span><span class="s3">, </span><span class="s1">IBar])</span>
        <span class="s1">self.assertEqual(alb._extendors[IBar]</span><span class="s3">, </span><span class="s1">[IBar])</span>
        <span class="s1">self.assertEqual(sorted(alb._extendors[Interface])</span><span class="s3">,</span>
                         <span class="s1">sorted([IFoo</span><span class="s3">, </span><span class="s1">IBar]))</span>

    <span class="s3">def </span><span class="s1">test_changed_empty_required(self):</span>
        <span class="s0"># ALB.changed expects to call a mixed in changed.</span>
        <span class="s3">class </span><span class="s1">Mixin(object):</span>
            <span class="s3">def </span><span class="s1">changed(self</span><span class="s3">, </span><span class="s1">*other):</span>
                <span class="s3">pass</span>
        <span class="s3">class </span><span class="s1">Derived(self._getTargetClass()</span><span class="s3">, </span><span class="s1">Mixin):</span>
            <span class="s3">pass</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">alb = Derived(registry)</span>
        <span class="s1">alb.changed(alb)</span>

    <span class="s3">def </span><span class="s1">test_changed_w_required(self):</span>
        <span class="s0"># ALB.changed expects to call a mixed in changed.</span>
        <span class="s3">class </span><span class="s1">Mixin(object):</span>
            <span class="s3">def </span><span class="s1">changed(self</span><span class="s3">, </span><span class="s1">*other):</span>
                <span class="s3">pass</span>
        <span class="s3">class </span><span class="s1">Derived(self._getTargetClass()</span><span class="s3">, </span><span class="s1">Mixin):</span>
            <span class="s3">pass</span>
        <span class="s3">class </span><span class="s1">FauxWeakref(object):</span>
            <span class="s1">_unsub = </span><span class="s3">None</span>
            <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">here):</span>
                <span class="s1">self._here = here</span>
            <span class="s3">def </span><span class="s1">__call__(self):</span>
                <span class="s3">return </span><span class="s1">self </span><span class="s3">if </span><span class="s1">self._here </span><span class="s3">else None</span>
            <span class="s3">def </span><span class="s1">unsubscribe(self</span><span class="s3">, </span><span class="s1">target):</span>
                <span class="s1">self._unsub = target</span>
        <span class="s1">gone = FauxWeakref(</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">here = FauxWeakref(</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">alb = Derived(registry)</span>
        <span class="s1">alb._required[gone] = </span><span class="s4">1</span>
        <span class="s1">alb._required[here] = </span><span class="s4">1</span>
        <span class="s1">alb.changed(alb)</span>
        <span class="s1">self.assertEqual(len(alb._required)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(gone._unsub</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(here._unsub</span><span class="s3">, </span><span class="s1">alb)</span>

    <span class="s3">def </span><span class="s1">test_init_extendors_after_registry_update(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">registry._provided = [IFoo</span><span class="s3">, </span><span class="s1">IBar]</span>
        <span class="s1">alb.init_extendors()</span>
        <span class="s1">self.assertEqual(sorted(alb._extendors.keys())</span><span class="s3">,</span>
                         <span class="s1">sorted([IBar</span><span class="s3">, </span><span class="s1">IFoo</span><span class="s3">, </span><span class="s1">Interface]))</span>
        <span class="s1">self.assertEqual(alb._extendors[IFoo]</span><span class="s3">, </span><span class="s1">[IFoo</span><span class="s3">, </span><span class="s1">IBar])</span>
        <span class="s1">self.assertEqual(alb._extendors[IBar]</span><span class="s3">, </span><span class="s1">[IBar])</span>
        <span class="s1">self.assertEqual(sorted(alb._extendors[Interface])</span><span class="s3">,</span>
                         <span class="s1">sorted([IFoo</span><span class="s3">, </span><span class="s1">IBar]))</span>

    <span class="s3">def </span><span class="s1">test_add_extendor(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">alb.add_extendor(IFoo)</span>
        <span class="s1">alb.add_extendor(IBar)</span>
        <span class="s1">self.assertEqual(sorted(alb._extendors.keys())</span><span class="s3">,</span>
                         <span class="s1">sorted([IBar</span><span class="s3">, </span><span class="s1">IFoo</span><span class="s3">, </span><span class="s1">Interface]))</span>
        <span class="s1">self.assertEqual(alb._extendors[IFoo]</span><span class="s3">, </span><span class="s1">[IFoo</span><span class="s3">, </span><span class="s1">IBar])</span>
        <span class="s1">self.assertEqual(alb._extendors[IBar]</span><span class="s3">, </span><span class="s1">[IBar])</span>
        <span class="s1">self.assertEqual(sorted(alb._extendors[Interface])</span><span class="s3">,</span>
                         <span class="s1">sorted([IFoo</span><span class="s3">, </span><span class="s1">IBar]))</span>

    <span class="s3">def </span><span class="s1">test_remove_extendor(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">alb.remove_extendor(IFoo)</span>
        <span class="s1">self.assertEqual(sorted(alb._extendors.keys())</span><span class="s3">,</span>
                         <span class="s1">sorted([IFoo</span><span class="s3">, </span><span class="s1">IBar</span><span class="s3">, </span><span class="s1">Interface]))</span>
        <span class="s1">self.assertEqual(alb._extendors[IFoo]</span><span class="s3">, </span><span class="s1">[IBar])</span>
        <span class="s1">self.assertEqual(alb._extendors[IBar]</span><span class="s3">, </span><span class="s1">[IBar])</span>
        <span class="s1">self.assertEqual(sorted(alb._extendors[Interface])</span><span class="s3">,</span>
                         <span class="s1">sorted([IBar]))</span>

    <span class="s0"># test '_subscribe' via its callers, '_uncached_lookup', etc.</span>

    <span class="s3">def </span><span class="s1">test__uncached_lookup_empty_ro(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">result = alb._uncached_lookup((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(alb._required)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertIn(IFoo.weakref()</span><span class="s3">, </span><span class="s1">alb._required)</span>

    <span class="s3">def </span><span class="s1">test__uncached_lookup_order_miss(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">result = alb._uncached_lookup((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__uncached_lookup_extendors_miss(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">subr._adapters = [{}</span><span class="s3">, </span><span class="s1">{}] </span><span class="s0">#utilities, single adapters</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_lookup((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__uncached_lookup_components_miss_wrong_iface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">IQux = InterfaceClass(</span><span class="s5">'IQux'</span><span class="s1">)</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">irrelevant = object()</span>
        <span class="s1">subr._adapters = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IQux: {</span><span class="s5">''</span><span class="s1">: irrelevant}</span><span class="s3">,</span>
                   <span class="s1">}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_lookup((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__uncached_lookup_components_miss_wrong_name(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>

        <span class="s1">wrongname = object()</span>
        <span class="s1">subr._adapters = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IBar: {</span><span class="s5">'wrongname'</span><span class="s1">: wrongname}</span><span class="s3">,</span>
                   <span class="s1">}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_lookup((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test__uncached_lookup_simple_hit(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">_expected = object()</span>
        <span class="s1">subr._adapters = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IBar: {</span><span class="s5">''</span><span class="s1">: _expected}}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_lookup((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertIs(result</span><span class="s3">, </span><span class="s1">_expected)</span>

    <span class="s3">def </span><span class="s1">test__uncached_lookup_repeated_hit(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">_expected = object()</span>
        <span class="s1">subr._adapters = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IBar: {</span><span class="s5">''</span><span class="s1">: _expected}}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_lookup((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">result2 = alb._uncached_lookup((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertIs(result</span><span class="s3">, </span><span class="s1">_expected)</span>
        <span class="s1">self.assertIs(result2</span><span class="s3">, </span><span class="s1">_expected)</span>

    <span class="s3">def </span><span class="s1">test_queryMultiAdaptor_lookup_miss(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">subr._adapters = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">alb.lookup = alb._uncached_lookup </span><span class="s0"># provided by derived</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">_default = object()</span>
        <span class="s1">result = alb.queryMultiAdapter((foo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar</span><span class="s3">, </span><span class="s1">default=_default)</span>
        <span class="s1">self.assertIs(result</span><span class="s3">, </span><span class="s1">_default)</span>

    <span class="s3">def </span><span class="s1">test_queryMultiAdapter_errors_on_attribute_access(self):</span>
        <span class="s0"># Any error on attribute access previously lead to using the _empty singleton as &quot;requires&quot;</span>
        <span class="s0"># argument (See https://github.com/zopefoundation/zope.interface/issues/162)</span>
        <span class="s0"># but after https://github.com/zopefoundation/zope.interface/issues/200</span>
        <span class="s0"># they get propagated.</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s3">from </span><span class="s1">zope.interface.tests </span><span class="s3">import </span><span class="s1">MissingSomeAttrs</span>

        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">alb.lookup = alb._uncached_lookup</span>

        <span class="s3">def </span><span class="s1">test(ob):</span>
            <span class="s3">return </span><span class="s1">alb.queryMultiAdapter(</span>
                <span class="s1">(ob</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">IFoo</span><span class="s3">,</span>
            <span class="s1">)</span>

        <span class="s1">PY3 = str </span><span class="s3">is not </span><span class="s1">bytes</span>
        <span class="s1">MissingSomeAttrs.test_raises(self</span><span class="s3">, </span><span class="s1">test</span><span class="s3">,</span>
                                     <span class="s1">expected_missing=</span><span class="s5">'__class__' </span><span class="s3">if </span><span class="s1">PY3 </span><span class="s3">else </span><span class="s5">'__providedBy__'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_queryMultiAdaptor_factory_miss(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">_expected = object()</span>
        <span class="s1">_called_with = []</span>
        <span class="s3">def </span><span class="s1">_factory(context):</span>
            <span class="s1">_called_with.append(context)</span>

        <span class="s1">subr._adapters = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IBar: {</span><span class="s5">''</span><span class="s1">: _factory}}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">alb.lookup = alb._uncached_lookup </span><span class="s0"># provided by derived</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">_default = object()</span>
        <span class="s1">result = alb.queryMultiAdapter((foo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar</span><span class="s3">, </span><span class="s1">default=_default)</span>
        <span class="s1">self.assertIs(result</span><span class="s3">, </span><span class="s1">_default)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[foo])</span>

    <span class="s3">def </span><span class="s1">test_queryMultiAdaptor_factory_hit(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">_expected = object()</span>
        <span class="s1">_called_with = []</span>
        <span class="s3">def </span><span class="s1">_factory(context):</span>
            <span class="s1">_called_with.append(context)</span>
            <span class="s3">return </span><span class="s1">_expected</span>
        <span class="s1">subr._adapters = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IBar: {</span><span class="s5">''</span><span class="s1">: _factory}}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">alb.lookup = alb._uncached_lookup </span><span class="s0"># provided by derived</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">_default = object()</span>
        <span class="s1">result = alb.queryMultiAdapter((foo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar</span><span class="s3">, </span><span class="s1">default=_default)</span>
        <span class="s1">self.assertIs(result</span><span class="s3">, </span><span class="s1">_expected)</span>
        <span class="s1">self.assertEqual(_called_with</span><span class="s3">, </span><span class="s1">[foo])</span>

    <span class="s3">def </span><span class="s1">test_queryMultiAdapter_super_unwraps(self):</span>
        <span class="s1">alb = self._makeOne(self._makeRegistry())</span>
        <span class="s3">def </span><span class="s1">lookup(*args):</span>
            <span class="s3">return </span><span class="s1">factory</span>
        <span class="s3">def </span><span class="s1">factory(*args):</span>
            <span class="s3">return </span><span class="s1">args</span>
        <span class="s1">alb.lookup = lookup</span>

        <span class="s1">objects = [</span>
            <span class="s1">super(AdapterLookupBaseTests</span><span class="s3">, </span><span class="s1">self)</span><span class="s3">,</span>
            <span class="s4">42</span><span class="s3">,</span>
            <span class="s5">&quot;abc&quot;</span><span class="s3">,</span>
            <span class="s1">super(AdapterLookupBaseTests</span><span class="s3">, </span><span class="s1">self)</span><span class="s3">,</span>
        <span class="s1">]</span>

        <span class="s1">result = alb.queryMultiAdapter(objects</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, </span><span class="s1">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s4">42</span><span class="s3">,</span>
            <span class="s5">&quot;abc&quot;</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">))</span>

    <span class="s3">def </span><span class="s1">test__uncached_lookupAll_empty_ro(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">result = alb._uncached_lookupAll((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, </span><span class="s1">())</span>
        <span class="s1">self.assertEqual(len(alb._required)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertIn(IFoo.weakref()</span><span class="s3">, </span><span class="s1">alb._required)</span>

    <span class="s3">def </span><span class="s1">test__uncached_lookupAll_order_miss(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_lookupAll((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, </span><span class="s1">())</span>

    <span class="s3">def </span><span class="s1">test__uncached_lookupAll_extendors_miss(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">subr._adapters = [{}</span><span class="s3">, </span><span class="s1">{}] </span><span class="s0">#utilities, single adapters</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_lookupAll((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, </span><span class="s1">())</span>

    <span class="s3">def </span><span class="s1">test__uncached_lookupAll_components_miss(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">IQux = InterfaceClass(</span><span class="s5">'IQux'</span><span class="s1">)</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">irrelevant = object()</span>
        <span class="s1">subr._adapters = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IQux: {</span><span class="s5">''</span><span class="s1">: irrelevant}}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_lookupAll((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, </span><span class="s1">())</span>

    <span class="s3">def </span><span class="s1">test__uncached_lookupAll_simple_hit(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">_expected = object()</span>
        <span class="s1">_named = object()</span>
        <span class="s1">subr._adapters = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IBar: {</span><span class="s5">''</span><span class="s1">: _expected</span><span class="s3">, </span><span class="s5">'named'</span><span class="s1">: _named}}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_lookupAll((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(sorted(result)</span><span class="s3">, </span><span class="s1">[(</span><span class="s5">''</span><span class="s3">, </span><span class="s1">_expected)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">'named'</span><span class="s3">, </span><span class="s1">_named)])</span>

    <span class="s3">def </span><span class="s1">test_names(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">_expected = object()</span>
        <span class="s1">_named = object()</span>
        <span class="s1">subr._adapters = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IBar: {</span><span class="s5">''</span><span class="s1">: _expected</span><span class="s3">, </span><span class="s5">'named'</span><span class="s1">: _named}}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">alb.lookupAll = alb._uncached_lookupAll</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb.names((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(sorted(result)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">''</span><span class="s3">, </span><span class="s5">'named'</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test__uncached_subscriptions_empty_ro(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">result = alb._uncached_subscriptions((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s1">self.assertEqual(len(alb._required)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertIn(IFoo.weakref()</span><span class="s3">, </span><span class="s1">alb._required)</span>

    <span class="s3">def </span><span class="s1">test__uncached_subscriptions_order_miss(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_subscriptions((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test__uncached_subscriptions_extendors_miss(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry()</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">subr._subscribers = [{}</span><span class="s3">, </span><span class="s1">{}] </span><span class="s0">#utilities, single adapters</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_subscriptions((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test__uncached_subscriptions_components_miss_wrong_iface(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">IQux = InterfaceClass(</span><span class="s5">'IQux'</span><span class="s1">)</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">irrelevant = object()</span>
        <span class="s1">subr._subscribers = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IQux: {</span><span class="s5">''</span><span class="s1">: irrelevant}}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_subscriptions((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test__uncached_subscriptions_components_miss_wrong_name(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">wrongname = object()</span>
        <span class="s1">subr._subscribers = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IBar: {</span><span class="s5">'wrongname'</span><span class="s1">: wrongname}}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_subscriptions((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">test__uncached_subscriptions_simple_hit(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
                <span class="s3">return True</span>
        <span class="s1">_exp1</span><span class="s3">, </span><span class="s1">_exp2 = Foo()</span><span class="s3">, </span><span class="s1">Foo()</span>
        <span class="s1">subr._subscribers = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IBar: {</span><span class="s5">''</span><span class="s1">: (_exp1</span><span class="s3">, </span><span class="s1">_exp2)}}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb._uncached_subscriptions((IFoo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(sorted(result)</span><span class="s3">, </span><span class="s1">sorted([_exp1</span><span class="s3">, </span><span class="s1">_exp2]))</span>

    <span class="s3">def </span><span class="s1">test_subscribers_wo_provided(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">_called = {}</span>
        <span class="s3">def </span><span class="s1">_factory1(context):</span>
            <span class="s1">_called.setdefault(</span><span class="s5">'_factory1'</span><span class="s3">, </span><span class="s1">[]).append(context)</span>
        <span class="s3">def </span><span class="s1">_factory2(context):</span>
            <span class="s1">_called.setdefault(</span><span class="s5">'_factory2'</span><span class="s3">, </span><span class="s1">[]).append(context)</span>
        <span class="s1">subr._subscribers = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {</span><span class="s3">None</span><span class="s1">: {</span><span class="s5">''</span><span class="s1">: (_factory1</span><span class="s3">, </span><span class="s1">_factory2)}}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">alb.subscriptions = alb._uncached_subscriptions</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb.subscribers((foo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, </span><span class="s1">())</span>
        <span class="s1">self.assertEqual(_called</span><span class="s3">, </span><span class="s1">{</span><span class="s5">'_factory1'</span><span class="s1">: [foo]</span><span class="s3">, </span><span class="s5">'_factory2'</span><span class="s1">: [foo]})</span>

    <span class="s3">def </span><span class="s1">test_subscribers_w_provided(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.declarations </span><span class="s3">import </span><span class="s1">implementer</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">InterfaceClass</span>
        <span class="s1">IFoo = InterfaceClass(</span><span class="s5">'IFoo'</span><span class="s1">)</span>
        <span class="s1">IBar = InterfaceClass(</span><span class="s5">'IBar'</span><span class="s3">, </span><span class="s1">(IFoo</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">@implementer(IFoo)</span>
        <span class="s3">class </span><span class="s1">Foo(object):</span>
            <span class="s3">pass</span>
        <span class="s1">foo = Foo()</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">registry = self._makeRegistry(IFoo</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">subr = self._makeSubregistry()</span>
        <span class="s1">_called = {}</span>
        <span class="s1">_exp1</span><span class="s3">, </span><span class="s1">_exp2 = object()</span><span class="s3">, </span><span class="s1">object()</span>
        <span class="s3">def </span><span class="s1">_factory1(context):</span>
            <span class="s1">_called.setdefault(</span><span class="s5">'_factory1'</span><span class="s3">, </span><span class="s1">[]).append(context)</span>
            <span class="s3">return </span><span class="s1">_exp1</span>
        <span class="s3">def </span><span class="s1">_factory2(context):</span>
            <span class="s1">_called.setdefault(</span><span class="s5">'_factory2'</span><span class="s3">, </span><span class="s1">[]).append(context)</span>
            <span class="s3">return </span><span class="s1">_exp2</span>
        <span class="s3">def </span><span class="s1">_side_effect_only(context):</span>
            <span class="s1">_called.setdefault(</span><span class="s5">'_side_effect_only'</span><span class="s3">, </span><span class="s1">[]).append(context)</span>

        <span class="s1">subr._subscribers = [ </span><span class="s0">#utilities, single adapters</span>
            <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">{IFoo: {IBar: {</span><span class="s5">''</span><span class="s1">: (_factory1</span><span class="s3">, </span><span class="s1">_factory2</span><span class="s3">, </span><span class="s1">_side_effect_only)}}}</span><span class="s3">,</span>
        <span class="s1">]</span>
        <span class="s1">registry.ro.append(subr)</span>
        <span class="s1">alb = self._makeOne(registry)</span>
        <span class="s1">alb.subscriptions = alb._uncached_subscriptions</span>
        <span class="s1">subr._v_lookup = alb</span>
        <span class="s1">result = alb.subscribers((foo</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">IBar)</span>
        <span class="s1">self.assertEqual(result</span><span class="s3">, </span><span class="s1">[_exp1</span><span class="s3">, </span><span class="s1">_exp2])</span>
        <span class="s1">self.assertEqual(_called</span><span class="s3">,</span>
                         <span class="s1">{</span><span class="s5">'_factory1'</span><span class="s1">: [foo]</span><span class="s3">,</span>
                          <span class="s5">'_factory2'</span><span class="s1">: [foo]</span><span class="s3">,</span>
                          <span class="s5">'_side_effect_only'</span><span class="s1">: [foo]</span><span class="s3">,</span>
                         <span class="s1">})</span>


<span class="s3">class </span><span class="s1">VerifyingAdapterRegistryTests(unittest.TestCase):</span>
    <span class="s0"># This is also the base for AdapterRegistryTests. That makes the</span>
    <span class="s0"># inheritance seems backwards, but even though they implement the</span>
    <span class="s0"># same interfaces, VAR and AR each only extend BAR; and neither</span>
    <span class="s0"># one will pass the test cases for BAR (it uses a special</span>
    <span class="s0"># LookupClass just for the tests).</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">VerifyingAdapterRegistry</span>
        <span class="s3">return </span><span class="s1">VerifyingAdapterRegistry</span>

    <span class="s3">def </span><span class="s1">_makeOne(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._getTargetClass()(*args</span><span class="s3">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">test_verify_object_provides_IAdapterRegistry(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.verify </span><span class="s3">import </span><span class="s1">verifyObject</span>
        <span class="s3">from </span><span class="s1">zope.interface.interfaces </span><span class="s3">import </span><span class="s1">IAdapterRegistry</span>
        <span class="s1">registry = self._makeOne()</span>
        <span class="s1">verifyObject(IAdapterRegistry</span><span class="s3">, </span><span class="s1">registry)</span>


<span class="s3">class </span><span class="s1">AdapterRegistryTests(VerifyingAdapterRegistryTests):</span>

    <span class="s3">def </span><span class="s1">_getTargetClass(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">AdapterRegistry</span>
        <span class="s3">return </span><span class="s1">AdapterRegistry</span>

    <span class="s3">def </span><span class="s1">test_ctor_no_bases(self):</span>
        <span class="s1">ar = self._makeOne()</span>
        <span class="s1">self.assertEqual(len(ar._v_subregistries)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_ctor_w_bases(self):</span>
        <span class="s1">base = self._makeOne()</span>
        <span class="s1">sub = self._makeOne([base])</span>
        <span class="s1">self.assertEqual(len(sub._v_subregistries)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(base._v_subregistries)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertIn(sub</span><span class="s3">, </span><span class="s1">base._v_subregistries)</span>

    <span class="s0"># test _addSubregistry / _removeSubregistry via only caller, _setBases</span>

    <span class="s3">def </span><span class="s1">test__setBases_removing_existing_subregistry(self):</span>
        <span class="s1">before = self._makeOne()</span>
        <span class="s1">after = self._makeOne()</span>
        <span class="s1">sub = self._makeOne([before])</span>
        <span class="s1">sub.__bases__ = [after]</span>
        <span class="s1">self.assertEqual(len(before._v_subregistries)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(after._v_subregistries)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertIn(sub</span><span class="s3">, </span><span class="s1">after._v_subregistries)</span>

    <span class="s3">def </span><span class="s1">test__setBases_wo_stray_entry(self):</span>
        <span class="s1">before = self._makeOne()</span>
        <span class="s1">stray = self._makeOne()</span>
        <span class="s1">after = self._makeOne()</span>
        <span class="s1">sub = self._makeOne([before])</span>
        <span class="s1">sub.__dict__[</span><span class="s5">'__bases__'</span><span class="s1">].append(stray)</span>
        <span class="s1">sub.__bases__ = [after]</span>
        <span class="s1">self.assertEqual(len(before._v_subregistries)</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(after._v_subregistries)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertIn(sub</span><span class="s3">, </span><span class="s1">after._v_subregistries)</span>

    <span class="s3">def </span><span class="s1">test__setBases_w_existing_entry_continuing(self):</span>
        <span class="s1">before = self._makeOne()</span>
        <span class="s1">after = self._makeOne()</span>
        <span class="s1">sub = self._makeOne([before])</span>
        <span class="s1">sub.__bases__ = [before</span><span class="s3">, </span><span class="s1">after]</span>
        <span class="s1">self.assertEqual(len(before._v_subregistries)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(after._v_subregistries)</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.assertIn(sub</span><span class="s3">, </span><span class="s1">before._v_subregistries)</span>
        <span class="s1">self.assertIn(sub</span><span class="s3">, </span><span class="s1">after._v_subregistries)</span>

    <span class="s3">def </span><span class="s1">test_changed_w_subregistries(self):</span>
        <span class="s1">base = self._makeOne()</span>
        <span class="s3">class </span><span class="s1">Derived(object):</span>
            <span class="s1">_changed = </span><span class="s3">None</span>
            <span class="s3">def </span><span class="s1">changed(self</span><span class="s3">, </span><span class="s1">originally_changed):</span>
                <span class="s1">self._changed = originally_changed</span>
        <span class="s1">derived1</span><span class="s3">, </span><span class="s1">derived2 = Derived()</span><span class="s3">, </span><span class="s1">Derived()</span>
        <span class="s1">base._addSubregistry(derived1)</span>
        <span class="s1">base._addSubregistry(derived2)</span>
        <span class="s1">orig = object()</span>
        <span class="s1">base.changed(orig)</span>
        <span class="s1">self.assertIs(derived1._changed</span><span class="s3">, </span><span class="s1">orig)</span>
        <span class="s1">self.assertIs(derived2._changed</span><span class="s3">, </span><span class="s1">orig)</span>


<span class="s3">class </span><span class="s1">Test_utils(unittest.TestCase):</span>

    <span class="s3">def </span><span class="s1">test__convert_None_to_Interface_w_None(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">_convert_None_to_Interface</span>
        <span class="s3">from </span><span class="s1">zope.interface.interface </span><span class="s3">import </span><span class="s1">Interface</span>
        <span class="s1">self.assertIs(_convert_None_to_Interface(</span><span class="s3">None</span><span class="s1">)</span><span class="s3">, </span><span class="s1">Interface)</span>

    <span class="s3">def </span><span class="s1">test__convert_None_to_Interface_w_other(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">_convert_None_to_Interface</span>
        <span class="s1">other = object()</span>
        <span class="s1">self.assertIs(_convert_None_to_Interface(other)</span><span class="s3">, </span><span class="s1">other)</span>

    <span class="s3">def </span><span class="s1">test__normalize_name_str(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">_normalize_name</span>
        <span class="s1">STR = </span><span class="s6">b'str'</span>
        <span class="s1">UNICODE = </span><span class="s5">u'str'</span>
        <span class="s1">norm = _normalize_name(STR)</span>
        <span class="s1">self.assertEqual(norm</span><span class="s3">, </span><span class="s1">UNICODE)</span>
        <span class="s1">self.assertIsInstance(norm</span><span class="s3">, </span><span class="s1">type(UNICODE))</span>

    <span class="s3">def </span><span class="s1">test__normalize_name_unicode(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">_normalize_name</span>

        <span class="s1">USTR = </span><span class="s5">u'ustr'</span>
        <span class="s1">self.assertEqual(_normalize_name(USTR)</span><span class="s3">, </span><span class="s1">USTR)</span>

    <span class="s3">def </span><span class="s1">test__normalize_name_other(self):</span>
        <span class="s3">from </span><span class="s1">zope.interface.adapter </span><span class="s3">import </span><span class="s1">_normalize_name</span>
        <span class="s3">for </span><span class="s1">other </span><span class="s3">in </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">()</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">object():</span>
            <span class="s1">self.assertRaises(TypeError</span><span class="s3">, </span><span class="s1">_normalize_name</span><span class="s3">, </span><span class="s1">other)</span>

    <span class="s0"># _lookup, _lookupAll, and _subscriptions tested via their callers</span>
    <span class="s0"># (AdapterLookupBase.{lookup,lookupAll,subscriptions}).</span>
</pre>
</body>
</html>