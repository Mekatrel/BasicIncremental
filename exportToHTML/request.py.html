<html>
<head>
<title>request.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
request.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Ported using Python-Future from the Python 3.3 standard library. 
 
An extensible library for opening URLs using a variety of protocols 
 
The simplest way to use this module is to call the urlopen function, 
which accepts a string containing a URL or a Request object (described 
below).  It opens the URL and returns the results as file-like 
object; the returned object has some extra methods described below. 
 
The OpenerDirector manages a collection of Handler objects that do 
all the actual work.  Each Handler implements a particular protocol or 
option.  The OpenerDirector is a composite object that invokes the 
Handlers needed to open the requested URL.  For example, the 
HTTPHandler performs HTTP GET and POST requests and deals with 
non-error returns.  The HTTPRedirectHandler automatically deals with 
HTTP 301, 302, 303 and 307 redirect errors, and the HTTPDigestAuthHandler 
deals with digest authentication. 
 
urlopen(url, data=None) -- Basic usage is the same as original 
urllib.  pass the url and optionally data to post to an HTTP URL, and 
get a file-like object back.  One difference is that you can also pass 
a Request instance instead of URL.  Raises a URLError (subclass of 
IOError); for HTTP errors, raises an HTTPError, which can also be 
treated as a valid response. 
 
build_opener -- Function that creates a new OpenerDirector instance. 
Will install the default handlers.  Accepts one or more Handlers as 
arguments, either instances or Handler classes that it will 
instantiate.  If one of the argument is a subclass of the default 
handler, the argument will be installed instead of the default. 
 
install_opener -- Installs a new opener as the default opener. 
 
objects of interest: 
 
OpenerDirector -- Sets up the User Agent as the Python-urllib client and manages 
the Handler classes, while dealing with requests and responses. 
 
Request -- An object that encapsulates the state of a request.  The 
state can be as simple as the URL.  It can also include extra HTTP 
headers, e.g. a User-Agent. 
 
BaseHandler -- 
 
internals: 
BaseHandler and parent 
_call_chain conventions 
 
Example usage: 
 
import urllib.request 
 
# set up authentication info 
authinfo = urllib.request.HTTPBasicAuthHandler() 
authinfo.add_password(realm='PDQ Application', 
                      uri='https://mahler:8092/site-updates.py', 
                      user='klem', 
                      passwd='geheim$parole') 
 
proxy_support = urllib.request.ProxyHandler({&quot;http&quot; : &quot;http://ahad-haam:3128&quot;}) 
 
# build a new opener that adds authentication and caching FTP handlers 
opener = urllib.request.build_opener(proxy_support, authinfo, 
                                     urllib.request.CacheFTPHandler) 
 
# install it 
urllib.request.install_opener(opener) 
 
f = urllib.request.urlopen('http://www.python.org/') 
&quot;&quot;&quot;</span>

<span class="s2"># XXX issues:</span>
<span class="s2"># If an authentication error handler that tries to perform</span>
<span class="s2"># authentication for some reason but fails, how should the error be</span>
<span class="s2"># signalled?  The client needs to know the HTTP error code.  But if</span>
<span class="s2"># the handler knows that the problem was, e.g., that it didn't know</span>
<span class="s2"># that hash algo that requested in the challenge, it would be good to</span>
<span class="s2"># pass that information along to the client, too.</span>
<span class="s2"># ftp errors aren't handled cleanly</span>
<span class="s2"># check digest against correct (i.e. non-apache) implementation</span>

<span class="s2"># Possible extensions:</span>
<span class="s2"># complex proxies  XXX not sure what exactly was meant by this</span>
<span class="s2"># abstract factory for opener</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">absolute_import</span><span class="s3">, </span><span class="s1">division</span><span class="s3">, </span><span class="s1">print_function</span><span class="s3">, </span><span class="s1">unicode_literals</span>
<span class="s3">from </span><span class="s1">future.builtins </span><span class="s3">import </span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">, </span><span class="s1">filter</span><span class="s3">, </span><span class="s1">input</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">map</span><span class="s3">, </span><span class="s1">open</span><span class="s3">, </span><span class="s1">str</span>
<span class="s3">from </span><span class="s1">future.utils </span><span class="s3">import </span><span class="s1">PY2</span><span class="s3">, </span><span class="s1">PY3</span><span class="s3">, </span><span class="s1">raise_with_traceback</span>

<span class="s3">import </span><span class="s1">base64</span>
<span class="s3">import </span><span class="s1">bisect</span>
<span class="s3">import </span><span class="s1">hashlib</span>
<span class="s3">import </span><span class="s1">array</span>

<span class="s3">from </span><span class="s1">future.backports </span><span class="s3">import </span><span class="s1">email</span>
<span class="s3">from </span><span class="s1">future.backports.http </span><span class="s3">import </span><span class="s1">client </span><span class="s3">as </span><span class="s1">http_client</span>
<span class="s3">from </span><span class="s1">.error </span><span class="s3">import </span><span class="s1">URLError</span><span class="s3">, </span><span class="s1">HTTPError</span><span class="s3">, </span><span class="s1">ContentTooShortError</span>
<span class="s3">from </span><span class="s1">.parse </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">urlparse</span><span class="s3">, </span><span class="s1">urlsplit</span><span class="s3">, </span><span class="s1">urljoin</span><span class="s3">, </span><span class="s1">unwrap</span><span class="s3">, </span><span class="s1">quote</span><span class="s3">, </span><span class="s1">unquote</span><span class="s3">,</span>
    <span class="s1">splittype</span><span class="s3">, </span><span class="s1">splithost</span><span class="s3">, </span><span class="s1">splitport</span><span class="s3">, </span><span class="s1">splituser</span><span class="s3">, </span><span class="s1">splitpasswd</span><span class="s3">,</span>
    <span class="s1">splitattr</span><span class="s3">, </span><span class="s1">splitquery</span><span class="s3">, </span><span class="s1">splitvalue</span><span class="s3">, </span><span class="s1">splittag</span><span class="s3">, </span><span class="s1">to_bytes</span><span class="s3">, </span><span class="s1">urlunparse)</span>
<span class="s3">from </span><span class="s1">.response </span><span class="s3">import </span><span class="s1">addinfourl</span><span class="s3">, </span><span class="s1">addclosehook</span>

<span class="s3">import </span><span class="s1">io</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">posixpath</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">socket</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">import </span><span class="s1">tempfile</span>
<span class="s3">import </span><span class="s1">contextlib</span>
<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">from </span><span class="s1">future.utils </span><span class="s3">import </span><span class="s1">PY2</span>

<span class="s3">if </span><span class="s1">PY2:</span>
    <span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">collections.abc </span><span class="s3">import </span><span class="s1">Iterable</span>

<span class="s2"># check for SSL</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">import </span><span class="s1">ssl</span>
    <span class="s2"># Not available in the SSL module in Py2:</span>
    <span class="s3">from </span><span class="s1">ssl </span><span class="s3">import </span><span class="s1">SSLContext</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s1">_have_ssl = </span><span class="s3">False</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">_have_ssl = </span><span class="s3">True</span>

<span class="s1">__all__ = [</span>
    <span class="s2"># Classes</span>
    <span class="s4">'Request'</span><span class="s3">, </span><span class="s4">'OpenerDirector'</span><span class="s3">, </span><span class="s4">'BaseHandler'</span><span class="s3">, </span><span class="s4">'HTTPDefaultErrorHandler'</span><span class="s3">,</span>
    <span class="s4">'HTTPRedirectHandler'</span><span class="s3">, </span><span class="s4">'HTTPCookieProcessor'</span><span class="s3">, </span><span class="s4">'ProxyHandler'</span><span class="s3">,</span>
    <span class="s4">'HTTPPasswordMgr'</span><span class="s3">, </span><span class="s4">'HTTPPasswordMgrWithDefaultRealm'</span><span class="s3">,</span>
    <span class="s4">'AbstractBasicAuthHandler'</span><span class="s3">, </span><span class="s4">'HTTPBasicAuthHandler'</span><span class="s3">, </span><span class="s4">'ProxyBasicAuthHandler'</span><span class="s3">,</span>
    <span class="s4">'AbstractDigestAuthHandler'</span><span class="s3">, </span><span class="s4">'HTTPDigestAuthHandler'</span><span class="s3">, </span><span class="s4">'ProxyDigestAuthHandler'</span><span class="s3">,</span>
    <span class="s4">'HTTPHandler'</span><span class="s3">, </span><span class="s4">'FileHandler'</span><span class="s3">, </span><span class="s4">'FTPHandler'</span><span class="s3">, </span><span class="s4">'CacheFTPHandler'</span><span class="s3">,</span>
    <span class="s4">'UnknownHandler'</span><span class="s3">, </span><span class="s4">'HTTPErrorProcessor'</span><span class="s3">,</span>
    <span class="s2"># Functions</span>
    <span class="s4">'urlopen'</span><span class="s3">, </span><span class="s4">'install_opener'</span><span class="s3">, </span><span class="s4">'build_opener'</span><span class="s3">,</span>
    <span class="s4">'pathname2url'</span><span class="s3">, </span><span class="s4">'url2pathname'</span><span class="s3">, </span><span class="s4">'getproxies'</span><span class="s3">,</span>
    <span class="s2"># Legacy interface</span>
    <span class="s4">'urlretrieve'</span><span class="s3">, </span><span class="s4">'urlcleanup'</span><span class="s3">, </span><span class="s4">'URLopener'</span><span class="s3">, </span><span class="s4">'FancyURLopener'</span><span class="s3">,</span>
<span class="s1">]</span>

<span class="s2"># used in User-Agent header sent</span>
<span class="s1">__version__ = sys.version[:</span><span class="s5">3</span><span class="s1">]</span>

<span class="s1">_opener = </span><span class="s3">None</span>
<span class="s3">def </span><span class="s1">urlopen(url</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">timeout=socket._GLOBAL_DEFAULT_TIMEOUT</span><span class="s3">, </span><span class="s1">**_3to2kwargs):</span>
    <span class="s3">if </span><span class="s4">'cadefault' </span><span class="s3">in </span><span class="s1">_3to2kwargs: cadefault = _3to2kwargs[</span><span class="s4">'cadefault'</span><span class="s1">]; </span><span class="s3">del </span><span class="s1">_3to2kwargs[</span><span class="s4">'cadefault'</span><span class="s1">]</span>
    <span class="s3">else</span><span class="s1">: cadefault = </span><span class="s3">False</span>
    <span class="s3">if </span><span class="s4">'capath' </span><span class="s3">in </span><span class="s1">_3to2kwargs: capath = _3to2kwargs[</span><span class="s4">'capath'</span><span class="s1">]; </span><span class="s3">del </span><span class="s1">_3to2kwargs[</span><span class="s4">'capath'</span><span class="s1">]</span>
    <span class="s3">else</span><span class="s1">: capath = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s4">'cafile' </span><span class="s3">in </span><span class="s1">_3to2kwargs: cafile = _3to2kwargs[</span><span class="s4">'cafile'</span><span class="s1">]; </span><span class="s3">del </span><span class="s1">_3to2kwargs[</span><span class="s4">'cafile'</span><span class="s1">]</span>
    <span class="s3">else</span><span class="s1">: cafile = </span><span class="s3">None</span>
    <span class="s3">global </span><span class="s1">_opener</span>
    <span class="s3">if </span><span class="s1">cafile </span><span class="s3">or </span><span class="s1">capath </span><span class="s3">or </span><span class="s1">cadefault:</span>
        <span class="s3">if not </span><span class="s1">_have_ssl:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'SSL support not available'</span><span class="s1">)</span>
        <span class="s1">context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)</span>
        <span class="s1">context.options |= ssl.OP_NO_SSLv2</span>
        <span class="s1">context.verify_mode = ssl.CERT_REQUIRED</span>
        <span class="s3">if </span><span class="s1">cafile </span><span class="s3">or </span><span class="s1">capath:</span>
            <span class="s1">context.load_verify_locations(cafile</span><span class="s3">, </span><span class="s1">capath)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">context.set_default_verify_paths()</span>
        <span class="s1">https_handler = HTTPSHandler(context=context</span><span class="s3">, </span><span class="s1">check_hostname=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">opener = build_opener(https_handler)</span>
    <span class="s3">elif </span><span class="s1">_opener </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">_opener = opener = build_opener()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">opener = _opener</span>
    <span class="s3">return </span><span class="s1">opener.open(url</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">timeout)</span>

<span class="s3">def </span><span class="s1">install_opener(opener):</span>
    <span class="s3">global </span><span class="s1">_opener</span>
    <span class="s1">_opener = opener</span>

<span class="s1">_url_tempfiles = []</span>
<span class="s3">def </span><span class="s1">urlretrieve(url</span><span class="s3">, </span><span class="s1">filename=</span><span class="s3">None, </span><span class="s1">reporthook=</span><span class="s3">None, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Retrieve a URL into a temporary location on disk. 
 
    Requires a URL argument. If a filename is passed, it is used as 
    the temporary file location. The reporthook argument should be 
    a callable that accepts a block number, a read size, and the 
    total file size of the URL target. The data argument should be 
    valid URL encoded data. 
 
    If a filename is passed and the URL points to a local resource, 
    the result is a copy from local file to new file. 
 
    Returns a tuple containing the path to the newly created 
    data file as well as the resulting HTTPMessage object. 
    &quot;&quot;&quot;</span>
    <span class="s1">url_type</span><span class="s3">, </span><span class="s1">path = splittype(url)</span>

    <span class="s3">with </span><span class="s1">contextlib.closing(urlopen(url</span><span class="s3">, </span><span class="s1">data)) </span><span class="s3">as </span><span class="s1">fp:</span>
        <span class="s1">headers = fp.info()</span>

        <span class="s2"># Just return the local path and the &quot;headers&quot; for file://</span>
        <span class="s2"># URLs. No sense in performing a copy unless requested.</span>
        <span class="s3">if </span><span class="s1">url_type == </span><span class="s4">&quot;file&quot; </span><span class="s3">and not </span><span class="s1">filename:</span>
            <span class="s3">return </span><span class="s1">os.path.normpath(path)</span><span class="s3">, </span><span class="s1">headers</span>

        <span class="s2"># Handle temporary file setup.</span>
        <span class="s3">if </span><span class="s1">filename:</span>
            <span class="s1">tfp = open(filename</span><span class="s3">, </span><span class="s4">'wb'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">tfp = tempfile.NamedTemporaryFile(delete=</span><span class="s3">False</span><span class="s1">)</span>
            <span class="s1">filename = tfp.name</span>
            <span class="s1">_url_tempfiles.append(filename)</span>

        <span class="s3">with </span><span class="s1">tfp:</span>
            <span class="s1">result = filename</span><span class="s3">, </span><span class="s1">headers</span>
            <span class="s1">bs = </span><span class="s5">1024</span><span class="s1">*</span><span class="s5">8</span>
            <span class="s1">size = -</span><span class="s5">1</span>
            <span class="s1">read = </span><span class="s5">0</span>
            <span class="s1">blocknum = </span><span class="s5">0</span>
            <span class="s3">if </span><span class="s4">&quot;content-length&quot; </span><span class="s3">in </span><span class="s1">headers:</span>
                <span class="s1">size = int(headers[</span><span class="s4">&quot;Content-Length&quot;</span><span class="s1">])</span>

            <span class="s3">if </span><span class="s1">reporthook:</span>
                <span class="s1">reporthook(blocknum</span><span class="s3">, </span><span class="s1">bs</span><span class="s3">, </span><span class="s1">size)</span>

            <span class="s3">while True</span><span class="s1">:</span>
                <span class="s1">block = fp.read(bs)</span>
                <span class="s3">if not </span><span class="s1">block:</span>
                    <span class="s3">break</span>
                <span class="s1">read += len(block)</span>
                <span class="s1">tfp.write(block)</span>
                <span class="s1">blocknum += </span><span class="s5">1</span>
                <span class="s3">if </span><span class="s1">reporthook:</span>
                    <span class="s1">reporthook(blocknum</span><span class="s3">, </span><span class="s1">bs</span><span class="s3">, </span><span class="s1">size)</span>

    <span class="s3">if </span><span class="s1">size &gt;= </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">read &lt; size:</span>
        <span class="s3">raise </span><span class="s1">ContentTooShortError(</span>
            <span class="s4">&quot;retrieval incomplete: got only %i out of %i bytes&quot;</span>
            <span class="s1">% (read</span><span class="s3">, </span><span class="s1">size)</span><span class="s3">, </span><span class="s1">result)</span>

    <span class="s3">return </span><span class="s1">result</span>

<span class="s3">def </span><span class="s1">urlcleanup():</span>
    <span class="s3">for </span><span class="s1">temp_file </span><span class="s3">in </span><span class="s1">_url_tempfiles:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">os.unlink(temp_file)</span>
        <span class="s3">except </span><span class="s1">EnvironmentError:</span>
            <span class="s3">pass</span>

    <span class="s3">del </span><span class="s1">_url_tempfiles[:]</span>
    <span class="s3">global </span><span class="s1">_opener</span>
    <span class="s3">if </span><span class="s1">_opener:</span>
        <span class="s1">_opener = </span><span class="s3">None</span>

<span class="s3">if </span><span class="s1">PY3:</span>
    <span class="s1">_cut_port_re = re.compile(</span><span class="s4">r&quot;:\d+$&quot;</span><span class="s3">, </span><span class="s1">re.ASCII)</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">_cut_port_re = re.compile(</span><span class="s4">r&quot;:\d+$&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">request_host(request):</span>

    <span class="s0">&quot;&quot;&quot;Return request-host, as defined by RFC 2965. 
 
    Variation from RFC: returned value is lowercased, for convenient 
    comparison. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">url = request.full_url</span>
    <span class="s1">host = urlparse(url)[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">host == </span><span class="s4">&quot;&quot;</span><span class="s1">:</span>
        <span class="s1">host = request.get_header(</span><span class="s4">&quot;Host&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

    <span class="s2"># remove port, if present</span>
    <span class="s1">host = _cut_port_re.sub(</span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">host.lower()</span>

<span class="s3">class </span><span class="s1">Request(object):</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">headers={}</span><span class="s3">,</span>
                 <span class="s1">origin_req_host=</span><span class="s3">None, </span><span class="s1">unverifiable=</span><span class="s3">False,</span>
                 <span class="s1">method=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2"># unwrap('&lt;URL:type://host/path&gt;') --&gt; 'type://host/path'</span>
        <span class="s1">self.full_url = unwrap(url)</span>
        <span class="s1">self.full_url</span><span class="s3">, </span><span class="s1">self.fragment = splittag(self.full_url)</span>
        <span class="s1">self.data = data</span>
        <span class="s1">self.headers = {}</span>
        <span class="s1">self._tunnel_host = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">headers.items():</span>
            <span class="s1">self.add_header(key</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s1">self.unredirected_hdrs = {}</span>
        <span class="s3">if </span><span class="s1">origin_req_host </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">origin_req_host = request_host(self)</span>
        <span class="s1">self.origin_req_host = origin_req_host</span>
        <span class="s1">self.unverifiable = unverifiable</span>
        <span class="s1">self.method = method</span>
        <span class="s1">self._parse()</span>

    <span class="s3">def </span><span class="s1">_parse(self):</span>
        <span class="s1">self.type</span><span class="s3">, </span><span class="s1">rest = splittype(self.full_url)</span>
        <span class="s3">if </span><span class="s1">self.type </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;unknown url type: %r&quot; </span><span class="s1">% self.full_url)</span>
        <span class="s1">self.host</span><span class="s3">, </span><span class="s1">self.selector = splithost(rest)</span>
        <span class="s3">if </span><span class="s1">self.host:</span>
            <span class="s1">self.host = unquote(self.host)</span>

    <span class="s3">def </span><span class="s1">get_method(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a string indicating the HTTP request method.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.method </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.method</span>
        <span class="s3">elif </span><span class="s1">self.data </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;POST&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;GET&quot;</span>

    <span class="s3">def </span><span class="s1">get_full_url(self):</span>
        <span class="s3">if </span><span class="s1">self.fragment:</span>
            <span class="s3">return </span><span class="s4">'%s#%s' </span><span class="s1">% (self.full_url</span><span class="s3">, </span><span class="s1">self.fragment)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.full_url</span>

    <span class="s2"># Begin deprecated methods</span>

    <span class="s3">def </span><span class="s1">add_data(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">msg = </span><span class="s4">&quot;Request.add_data method is deprecated.&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.data = data</span>

    <span class="s3">def </span><span class="s1">has_data(self):</span>
        <span class="s1">msg = </span><span class="s4">&quot;Request.has_data method is deprecated.&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.data </span><span class="s3">is not None</span>

    <span class="s3">def </span><span class="s1">get_data(self):</span>
        <span class="s1">msg = </span><span class="s4">&quot;Request.get_data method is deprecated.&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.data</span>

    <span class="s3">def </span><span class="s1">get_type(self):</span>
        <span class="s1">msg = </span><span class="s4">&quot;Request.get_type method is deprecated.&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.type</span>

    <span class="s3">def </span><span class="s1">get_host(self):</span>
        <span class="s1">msg = </span><span class="s4">&quot;Request.get_host method is deprecated.&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.host</span>

    <span class="s3">def </span><span class="s1">get_selector(self):</span>
        <span class="s1">msg = </span><span class="s4">&quot;Request.get_selector method is deprecated.&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.selector</span>

    <span class="s3">def </span><span class="s1">is_unverifiable(self):</span>
        <span class="s1">msg = </span><span class="s4">&quot;Request.is_unverifiable method is deprecated.&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.unverifiable</span>

    <span class="s3">def </span><span class="s1">get_origin_req_host(self):</span>
        <span class="s1">msg = </span><span class="s4">&quot;Request.get_origin_req_host method is deprecated.&quot;</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.origin_req_host</span>

    <span class="s2"># End deprecated methods</span>

    <span class="s3">def </span><span class="s1">set_proxy(self</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">type):</span>
        <span class="s3">if </span><span class="s1">self.type == </span><span class="s4">'https' </span><span class="s3">and not </span><span class="s1">self._tunnel_host:</span>
            <span class="s1">self._tunnel_host = self.host</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.type= type</span>
            <span class="s1">self.selector = self.full_url</span>
        <span class="s1">self.host = host</span>

    <span class="s3">def </span><span class="s1">has_proxy(self):</span>
        <span class="s3">return </span><span class="s1">self.selector == self.full_url</span>

    <span class="s3">def </span><span class="s1">add_header(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s2"># useful for something like authentication</span>
        <span class="s1">self.headers[key.capitalize()] = val</span>

    <span class="s3">def </span><span class="s1">add_unredirected_header(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s2"># will not be added to a redirected request</span>
        <span class="s1">self.unredirected_hdrs[key.capitalize()] = val</span>

    <span class="s3">def </span><span class="s1">has_header(self</span><span class="s3">, </span><span class="s1">header_name):</span>
        <span class="s3">return </span><span class="s1">(header_name </span><span class="s3">in </span><span class="s1">self.headers </span><span class="s3">or</span>
                <span class="s1">header_name </span><span class="s3">in </span><span class="s1">self.unredirected_hdrs)</span>

    <span class="s3">def </span><span class="s1">get_header(self</span><span class="s3">, </span><span class="s1">header_name</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">self.headers.get(</span>
            <span class="s1">header_name</span><span class="s3">,</span>
            <span class="s1">self.unredirected_hdrs.get(header_name</span><span class="s3">, </span><span class="s1">default))</span>

    <span class="s3">def </span><span class="s1">header_items(self):</span>
        <span class="s1">hdrs = self.unredirected_hdrs.copy()</span>
        <span class="s1">hdrs.update(self.headers)</span>
        <span class="s3">return </span><span class="s1">list(hdrs.items())</span>

<span class="s3">class </span><span class="s1">OpenerDirector(object):</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">client_version = </span><span class="s4">&quot;Python-urllib/%s&quot; </span><span class="s1">% __version__</span>
        <span class="s1">self.addheaders = [(</span><span class="s4">'User-agent'</span><span class="s3">, </span><span class="s1">client_version)]</span>
        <span class="s2"># self.handlers is retained only for backward compatibility</span>
        <span class="s1">self.handlers = []</span>
        <span class="s2"># manage the individual handlers</span>
        <span class="s1">self.handle_open = {}</span>
        <span class="s1">self.handle_error = {}</span>
        <span class="s1">self.process_response = {}</span>
        <span class="s1">self.process_request = {}</span>

    <span class="s3">def </span><span class="s1">add_handler(self</span><span class="s3">, </span><span class="s1">handler):</span>
        <span class="s3">if not </span><span class="s1">hasattr(handler</span><span class="s3">, </span><span class="s4">&quot;add_parent&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;expected BaseHandler instance, got %r&quot; </span><span class="s1">%</span>
                            <span class="s1">type(handler))</span>

        <span class="s1">added = </span><span class="s3">False</span>
        <span class="s3">for </span><span class="s1">meth </span><span class="s3">in </span><span class="s1">dir(handler):</span>
            <span class="s3">if </span><span class="s1">meth </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;redirect_request&quot;</span><span class="s3">, </span><span class="s4">&quot;do_open&quot;</span><span class="s3">, </span><span class="s4">&quot;proxy_open&quot;</span><span class="s1">]:</span>
                <span class="s2"># oops, coincidental match</span>
                <span class="s3">continue</span>

            <span class="s1">i = meth.find(</span><span class="s4">&quot;_&quot;</span><span class="s1">)</span>
            <span class="s1">protocol = meth[:i]</span>
            <span class="s1">condition = meth[i+</span><span class="s5">1</span><span class="s1">:]</span>

            <span class="s3">if </span><span class="s1">condition.startswith(</span><span class="s4">&quot;error&quot;</span><span class="s1">):</span>
                <span class="s1">j = condition.find(</span><span class="s4">&quot;_&quot;</span><span class="s1">) + i + </span><span class="s5">1</span>
                <span class="s1">kind = meth[j+</span><span class="s5">1</span><span class="s1">:]</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">kind = int(kind)</span>
                <span class="s3">except </span><span class="s1">ValueError:</span>
                    <span class="s3">pass</span>
                <span class="s1">lookup = self.handle_error.get(protocol</span><span class="s3">, </span><span class="s1">{})</span>
                <span class="s1">self.handle_error[protocol] = lookup</span>
            <span class="s3">elif </span><span class="s1">condition == </span><span class="s4">&quot;open&quot;</span><span class="s1">:</span>
                <span class="s1">kind = protocol</span>
                <span class="s1">lookup = self.handle_open</span>
            <span class="s3">elif </span><span class="s1">condition == </span><span class="s4">&quot;response&quot;</span><span class="s1">:</span>
                <span class="s1">kind = protocol</span>
                <span class="s1">lookup = self.process_response</span>
            <span class="s3">elif </span><span class="s1">condition == </span><span class="s4">&quot;request&quot;</span><span class="s1">:</span>
                <span class="s1">kind = protocol</span>
                <span class="s1">lookup = self.process_request</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">continue</span>

            <span class="s1">handlers = lookup.setdefault(kind</span><span class="s3">, </span><span class="s1">[])</span>
            <span class="s3">if </span><span class="s1">handlers:</span>
                <span class="s1">bisect.insort(handlers</span><span class="s3">, </span><span class="s1">handler)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">handlers.append(handler)</span>
            <span class="s1">added = </span><span class="s3">True</span>

        <span class="s3">if </span><span class="s1">added:</span>
            <span class="s1">bisect.insort(self.handlers</span><span class="s3">, </span><span class="s1">handler)</span>
            <span class="s1">handler.add_parent(self)</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s2"># Only exists for backwards compatibility.</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">_call_chain(self</span><span class="s3">, </span><span class="s1">chain</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, </span><span class="s1">meth_name</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s2"># Handlers raise an exception if no one else should try to handle</span>
        <span class="s2"># the request, or return None if they can't but another handler</span>
        <span class="s2"># could.  Otherwise, they return the response.</span>
        <span class="s1">handlers = chain.get(kind</span><span class="s3">, </span><span class="s1">())</span>
        <span class="s3">for </span><span class="s1">handler </span><span class="s3">in </span><span class="s1">handlers:</span>
            <span class="s1">func = getattr(handler</span><span class="s3">, </span><span class="s1">meth_name)</span>
            <span class="s1">result = func(*args)</span>
            <span class="s3">if </span><span class="s1">result </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">open(self</span><span class="s3">, </span><span class="s1">fullurl</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">timeout=socket._GLOBAL_DEFAULT_TIMEOUT):</span>
        <span class="s0">&quot;&quot;&quot; 
        Accept a URL or a Request object 
 
        Python-Future: if the URL is passed as a byte-string, decode it first. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(fullurl</span><span class="s3">, </span><span class="s1">bytes):</span>
            <span class="s1">fullurl = fullurl.decode()</span>
        <span class="s3">if </span><span class="s1">isinstance(fullurl</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">req = Request(fullurl</span><span class="s3">, </span><span class="s1">data)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">req = fullurl</span>
            <span class="s3">if </span><span class="s1">data </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">req.data = data</span>

        <span class="s1">req.timeout = timeout</span>
        <span class="s1">protocol = req.type</span>

        <span class="s2"># pre-process request</span>
        <span class="s1">meth_name = protocol+</span><span class="s4">&quot;_request&quot;</span>
        <span class="s3">for </span><span class="s1">processor </span><span class="s3">in </span><span class="s1">self.process_request.get(protocol</span><span class="s3">, </span><span class="s1">[]):</span>
            <span class="s1">meth = getattr(processor</span><span class="s3">, </span><span class="s1">meth_name)</span>
            <span class="s1">req = meth(req)</span>

        <span class="s1">response = self._open(req</span><span class="s3">, </span><span class="s1">data)</span>

        <span class="s2"># post-process response</span>
        <span class="s1">meth_name = protocol+</span><span class="s4">&quot;_response&quot;</span>
        <span class="s3">for </span><span class="s1">processor </span><span class="s3">in </span><span class="s1">self.process_response.get(protocol</span><span class="s3">, </span><span class="s1">[]):</span>
            <span class="s1">meth = getattr(processor</span><span class="s3">, </span><span class="s1">meth_name)</span>
            <span class="s1">response = meth(req</span><span class="s3">, </span><span class="s1">response)</span>

        <span class="s3">return </span><span class="s1">response</span>

    <span class="s3">def </span><span class="s1">_open(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">result = self._call_chain(self.handle_open</span><span class="s3">, </span><span class="s4">'default'</span><span class="s3">,</span>
                                  <span class="s4">'default_open'</span><span class="s3">, </span><span class="s1">req)</span>
        <span class="s3">if </span><span class="s1">result:</span>
            <span class="s3">return </span><span class="s1">result</span>

        <span class="s1">protocol = req.type</span>
        <span class="s1">result = self._call_chain(self.handle_open</span><span class="s3">, </span><span class="s1">protocol</span><span class="s3">, </span><span class="s1">protocol +</span>
                                  <span class="s4">'_open'</span><span class="s3">, </span><span class="s1">req)</span>
        <span class="s3">if </span><span class="s1">result:</span>
            <span class="s3">return </span><span class="s1">result</span>

        <span class="s3">return </span><span class="s1">self._call_chain(self.handle_open</span><span class="s3">, </span><span class="s4">'unknown'</span><span class="s3">,</span>
                                <span class="s4">'unknown_open'</span><span class="s3">, </span><span class="s1">req)</span>

    <span class="s3">def </span><span class="s1">error(self</span><span class="s3">, </span><span class="s1">proto</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">if </span><span class="s1">proto </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'http'</span><span class="s3">, </span><span class="s4">'https'</span><span class="s1">):</span>
            <span class="s2"># XXX http[s] protocols are special-cased</span>
            <span class="s1">dict = self.handle_error[</span><span class="s4">'http'</span><span class="s1">] </span><span class="s2"># https is not different than http</span>
            <span class="s1">proto = args[</span><span class="s5">2</span><span class="s1">]  </span><span class="s2"># YUCK!</span>
            <span class="s1">meth_name = </span><span class="s4">'http_error_%s' </span><span class="s1">% proto</span>
            <span class="s1">http_err = </span><span class="s5">1</span>
            <span class="s1">orig_args = args</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dict = self.handle_error</span>
            <span class="s1">meth_name = proto + </span><span class="s4">'_error'</span>
            <span class="s1">http_err = </span><span class="s5">0</span>
        <span class="s1">args = (dict</span><span class="s3">, </span><span class="s1">proto</span><span class="s3">, </span><span class="s1">meth_name) + args</span>
        <span class="s1">result = self._call_chain(*args)</span>
        <span class="s3">if </span><span class="s1">result:</span>
            <span class="s3">return </span><span class="s1">result</span>

        <span class="s3">if </span><span class="s1">http_err:</span>
            <span class="s1">args = (dict</span><span class="s3">, </span><span class="s4">'default'</span><span class="s3">, </span><span class="s4">'http_error_default'</span><span class="s1">) + orig_args</span>
            <span class="s3">return </span><span class="s1">self._call_chain(*args)</span>

<span class="s2"># XXX probably also want an abstract factory that knows when it makes</span>
<span class="s2"># sense to skip a superclass in favor of a subclass and when it might</span>
<span class="s2"># make sense to include both</span>

<span class="s3">def </span><span class="s1">build_opener(*handlers):</span>
    <span class="s0">&quot;&quot;&quot;Create an opener object from a list of handlers. 
 
    The opener will use several default handlers, including support 
    for HTTP, FTP and when applicable HTTPS. 
 
    If any of the handlers passed as arguments are subclasses of the 
    default handlers, the default handlers will not be used. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">isclass(obj):</span>
        <span class="s3">return </span><span class="s1">isinstance(obj</span><span class="s3">, </span><span class="s1">type) </span><span class="s3">or </span><span class="s1">hasattr(obj</span><span class="s3">, </span><span class="s4">&quot;__bases__&quot;</span><span class="s1">)</span>

    <span class="s1">opener = OpenerDirector()</span>
    <span class="s1">default_classes = [ProxyHandler</span><span class="s3">, </span><span class="s1">UnknownHandler</span><span class="s3">, </span><span class="s1">HTTPHandler</span><span class="s3">,</span>
                       <span class="s1">HTTPDefaultErrorHandler</span><span class="s3">, </span><span class="s1">HTTPRedirectHandler</span><span class="s3">,</span>
                       <span class="s1">FTPHandler</span><span class="s3">, </span><span class="s1">FileHandler</span><span class="s3">, </span><span class="s1">HTTPErrorProcessor]</span>
    <span class="s3">if </span><span class="s1">hasattr(http_client</span><span class="s3">, </span><span class="s4">&quot;HTTPSConnection&quot;</span><span class="s1">):</span>
        <span class="s1">default_classes.append(HTTPSHandler)</span>
    <span class="s1">skip = set()</span>
    <span class="s3">for </span><span class="s1">klass </span><span class="s3">in </span><span class="s1">default_classes:</span>
        <span class="s3">for </span><span class="s1">check </span><span class="s3">in </span><span class="s1">handlers:</span>
            <span class="s3">if </span><span class="s1">isclass(check):</span>
                <span class="s3">if </span><span class="s1">issubclass(check</span><span class="s3">, </span><span class="s1">klass):</span>
                    <span class="s1">skip.add(klass)</span>
            <span class="s3">elif </span><span class="s1">isinstance(check</span><span class="s3">, </span><span class="s1">klass):</span>
                <span class="s1">skip.add(klass)</span>
    <span class="s3">for </span><span class="s1">klass </span><span class="s3">in </span><span class="s1">skip:</span>
        <span class="s1">default_classes.remove(klass)</span>

    <span class="s3">for </span><span class="s1">klass </span><span class="s3">in </span><span class="s1">default_classes:</span>
        <span class="s1">opener.add_handler(klass())</span>

    <span class="s3">for </span><span class="s1">h </span><span class="s3">in </span><span class="s1">handlers:</span>
        <span class="s3">if </span><span class="s1">isclass(h):</span>
            <span class="s1">h = h()</span>
        <span class="s1">opener.add_handler(h)</span>
    <span class="s3">return </span><span class="s1">opener</span>

<span class="s3">class </span><span class="s1">BaseHandler(object):</span>
    <span class="s1">handler_order = </span><span class="s5">500</span>

    <span class="s3">def </span><span class="s1">add_parent(self</span><span class="s3">, </span><span class="s1">parent):</span>
        <span class="s1">self.parent = parent</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s2"># Only exists for backwards compatibility</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if not </span><span class="s1">hasattr(other</span><span class="s3">, </span><span class="s4">&quot;handler_order&quot;</span><span class="s1">):</span>
            <span class="s2"># Try to preserve the old behavior of having custom classes</span>
            <span class="s2"># inserted after default ones (works only for custom user</span>
            <span class="s2"># classes which are not aware of handler_order).</span>
            <span class="s3">return True</span>
        <span class="s3">return </span><span class="s1">self.handler_order &lt; other.handler_order</span>


<span class="s3">class </span><span class="s1">HTTPErrorProcessor(BaseHandler):</span>
    <span class="s0">&quot;&quot;&quot;Process HTTP error responses.&quot;&quot;&quot;</span>
    <span class="s1">handler_order = </span><span class="s5">1000  </span><span class="s2"># after all other processing</span>

    <span class="s3">def </span><span class="s1">http_response(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">response):</span>
        <span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">hdrs = response.code</span><span class="s3">, </span><span class="s1">response.msg</span><span class="s3">, </span><span class="s1">response.info()</span>

        <span class="s2"># According to RFC 2616, &quot;2xx&quot; code indicates that the client's</span>
        <span class="s2"># request was successfully received, understood, and accepted.</span>
        <span class="s3">if not </span><span class="s1">(</span><span class="s5">200 </span><span class="s1">&lt;= code &lt; </span><span class="s5">300</span><span class="s1">):</span>
            <span class="s1">response = self.parent.error(</span>
                <span class="s4">'http'</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">response</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">hdrs)</span>

        <span class="s3">return </span><span class="s1">response</span>

    <span class="s1">https_response = http_response</span>

<span class="s3">class </span><span class="s1">HTTPDefaultErrorHandler(BaseHandler):</span>
    <span class="s3">def </span><span class="s1">http_error_default(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">hdrs):</span>
        <span class="s3">raise </span><span class="s1">HTTPError(req.full_url</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">hdrs</span><span class="s3">, </span><span class="s1">fp)</span>

<span class="s3">class </span><span class="s1">HTTPRedirectHandler(BaseHandler):</span>
    <span class="s2"># maximum number of redirections to any single URL</span>
    <span class="s2"># this is needed because of the state that cookies introduce</span>
    <span class="s1">max_repeats = </span><span class="s5">4</span>
    <span class="s2"># maximum total number of redirections (regardless of URL) before</span>
    <span class="s2"># assuming we're in a loop</span>
    <span class="s1">max_redirections = </span><span class="s5">10</span>

    <span class="s3">def </span><span class="s1">redirect_request(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">newurl):</span>
        <span class="s0">&quot;&quot;&quot;Return a Request or None in response to a redirect. 
 
        This is called by the http_error_30x methods when a 
        redirection response is received.  If a redirection should 
        take place, return a new Request to allow http_error_30x to 
        perform the redirect.  Otherwise, raise HTTPError if no-one 
        else should try to handle this url.  Return None if you can't 
        but another Handler might. 
        &quot;&quot;&quot;</span>
        <span class="s1">m = req.get_method()</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">(code </span><span class="s3">in </span><span class="s1">(</span><span class="s5">301</span><span class="s3">, </span><span class="s5">302</span><span class="s3">, </span><span class="s5">303</span><span class="s3">, </span><span class="s5">307</span><span class="s1">) </span><span class="s3">and </span><span class="s1">m </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;GET&quot;</span><span class="s3">, </span><span class="s4">&quot;HEAD&quot;</span><span class="s1">)</span>
            <span class="s3">or </span><span class="s1">code </span><span class="s3">in </span><span class="s1">(</span><span class="s5">301</span><span class="s3">, </span><span class="s5">302</span><span class="s3">, </span><span class="s5">303</span><span class="s1">) </span><span class="s3">and </span><span class="s1">m == </span><span class="s4">&quot;POST&quot;</span><span class="s1">)):</span>
            <span class="s3">raise </span><span class="s1">HTTPError(req.full_url</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">fp)</span>

        <span class="s2"># Strictly (according to RFC 2616), 301 or 302 in response to</span>
        <span class="s2"># a POST MUST NOT cause a redirection without confirmation</span>
        <span class="s2"># from the user (of urllib.request, in this case).  In practice,</span>
        <span class="s2"># essentially all clients do redirect in this case, so we do</span>
        <span class="s2"># the same.</span>
        <span class="s2"># be conciliant with URIs containing a space</span>
        <span class="s1">newurl = newurl.replace(</span><span class="s4">' '</span><span class="s3">, </span><span class="s4">'%20'</span><span class="s1">)</span>
        <span class="s1">CONTENT_HEADERS = (</span><span class="s4">&quot;content-length&quot;</span><span class="s3">, </span><span class="s4">&quot;content-type&quot;</span><span class="s1">)</span>
        <span class="s1">newheaders = dict((k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">req.headers.items()</span>
                          <span class="s3">if </span><span class="s1">k.lower() </span><span class="s3">not in </span><span class="s1">CONTENT_HEADERS)</span>
        <span class="s3">return </span><span class="s1">Request(newurl</span><span class="s3">,</span>
                       <span class="s1">headers=newheaders</span><span class="s3">,</span>
                       <span class="s1">origin_req_host=req.origin_req_host</span><span class="s3">,</span>
                       <span class="s1">unverifiable=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s2"># Implementation note: To avoid the server sending us into an</span>
    <span class="s2"># infinite loop, the request object needs to track what URLs we</span>
    <span class="s2"># have already seen.  Do this by adding a handler-specific</span>
    <span class="s2"># attribute to the Request object.</span>
    <span class="s3">def </span><span class="s1">http_error_302(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s2"># Some servers (incorrectly) return multiple Location headers</span>
        <span class="s2"># (so probably same goes for URI).  Use first header.</span>
        <span class="s3">if </span><span class="s4">&quot;location&quot; </span><span class="s3">in </span><span class="s1">headers:</span>
            <span class="s1">newurl = headers[</span><span class="s4">&quot;location&quot;</span><span class="s1">]</span>
        <span class="s3">elif </span><span class="s4">&quot;uri&quot; </span><span class="s3">in </span><span class="s1">headers:</span>
            <span class="s1">newurl = headers[</span><span class="s4">&quot;uri&quot;</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return</span>

        <span class="s2"># fix a possible malformed URL</span>
        <span class="s1">urlparts = urlparse(newurl)</span>

        <span class="s2"># For security reasons we don't allow redirection to anything other</span>
        <span class="s2"># than http, https or ftp.</span>

        <span class="s3">if </span><span class="s1">urlparts.scheme </span><span class="s3">not in </span><span class="s1">(</span><span class="s4">'http'</span><span class="s3">, </span><span class="s4">'https'</span><span class="s3">, </span><span class="s4">'ftp'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">HTTPError(</span>
                <span class="s1">newurl</span><span class="s3">, </span><span class="s1">code</span><span class="s3">,</span>
                <span class="s4">&quot;%s - Redirection to url '%s' is not allowed&quot; </span><span class="s1">% (msg</span><span class="s3">, </span><span class="s1">newurl)</span><span class="s3">,</span>
                <span class="s1">headers</span><span class="s3">, </span><span class="s1">fp)</span>

        <span class="s3">if not </span><span class="s1">urlparts.path:</span>
            <span class="s1">urlparts = list(urlparts)</span>
            <span class="s1">urlparts[</span><span class="s5">2</span><span class="s1">] = </span><span class="s4">&quot;/&quot;</span>
        <span class="s1">newurl = urlunparse(urlparts)</span>

        <span class="s1">newurl = urljoin(req.full_url</span><span class="s3">, </span><span class="s1">newurl)</span>

        <span class="s2"># XXX Probably want to forget about the state of the current</span>
        <span class="s2"># request, although that might interact poorly with other</span>
        <span class="s2"># handlers that also use handler-specific request attributes</span>
        <span class="s1">new = self.redirect_request(req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">newurl)</span>
        <span class="s3">if </span><span class="s1">new </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>

        <span class="s2"># loop detection</span>
        <span class="s2"># .redirect_dict has a key url if url was previously visited.</span>
        <span class="s3">if </span><span class="s1">hasattr(req</span><span class="s3">, </span><span class="s4">'redirect_dict'</span><span class="s1">):</span>
            <span class="s1">visited = new.redirect_dict = req.redirect_dict</span>
            <span class="s3">if </span><span class="s1">(visited.get(newurl</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) &gt;= self.max_repeats </span><span class="s3">or</span>
                <span class="s1">len(visited) &gt;= self.max_redirections):</span>
                <span class="s3">raise </span><span class="s1">HTTPError(req.full_url</span><span class="s3">, </span><span class="s1">code</span><span class="s3">,</span>
                                <span class="s1">self.inf_msg + msg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">fp)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">visited = new.redirect_dict = req.redirect_dict = {}</span>
        <span class="s1">visited[newurl] = visited.get(newurl</span><span class="s3">, </span><span class="s5">0</span><span class="s1">) + </span><span class="s5">1</span>

        <span class="s2"># Don't close the fp until we are sure that we won't use it</span>
        <span class="s2"># with HTTPError.</span>
        <span class="s1">fp.read()</span>
        <span class="s1">fp.close()</span>

        <span class="s3">return </span><span class="s1">self.parent.open(new</span><span class="s3">, </span><span class="s1">timeout=req.timeout)</span>

    <span class="s1">http_error_301 = http_error_303 = http_error_307 = http_error_302</span>

    <span class="s1">inf_msg = </span><span class="s4">&quot;The HTTP server returned a redirect error that would &quot; </span><span class="s1">\</span>
              <span class="s4">&quot;lead to an infinite loop.</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">\</span>
              <span class="s4">&quot;The last 30x error message was:</span><span class="s3">\n</span><span class="s4">&quot;</span>


<span class="s3">def </span><span class="s1">_parse_proxy(proxy):</span>
    <span class="s0">&quot;&quot;&quot;Return (scheme, user, password, host/port) given a URL or an authority. 
 
    If a URL is supplied, it must have an authority (host:port) component. 
    According to RFC 3986, having an authority component means the URL must 
    have two slashes after the scheme: 
 
    &gt;&gt;&gt; _parse_proxy('file:/ftp.example.com/') 
    Traceback (most recent call last): 
    ValueError: proxy URL with no authority: 'file:/ftp.example.com/' 
 
    The first three items of the returned tuple may be None. 
 
    Examples of authority parsing: 
 
    &gt;&gt;&gt; _parse_proxy('proxy.example.com') 
    (None, None, None, 'proxy.example.com') 
    &gt;&gt;&gt; _parse_proxy('proxy.example.com:3128') 
    (None, None, None, 'proxy.example.com:3128') 
 
    The authority component may optionally include userinfo (assumed to be 
    username:password): 
 
    &gt;&gt;&gt; _parse_proxy('joe:password@proxy.example.com') 
    (None, 'joe', 'password', 'proxy.example.com') 
    &gt;&gt;&gt; _parse_proxy('joe:password@proxy.example.com:3128') 
    (None, 'joe', 'password', 'proxy.example.com:3128') 
 
    Same examples, but with URLs instead: 
 
    &gt;&gt;&gt; _parse_proxy('http://proxy.example.com/') 
    ('http', None, None, 'proxy.example.com') 
    &gt;&gt;&gt; _parse_proxy('http://proxy.example.com:3128/') 
    ('http', None, None, 'proxy.example.com:3128') 
    &gt;&gt;&gt; _parse_proxy('http://joe:password@proxy.example.com/') 
    ('http', 'joe', 'password', 'proxy.example.com') 
    &gt;&gt;&gt; _parse_proxy('http://joe:password@proxy.example.com:3128') 
    ('http', 'joe', 'password', 'proxy.example.com:3128') 
 
    Everything after the authority is ignored: 
 
    &gt;&gt;&gt; _parse_proxy('ftp://joe:password@proxy.example.com/rubbish:3128') 
    ('ftp', 'joe', 'password', 'proxy.example.com') 
 
    Test for no trailing '/' case: 
 
    &gt;&gt;&gt; _parse_proxy('http://joe:password@proxy.example.com') 
    ('http', 'joe', 'password', 'proxy.example.com') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">scheme</span><span class="s3">, </span><span class="s1">r_scheme = splittype(proxy)</span>
    <span class="s3">if not </span><span class="s1">r_scheme.startswith(</span><span class="s4">&quot;/&quot;</span><span class="s1">):</span>
        <span class="s2"># authority</span>
        <span class="s1">scheme = </span><span class="s3">None</span>
        <span class="s1">authority = proxy</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s2"># URL</span>
        <span class="s3">if not </span><span class="s1">r_scheme.startswith(</span><span class="s4">&quot;//&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;proxy URL with no authority: %r&quot; </span><span class="s1">% proxy)</span>
        <span class="s2"># We have an authority, so for RFC 3986-compliant URLs (by ss 3.</span>
        <span class="s2"># and 3.3.), path is empty or starts with '/'</span>
        <span class="s1">end = r_scheme.find(</span><span class="s4">&quot;/&quot;</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">end == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">end = </span><span class="s3">None</span>
        <span class="s1">authority = r_scheme[</span><span class="s5">2</span><span class="s1">:end]</span>
    <span class="s1">userinfo</span><span class="s3">, </span><span class="s1">hostport = splituser(authority)</span>
    <span class="s3">if </span><span class="s1">userinfo </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">password = splitpasswd(userinfo)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">user = password = </span><span class="s3">None</span>
    <span class="s3">return </span><span class="s1">scheme</span><span class="s3">, </span><span class="s1">user</span><span class="s3">, </span><span class="s1">password</span><span class="s3">, </span><span class="s1">hostport</span>

<span class="s3">class </span><span class="s1">ProxyHandler(BaseHandler):</span>
    <span class="s2"># Proxies must be in front</span>
    <span class="s1">handler_order = </span><span class="s5">100</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">proxies=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">proxies </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">proxies = getproxies()</span>
        <span class="s3">assert </span><span class="s1">hasattr(proxies</span><span class="s3">, </span><span class="s4">'keys'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;proxies must be a mapping&quot;</span>
        <span class="s1">self.proxies = proxies</span>
        <span class="s3">for </span><span class="s1">type</span><span class="s3">, </span><span class="s1">url </span><span class="s3">in </span><span class="s1">proxies.items():</span>
            <span class="s1">setattr(self</span><span class="s3">, </span><span class="s4">'%s_open' </span><span class="s1">% type</span><span class="s3">,</span>
                    <span class="s3">lambda </span><span class="s1">r</span><span class="s3">, </span><span class="s1">proxy=url</span><span class="s3">, </span><span class="s1">type=type</span><span class="s3">, </span><span class="s1">meth=self.proxy_open:</span>
                        <span class="s1">meth(r</span><span class="s3">, </span><span class="s1">proxy</span><span class="s3">, </span><span class="s1">type))</span>

    <span class="s3">def </span><span class="s1">proxy_open(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">proxy</span><span class="s3">, </span><span class="s1">type):</span>
        <span class="s1">orig_type = req.type</span>
        <span class="s1">proxy_type</span><span class="s3">, </span><span class="s1">user</span><span class="s3">, </span><span class="s1">password</span><span class="s3">, </span><span class="s1">hostport = _parse_proxy(proxy)</span>
        <span class="s3">if </span><span class="s1">proxy_type </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">proxy_type = orig_type</span>

        <span class="s3">if </span><span class="s1">req.host </span><span class="s3">and </span><span class="s1">proxy_bypass(req.host):</span>
            <span class="s3">return None</span>

        <span class="s3">if </span><span class="s1">user </span><span class="s3">and </span><span class="s1">password:</span>
            <span class="s1">user_pass = </span><span class="s4">'%s:%s' </span><span class="s1">% (unquote(user)</span><span class="s3">,</span>
                                   <span class="s1">unquote(password))</span>
            <span class="s1">creds = base64.b64encode(user_pass.encode()).decode(</span><span class="s4">&quot;ascii&quot;</span><span class="s1">)</span>
            <span class="s1">req.add_header(</span><span class="s4">'Proxy-authorization'</span><span class="s3">, </span><span class="s4">'Basic ' </span><span class="s1">+ creds)</span>
        <span class="s1">hostport = unquote(hostport)</span>
        <span class="s1">req.set_proxy(hostport</span><span class="s3">, </span><span class="s1">proxy_type)</span>
        <span class="s3">if </span><span class="s1">orig_type == proxy_type </span><span class="s3">or </span><span class="s1">orig_type == </span><span class="s4">'https'</span><span class="s1">:</span>
            <span class="s2"># let other handlers take care of it</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># need to start over, because the other handlers don't</span>
            <span class="s2"># grok the proxy's URL type</span>
            <span class="s2"># e.g. if we have a constructor arg proxies like so:</span>
            <span class="s2"># {'http': 'ftp://proxy.example.com'}, we may end up turning</span>
            <span class="s2"># a request for http://acme.example.com/a into one for</span>
            <span class="s2"># ftp://proxy.example.com/a</span>
            <span class="s3">return </span><span class="s1">self.parent.open(req</span><span class="s3">, </span><span class="s1">timeout=req.timeout)</span>

<span class="s3">class </span><span class="s1">HTTPPasswordMgr(object):</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.passwd = {}</span>

    <span class="s3">def </span><span class="s1">add_password(self</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">uri</span><span class="s3">, </span><span class="s1">user</span><span class="s3">, </span><span class="s1">passwd):</span>
        <span class="s2"># uri could be a single URI or a sequence</span>
        <span class="s3">if </span><span class="s1">isinstance(uri</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">uri = [uri]</span>
        <span class="s3">if </span><span class="s1">realm </span><span class="s3">not in </span><span class="s1">self.passwd:</span>
            <span class="s1">self.passwd[realm] = {}</span>
        <span class="s3">for </span><span class="s1">default_port </span><span class="s3">in True, False</span><span class="s1">:</span>
            <span class="s1">reduced_uri = tuple(</span>
                <span class="s1">[self.reduce_uri(u</span><span class="s3">, </span><span class="s1">default_port) </span><span class="s3">for </span><span class="s1">u </span><span class="s3">in </span><span class="s1">uri])</span>
            <span class="s1">self.passwd[realm][reduced_uri] = (user</span><span class="s3">, </span><span class="s1">passwd)</span>

    <span class="s3">def </span><span class="s1">find_user_password(self</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">authuri):</span>
        <span class="s1">domains = self.passwd.get(realm</span><span class="s3">, </span><span class="s1">{})</span>
        <span class="s3">for </span><span class="s1">default_port </span><span class="s3">in True, False</span><span class="s1">:</span>
            <span class="s1">reduced_authuri = self.reduce_uri(authuri</span><span class="s3">, </span><span class="s1">default_port)</span>
            <span class="s3">for </span><span class="s1">uris</span><span class="s3">, </span><span class="s1">authinfo </span><span class="s3">in </span><span class="s1">domains.items():</span>
                <span class="s3">for </span><span class="s1">uri </span><span class="s3">in </span><span class="s1">uris:</span>
                    <span class="s3">if </span><span class="s1">self.is_suburi(uri</span><span class="s3">, </span><span class="s1">reduced_authuri):</span>
                        <span class="s3">return </span><span class="s1">authinfo</span>
        <span class="s3">return None, None</span>

    <span class="s3">def </span><span class="s1">reduce_uri(self</span><span class="s3">, </span><span class="s1">uri</span><span class="s3">, </span><span class="s1">default_port=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Accept authority or URI and extract only the authority and path.&quot;&quot;&quot;</span>
        <span class="s2"># note HTTP URLs do not have a userinfo component</span>
        <span class="s1">parts = urlsplit(uri)</span>
        <span class="s3">if </span><span class="s1">parts[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s2"># URI</span>
            <span class="s1">scheme = parts[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">authority = parts[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">path = parts[</span><span class="s5">2</span><span class="s1">] </span><span class="s3">or </span><span class="s4">'/'</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># host or host:port</span>
            <span class="s1">scheme = </span><span class="s3">None</span>
            <span class="s1">authority = uri</span>
            <span class="s1">path = </span><span class="s4">'/'</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">port = splitport(authority)</span>
        <span class="s3">if </span><span class="s1">default_port </span><span class="s3">and </span><span class="s1">port </span><span class="s3">is None and </span><span class="s1">scheme </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">dport = {</span><span class="s4">&quot;http&quot;</span><span class="s1">: </span><span class="s5">80</span><span class="s3">,</span>
                     <span class="s4">&quot;https&quot;</span><span class="s1">: </span><span class="s5">443</span><span class="s3">,</span>
                     <span class="s1">}.get(scheme)</span>
            <span class="s3">if </span><span class="s1">dport </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">authority = </span><span class="s4">&quot;%s:%d&quot; </span><span class="s1">% (host</span><span class="s3">, </span><span class="s1">dport)</span>
        <span class="s3">return </span><span class="s1">authority</span><span class="s3">, </span><span class="s1">path</span>

    <span class="s3">def </span><span class="s1">is_suburi(self</span><span class="s3">, </span><span class="s1">base</span><span class="s3">, </span><span class="s1">test):</span>
        <span class="s0">&quot;&quot;&quot;Check if test is below base in a URI tree 
 
        Both args must be URIs in reduced form. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">base == test:</span>
            <span class="s3">return True</span>
        <span class="s3">if </span><span class="s1">base[</span><span class="s5">0</span><span class="s1">] != test[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s3">return False</span>
        <span class="s1">common = posixpath.commonprefix((base[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">test[</span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s3">if </span><span class="s1">len(common) == len(base[</span><span class="s5">1</span><span class="s1">]):</span>
            <span class="s3">return True</span>
        <span class="s3">return False</span>


<span class="s3">class </span><span class="s1">HTTPPasswordMgrWithDefaultRealm(HTTPPasswordMgr):</span>

    <span class="s3">def </span><span class="s1">find_user_password(self</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">authuri):</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">password = HTTPPasswordMgr.find_user_password(self</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">,</span>
                                                            <span class="s1">authuri)</span>
        <span class="s3">if </span><span class="s1">user </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">user</span><span class="s3">, </span><span class="s1">password</span>
        <span class="s3">return </span><span class="s1">HTTPPasswordMgr.find_user_password(self</span><span class="s3">, None, </span><span class="s1">authuri)</span>


<span class="s3">class </span><span class="s1">AbstractBasicAuthHandler(object):</span>

    <span class="s2"># XXX this allows for multiple auth-schemes, but will stupidly pick</span>
    <span class="s2"># the last one with a realm specified.</span>

    <span class="s2"># allow for double- and single-quoted realm values</span>
    <span class="s2"># (single quotes are a violation of the RFC, but appear in the wild)</span>
    <span class="s1">rx = re.compile(</span><span class="s4">'(?:.*,)*[ </span><span class="s3">\t</span><span class="s4">]*([^ </span><span class="s3">\t</span><span class="s4">]+)[ </span><span class="s3">\t</span><span class="s4">]+'</span>
                    <span class="s4">'realm=([&quot;</span><span class="s3">\'</span><span class="s4">]?)([^&quot;</span><span class="s3">\'</span><span class="s4">]*)</span><span class="s3">\\</span><span class="s4">2'</span><span class="s3">, </span><span class="s1">re.I)</span>

    <span class="s2"># XXX could pre-emptively send auth info already accepted (RFC 2617,</span>
    <span class="s2"># end of section 2, and section 1.2 immediately after &quot;credentials&quot;</span>
    <span class="s2"># production).</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">password_mgr=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">password_mgr </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">password_mgr = HTTPPasswordMgr()</span>
        <span class="s1">self.passwd = password_mgr</span>
        <span class="s1">self.add_password = self.passwd.add_password</span>
        <span class="s1">self.retried = </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">reset_retry_count(self):</span>
        <span class="s1">self.retried = </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">http_error_auth_reqed(self</span><span class="s3">, </span><span class="s1">authreq</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s2"># host may be an authority (without userinfo) or a URL with an</span>
        <span class="s2"># authority</span>
        <span class="s2"># XXX could be multiple headers</span>
        <span class="s1">authreq = headers.get(authreq</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.retried &gt; </span><span class="s5">5</span><span class="s1">:</span>
            <span class="s2"># retry sending the username:password 5 times before failing.</span>
            <span class="s3">raise </span><span class="s1">HTTPError(req.get_full_url()</span><span class="s3">, </span><span class="s5">401</span><span class="s3">, </span><span class="s4">&quot;basic auth failed&quot;</span><span class="s3">,</span>
                    <span class="s1">headers</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.retried += </span><span class="s5">1</span>

        <span class="s3">if </span><span class="s1">authreq:</span>
            <span class="s1">scheme = authreq.split()[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">scheme.lower() != </span><span class="s4">'basic'</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;AbstractBasicAuthHandler does not&quot;</span>
                                 <span class="s4">&quot; support the following scheme: '%s'&quot; </span><span class="s1">%</span>
                                 <span class="s1">scheme)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">mo = AbstractBasicAuthHandler.rx.search(authreq)</span>
                <span class="s3">if </span><span class="s1">mo:</span>
                    <span class="s1">scheme</span><span class="s3">, </span><span class="s1">quote</span><span class="s3">, </span><span class="s1">realm = mo.groups()</span>
                    <span class="s3">if </span><span class="s1">quote </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">'&quot;'</span><span class="s3">,</span><span class="s4">&quot;'&quot;</span><span class="s1">]:</span>
                        <span class="s1">warnings.warn(</span><span class="s4">&quot;Basic Auth Realm was unquoted&quot;</span><span class="s3">,</span>
                                      <span class="s1">UserWarning</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">scheme.lower() == </span><span class="s4">'basic'</span><span class="s1">:</span>
                        <span class="s1">response = self.retry_http_basic_auth(host</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">realm)</span>
                        <span class="s3">if </span><span class="s1">response </span><span class="s3">and </span><span class="s1">response.code != </span><span class="s5">401</span><span class="s1">:</span>
                            <span class="s1">self.retried = </span><span class="s5">0</span>
                        <span class="s3">return </span><span class="s1">response</span>

    <span class="s3">def </span><span class="s1">retry_http_basic_auth(self</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">realm):</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">pw = self.passwd.find_user_password(realm</span><span class="s3">, </span><span class="s1">host)</span>
        <span class="s3">if </span><span class="s1">pw </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">raw = </span><span class="s4">&quot;%s:%s&quot; </span><span class="s1">% (user</span><span class="s3">, </span><span class="s1">pw)</span>
            <span class="s1">auth = </span><span class="s4">&quot;Basic &quot; </span><span class="s1">+ base64.b64encode(raw.encode()).decode(</span><span class="s4">&quot;ascii&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">req.headers.get(self.auth_header</span><span class="s3">, None</span><span class="s1">) == auth:</span>
                <span class="s3">return None</span>
            <span class="s1">req.add_unredirected_header(self.auth_header</span><span class="s3">, </span><span class="s1">auth)</span>
            <span class="s3">return </span><span class="s1">self.parent.open(req</span><span class="s3">, </span><span class="s1">timeout=req.timeout)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return None</span>


<span class="s3">class </span><span class="s1">HTTPBasicAuthHandler(AbstractBasicAuthHandler</span><span class="s3">, </span><span class="s1">BaseHandler):</span>

    <span class="s1">auth_header = </span><span class="s4">'Authorization'</span>

    <span class="s3">def </span><span class="s1">http_error_401(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s1">url = req.full_url</span>
        <span class="s1">response = self.http_error_auth_reqed(</span><span class="s4">'www-authenticate'</span><span class="s3">,</span>
                                          <span class="s1">url</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s1">self.reset_retry_count()</span>
        <span class="s3">return </span><span class="s1">response</span>


<span class="s3">class </span><span class="s1">ProxyBasicAuthHandler(AbstractBasicAuthHandler</span><span class="s3">, </span><span class="s1">BaseHandler):</span>

    <span class="s1">auth_header = </span><span class="s4">'Proxy-authorization'</span>

    <span class="s3">def </span><span class="s1">http_error_407(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s2"># http_error_auth_reqed requires that there is no userinfo component in</span>
        <span class="s2"># authority.  Assume there isn't one, since urllib.request does not (and</span>
        <span class="s2"># should not, RFC 3986 s. 3.2.1) support requests for URLs containing</span>
        <span class="s2"># userinfo.</span>
        <span class="s1">authority = req.host</span>
        <span class="s1">response = self.http_error_auth_reqed(</span><span class="s4">'proxy-authenticate'</span><span class="s3">,</span>
                                          <span class="s1">authority</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s1">self.reset_retry_count()</span>
        <span class="s3">return </span><span class="s1">response</span>


<span class="s2"># Return n random bytes.</span>
<span class="s1">_randombytes = os.urandom</span>


<span class="s3">class </span><span class="s1">AbstractDigestAuthHandler(object):</span>
    <span class="s2"># Digest authentication is specified in RFC 2617.</span>

    <span class="s2"># XXX The client does not inspect the Authentication-Info header</span>
    <span class="s2"># in a successful response.</span>

    <span class="s2"># XXX It should be possible to test this implementation against</span>
    <span class="s2"># a mock server that just generates a static set of challenges.</span>

    <span class="s2"># XXX qop=&quot;auth-int&quot; supports is shaky</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">passwd=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">passwd </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">passwd = HTTPPasswordMgr()</span>
        <span class="s1">self.passwd = passwd</span>
        <span class="s1">self.add_password = self.passwd.add_password</span>
        <span class="s1">self.retried = </span><span class="s5">0</span>
        <span class="s1">self.nonce_count = </span><span class="s5">0</span>
        <span class="s1">self.last_nonce = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">reset_retry_count(self):</span>
        <span class="s1">self.retried = </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">http_error_auth_reqed(self</span><span class="s3">, </span><span class="s1">auth_header</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s1">authreq = headers.get(auth_header</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.retried &gt; </span><span class="s5">5</span><span class="s1">:</span>
            <span class="s2"># Don't fail endlessly - if we failed once, we'll probably</span>
            <span class="s2"># fail a second time. Hm. Unless the Password Manager is</span>
            <span class="s2"># prompting for the information. Crap. This isn't great</span>
            <span class="s2"># but it's better than the current 'repeat until recursion</span>
            <span class="s2"># depth exceeded' approach &lt;wink&gt;</span>
            <span class="s3">raise </span><span class="s1">HTTPError(req.full_url</span><span class="s3">, </span><span class="s5">401</span><span class="s3">, </span><span class="s4">&quot;digest auth failed&quot;</span><span class="s3">,</span>
                            <span class="s1">headers</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.retried += </span><span class="s5">1</span>
        <span class="s3">if </span><span class="s1">authreq:</span>
            <span class="s1">scheme = authreq.split()[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">scheme.lower() == </span><span class="s4">'digest'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self.retry_http_digest_auth(req</span><span class="s3">, </span><span class="s1">authreq)</span>
            <span class="s3">elif </span><span class="s1">scheme.lower() != </span><span class="s4">'basic'</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;AbstractDigestAuthHandler does not support&quot;</span>
                                 <span class="s4">&quot; the following scheme: '%s'&quot; </span><span class="s1">% scheme)</span>

    <span class="s3">def </span><span class="s1">retry_http_digest_auth(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">auth):</span>
        <span class="s1">token</span><span class="s3">, </span><span class="s1">challenge = auth.split(</span><span class="s4">' '</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">chal = parse_keqv_list(filter(</span><span class="s3">None, </span><span class="s1">parse_http_list(challenge)))</span>
        <span class="s1">auth = self.get_authorization(req</span><span class="s3">, </span><span class="s1">chal)</span>
        <span class="s3">if </span><span class="s1">auth:</span>
            <span class="s1">auth_val = </span><span class="s4">'Digest %s' </span><span class="s1">% auth</span>
            <span class="s3">if </span><span class="s1">req.headers.get(self.auth_header</span><span class="s3">, None</span><span class="s1">) == auth_val:</span>
                <span class="s3">return None</span>
            <span class="s1">req.add_unredirected_header(self.auth_header</span><span class="s3">, </span><span class="s1">auth_val)</span>
            <span class="s1">resp = self.parent.open(req</span><span class="s3">, </span><span class="s1">timeout=req.timeout)</span>
            <span class="s3">return </span><span class="s1">resp</span>

    <span class="s3">def </span><span class="s1">get_cnonce(self</span><span class="s3">, </span><span class="s1">nonce):</span>
        <span class="s2"># The cnonce-value is an opaque</span>
        <span class="s2"># quoted string value provided by the client and used by both client</span>
        <span class="s2"># and server to avoid chosen plaintext attacks, to provide mutual</span>
        <span class="s2"># authentication, and to provide some message integrity protection.</span>
        <span class="s2"># This isn't a fabulous effort, but it's probably Good Enough.</span>
        <span class="s1">s = </span><span class="s4">&quot;%s:%s:%s:&quot; </span><span class="s1">% (self.nonce_count</span><span class="s3">, </span><span class="s1">nonce</span><span class="s3">, </span><span class="s1">time.ctime())</span>
        <span class="s1">b = s.encode(</span><span class="s4">&quot;ascii&quot;</span><span class="s1">) + _randombytes(</span><span class="s5">8</span><span class="s1">)</span>
        <span class="s1">dig = hashlib.sha1(b).hexdigest()</span>
        <span class="s3">return </span><span class="s1">dig[:</span><span class="s5">16</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">get_authorization(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">chal):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">realm = chal[</span><span class="s4">'realm'</span><span class="s1">]</span>
            <span class="s1">nonce = chal[</span><span class="s4">'nonce'</span><span class="s1">]</span>
            <span class="s1">qop = chal.get(</span><span class="s4">'qop'</span><span class="s1">)</span>
            <span class="s1">algorithm = chal.get(</span><span class="s4">'algorithm'</span><span class="s3">, </span><span class="s4">'MD5'</span><span class="s1">)</span>
            <span class="s2"># mod_digest doesn't send an opaque, even though it isn't</span>
            <span class="s2"># supposed to be optional</span>
            <span class="s1">opaque = chal.get(</span><span class="s4">'opaque'</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">return None</span>

        <span class="s1">H</span><span class="s3">, </span><span class="s1">KD = self.get_algorithm_impls(algorithm)</span>
        <span class="s3">if </span><span class="s1">H </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s1">user</span><span class="s3">, </span><span class="s1">pw = self.passwd.find_user_password(realm</span><span class="s3">, </span><span class="s1">req.full_url)</span>
        <span class="s3">if </span><span class="s1">user </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s2"># XXX not implemented yet</span>
        <span class="s3">if </span><span class="s1">req.data </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">entdig = self.get_entity_digest(req.data</span><span class="s3">, </span><span class="s1">chal)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">entdig = </span><span class="s3">None</span>

        <span class="s1">A1 = </span><span class="s4">&quot;%s:%s:%s&quot; </span><span class="s1">% (user</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">pw)</span>
        <span class="s1">A2 = </span><span class="s4">&quot;%s:%s&quot; </span><span class="s1">% (req.get_method()</span><span class="s3">,</span>
                        <span class="s2"># XXX selector: what about proxies and full urls</span>
                        <span class="s1">req.selector)</span>
        <span class="s3">if </span><span class="s1">qop == </span><span class="s4">'auth'</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">nonce == self.last_nonce:</span>
                <span class="s1">self.nonce_count += </span><span class="s5">1</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.nonce_count = </span><span class="s5">1</span>
                <span class="s1">self.last_nonce = nonce</span>
            <span class="s1">ncvalue = </span><span class="s4">'%08x' </span><span class="s1">% self.nonce_count</span>
            <span class="s1">cnonce = self.get_cnonce(nonce)</span>
            <span class="s1">noncebit = </span><span class="s4">&quot;%s:%s:%s:%s:%s&quot; </span><span class="s1">% (nonce</span><span class="s3">, </span><span class="s1">ncvalue</span><span class="s3">, </span><span class="s1">cnonce</span><span class="s3">, </span><span class="s1">qop</span><span class="s3">, </span><span class="s1">H(A2))</span>
            <span class="s1">respdig = KD(H(A1)</span><span class="s3">, </span><span class="s1">noncebit)</span>
        <span class="s3">elif </span><span class="s1">qop </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">respdig = KD(H(A1)</span><span class="s3">, </span><span class="s4">&quot;%s:%s&quot; </span><span class="s1">% (nonce</span><span class="s3">, </span><span class="s1">H(A2)))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># XXX handle auth-int.</span>
            <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">&quot;qop '%s' is not supported.&quot; </span><span class="s1">% qop)</span>

        <span class="s2"># XXX should the partial digests be encoded too?</span>

        <span class="s1">base = </span><span class="s4">'username=&quot;%s&quot;, realm=&quot;%s&quot;, nonce=&quot;%s&quot;, uri=&quot;%s&quot;, ' </span><span class="s1">\</span>
               <span class="s4">'response=&quot;%s&quot;' </span><span class="s1">% (user</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">nonce</span><span class="s3">, </span><span class="s1">req.selector</span><span class="s3">,</span>
                                  <span class="s1">respdig)</span>
        <span class="s3">if </span><span class="s1">opaque:</span>
            <span class="s1">base += </span><span class="s4">', opaque=&quot;%s&quot;' </span><span class="s1">% opaque</span>
        <span class="s3">if </span><span class="s1">entdig:</span>
            <span class="s1">base += </span><span class="s4">', digest=&quot;%s&quot;' </span><span class="s1">% entdig</span>
        <span class="s1">base += </span><span class="s4">', algorithm=&quot;%s&quot;' </span><span class="s1">% algorithm</span>
        <span class="s3">if </span><span class="s1">qop:</span>
            <span class="s1">base += </span><span class="s4">', qop=auth, nc=%s, cnonce=&quot;%s&quot;' </span><span class="s1">% (ncvalue</span><span class="s3">, </span><span class="s1">cnonce)</span>
        <span class="s3">return </span><span class="s1">base</span>

    <span class="s3">def </span><span class="s1">get_algorithm_impls(self</span><span class="s3">, </span><span class="s1">algorithm):</span>
        <span class="s2"># lambdas assume digest modules are imported at the top level</span>
        <span class="s3">if </span><span class="s1">algorithm == </span><span class="s4">'MD5'</span><span class="s1">:</span>
            <span class="s1">H = </span><span class="s3">lambda </span><span class="s1">x: hashlib.md5(x.encode(</span><span class="s4">&quot;ascii&quot;</span><span class="s1">)).hexdigest()</span>
        <span class="s3">elif </span><span class="s1">algorithm == </span><span class="s4">'SHA'</span><span class="s1">:</span>
            <span class="s1">H = </span><span class="s3">lambda </span><span class="s1">x: hashlib.sha1(x.encode(</span><span class="s4">&quot;ascii&quot;</span><span class="s1">)).hexdigest()</span>
        <span class="s2"># XXX MD5-sess</span>
        <span class="s1">KD = </span><span class="s3">lambda </span><span class="s1">s</span><span class="s3">, </span><span class="s1">d: H(</span><span class="s4">&quot;%s:%s&quot; </span><span class="s1">% (s</span><span class="s3">, </span><span class="s1">d))</span>
        <span class="s3">return </span><span class="s1">H</span><span class="s3">, </span><span class="s1">KD</span>

    <span class="s3">def </span><span class="s1">get_entity_digest(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">chal):</span>
        <span class="s2"># XXX not implemented yet</span>
        <span class="s3">return None</span>


<span class="s3">class </span><span class="s1">HTTPDigestAuthHandler(BaseHandler</span><span class="s3">, </span><span class="s1">AbstractDigestAuthHandler):</span>
    <span class="s0">&quot;&quot;&quot;An authentication protocol defined by RFC 2069 
 
    Digest authentication improves on basic authentication because it 
    does not transmit passwords in the clear. 
    &quot;&quot;&quot;</span>

    <span class="s1">auth_header = </span><span class="s4">'Authorization'</span>
    <span class="s1">handler_order = </span><span class="s5">490  </span><span class="s2"># before Basic auth</span>

    <span class="s3">def </span><span class="s1">http_error_401(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s1">host = urlparse(req.full_url)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">retry = self.http_error_auth_reqed(</span><span class="s4">'www-authenticate'</span><span class="s3">,</span>
                                           <span class="s1">host</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s1">self.reset_retry_count()</span>
        <span class="s3">return </span><span class="s1">retry</span>


<span class="s3">class </span><span class="s1">ProxyDigestAuthHandler(BaseHandler</span><span class="s3">, </span><span class="s1">AbstractDigestAuthHandler):</span>

    <span class="s1">auth_header = </span><span class="s4">'Proxy-Authorization'</span>
    <span class="s1">handler_order = </span><span class="s5">490  </span><span class="s2"># before Basic auth</span>

    <span class="s3">def </span><span class="s1">http_error_407(self</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">code</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s1">host = req.host</span>
        <span class="s1">retry = self.http_error_auth_reqed(</span><span class="s4">'proxy-authenticate'</span><span class="s3">,</span>
                                           <span class="s1">host</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s1">self.reset_retry_count()</span>
        <span class="s3">return </span><span class="s1">retry</span>

<span class="s3">class </span><span class="s1">AbstractHTTPHandler(BaseHandler):</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">debuglevel=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._debuglevel = debuglevel</span>

    <span class="s3">def </span><span class="s1">set_http_debuglevel(self</span><span class="s3">, </span><span class="s1">level):</span>
        <span class="s1">self._debuglevel = level</span>

    <span class="s3">def </span><span class="s1">do_request_(self</span><span class="s3">, </span><span class="s1">request):</span>
        <span class="s1">host = request.host</span>
        <span class="s3">if not </span><span class="s1">host:</span>
            <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'no host given'</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">request.data </span><span class="s3">is not None</span><span class="s1">:  </span><span class="s2"># POST</span>
            <span class="s1">data = request.data</span>
            <span class="s3">if </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">str):</span>
                <span class="s1">msg = </span><span class="s4">&quot;POST data should be bytes or an iterable of bytes. &quot; </span><span class="s1">\</span>
                      <span class="s4">&quot;It cannot be of type str.&quot;</span>
                <span class="s3">raise </span><span class="s1">TypeError(msg)</span>
            <span class="s3">if not </span><span class="s1">request.has_header(</span><span class="s4">'Content-type'</span><span class="s1">):</span>
                <span class="s1">request.add_unredirected_header(</span>
                    <span class="s4">'Content-type'</span><span class="s3">,</span>
                    <span class="s4">'application/x-www-form-urlencoded'</span><span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">request.has_header(</span><span class="s4">'Content-length'</span><span class="s1">):</span>
                <span class="s1">size = </span><span class="s3">None</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s2">### For Python-Future:</span>
                    <span class="s3">if </span><span class="s1">PY2 </span><span class="s3">and </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">array.array):</span>
                        <span class="s2"># memoryviews of arrays aren't supported</span>
                        <span class="s2"># in Py2.7. (e.g. memoryview(array.array('I',</span>
                        <span class="s2"># [1, 2, 3, 4])) raises a TypeError.)</span>
                        <span class="s2"># So we calculate the size manually instead:</span>
                        <span class="s1">size = len(data) * data.itemsize</span>
                    <span class="s2">###</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">mv = memoryview(data)</span>
                        <span class="s1">size = len(mv) * mv.itemsize</span>
                <span class="s3">except </span><span class="s1">TypeError:</span>
                    <span class="s3">if </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">Iterable):</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Content-Length should be specified &quot;</span>
                                <span class="s4">&quot;for iterable data of type %r %r&quot; </span><span class="s1">% (type(data)</span><span class="s3">,</span>
                                <span class="s1">data))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">request.add_unredirected_header(</span>
                            <span class="s4">'Content-length'</span><span class="s3">, </span><span class="s4">'%d' </span><span class="s1">% size)</span>

        <span class="s1">sel_host = host</span>
        <span class="s3">if </span><span class="s1">request.has_proxy():</span>
            <span class="s1">scheme</span><span class="s3">, </span><span class="s1">sel = splittype(request.selector)</span>
            <span class="s1">sel_host</span><span class="s3">, </span><span class="s1">sel_path = splithost(sel)</span>
        <span class="s3">if not </span><span class="s1">request.has_header(</span><span class="s4">'Host'</span><span class="s1">):</span>
            <span class="s1">request.add_unredirected_header(</span><span class="s4">'Host'</span><span class="s3">, </span><span class="s1">sel_host)</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self.parent.addheaders:</span>
            <span class="s1">name = name.capitalize()</span>
            <span class="s3">if not </span><span class="s1">request.has_header(name):</span>
                <span class="s1">request.add_unredirected_header(name</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">return </span><span class="s1">request</span>

    <span class="s3">def </span><span class="s1">do_open(self</span><span class="s3">, </span><span class="s1">http_class</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">**http_conn_args):</span>
        <span class="s0">&quot;&quot;&quot;Return an HTTPResponse object for the request, using http_class. 
 
        http_class must implement the HTTPConnection API from http.client. 
        &quot;&quot;&quot;</span>
        <span class="s1">host = req.host</span>
        <span class="s3">if not </span><span class="s1">host:</span>
            <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'no host given'</span><span class="s1">)</span>

        <span class="s2"># will parse host:port</span>
        <span class="s1">h = http_class(host</span><span class="s3">, </span><span class="s1">timeout=req.timeout</span><span class="s3">, </span><span class="s1">**http_conn_args)</span>

        <span class="s1">headers = dict(req.unredirected_hdrs)</span>
        <span class="s1">headers.update(dict((k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">req.headers.items()</span>
                            <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">headers))</span>

        <span class="s2"># TODO(jhylton): Should this be redesigned to handle</span>
        <span class="s2"># persistent connections?</span>

        <span class="s2"># We want to make an HTTP/1.1 request, but the addinfourl</span>
        <span class="s2"># class isn't prepared to deal with a persistent connection.</span>
        <span class="s2"># It will try to read all remaining data from the socket,</span>
        <span class="s2"># which will block while the server waits for the next request.</span>
        <span class="s2"># So make sure the connection gets closed after the (only)</span>
        <span class="s2"># request.</span>
        <span class="s1">headers[</span><span class="s4">&quot;Connection&quot;</span><span class="s1">] = </span><span class="s4">&quot;close&quot;</span>
        <span class="s1">headers = dict((name.title()</span><span class="s3">, </span><span class="s1">val) </span><span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">headers.items())</span>

        <span class="s3">if </span><span class="s1">req._tunnel_host:</span>
            <span class="s1">tunnel_headers = {}</span>
            <span class="s1">proxy_auth_hdr = </span><span class="s4">&quot;Proxy-Authorization&quot;</span>
            <span class="s3">if </span><span class="s1">proxy_auth_hdr </span><span class="s3">in </span><span class="s1">headers:</span>
                <span class="s1">tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]</span>
                <span class="s2"># Proxy-Authorization should not be sent to origin</span>
                <span class="s2"># server.</span>
                <span class="s3">del </span><span class="s1">headers[proxy_auth_hdr]</span>
            <span class="s1">h.set_tunnel(req._tunnel_host</span><span class="s3">, </span><span class="s1">headers=tunnel_headers)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">h.request(req.get_method()</span><span class="s3">, </span><span class="s1">req.selector</span><span class="s3">, </span><span class="s1">req.data</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s3">except </span><span class="s1">socket.error </span><span class="s3">as </span><span class="s1">err: </span><span class="s2"># timeout error</span>
            <span class="s1">h.close()</span>
            <span class="s3">raise </span><span class="s1">URLError(err)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">r = h.getresponse()</span>
            <span class="s2"># If the server does not send us a 'Connection: close' header,</span>
            <span class="s2"># HTTPConnection assumes the socket should be left open. Manually</span>
            <span class="s2"># mark the socket to be closed when this response object goes away.</span>
            <span class="s3">if </span><span class="s1">h.sock:</span>
                <span class="s1">h.sock.close()</span>
                <span class="s1">h.sock = </span><span class="s3">None</span>


        <span class="s1">r.url = req.get_full_url()</span>
        <span class="s2"># This line replaces the .msg attribute of the HTTPResponse</span>
        <span class="s2"># with .headers, because urllib clients expect the response to</span>
        <span class="s2"># have the reason in .msg.  It would be good to mark this</span>
        <span class="s2"># attribute is deprecated and get then to use info() or</span>
        <span class="s2"># .headers.</span>
        <span class="s1">r.msg = r.reason</span>
        <span class="s3">return </span><span class="s1">r</span>


<span class="s3">class </span><span class="s1">HTTPHandler(AbstractHTTPHandler):</span>

    <span class="s3">def </span><span class="s1">http_open(self</span><span class="s3">, </span><span class="s1">req):</span>
        <span class="s3">return </span><span class="s1">self.do_open(http_client.HTTPConnection</span><span class="s3">, </span><span class="s1">req)</span>

    <span class="s1">http_request = AbstractHTTPHandler.do_request_</span>

<span class="s3">if </span><span class="s1">hasattr(http_client</span><span class="s3">, </span><span class="s4">'HTTPSConnection'</span><span class="s1">):</span>

    <span class="s3">class </span><span class="s1">HTTPSHandler(AbstractHTTPHandler):</span>

        <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">debuglevel=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">context=</span><span class="s3">None, </span><span class="s1">check_hostname=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s1">AbstractHTTPHandler.__init__(self</span><span class="s3">, </span><span class="s1">debuglevel)</span>
            <span class="s1">self._context = context</span>
            <span class="s1">self._check_hostname = check_hostname</span>

        <span class="s3">def </span><span class="s1">https_open(self</span><span class="s3">, </span><span class="s1">req):</span>
            <span class="s3">return </span><span class="s1">self.do_open(http_client.HTTPSConnection</span><span class="s3">, </span><span class="s1">req</span><span class="s3">,</span>
                <span class="s1">context=self._context</span><span class="s3">, </span><span class="s1">check_hostname=self._check_hostname)</span>

        <span class="s1">https_request = AbstractHTTPHandler.do_request_</span>

    <span class="s1">__all__.append(</span><span class="s4">'HTTPSHandler'</span><span class="s1">)</span>

<span class="s3">class </span><span class="s1">HTTPCookieProcessor(BaseHandler):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">cookiejar=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">import </span><span class="s1">future.backports.http.cookiejar </span><span class="s3">as </span><span class="s1">http_cookiejar</span>
        <span class="s3">if </span><span class="s1">cookiejar </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">cookiejar = http_cookiejar.CookieJar()</span>
        <span class="s1">self.cookiejar = cookiejar</span>

    <span class="s3">def </span><span class="s1">http_request(self</span><span class="s3">, </span><span class="s1">request):</span>
        <span class="s1">self.cookiejar.add_cookie_header(request)</span>
        <span class="s3">return </span><span class="s1">request</span>

    <span class="s3">def </span><span class="s1">http_response(self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">response):</span>
        <span class="s1">self.cookiejar.extract_cookies(response</span><span class="s3">, </span><span class="s1">request)</span>
        <span class="s3">return </span><span class="s1">response</span>

    <span class="s1">https_request = http_request</span>
    <span class="s1">https_response = http_response</span>

<span class="s3">class </span><span class="s1">UnknownHandler(BaseHandler):</span>
    <span class="s3">def </span><span class="s1">unknown_open(self</span><span class="s3">, </span><span class="s1">req):</span>
        <span class="s1">type = req.type</span>
        <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'unknown url type: %s' </span><span class="s1">% type)</span>

<span class="s3">def </span><span class="s1">parse_keqv_list(l):</span>
    <span class="s0">&quot;&quot;&quot;Parse list of key=value strings where keys are not duplicated.&quot;&quot;&quot;</span>
    <span class="s1">parsed = {}</span>
    <span class="s3">for </span><span class="s1">elt </span><span class="s3">in </span><span class="s1">l:</span>
        <span class="s1">k</span><span class="s3">, </span><span class="s1">v = elt.split(</span><span class="s4">'='</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">v[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'&quot;' </span><span class="s3">and </span><span class="s1">v[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s4">'&quot;'</span><span class="s1">:</span>
            <span class="s1">v = v[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">parsed[k] = v</span>
    <span class="s3">return </span><span class="s1">parsed</span>

<span class="s3">def </span><span class="s1">parse_http_list(s):</span>
    <span class="s0">&quot;&quot;&quot;Parse lists as described by RFC 2068 Section 2. 
 
    In particular, parse comma-separated lists where the elements of 
    the list may include quoted-strings.  A quoted-string could 
    contain a comma.  A non-quoted string could have quotes in the 
    middle.  Neither commas nor quotes count if they are escaped. 
    Only double-quotes count, not single-quotes. 
    &quot;&quot;&quot;</span>
    <span class="s1">res = []</span>
    <span class="s1">part = </span><span class="s4">''</span>

    <span class="s1">escape = quote = </span><span class="s3">False</span>
    <span class="s3">for </span><span class="s1">cur </span><span class="s3">in </span><span class="s1">s:</span>
        <span class="s3">if </span><span class="s1">escape:</span>
            <span class="s1">part += cur</span>
            <span class="s1">escape = </span><span class="s3">False</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">quote:</span>
            <span class="s3">if </span><span class="s1">cur == </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">'</span><span class="s1">:</span>
                <span class="s1">escape = </span><span class="s3">True</span>
                <span class="s3">continue</span>
            <span class="s3">elif </span><span class="s1">cur == </span><span class="s4">'&quot;'</span><span class="s1">:</span>
                <span class="s1">quote = </span><span class="s3">False</span>
            <span class="s1">part += cur</span>
            <span class="s3">continue</span>

        <span class="s3">if </span><span class="s1">cur == </span><span class="s4">','</span><span class="s1">:</span>
            <span class="s1">res.append(part)</span>
            <span class="s1">part = </span><span class="s4">''</span>
            <span class="s3">continue</span>

        <span class="s3">if </span><span class="s1">cur == </span><span class="s4">'&quot;'</span><span class="s1">:</span>
            <span class="s1">quote = </span><span class="s3">True</span>

        <span class="s1">part += cur</span>

    <span class="s2"># append last part</span>
    <span class="s3">if </span><span class="s1">part:</span>
        <span class="s1">res.append(part)</span>

    <span class="s3">return </span><span class="s1">[part.strip() </span><span class="s3">for </span><span class="s1">part </span><span class="s3">in </span><span class="s1">res]</span>

<span class="s3">class </span><span class="s1">FileHandler(BaseHandler):</span>
    <span class="s2"># Use local file or FTP depending on form of URL</span>
    <span class="s3">def </span><span class="s1">file_open(self</span><span class="s3">, </span><span class="s1">req):</span>
        <span class="s1">url = req.selector</span>
        <span class="s3">if </span><span class="s1">url[:</span><span class="s5">2</span><span class="s1">] == </span><span class="s4">'//' </span><span class="s3">and </span><span class="s1">url[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">3</span><span class="s1">] != </span><span class="s4">'/' </span><span class="s3">and </span><span class="s1">(req.host </span><span class="s3">and</span>
                <span class="s1">req.host != </span><span class="s4">'localhost'</span><span class="s1">):</span>
            <span class="s3">if not </span><span class="s1">req.host </span><span class="s3">is </span><span class="s1">self.get_names():</span>
                <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">&quot;file:// scheme is supported only on localhost&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.open_local_file(req)</span>

    <span class="s2"># names for the localhost</span>
    <span class="s1">names = </span><span class="s3">None</span>
    <span class="s3">def </span><span class="s1">get_names(self):</span>
        <span class="s3">if </span><span class="s1">FileHandler.names </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">FileHandler.names = tuple(</span>
                    <span class="s1">socket.gethostbyname_ex(</span><span class="s4">'localhost'</span><span class="s1">)[</span><span class="s5">2</span><span class="s1">] +</span>
                    <span class="s1">socket.gethostbyname_ex(socket.gethostname())[</span><span class="s5">2</span><span class="s1">])</span>
            <span class="s3">except </span><span class="s1">socket.gaierror:</span>
                <span class="s1">FileHandler.names = (socket.gethostbyname(</span><span class="s4">'localhost'</span><span class="s1">)</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">FileHandler.names</span>

    <span class="s2"># not entirely sure what the rules are here</span>
    <span class="s3">def </span><span class="s1">open_local_file(self</span><span class="s3">, </span><span class="s1">req):</span>
        <span class="s3">import </span><span class="s1">future.backports.email.utils </span><span class="s3">as </span><span class="s1">email_utils</span>
        <span class="s3">import </span><span class="s1">mimetypes</span>
        <span class="s1">host = req.host</span>
        <span class="s1">filename = req.selector</span>
        <span class="s1">localfile = url2pathname(filename)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">stats = os.stat(localfile)</span>
            <span class="s1">size = stats.st_size</span>
            <span class="s1">modified = email_utils.formatdate(stats.st_mtime</span><span class="s3">, </span><span class="s1">usegmt=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">mtype = mimetypes.guess_type(filename)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">headers = email.message_from_string(</span>
                <span class="s4">'Content-type: %s</span><span class="s3">\n</span><span class="s4">Content-length: %d</span><span class="s3">\n</span><span class="s4">Last-modified: %s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">%</span>
                <span class="s1">(mtype </span><span class="s3">or </span><span class="s4">'text/plain'</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">modified))</span>
            <span class="s3">if </span><span class="s1">host:</span>
                <span class="s1">host</span><span class="s3">, </span><span class="s1">port = splitport(host)</span>
            <span class="s3">if not </span><span class="s1">host </span><span class="s3">or </span><span class="s1">\</span>
                <span class="s1">(</span><span class="s3">not </span><span class="s1">port </span><span class="s3">and </span><span class="s1">_safe_gethostbyname(host) </span><span class="s3">in </span><span class="s1">self.get_names()):</span>
                <span class="s3">if </span><span class="s1">host:</span>
                    <span class="s1">origurl = </span><span class="s4">'file://' </span><span class="s1">+ host + filename</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">origurl = </span><span class="s4">'file://' </span><span class="s1">+ filename</span>
                <span class="s3">return </span><span class="s1">addinfourl(open(localfile</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">origurl)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">exp:</span>
            <span class="s2"># users shouldn't expect OSErrors coming from urlopen()</span>
            <span class="s3">raise </span><span class="s1">URLError(exp)</span>
        <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'file not on local host'</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_safe_gethostbyname(host):</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">socket.gethostbyname(host)</span>
    <span class="s3">except </span><span class="s1">socket.gaierror:</span>
        <span class="s3">return None</span>

<span class="s3">class </span><span class="s1">FTPHandler(BaseHandler):</span>
    <span class="s3">def </span><span class="s1">ftp_open(self</span><span class="s3">, </span><span class="s1">req):</span>
        <span class="s3">import </span><span class="s1">ftplib</span>
        <span class="s3">import </span><span class="s1">mimetypes</span>
        <span class="s1">host = req.host</span>
        <span class="s3">if not </span><span class="s1">host:</span>
            <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'ftp error: no host given'</span><span class="s1">)</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">port = splitport(host)</span>
        <span class="s3">if </span><span class="s1">port </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">port = ftplib.FTP_PORT</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">port = int(port)</span>

        <span class="s2"># username/password handling</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">host = splituser(host)</span>
        <span class="s3">if </span><span class="s1">user:</span>
            <span class="s1">user</span><span class="s3">, </span><span class="s1">passwd = splitpasswd(user)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">passwd = </span><span class="s3">None</span>
        <span class="s1">host = unquote(host)</span>
        <span class="s1">user = user </span><span class="s3">or </span><span class="s4">''</span>
        <span class="s1">passwd = passwd </span><span class="s3">or </span><span class="s4">''</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">host = socket.gethostbyname(host)</span>
        <span class="s3">except </span><span class="s1">socket.error </span><span class="s3">as </span><span class="s1">msg:</span>
            <span class="s3">raise </span><span class="s1">URLError(msg)</span>
        <span class="s1">path</span><span class="s3">, </span><span class="s1">attrs = splitattr(req.selector)</span>
        <span class="s1">dirs = path.split(</span><span class="s4">'/'</span><span class="s1">)</span>
        <span class="s1">dirs = list(map(unquote</span><span class="s3">, </span><span class="s1">dirs))</span>
        <span class="s1">dirs</span><span class="s3">, </span><span class="s1">file = dirs[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dirs[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">dirs </span><span class="s3">and not </span><span class="s1">dirs[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">dirs = dirs[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">fw = self.connect_ftp(user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">req.timeout)</span>
            <span class="s1">type = file </span><span class="s3">and </span><span class="s4">'I' </span><span class="s3">or </span><span class="s4">'D'</span>
            <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">attrs:</span>
                <span class="s1">attr</span><span class="s3">, </span><span class="s1">value = splitvalue(attr)</span>
                <span class="s3">if </span><span class="s1">attr.lower() == </span><span class="s4">'type' </span><span class="s3">and </span><span class="s1">\</span>
                   <span class="s1">value </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s4">'A'</span><span class="s3">, </span><span class="s4">'i'</span><span class="s3">, </span><span class="s4">'I'</span><span class="s3">, </span><span class="s4">'d'</span><span class="s3">, </span><span class="s4">'D'</span><span class="s1">):</span>
                    <span class="s1">type = value.upper()</span>
            <span class="s1">fp</span><span class="s3">, </span><span class="s1">retrlen = fw.retrfile(file</span><span class="s3">, </span><span class="s1">type)</span>
            <span class="s1">headers = </span><span class="s4">&quot;&quot;</span>
            <span class="s1">mtype = mimetypes.guess_type(req.full_url)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">mtype:</span>
                <span class="s1">headers += </span><span class="s4">&quot;Content-type: %s</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">% mtype</span>
            <span class="s3">if </span><span class="s1">retrlen </span><span class="s3">is not None and </span><span class="s1">retrlen &gt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">headers += </span><span class="s4">&quot;Content-length: %d</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">% retrlen</span>
            <span class="s1">headers = email.message_from_string(headers)</span>
            <span class="s3">return </span><span class="s1">addinfourl(fp</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">req.full_url)</span>
        <span class="s3">except </span><span class="s1">ftplib.all_errors </span><span class="s3">as </span><span class="s1">exp:</span>
            <span class="s1">exc = URLError(</span><span class="s4">'ftp error: %r' </span><span class="s1">% exp)</span>
            <span class="s1">raise_with_traceback(exc)</span>

    <span class="s3">def </span><span class="s1">connect_ftp(self</span><span class="s3">, </span><span class="s1">user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">timeout):</span>
        <span class="s3">return </span><span class="s1">ftpwrapper(user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">,</span>
                          <span class="s1">persistent=</span><span class="s3">False</span><span class="s1">)</span>

<span class="s3">class </span><span class="s1">CacheFTPHandler(FTPHandler):</span>
    <span class="s2"># XXX would be nice to have pluggable cache strategies</span>
    <span class="s2"># XXX this stuff is definitely not thread safe</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.cache = {}</span>
        <span class="s1">self.timeout = {}</span>
        <span class="s1">self.soonest = </span><span class="s5">0</span>
        <span class="s1">self.delay = </span><span class="s5">60</span>
        <span class="s1">self.max_conns = </span><span class="s5">16</span>

    <span class="s3">def </span><span class="s1">setTimeout(self</span><span class="s3">, </span><span class="s1">t):</span>
        <span class="s1">self.delay = t</span>

    <span class="s3">def </span><span class="s1">setMaxConns(self</span><span class="s3">, </span><span class="s1">m):</span>
        <span class="s1">self.max_conns = m</span>

    <span class="s3">def </span><span class="s1">connect_ftp(self</span><span class="s3">, </span><span class="s1">user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">timeout):</span>
        <span class="s1">key = user</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s4">'/'</span><span class="s1">.join(dirs)</span><span class="s3">, </span><span class="s1">timeout</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.cache:</span>
            <span class="s1">self.timeout[key] = time.time() + self.delay</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.cache[key] = ftpwrapper(user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">,</span>
                                         <span class="s1">dirs</span><span class="s3">, </span><span class="s1">timeout)</span>
            <span class="s1">self.timeout[key] = time.time() + self.delay</span>
        <span class="s1">self.check_cache()</span>
        <span class="s3">return </span><span class="s1">self.cache[key]</span>

    <span class="s3">def </span><span class="s1">check_cache(self):</span>
        <span class="s2"># first check for old ones</span>
        <span class="s1">t = time.time()</span>
        <span class="s3">if </span><span class="s1">self.soonest &lt;= t:</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">list(self.timeout.items()):</span>
                <span class="s3">if </span><span class="s1">v &lt; t:</span>
                    <span class="s1">self.cache[k].close()</span>
                    <span class="s3">del </span><span class="s1">self.cache[k]</span>
                    <span class="s3">del </span><span class="s1">self.timeout[k]</span>
        <span class="s1">self.soonest = min(list(self.timeout.values()))</span>

        <span class="s2"># then check the size</span>
        <span class="s3">if </span><span class="s1">len(self.cache) == self.max_conns:</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">list(self.timeout.items()):</span>
                <span class="s3">if </span><span class="s1">v == self.soonest:</span>
                    <span class="s3">del </span><span class="s1">self.cache[k]</span>
                    <span class="s3">del </span><span class="s1">self.timeout[k]</span>
                    <span class="s3">break</span>
            <span class="s1">self.soonest = min(list(self.timeout.values()))</span>

    <span class="s3">def </span><span class="s1">clear_cache(self):</span>
        <span class="s3">for </span><span class="s1">conn </span><span class="s3">in </span><span class="s1">self.cache.values():</span>
            <span class="s1">conn.close()</span>
        <span class="s1">self.cache.clear()</span>
        <span class="s1">self.timeout.clear()</span>


<span class="s2"># Code move from the old urllib module</span>

<span class="s1">MAXFTPCACHE = </span><span class="s5">10        </span><span class="s2"># Trim the ftp cache beyond this size</span>

<span class="s2"># Helper for non-unix systems</span>
<span class="s3">if </span><span class="s1">os.name == </span><span class="s4">'nt'</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">nturl2path </span><span class="s3">import </span><span class="s1">url2pathname</span><span class="s3">, </span><span class="s1">pathname2url</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s3">def </span><span class="s1">url2pathname(pathname):</span>
        <span class="s0">&quot;&quot;&quot;OS-specific conversion from a relative URL of the 'file' scheme 
        to a file system path; not recommended for general use.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">unquote(pathname)</span>

    <span class="s3">def </span><span class="s1">pathname2url(pathname):</span>
        <span class="s0">&quot;&quot;&quot;OS-specific conversion from a file system path to a relative URL 
        of the 'file' scheme; not recommended for general use.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">quote(pathname)</span>

<span class="s2"># This really consists of two pieces:</span>
<span class="s2"># (1) a class which handles opening of all sorts of URLs</span>
<span class="s2">#     (plus assorted utilities etc.)</span>
<span class="s2"># (2) a set of functions for parsing URLs</span>
<span class="s2"># XXX Should these be separated out into different modules?</span>


<span class="s1">ftpcache = {}</span>
<span class="s3">class </span><span class="s1">URLopener(object):</span>
    <span class="s0">&quot;&quot;&quot;Class to open URLs. 
    This is a class rather than just a subroutine because we may need 
    more than one set of global protocol-specific options. 
    Note -- this is a base class for those who don't want the 
    automatic handling of errors type 302 (relocated) and 401 
    (authorization needed).&quot;&quot;&quot;</span>

    <span class="s1">__tempfiles = </span><span class="s3">None</span>

    <span class="s1">version = </span><span class="s4">&quot;Python-urllib/%s&quot; </span><span class="s1">% __version__</span>

    <span class="s2"># Constructor</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">proxies=</span><span class="s3">None, </span><span class="s1">**x509):</span>
        <span class="s1">msg = </span><span class="s4">&quot;%(class)s style of invoking requests is deprecated. &quot; </span><span class="s1">\</span>
              <span class="s4">&quot;Use newer urlopen functions/methods&quot; </span><span class="s1">% {</span><span class="s4">'class'</span><span class="s1">: self.__class__.__name__}</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">proxies </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">proxies = getproxies()</span>
        <span class="s3">assert </span><span class="s1">hasattr(proxies</span><span class="s3">, </span><span class="s4">'keys'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;proxies must be a mapping&quot;</span>
        <span class="s1">self.proxies = proxies</span>
        <span class="s1">self.key_file = x509.get(</span><span class="s4">'key_file'</span><span class="s1">)</span>
        <span class="s1">self.cert_file = x509.get(</span><span class="s4">'cert_file'</span><span class="s1">)</span>
        <span class="s1">self.addheaders = [(</span><span class="s4">'User-Agent'</span><span class="s3">, </span><span class="s1">self.version)]</span>
        <span class="s1">self.__tempfiles = []</span>
        <span class="s1">self.__unlink = os.unlink </span><span class="s2"># See cleanup()</span>
        <span class="s1">self.tempcache = </span><span class="s3">None</span>
        <span class="s2"># Undocumented feature: if you assign {} to tempcache,</span>
        <span class="s2"># it is used to cache files retrieved with</span>
        <span class="s2"># self.retrieve().  This is not enabled by default</span>
        <span class="s2"># since it does not work for changing documents (and I</span>
        <span class="s2"># haven't got the logic to check expiration headers</span>
        <span class="s2"># yet).</span>
        <span class="s1">self.ftpcache = ftpcache</span>
        <span class="s2"># Undocumented feature: you can use a different</span>
        <span class="s2"># ftp cache by assigning to the .ftpcache member;</span>
        <span class="s2"># in case you want logically independent URL openers</span>
        <span class="s2"># XXX This is not threadsafe.  Bah.</span>

    <span class="s3">def </span><span class="s1">__del__(self):</span>
        <span class="s1">self.close()</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s1">self.cleanup()</span>

    <span class="s3">def </span><span class="s1">cleanup(self):</span>
        <span class="s2"># This code sometimes runs when the rest of this module</span>
        <span class="s2"># has already been deleted, so it can't use any globals</span>
        <span class="s2"># or import anything.</span>
        <span class="s3">if </span><span class="s1">self.__tempfiles:</span>
            <span class="s3">for </span><span class="s1">file </span><span class="s3">in </span><span class="s1">self.__tempfiles:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">self.__unlink(file)</span>
                <span class="s3">except </span><span class="s1">OSError:</span>
                    <span class="s3">pass</span>
            <span class="s3">del </span><span class="s1">self.__tempfiles[:]</span>
        <span class="s3">if </span><span class="s1">self.tempcache:</span>
            <span class="s1">self.tempcache.clear()</span>

    <span class="s3">def </span><span class="s1">addheader(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot;Add a header to be used by the HTTP interface only 
        e.g. u.addheader('Accept', 'sound/basic')&quot;&quot;&quot;</span>
        <span class="s1">self.addheaders.append(args)</span>

    <span class="s2"># External interface</span>
    <span class="s3">def </span><span class="s1">open(self</span><span class="s3">, </span><span class="s1">fullurl</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Use URLopener().open(file) instead of open(file, 'r').&quot;&quot;&quot;</span>
        <span class="s1">fullurl = unwrap(to_bytes(fullurl))</span>
        <span class="s1">fullurl = quote(fullurl</span><span class="s3">, </span><span class="s1">safe=</span><span class="s4">&quot;%/:=&amp;?~#+!$,;'@()*[]|&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.tempcache </span><span class="s3">and </span><span class="s1">fullurl </span><span class="s3">in </span><span class="s1">self.tempcache:</span>
            <span class="s1">filename</span><span class="s3">, </span><span class="s1">headers = self.tempcache[fullurl]</span>
            <span class="s1">fp = open(filename</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">addinfourl(fp</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">fullurl)</span>
        <span class="s1">urltype</span><span class="s3">, </span><span class="s1">url = splittype(fullurl)</span>
        <span class="s3">if not </span><span class="s1">urltype:</span>
            <span class="s1">urltype = </span><span class="s4">'file'</span>
        <span class="s3">if </span><span class="s1">urltype </span><span class="s3">in </span><span class="s1">self.proxies:</span>
            <span class="s1">proxy = self.proxies[urltype]</span>
            <span class="s1">urltype</span><span class="s3">, </span><span class="s1">proxyhost = splittype(proxy)</span>
            <span class="s1">host</span><span class="s3">, </span><span class="s1">selector = splithost(proxyhost)</span>
            <span class="s1">url = (host</span><span class="s3">, </span><span class="s1">fullurl) </span><span class="s2"># Signal special case to open_*()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">proxy = </span><span class="s3">None</span>
        <span class="s1">name = </span><span class="s4">'open_' </span><span class="s1">+ urltype</span>
        <span class="s1">self.type = urltype</span>
        <span class="s1">name = name.replace(</span><span class="s4">'-'</span><span class="s3">, </span><span class="s4">'_'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s3">if </span><span class="s1">proxy:</span>
                <span class="s3">return </span><span class="s1">self.open_unknown_proxy(proxy</span><span class="s3">, </span><span class="s1">fullurl</span><span class="s3">, </span><span class="s1">data)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self.open_unknown(fullurl</span><span class="s3">, </span><span class="s1">data)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">data </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s1">name)(url)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s1">name)(url</span><span class="s3">, </span><span class="s1">data)</span>
        <span class="s3">except </span><span class="s1">HTTPError:</span>
            <span class="s3">raise</span>
        <span class="s3">except </span><span class="s1">socket.error </span><span class="s3">as </span><span class="s1">msg:</span>
            <span class="s1">raise_with_traceback(IOError(</span><span class="s4">'socket error'</span><span class="s3">, </span><span class="s1">msg))</span>

    <span class="s3">def </span><span class="s1">open_unknown(self</span><span class="s3">, </span><span class="s1">fullurl</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Overridable interface to open unknown URL type.&quot;&quot;&quot;</span>
        <span class="s1">type</span><span class="s3">, </span><span class="s1">url = splittype(fullurl)</span>
        <span class="s3">raise </span><span class="s1">IOError(</span><span class="s4">'url error'</span><span class="s3">, </span><span class="s4">'unknown url type'</span><span class="s3">, </span><span class="s1">type)</span>

    <span class="s3">def </span><span class="s1">open_unknown_proxy(self</span><span class="s3">, </span><span class="s1">proxy</span><span class="s3">, </span><span class="s1">fullurl</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Overridable interface to open unknown URL type.&quot;&quot;&quot;</span>
        <span class="s1">type</span><span class="s3">, </span><span class="s1">url = splittype(fullurl)</span>
        <span class="s3">raise </span><span class="s1">IOError(</span><span class="s4">'url error'</span><span class="s3">, </span><span class="s4">'invalid proxy for %s' </span><span class="s1">% type</span><span class="s3">, </span><span class="s1">proxy)</span>

    <span class="s2"># External interface</span>
    <span class="s3">def </span><span class="s1">retrieve(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">filename=</span><span class="s3">None, </span><span class="s1">reporthook=</span><span class="s3">None, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;retrieve(url) returns (filename, headers) for a local object 
        or (tempfilename, headers) for a remote object.&quot;&quot;&quot;</span>
        <span class="s1">url = unwrap(to_bytes(url))</span>
        <span class="s3">if </span><span class="s1">self.tempcache </span><span class="s3">and </span><span class="s1">url </span><span class="s3">in </span><span class="s1">self.tempcache:</span>
            <span class="s3">return </span><span class="s1">self.tempcache[url]</span>
        <span class="s1">type</span><span class="s3">, </span><span class="s1">url1 = splittype(url)</span>
        <span class="s3">if </span><span class="s1">filename </span><span class="s3">is None and </span><span class="s1">(</span><span class="s3">not </span><span class="s1">type </span><span class="s3">or </span><span class="s1">type == </span><span class="s4">'file'</span><span class="s1">):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">fp = self.open_local_file(url1)</span>
                <span class="s1">hdrs = fp.info()</span>
                <span class="s1">fp.close()</span>
                <span class="s3">return </span><span class="s1">url2pathname(splithost(url1)[</span><span class="s5">1</span><span class="s1">])</span><span class="s3">, </span><span class="s1">hdrs</span>
            <span class="s3">except </span><span class="s1">IOError </span><span class="s3">as </span><span class="s1">msg:</span>
                <span class="s3">pass</span>
        <span class="s1">fp = self.open(url</span><span class="s3">, </span><span class="s1">data)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">headers = fp.info()</span>
            <span class="s3">if </span><span class="s1">filename:</span>
                <span class="s1">tfp = open(filename</span><span class="s3">, </span><span class="s4">'wb'</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">import </span><span class="s1">tempfile</span>
                <span class="s1">garbage</span><span class="s3">, </span><span class="s1">path = splittype(url)</span>
                <span class="s1">garbage</span><span class="s3">, </span><span class="s1">path = splithost(path </span><span class="s3">or </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">path</span><span class="s3">, </span><span class="s1">garbage = splitquery(path </span><span class="s3">or </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">path</span><span class="s3">, </span><span class="s1">garbage = splitattr(path </span><span class="s3">or </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">suffix = os.path.splitext(path)[</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">(fd</span><span class="s3">, </span><span class="s1">filename) = tempfile.mkstemp(suffix)</span>
                <span class="s1">self.__tempfiles.append(filename)</span>
                <span class="s1">tfp = os.fdopen(fd</span><span class="s3">, </span><span class="s4">'wb'</span><span class="s1">)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">result = filename</span><span class="s3">, </span><span class="s1">headers</span>
                <span class="s3">if </span><span class="s1">self.tempcache </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">self.tempcache[url] = result</span>
                <span class="s1">bs = </span><span class="s5">1024</span><span class="s1">*</span><span class="s5">8</span>
                <span class="s1">size = -</span><span class="s5">1</span>
                <span class="s1">read = </span><span class="s5">0</span>
                <span class="s1">blocknum = </span><span class="s5">0</span>
                <span class="s3">if </span><span class="s4">&quot;content-length&quot; </span><span class="s3">in </span><span class="s1">headers:</span>
                    <span class="s1">size = int(headers[</span><span class="s4">&quot;Content-Length&quot;</span><span class="s1">])</span>
                <span class="s3">if </span><span class="s1">reporthook:</span>
                    <span class="s1">reporthook(blocknum</span><span class="s3">, </span><span class="s1">bs</span><span class="s3">, </span><span class="s1">size)</span>
                <span class="s3">while </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">block = fp.read(bs)</span>
                    <span class="s3">if not </span><span class="s1">block:</span>
                        <span class="s3">break</span>
                    <span class="s1">read += len(block)</span>
                    <span class="s1">tfp.write(block)</span>
                    <span class="s1">blocknum += </span><span class="s5">1</span>
                    <span class="s3">if </span><span class="s1">reporthook:</span>
                        <span class="s1">reporthook(blocknum</span><span class="s3">, </span><span class="s1">bs</span><span class="s3">, </span><span class="s1">size)</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s1">tfp.close()</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">fp.close()</span>

        <span class="s2"># raise exception if actual size does not match content-length header</span>
        <span class="s3">if </span><span class="s1">size &gt;= </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">read &lt; size:</span>
            <span class="s3">raise </span><span class="s1">ContentTooShortError(</span>
                <span class="s4">&quot;retrieval incomplete: got only %i out of %i bytes&quot;</span>
                <span class="s1">% (read</span><span class="s3">, </span><span class="s1">size)</span><span class="s3">, </span><span class="s1">result)</span>

        <span class="s3">return </span><span class="s1">result</span>

    <span class="s2"># Each method named open_&lt;type&gt; knows how to open that type of URL</span>

    <span class="s3">def </span><span class="s1">_open_generic_http(self</span><span class="s3">, </span><span class="s1">connection_factory</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s0">&quot;&quot;&quot;Make an HTTP connection using connection_class. 
 
        This is an internal method that should be called from 
        open_http() or open_https(). 
 
        Arguments: 
        - connection_factory should take a host name and return an 
          HTTPConnection instance. 
        - url is the url to retrieval or a host, relative-path pair. 
        - data is payload for a POST request or None. 
        &quot;&quot;&quot;</span>

        <span class="s1">user_passwd = </span><span class="s3">None</span>
        <span class="s1">proxy_passwd= </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">isinstance(url</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">host</span><span class="s3">, </span><span class="s1">selector = splithost(url)</span>
            <span class="s3">if </span><span class="s1">host:</span>
                <span class="s1">user_passwd</span><span class="s3">, </span><span class="s1">host = splituser(host)</span>
                <span class="s1">host = unquote(host)</span>
            <span class="s1">realhost = host</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">host</span><span class="s3">, </span><span class="s1">selector = url</span>
            <span class="s2"># check whether the proxy contains authorization information</span>
            <span class="s1">proxy_passwd</span><span class="s3">, </span><span class="s1">host = splituser(host)</span>
            <span class="s2"># now we proceed with the url we want to obtain</span>
            <span class="s1">urltype</span><span class="s3">, </span><span class="s1">rest = splittype(selector)</span>
            <span class="s1">url = rest</span>
            <span class="s1">user_passwd = </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">urltype.lower() != </span><span class="s4">'http'</span><span class="s1">:</span>
                <span class="s1">realhost = </span><span class="s3">None</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">realhost</span><span class="s3">, </span><span class="s1">rest = splithost(rest)</span>
                <span class="s3">if </span><span class="s1">realhost:</span>
                    <span class="s1">user_passwd</span><span class="s3">, </span><span class="s1">realhost = splituser(realhost)</span>
                <span class="s3">if </span><span class="s1">user_passwd:</span>
                    <span class="s1">selector = </span><span class="s4">&quot;%s://%s%s&quot; </span><span class="s1">% (urltype</span><span class="s3">, </span><span class="s1">realhost</span><span class="s3">, </span><span class="s1">rest)</span>
                <span class="s3">if </span><span class="s1">proxy_bypass(realhost):</span>
                    <span class="s1">host = realhost</span>

        <span class="s3">if not </span><span class="s1">host: </span><span class="s3">raise </span><span class="s1">IOError(</span><span class="s4">'http error'</span><span class="s3">, </span><span class="s4">'no host given'</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">proxy_passwd:</span>
            <span class="s1">proxy_passwd = unquote(proxy_passwd)</span>
            <span class="s1">proxy_auth = base64.b64encode(proxy_passwd.encode()).decode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">proxy_auth = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">user_passwd:</span>
            <span class="s1">user_passwd = unquote(user_passwd)</span>
            <span class="s1">auth = base64.b64encode(user_passwd.encode()).decode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">auth = </span><span class="s3">None</span>
        <span class="s1">http_conn = connection_factory(host)</span>
        <span class="s1">headers = {}</span>
        <span class="s3">if </span><span class="s1">proxy_auth:</span>
            <span class="s1">headers[</span><span class="s4">&quot;Proxy-Authorization&quot;</span><span class="s1">] = </span><span class="s4">&quot;Basic %s&quot; </span><span class="s1">% proxy_auth</span>
        <span class="s3">if </span><span class="s1">auth:</span>
            <span class="s1">headers[</span><span class="s4">&quot;Authorization&quot;</span><span class="s1">] =  </span><span class="s4">&quot;Basic %s&quot; </span><span class="s1">% auth</span>
        <span class="s3">if </span><span class="s1">realhost:</span>
            <span class="s1">headers[</span><span class="s4">&quot;Host&quot;</span><span class="s1">] = realhost</span>

        <span class="s2"># Add Connection:close as we don't support persistent connections yet.</span>
        <span class="s2"># This helps in closing the socket and avoiding ResourceWarning</span>

        <span class="s1">headers[</span><span class="s4">&quot;Connection&quot;</span><span class="s1">] = </span><span class="s4">&quot;close&quot;</span>

        <span class="s3">for </span><span class="s1">header</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self.addheaders:</span>
            <span class="s1">headers[header] = value</span>

        <span class="s3">if </span><span class="s1">data </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">headers[</span><span class="s4">&quot;Content-Type&quot;</span><span class="s1">] = </span><span class="s4">&quot;application/x-www-form-urlencoded&quot;</span>
            <span class="s1">http_conn.request(</span><span class="s4">&quot;POST&quot;</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">http_conn.request(</span><span class="s4">&quot;GET&quot;</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">headers=headers)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">response = http_conn.getresponse()</span>
        <span class="s3">except </span><span class="s1">http_client.BadStatusLine:</span>
            <span class="s2"># something went wrong with the HTTP status line</span>
            <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">&quot;http protocol error: bad status line&quot;</span><span class="s1">)</span>

        <span class="s2"># According to RFC 2616, &quot;2xx&quot; code indicates that the client's</span>
        <span class="s2"># request was successfully received, understood, and accepted.</span>
        <span class="s3">if </span><span class="s5">200 </span><span class="s1">&lt;= response.status &lt; </span><span class="s5">300</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">addinfourl(response</span><span class="s3">, </span><span class="s1">response.msg</span><span class="s3">, </span><span class="s4">&quot;http:&quot; </span><span class="s1">+ url</span><span class="s3">,</span>
                              <span class="s1">response.status)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.http_error(</span>
                <span class="s1">url</span><span class="s3">, </span><span class="s1">response.fp</span><span class="s3">,</span>
                <span class="s1">response.status</span><span class="s3">, </span><span class="s1">response.reason</span><span class="s3">, </span><span class="s1">response.msg</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s3">def </span><span class="s1">open_http(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Use HTTP protocol.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._open_generic_http(http_client.HTTPConnection</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s3">def </span><span class="s1">http_error(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Handle http errors. 
 
        Derived class can override this, or provide specific handlers 
        named http_error_DDD where DDD is the 3-digit error code.&quot;&quot;&quot;</span>
        <span class="s2"># First check if there's a specific handler for this error</span>
        <span class="s1">name = </span><span class="s4">'http_error_%d' </span><span class="s1">% errcode</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s1">name):</span>
            <span class="s1">method = getattr(self</span><span class="s3">, </span><span class="s1">name)</span>
            <span class="s3">if </span><span class="s1">data </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">result = method(url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">result = method(url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">data)</span>
            <span class="s3">if </span><span class="s1">result: </span><span class="s3">return </span><span class="s1">result</span>
        <span class="s3">return </span><span class="s1">self.http_error_default(url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers)</span>

    <span class="s3">def </span><span class="s1">http_error_default(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s0">&quot;&quot;&quot;Default error handler: close the connection and raise IOError.&quot;&quot;&quot;</span>
        <span class="s1">fp.close()</span>
        <span class="s3">raise </span><span class="s1">HTTPError(url</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">_have_ssl:</span>
        <span class="s3">def </span><span class="s1">_https_connection(self</span><span class="s3">, </span><span class="s1">host):</span>
            <span class="s3">return </span><span class="s1">http_client.HTTPSConnection(host</span><span class="s3">,</span>
                                           <span class="s1">key_file=self.key_file</span><span class="s3">,</span>
                                           <span class="s1">cert_file=self.cert_file)</span>

        <span class="s3">def </span><span class="s1">open_https(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot;Use HTTPS protocol.&quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">self._open_generic_http(self._https_connection</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s3">def </span><span class="s1">open_file(self</span><span class="s3">, </span><span class="s1">url):</span>
        <span class="s0">&quot;&quot;&quot;Use local file or FTP depending on form of URL.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">isinstance(url</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'file error: proxy support for file protocol currently not implemented'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">url[:</span><span class="s5">2</span><span class="s1">] == </span><span class="s4">'//' </span><span class="s3">and </span><span class="s1">url[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">3</span><span class="s1">] != </span><span class="s4">'/' </span><span class="s3">and </span><span class="s1">url[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">12</span><span class="s1">].lower() != </span><span class="s4">'localhost/'</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;file:// scheme is supported only on localhost&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.open_local_file(url)</span>

    <span class="s3">def </span><span class="s1">open_local_file(self</span><span class="s3">, </span><span class="s1">url):</span>
        <span class="s0">&quot;&quot;&quot;Use local file.&quot;&quot;&quot;</span>
        <span class="s3">import </span><span class="s1">future.backports.email.utils </span><span class="s3">as </span><span class="s1">email_utils</span>
        <span class="s3">import </span><span class="s1">mimetypes</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">file = splithost(url)</span>
        <span class="s1">localname = url2pathname(file)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">stats = os.stat(localname)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">raise </span><span class="s1">URLError(e.strerror</span><span class="s3">, </span><span class="s1">e.filename)</span>
        <span class="s1">size = stats.st_size</span>
        <span class="s1">modified = email_utils.formatdate(stats.st_mtime</span><span class="s3">, </span><span class="s1">usegmt=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">mtype = mimetypes.guess_type(url)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">headers = email.message_from_string(</span>
            <span class="s4">'Content-Type: %s</span><span class="s3">\n</span><span class="s4">Content-Length: %d</span><span class="s3">\n</span><span class="s4">Last-modified: %s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">%</span>
            <span class="s1">(mtype </span><span class="s3">or </span><span class="s4">'text/plain'</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">modified))</span>
        <span class="s3">if not </span><span class="s1">host:</span>
            <span class="s1">urlfile = file</span>
            <span class="s3">if </span><span class="s1">file[:</span><span class="s5">1</span><span class="s1">] == </span><span class="s4">'/'</span><span class="s1">:</span>
                <span class="s1">urlfile = </span><span class="s4">'file://' </span><span class="s1">+ file</span>
            <span class="s3">return </span><span class="s1">addinfourl(open(localname</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">urlfile)</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">port = splitport(host)</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">port</span>
           <span class="s3">and </span><span class="s1">socket.gethostbyname(host) </span><span class="s3">in </span><span class="s1">((localhost()</span><span class="s3">,</span><span class="s1">) + thishost())):</span>
            <span class="s1">urlfile = file</span>
            <span class="s3">if </span><span class="s1">file[:</span><span class="s5">1</span><span class="s1">] == </span><span class="s4">'/'</span><span class="s1">:</span>
                <span class="s1">urlfile = </span><span class="s4">'file://' </span><span class="s1">+ file</span>
            <span class="s3">elif </span><span class="s1">file[:</span><span class="s5">2</span><span class="s1">] == </span><span class="s4">'./'</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;local file url may start with / or file:. Unknown url of type: %s&quot; </span><span class="s1">% url)</span>
            <span class="s3">return </span><span class="s1">addinfourl(open(localname</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">urlfile)</span>
        <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'local file error: not on local host'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">open_ftp(self</span><span class="s3">, </span><span class="s1">url):</span>
        <span class="s0">&quot;&quot;&quot;Use FTP protocol.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">isinstance(url</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'ftp error: proxy support for ftp protocol currently not implemented'</span><span class="s1">)</span>
        <span class="s3">import </span><span class="s1">mimetypes</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">path = splithost(url)</span>
        <span class="s3">if not </span><span class="s1">host: </span><span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'ftp error: no host given'</span><span class="s1">)</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">port = splitport(host)</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">host = splituser(host)</span>
        <span class="s3">if </span><span class="s1">user: user</span><span class="s3">, </span><span class="s1">passwd = splitpasswd(user)</span>
        <span class="s3">else</span><span class="s1">: passwd = </span><span class="s3">None</span>
        <span class="s1">host = unquote(host)</span>
        <span class="s1">user = unquote(user </span><span class="s3">or </span><span class="s4">''</span><span class="s1">)</span>
        <span class="s1">passwd = unquote(passwd </span><span class="s3">or </span><span class="s4">''</span><span class="s1">)</span>
        <span class="s1">host = socket.gethostbyname(host)</span>
        <span class="s3">if not </span><span class="s1">port:</span>
            <span class="s3">import </span><span class="s1">ftplib</span>
            <span class="s1">port = ftplib.FTP_PORT</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">port = int(port)</span>
        <span class="s1">path</span><span class="s3">, </span><span class="s1">attrs = splitattr(path)</span>
        <span class="s1">path = unquote(path)</span>
        <span class="s1">dirs = path.split(</span><span class="s4">'/'</span><span class="s1">)</span>
        <span class="s1">dirs</span><span class="s3">, </span><span class="s1">file = dirs[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dirs[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">dirs </span><span class="s3">and not </span><span class="s1">dirs[</span><span class="s5">0</span><span class="s1">]: dirs = dirs[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s3">if </span><span class="s1">dirs </span><span class="s3">and not </span><span class="s1">dirs[</span><span class="s5">0</span><span class="s1">]: dirs[</span><span class="s5">0</span><span class="s1">] = </span><span class="s4">'/'</span>
        <span class="s1">key = user</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s4">'/'</span><span class="s1">.join(dirs)</span>
        <span class="s2"># XXX thread unsafe!</span>
        <span class="s3">if </span><span class="s1">len(self.ftpcache) &gt; MAXFTPCACHE:</span>
            <span class="s2"># Prune the cache, rather arbitrarily</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">self.ftpcache.keys():</span>
                <span class="s3">if </span><span class="s1">k != key:</span>
                    <span class="s1">v = self.ftpcache[k]</span>
                    <span class="s3">del </span><span class="s1">self.ftpcache[k]</span>
                    <span class="s1">v.close()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">not in </span><span class="s1">self.ftpcache:</span>
                <span class="s1">self.ftpcache[key] = \</span>
                    <span class="s1">ftpwrapper(user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">dirs)</span>
            <span class="s3">if not </span><span class="s1">file: type = </span><span class="s4">'D'</span>
            <span class="s3">else</span><span class="s1">: type = </span><span class="s4">'I'</span>
            <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">attrs:</span>
                <span class="s1">attr</span><span class="s3">, </span><span class="s1">value = splitvalue(attr)</span>
                <span class="s3">if </span><span class="s1">attr.lower() == </span><span class="s4">'type' </span><span class="s3">and </span><span class="s1">\</span>
                   <span class="s1">value </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s4">'A'</span><span class="s3">, </span><span class="s4">'i'</span><span class="s3">, </span><span class="s4">'I'</span><span class="s3">, </span><span class="s4">'d'</span><span class="s3">, </span><span class="s4">'D'</span><span class="s1">):</span>
                    <span class="s1">type = value.upper()</span>
            <span class="s1">(fp</span><span class="s3">, </span><span class="s1">retrlen) = self.ftpcache[key].retrfile(file</span><span class="s3">, </span><span class="s1">type)</span>
            <span class="s1">mtype = mimetypes.guess_type(</span><span class="s4">&quot;ftp:&quot; </span><span class="s1">+ url)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">headers = </span><span class="s4">&quot;&quot;</span>
            <span class="s3">if </span><span class="s1">mtype:</span>
                <span class="s1">headers += </span><span class="s4">&quot;Content-Type: %s</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">% mtype</span>
            <span class="s3">if </span><span class="s1">retrlen </span><span class="s3">is not None and </span><span class="s1">retrlen &gt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">headers += </span><span class="s4">&quot;Content-Length: %d</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">% retrlen</span>
            <span class="s1">headers = email.message_from_string(headers)</span>
            <span class="s3">return </span><span class="s1">addinfourl(fp</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s4">&quot;ftp:&quot; </span><span class="s1">+ url)</span>
        <span class="s3">except </span><span class="s1">ftperrors() </span><span class="s3">as </span><span class="s1">exp:</span>
            <span class="s1">raise_with_traceback(URLError(</span><span class="s4">'ftp error %r' </span><span class="s1">% exp))</span>

    <span class="s3">def </span><span class="s1">open_data(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Use &quot;data&quot; URL.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">isinstance(url</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s3">raise </span><span class="s1">URLError(</span><span class="s4">'data error: proxy support for data protocol currently not implemented'</span><span class="s1">)</span>
        <span class="s2"># ignore POSTed data</span>
        <span class="s2">#</span>
        <span class="s2"># syntax of data URLs:</span>
        <span class="s2"># dataurl   := &quot;data:&quot; [ mediatype ] [ &quot;;base64&quot; ] &quot;,&quot; data</span>
        <span class="s2"># mediatype := [ type &quot;/&quot; subtype ] *( &quot;;&quot; parameter )</span>
        <span class="s2"># data      := *urlchar</span>
        <span class="s2"># parameter := attribute &quot;=&quot; value</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">[type</span><span class="s3">, </span><span class="s1">data] = url.split(</span><span class="s4">','</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">ValueError:</span>
            <span class="s3">raise </span><span class="s1">IOError(</span><span class="s4">'data error'</span><span class="s3">, </span><span class="s4">'bad data URL'</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">type:</span>
            <span class="s1">type = </span><span class="s4">'text/plain;charset=US-ASCII'</span>
        <span class="s1">semi = type.rfind(</span><span class="s4">';'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">semi &gt;= </span><span class="s5">0 </span><span class="s3">and </span><span class="s4">'=' </span><span class="s3">not in </span><span class="s1">type[semi:]:</span>
            <span class="s1">encoding = type[semi+</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s1">type = type[:semi]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">encoding = </span><span class="s4">''</span>
        <span class="s1">msg = []</span>
        <span class="s1">msg.append(</span><span class="s4">'Date: %s'</span><span class="s1">%time.strftime(</span><span class="s4">'%a, %d %b %Y %H:%M:%S GMT'</span><span class="s3">,</span>
                                            <span class="s1">time.gmtime(time.time())))</span>
        <span class="s1">msg.append(</span><span class="s4">'Content-type: %s' </span><span class="s1">% type)</span>
        <span class="s3">if </span><span class="s1">encoding == </span><span class="s4">'base64'</span><span class="s1">:</span>
            <span class="s2"># XXX is this encoding/decoding ok?</span>
            <span class="s1">data = base64.decodebytes(data.encode(</span><span class="s4">'ascii'</span><span class="s1">)).decode(</span><span class="s4">'latin-1'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">data = unquote(data)</span>
        <span class="s1">msg.append(</span><span class="s4">'Content-Length: %d' </span><span class="s1">% len(data))</span>
        <span class="s1">msg.append(</span><span class="s4">''</span><span class="s1">)</span>
        <span class="s1">msg.append(data)</span>
        <span class="s1">msg = </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">.join(msg)</span>
        <span class="s1">headers = email.message_from_string(msg)</span>
        <span class="s1">f = io.StringIO(msg)</span>
        <span class="s2">#f.fileno = None     # needed for addinfourl</span>
        <span class="s3">return </span><span class="s1">addinfourl(f</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">url)</span>


<span class="s3">class </span><span class="s1">FancyURLopener(URLopener):</span>
    <span class="s0">&quot;&quot;&quot;Derived class with handlers for errors we can handle (perhaps).&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">URLopener.__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.auth_cache = {}</span>
        <span class="s1">self.tries = </span><span class="s5">0</span>
        <span class="s1">self.maxtries = </span><span class="s5">10</span>

    <span class="s3">def </span><span class="s1">http_error_default(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s0">&quot;&quot;&quot;Default error handling -- don't raise an exception.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">addinfourl(fp</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s4">&quot;http:&quot; </span><span class="s1">+ url</span><span class="s3">, </span><span class="s1">errcode)</span>

    <span class="s3">def </span><span class="s1">http_error_302(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Error 302 -- relocated (temporarily).&quot;&quot;&quot;</span>
        <span class="s1">self.tries += </span><span class="s5">1</span>
        <span class="s3">if </span><span class="s1">self.maxtries </span><span class="s3">and </span><span class="s1">self.tries &gt;= self.maxtries:</span>
            <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;http_error_500&quot;</span><span class="s1">):</span>
                <span class="s1">meth = self.http_error_500</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">meth = self.http_error_default</span>
            <span class="s1">self.tries = </span><span class="s5">0</span>
            <span class="s3">return </span><span class="s1">meth(url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s5">500</span><span class="s3">,</span>
                        <span class="s4">&quot;Internal Server Error: Redirect Recursion&quot;</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s1">result = self.redirect_internal(url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">,</span>
                                        <span class="s1">data)</span>
        <span class="s1">self.tries = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">redirect_internal(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s3">if </span><span class="s4">'location' </span><span class="s3">in </span><span class="s1">headers:</span>
            <span class="s1">newurl = headers[</span><span class="s4">'location'</span><span class="s1">]</span>
        <span class="s3">elif </span><span class="s4">'uri' </span><span class="s3">in </span><span class="s1">headers:</span>
            <span class="s1">newurl = headers[</span><span class="s4">'uri'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s1">fp.close()</span>

        <span class="s2"># In case the server sent a relative URL, join with original:</span>
        <span class="s1">newurl = urljoin(self.type + </span><span class="s4">&quot;:&quot; </span><span class="s1">+ url</span><span class="s3">, </span><span class="s1">newurl)</span>

        <span class="s1">urlparts = urlparse(newurl)</span>

        <span class="s2"># For security reasons, we don't allow redirection to anything other</span>
        <span class="s2"># than http, https and ftp.</span>

        <span class="s2"># We are using newer HTTPError with older redirect_internal method</span>
        <span class="s2"># This older method will get deprecated in 3.3</span>

        <span class="s3">if </span><span class="s1">urlparts.scheme </span><span class="s3">not in </span><span class="s1">(</span><span class="s4">'http'</span><span class="s3">, </span><span class="s4">'https'</span><span class="s3">, </span><span class="s4">'ftp'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">HTTPError(newurl</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">,</span>
                            <span class="s1">errmsg +</span>
                            <span class="s4">&quot; Redirection to url '%s' is not allowed.&quot; </span><span class="s1">% newurl</span><span class="s3">,</span>
                            <span class="s1">headers</span><span class="s3">, </span><span class="s1">fp)</span>

        <span class="s3">return </span><span class="s1">self.open(newurl)</span>

    <span class="s3">def </span><span class="s1">http_error_301(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Error 301 -- also relocated (permanently).&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.http_error_302(url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s3">def </span><span class="s1">http_error_303(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Error 303 -- also relocated (essentially identical to 302).&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.http_error_302(url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s3">def </span><span class="s1">http_error_307(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Error 307 -- relocated, but turn POST into error.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">data </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.http_error_302(url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">data)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.http_error_default(url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers)</span>

    <span class="s3">def </span><span class="s1">http_error_401(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None,</span>
            <span class="s1">retry=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Error 401 -- authentication required. 
        This function supports Basic authentication only.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s4">'www-authenticate' </span><span class="s3">not in </span><span class="s1">headers:</span>
            <span class="s1">URLopener.http_error_default(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">,</span>
                                         <span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s1">stuff = headers[</span><span class="s4">'www-authenticate'</span><span class="s1">]</span>
        <span class="s1">match = re.match(</span><span class="s4">'[ </span><span class="s3">\t</span><span class="s4">]*([^ </span><span class="s3">\t</span><span class="s4">]+)[ </span><span class="s3">\t</span><span class="s4">]+realm=&quot;([^&quot;]*)&quot;'</span><span class="s3">, </span><span class="s1">stuff)</span>
        <span class="s3">if not </span><span class="s1">match:</span>
            <span class="s1">URLopener.http_error_default(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">,</span>
                                         <span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s1">scheme</span><span class="s3">, </span><span class="s1">realm = match.groups()</span>
        <span class="s3">if </span><span class="s1">scheme.lower() != </span><span class="s4">'basic'</span><span class="s1">:</span>
            <span class="s1">URLopener.http_error_default(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">,</span>
                                         <span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s3">if not </span><span class="s1">retry:</span>
            <span class="s1">URLopener.http_error_default(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">,</span>
                    <span class="s1">headers)</span>
        <span class="s1">name = </span><span class="s4">'retry_' </span><span class="s1">+ self.type + </span><span class="s4">'_basic_auth'</span>
        <span class="s3">if </span><span class="s1">data </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">,</span><span class="s1">name)(url</span><span class="s3">, </span><span class="s1">realm)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">,</span><span class="s1">name)(url</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s3">def </span><span class="s1">http_error_407(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None,</span>
            <span class="s1">retry=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Error 407 -- proxy authentication required. 
        This function supports Basic authentication only.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s4">'proxy-authenticate' </span><span class="s3">not in </span><span class="s1">headers:</span>
            <span class="s1">URLopener.http_error_default(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">,</span>
                                         <span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s1">stuff = headers[</span><span class="s4">'proxy-authenticate'</span><span class="s1">]</span>
        <span class="s1">match = re.match(</span><span class="s4">'[ </span><span class="s3">\t</span><span class="s4">]*([^ </span><span class="s3">\t</span><span class="s4">]+)[ </span><span class="s3">\t</span><span class="s4">]+realm=&quot;([^&quot;]*)&quot;'</span><span class="s3">, </span><span class="s1">stuff)</span>
        <span class="s3">if not </span><span class="s1">match:</span>
            <span class="s1">URLopener.http_error_default(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">,</span>
                                         <span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s1">scheme</span><span class="s3">, </span><span class="s1">realm = match.groups()</span>
        <span class="s3">if </span><span class="s1">scheme.lower() != </span><span class="s4">'basic'</span><span class="s1">:</span>
            <span class="s1">URLopener.http_error_default(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">,</span>
                                         <span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s3">if not </span><span class="s1">retry:</span>
            <span class="s1">URLopener.http_error_default(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">,</span>
                    <span class="s1">headers)</span>
        <span class="s1">name = </span><span class="s4">'retry_proxy_' </span><span class="s1">+ self.type + </span><span class="s4">'_basic_auth'</span>
        <span class="s3">if </span><span class="s1">data </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">,</span><span class="s1">name)(url</span><span class="s3">, </span><span class="s1">realm)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">,</span><span class="s1">name)(url</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s3">def </span><span class="s1">retry_proxy_http_basic_auth(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">selector = splithost(url)</span>
        <span class="s1">newurl = </span><span class="s4">'http://' </span><span class="s1">+ host + selector</span>
        <span class="s1">proxy = self.proxies[</span><span class="s4">'http'</span><span class="s1">]</span>
        <span class="s1">urltype</span><span class="s3">, </span><span class="s1">proxyhost = splittype(proxy)</span>
        <span class="s1">proxyhost</span><span class="s3">, </span><span class="s1">proxyselector = splithost(proxyhost)</span>
        <span class="s1">i = proxyhost.find(</span><span class="s4">'@'</span><span class="s1">) + </span><span class="s5">1</span>
        <span class="s1">proxyhost = proxyhost[i:]</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">passwd = self.get_user_passwd(proxyhost</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">i)</span>
        <span class="s3">if not </span><span class="s1">(user </span><span class="s3">or </span><span class="s1">passwd): </span><span class="s3">return None</span>
        <span class="s1">proxyhost = </span><span class="s4">&quot;%s:%s@%s&quot; </span><span class="s1">% (quote(user</span><span class="s3">, </span><span class="s1">safe=</span><span class="s4">''</span><span class="s1">)</span><span class="s3">,</span>
                                  <span class="s1">quote(passwd</span><span class="s3">, </span><span class="s1">safe=</span><span class="s4">''</span><span class="s1">)</span><span class="s3">, </span><span class="s1">proxyhost)</span>
        <span class="s1">self.proxies[</span><span class="s4">'http'</span><span class="s1">] = </span><span class="s4">'http://' </span><span class="s1">+ proxyhost + proxyselector</span>
        <span class="s3">if </span><span class="s1">data </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.open(newurl)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.open(newurl</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s3">def </span><span class="s1">retry_proxy_https_basic_auth(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">selector = splithost(url)</span>
        <span class="s1">newurl = </span><span class="s4">'https://' </span><span class="s1">+ host + selector</span>
        <span class="s1">proxy = self.proxies[</span><span class="s4">'https'</span><span class="s1">]</span>
        <span class="s1">urltype</span><span class="s3">, </span><span class="s1">proxyhost = splittype(proxy)</span>
        <span class="s1">proxyhost</span><span class="s3">, </span><span class="s1">proxyselector = splithost(proxyhost)</span>
        <span class="s1">i = proxyhost.find(</span><span class="s4">'@'</span><span class="s1">) + </span><span class="s5">1</span>
        <span class="s1">proxyhost = proxyhost[i:]</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">passwd = self.get_user_passwd(proxyhost</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">i)</span>
        <span class="s3">if not </span><span class="s1">(user </span><span class="s3">or </span><span class="s1">passwd): </span><span class="s3">return None</span>
        <span class="s1">proxyhost = </span><span class="s4">&quot;%s:%s@%s&quot; </span><span class="s1">% (quote(user</span><span class="s3">, </span><span class="s1">safe=</span><span class="s4">''</span><span class="s1">)</span><span class="s3">,</span>
                                  <span class="s1">quote(passwd</span><span class="s3">, </span><span class="s1">safe=</span><span class="s4">''</span><span class="s1">)</span><span class="s3">, </span><span class="s1">proxyhost)</span>
        <span class="s1">self.proxies[</span><span class="s4">'https'</span><span class="s1">] = </span><span class="s4">'https://' </span><span class="s1">+ proxyhost + proxyselector</span>
        <span class="s3">if </span><span class="s1">data </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.open(newurl)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.open(newurl</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s3">def </span><span class="s1">retry_http_basic_auth(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">selector = splithost(url)</span>
        <span class="s1">i = host.find(</span><span class="s4">'@'</span><span class="s1">) + </span><span class="s5">1</span>
        <span class="s1">host = host[i:]</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">passwd = self.get_user_passwd(host</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">i)</span>
        <span class="s3">if not </span><span class="s1">(user </span><span class="s3">or </span><span class="s1">passwd): </span><span class="s3">return None</span>
        <span class="s1">host = </span><span class="s4">&quot;%s:%s@%s&quot; </span><span class="s1">% (quote(user</span><span class="s3">, </span><span class="s1">safe=</span><span class="s4">''</span><span class="s1">)</span><span class="s3">,</span>
                             <span class="s1">quote(passwd</span><span class="s3">, </span><span class="s1">safe=</span><span class="s4">''</span><span class="s1">)</span><span class="s3">, </span><span class="s1">host)</span>
        <span class="s1">newurl = </span><span class="s4">'http://' </span><span class="s1">+ host + selector</span>
        <span class="s3">if </span><span class="s1">data </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.open(newurl)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.open(newurl</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s3">def </span><span class="s1">retry_https_basic_auth(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">host</span><span class="s3">, </span><span class="s1">selector = splithost(url)</span>
        <span class="s1">i = host.find(</span><span class="s4">'@'</span><span class="s1">) + </span><span class="s5">1</span>
        <span class="s1">host = host[i:]</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">passwd = self.get_user_passwd(host</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">i)</span>
        <span class="s3">if not </span><span class="s1">(user </span><span class="s3">or </span><span class="s1">passwd): </span><span class="s3">return None</span>
        <span class="s1">host = </span><span class="s4">&quot;%s:%s@%s&quot; </span><span class="s1">% (quote(user</span><span class="s3">, </span><span class="s1">safe=</span><span class="s4">''</span><span class="s1">)</span><span class="s3">,</span>
                             <span class="s1">quote(passwd</span><span class="s3">, </span><span class="s1">safe=</span><span class="s4">''</span><span class="s1">)</span><span class="s3">, </span><span class="s1">host)</span>
        <span class="s1">newurl = </span><span class="s4">'https://' </span><span class="s1">+ host + selector</span>
        <span class="s3">if </span><span class="s1">data </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.open(newurl)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.open(newurl</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s3">def </span><span class="s1">get_user_passwd(self</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">clear_cache=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">key = realm + </span><span class="s4">'@' </span><span class="s1">+ host.lower()</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.auth_cache:</span>
            <span class="s3">if </span><span class="s1">clear_cache:</span>
                <span class="s3">del </span><span class="s1">self.auth_cache[key]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self.auth_cache[key]</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">passwd = self.prompt_user_passwd(host</span><span class="s3">, </span><span class="s1">realm)</span>
        <span class="s3">if </span><span class="s1">user </span><span class="s3">or </span><span class="s1">passwd: self.auth_cache[key] = (user</span><span class="s3">, </span><span class="s1">passwd)</span>
        <span class="s3">return </span><span class="s1">user</span><span class="s3">, </span><span class="s1">passwd</span>

    <span class="s3">def </span><span class="s1">prompt_user_passwd(self</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">realm):</span>
        <span class="s0">&quot;&quot;&quot;Override this in a GUI environment!&quot;&quot;&quot;</span>
        <span class="s3">import </span><span class="s1">getpass</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">user = input(</span><span class="s4">&quot;Enter username for %s at %s: &quot; </span><span class="s1">% (realm</span><span class="s3">, </span><span class="s1">host))</span>
            <span class="s1">passwd = getpass.getpass(</span><span class="s4">&quot;Enter password for %s in %s at %s: &quot; </span><span class="s1">%</span>
                <span class="s1">(user</span><span class="s3">, </span><span class="s1">realm</span><span class="s3">, </span><span class="s1">host))</span>
            <span class="s3">return </span><span class="s1">user</span><span class="s3">, </span><span class="s1">passwd</span>
        <span class="s3">except </span><span class="s1">KeyboardInterrupt:</span>
            <span class="s1">print()</span>
            <span class="s3">return None, None</span>


<span class="s2"># Utility functions</span>

<span class="s1">_localhost = </span><span class="s3">None</span>
<span class="s3">def </span><span class="s1">localhost():</span>
    <span class="s0">&quot;&quot;&quot;Return the IP address of the magic hostname 'localhost'.&quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">_localhost</span>
    <span class="s3">if </span><span class="s1">_localhost </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">_localhost = socket.gethostbyname(</span><span class="s4">'localhost'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_localhost</span>

<span class="s1">_thishost = </span><span class="s3">None</span>
<span class="s3">def </span><span class="s1">thishost():</span>
    <span class="s0">&quot;&quot;&quot;Return the IP addresses of the current host.&quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">_thishost</span>
    <span class="s3">if </span><span class="s1">_thishost </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">_thishost = tuple(socket.gethostbyname_ex(socket.gethostname())[</span><span class="s5">2</span><span class="s1">])</span>
        <span class="s3">except </span><span class="s1">socket.gaierror:</span>
            <span class="s1">_thishost = tuple(socket.gethostbyname_ex(</span><span class="s4">'localhost'</span><span class="s1">)[</span><span class="s5">2</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">_thishost</span>

<span class="s1">_ftperrors = </span><span class="s3">None</span>
<span class="s3">def </span><span class="s1">ftperrors():</span>
    <span class="s0">&quot;&quot;&quot;Return the set of errors raised by the FTP class.&quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">_ftperrors</span>
    <span class="s3">if </span><span class="s1">_ftperrors </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">import </span><span class="s1">ftplib</span>
        <span class="s1">_ftperrors = ftplib.all_errors</span>
    <span class="s3">return </span><span class="s1">_ftperrors</span>

<span class="s1">_noheaders = </span><span class="s3">None</span>
<span class="s3">def </span><span class="s1">noheaders():</span>
    <span class="s0">&quot;&quot;&quot;Return an empty email Message object.&quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">_noheaders</span>
    <span class="s3">if </span><span class="s1">_noheaders </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">_noheaders = email.message_from_string(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_noheaders</span>


<span class="s2"># Utility classes</span>

<span class="s3">class </span><span class="s1">ftpwrapper(object):</span>
    <span class="s0">&quot;&quot;&quot;Class used by open_ftp() for cache of open FTP connections.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">user</span><span class="s3">, </span><span class="s1">passwd</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">timeout=</span><span class="s3">None,</span>
                 <span class="s1">persistent=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">self.user = user</span>
        <span class="s1">self.passwd = passwd</span>
        <span class="s1">self.host = host</span>
        <span class="s1">self.port = port</span>
        <span class="s1">self.dirs = dirs</span>
        <span class="s1">self.timeout = timeout</span>
        <span class="s1">self.refcount = </span><span class="s5">0</span>
        <span class="s1">self.keepalive = persistent</span>
        <span class="s1">self.init()</span>

    <span class="s3">def </span><span class="s1">init(self):</span>
        <span class="s3">import </span><span class="s1">ftplib</span>
        <span class="s1">self.busy = </span><span class="s5">0</span>
        <span class="s1">self.ftp = ftplib.FTP()</span>
        <span class="s1">self.ftp.connect(self.host</span><span class="s3">, </span><span class="s1">self.port</span><span class="s3">, </span><span class="s1">self.timeout)</span>
        <span class="s1">self.ftp.login(self.user</span><span class="s3">, </span><span class="s1">self.passwd)</span>
        <span class="s1">_target = </span><span class="s4">'/'</span><span class="s1">.join(self.dirs)</span>
        <span class="s1">self.ftp.cwd(_target)</span>

    <span class="s3">def </span><span class="s1">retrfile(self</span><span class="s3">, </span><span class="s1">file</span><span class="s3">, </span><span class="s1">type):</span>
        <span class="s3">import </span><span class="s1">ftplib</span>
        <span class="s1">self.endtransfer()</span>
        <span class="s3">if </span><span class="s1">type </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'d'</span><span class="s3">, </span><span class="s4">'D'</span><span class="s1">): cmd = </span><span class="s4">'TYPE A'</span><span class="s1">; isdir = </span><span class="s5">1</span>
        <span class="s3">else</span><span class="s1">: cmd = </span><span class="s4">'TYPE ' </span><span class="s1">+ type; isdir = </span><span class="s5">0</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.ftp.voidcmd(cmd)</span>
        <span class="s3">except </span><span class="s1">ftplib.all_errors:</span>
            <span class="s1">self.init()</span>
            <span class="s1">self.ftp.voidcmd(cmd)</span>
        <span class="s1">conn = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">file </span><span class="s3">and not </span><span class="s1">isdir:</span>
            <span class="s2"># Try to retrieve as a file</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">cmd = </span><span class="s4">'RETR ' </span><span class="s1">+ file</span>
                <span class="s1">conn</span><span class="s3">, </span><span class="s1">retrlen = self.ftp.ntransfercmd(cmd)</span>
            <span class="s3">except </span><span class="s1">ftplib.error_perm </span><span class="s3">as </span><span class="s1">reason:</span>
                <span class="s3">if </span><span class="s1">str(reason)[:</span><span class="s5">3</span><span class="s1">] != </span><span class="s4">'550'</span><span class="s1">:</span>
                    <span class="s1">raise_with_traceback(URLError(</span><span class="s4">'ftp error: %r' </span><span class="s1">% reason))</span>
        <span class="s3">if not </span><span class="s1">conn:</span>
            <span class="s2"># Set transfer mode to ASCII!</span>
            <span class="s1">self.ftp.voidcmd(</span><span class="s4">'TYPE A'</span><span class="s1">)</span>
            <span class="s2"># Try a directory listing. Verify that directory exists.</span>
            <span class="s3">if </span><span class="s1">file:</span>
                <span class="s1">pwd = self.ftp.pwd()</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">self.ftp.cwd(file)</span>
                    <span class="s3">except </span><span class="s1">ftplib.error_perm </span><span class="s3">as </span><span class="s1">reason:</span>
                        <span class="s2">### Was:</span>
                        <span class="s2"># raise URLError('ftp error: %r' % reason) from reason</span>
                        <span class="s1">exc = URLError(</span><span class="s4">'ftp error: %r' </span><span class="s1">% reason)</span>
                        <span class="s1">exc.__cause__ = reason</span>
                        <span class="s3">raise </span><span class="s1">exc</span>
                <span class="s3">finally</span><span class="s1">:</span>
                    <span class="s1">self.ftp.cwd(pwd)</span>
                <span class="s1">cmd = </span><span class="s4">'LIST ' </span><span class="s1">+ file</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">cmd = </span><span class="s4">'LIST'</span>
            <span class="s1">conn</span><span class="s3">, </span><span class="s1">retrlen = self.ftp.ntransfercmd(cmd)</span>
        <span class="s1">self.busy = </span><span class="s5">1</span>

        <span class="s1">ftpobj = addclosehook(conn.makefile(</span><span class="s4">'rb'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">self.file_close)</span>
        <span class="s1">self.refcount += </span><span class="s5">1</span>
        <span class="s1">conn.close()</span>
        <span class="s2"># Pass back both a suitably decorated object and a retrieval length</span>
        <span class="s3">return </span><span class="s1">(ftpobj</span><span class="s3">, </span><span class="s1">retrlen)</span>

    <span class="s3">def </span><span class="s1">endtransfer(self):</span>
        <span class="s1">self.busy = </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s1">self.keepalive = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">self.refcount &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">self.real_close()</span>

    <span class="s3">def </span><span class="s1">file_close(self):</span>
        <span class="s1">self.endtransfer()</span>
        <span class="s1">self.refcount -= </span><span class="s5">1</span>
        <span class="s3">if </span><span class="s1">self.refcount &lt;= </span><span class="s5">0 </span><span class="s3">and not </span><span class="s1">self.keepalive:</span>
            <span class="s1">self.real_close()</span>

    <span class="s3">def </span><span class="s1">real_close(self):</span>
        <span class="s1">self.endtransfer()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.ftp.close()</span>
        <span class="s3">except </span><span class="s1">ftperrors():</span>
            <span class="s3">pass</span>

<span class="s2"># Proxy handling</span>
<span class="s3">def </span><span class="s1">getproxies_environment():</span>
    <span class="s0">&quot;&quot;&quot;Return a dictionary of scheme -&gt; proxy server URL mappings. 
 
    Scan the environment for variables named &lt;scheme&gt;_proxy; 
    this seems to be the standard convention.  If you need a 
    different way, you can pass a proxies dictionary to the 
    [Fancy]URLopener constructor. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">proxies = {}</span>
    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">os.environ.items():</span>
        <span class="s1">name = name.lower()</span>
        <span class="s3">if </span><span class="s1">value </span><span class="s3">and </span><span class="s1">name[-</span><span class="s5">6</span><span class="s1">:] == </span><span class="s4">'_proxy'</span><span class="s1">:</span>
            <span class="s1">proxies[name[:-</span><span class="s5">6</span><span class="s1">]] = value</span>
    <span class="s3">return </span><span class="s1">proxies</span>

<span class="s3">def </span><span class="s1">proxy_bypass_environment(host):</span>
    <span class="s0">&quot;&quot;&quot;Test if proxies should not be used for a particular host. 
 
    Checks the environment for a variable named no_proxy, which should 
    be a list of DNS suffixes separated by commas, or '*' for all hosts. 
    &quot;&quot;&quot;</span>
    <span class="s1">no_proxy = os.environ.get(</span><span class="s4">'no_proxy'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">) </span><span class="s3">or </span><span class="s1">os.environ.get(</span><span class="s4">'NO_PROXY'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
    <span class="s2"># '*' is special case for always bypass</span>
    <span class="s3">if </span><span class="s1">no_proxy == </span><span class="s4">'*'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s5">1</span>
    <span class="s2"># strip port off host</span>
    <span class="s1">hostonly</span><span class="s3">, </span><span class="s1">port = splitport(host)</span>
    <span class="s2"># check if the host ends with any of the DNS suffixes</span>
    <span class="s1">no_proxy_list = [proxy.strip() </span><span class="s3">for </span><span class="s1">proxy </span><span class="s3">in </span><span class="s1">no_proxy.split(</span><span class="s4">','</span><span class="s1">)]</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">no_proxy_list:</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">and </span><span class="s1">(hostonly.endswith(name) </span><span class="s3">or </span><span class="s1">host.endswith(name)):</span>
            <span class="s3">return </span><span class="s5">1</span>
    <span class="s2"># otherwise, don't bypass</span>
    <span class="s3">return </span><span class="s5">0</span>


<span class="s2"># This code tests an OSX specific data structure but is testable on all</span>
<span class="s2"># platforms</span>
<span class="s3">def </span><span class="s1">_proxy_bypass_macosx_sysconf(host</span><span class="s3">, </span><span class="s1">proxy_settings):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True iff this host shouldn't be accessed using a proxy 
 
    This function uses the MacOSX framework SystemConfiguration 
    to fetch the proxy information. 
 
    proxy_settings come from _scproxy._get_proxy_settings or get mocked ie: 
    { 'exclude_simple': bool, 
      'exceptions': ['foo.bar', '*.bar.com', '127.0.0.1', '10.1', '10.0/16'] 
    } 
    &quot;&quot;&quot;</span>
    <span class="s3">from </span><span class="s1">fnmatch </span><span class="s3">import </span><span class="s1">fnmatch</span>

    <span class="s1">hostonly</span><span class="s3">, </span><span class="s1">port = splitport(host)</span>

    <span class="s3">def </span><span class="s1">ip2num(ipAddr):</span>
        <span class="s1">parts = ipAddr.split(</span><span class="s4">'.'</span><span class="s1">)</span>
        <span class="s1">parts = list(map(int</span><span class="s3">, </span><span class="s1">parts))</span>
        <span class="s3">if </span><span class="s1">len(parts) != </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s1">parts = (parts + [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">])[:</span><span class="s5">4</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">(parts[</span><span class="s5">0</span><span class="s1">] &lt;&lt; </span><span class="s5">24</span><span class="s1">) | (parts[</span><span class="s5">1</span><span class="s1">] &lt;&lt; </span><span class="s5">16</span><span class="s1">) | (parts[</span><span class="s5">2</span><span class="s1">] &lt;&lt; </span><span class="s5">8</span><span class="s1">) | parts[</span><span class="s5">3</span><span class="s1">]</span>

    <span class="s2"># Check for simple host names:</span>
    <span class="s3">if </span><span class="s4">'.' </span><span class="s3">not in </span><span class="s1">host:</span>
        <span class="s3">if </span><span class="s1">proxy_settings[</span><span class="s4">'exclude_simple'</span><span class="s1">]:</span>
            <span class="s3">return True</span>

    <span class="s1">hostIP = </span><span class="s3">None</span>

    <span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">proxy_settings.get(</span><span class="s4">'exceptions'</span><span class="s3">, </span><span class="s1">()):</span>
        <span class="s2"># Items in the list are strings like these: *.local, 169.254/16</span>
        <span class="s3">if not </span><span class="s1">value: </span><span class="s3">continue</span>

        <span class="s1">m = re.match(</span><span class="s4">r&quot;(\d+(?:\.\d+)*)(/\d+)?&quot;</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s3">if </span><span class="s1">m </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">hostIP </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">hostIP = socket.gethostbyname(hostonly)</span>
                    <span class="s1">hostIP = ip2num(hostIP)</span>
                <span class="s3">except </span><span class="s1">socket.error:</span>
                    <span class="s3">continue</span>

            <span class="s1">base = ip2num(m.group(</span><span class="s5">1</span><span class="s1">))</span>
            <span class="s1">mask = m.group(</span><span class="s5">2</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">mask </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">mask = </span><span class="s5">8 </span><span class="s1">* (m.group(</span><span class="s5">1</span><span class="s1">).count(</span><span class="s4">'.'</span><span class="s1">) + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">mask = int(mask[</span><span class="s5">1</span><span class="s1">:])</span>
            <span class="s1">mask = </span><span class="s5">32 </span><span class="s1">- mask</span>

            <span class="s3">if </span><span class="s1">(hostIP &gt;&gt; mask) == (base &gt;&gt; mask):</span>
                <span class="s3">return True</span>

        <span class="s3">elif </span><span class="s1">fnmatch(host</span><span class="s3">, </span><span class="s1">value):</span>
            <span class="s3">return True</span>

    <span class="s3">return False</span>


<span class="s3">if </span><span class="s1">sys.platform == </span><span class="s4">'darwin'</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">_scproxy </span><span class="s3">import </span><span class="s1">_get_proxy_settings</span><span class="s3">, </span><span class="s1">_get_proxies</span>

    <span class="s3">def </span><span class="s1">proxy_bypass_macosx_sysconf(host):</span>
        <span class="s1">proxy_settings = _get_proxy_settings()</span>
        <span class="s3">return </span><span class="s1">_proxy_bypass_macosx_sysconf(host</span><span class="s3">, </span><span class="s1">proxy_settings)</span>

    <span class="s3">def </span><span class="s1">getproxies_macosx_sysconf():</span>
        <span class="s0">&quot;&quot;&quot;Return a dictionary of scheme -&gt; proxy server URL mappings. 
 
        This function uses the MacOSX framework SystemConfiguration 
        to fetch the proxy information. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">_get_proxies()</span>



    <span class="s3">def </span><span class="s1">proxy_bypass(host):</span>
        <span class="s3">if </span><span class="s1">getproxies_environment():</span>
            <span class="s3">return </span><span class="s1">proxy_bypass_environment(host)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">proxy_bypass_macosx_sysconf(host)</span>

    <span class="s3">def </span><span class="s1">getproxies():</span>
        <span class="s3">return </span><span class="s1">getproxies_environment() </span><span class="s3">or </span><span class="s1">getproxies_macosx_sysconf()</span>


<span class="s3">elif </span><span class="s1">os.name == </span><span class="s4">'nt'</span><span class="s1">:</span>
    <span class="s3">def </span><span class="s1">getproxies_registry():</span>
        <span class="s0">&quot;&quot;&quot;Return a dictionary of scheme -&gt; proxy server URL mappings. 
 
        Win32 uses the registry to store proxies. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">proxies = {}</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">import </span><span class="s1">winreg</span>
        <span class="s3">except </span><span class="s1">ImportError:</span>
            <span class="s2"># Std module, so should be around - but you never know!</span>
            <span class="s3">return </span><span class="s1">proxies</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">internetSettings = winreg.OpenKey(winreg.HKEY_CURRENT_USER</span><span class="s3">,</span>
                <span class="s4">r'Software\Microsoft\Windows\CurrentVersion\Internet Settings'</span><span class="s1">)</span>
            <span class="s1">proxyEnable = winreg.QueryValueEx(internetSettings</span><span class="s3">,</span>
                                               <span class="s4">'ProxyEnable'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">proxyEnable:</span>
                <span class="s2"># Returned as Unicode but problems if not converted to ASCII</span>
                <span class="s1">proxyServer = str(winreg.QueryValueEx(internetSettings</span><span class="s3">,</span>
                                                       <span class="s4">'ProxyServer'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s3">if </span><span class="s4">'=' </span><span class="s3">in </span><span class="s1">proxyServer:</span>
                    <span class="s2"># Per-protocol settings</span>
                    <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">proxyServer.split(</span><span class="s4">';'</span><span class="s1">):</span>
                        <span class="s1">protocol</span><span class="s3">, </span><span class="s1">address = p.split(</span><span class="s4">'='</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
                        <span class="s2"># See if address has a type:// prefix</span>
                        <span class="s3">if not </span><span class="s1">re.match(</span><span class="s4">'^([^/:]+)://'</span><span class="s3">, </span><span class="s1">address):</span>
                            <span class="s1">address = </span><span class="s4">'%s://%s' </span><span class="s1">% (protocol</span><span class="s3">, </span><span class="s1">address)</span>
                        <span class="s1">proxies[protocol] = address</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s2"># Use one setting for all protocols</span>
                    <span class="s3">if </span><span class="s1">proxyServer[:</span><span class="s5">5</span><span class="s1">] == </span><span class="s4">'http:'</span><span class="s1">:</span>
                        <span class="s1">proxies[</span><span class="s4">'http'</span><span class="s1">] = proxyServer</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">proxies[</span><span class="s4">'http'</span><span class="s1">] = </span><span class="s4">'http://%s' </span><span class="s1">% proxyServer</span>
                        <span class="s1">proxies[</span><span class="s4">'https'</span><span class="s1">] = </span><span class="s4">'https://%s' </span><span class="s1">% proxyServer</span>
                        <span class="s1">proxies[</span><span class="s4">'ftp'</span><span class="s1">] = </span><span class="s4">'ftp://%s' </span><span class="s1">% proxyServer</span>
            <span class="s1">internetSettings.Close()</span>
        <span class="s3">except </span><span class="s1">(WindowsError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">TypeError):</span>
            <span class="s2"># Either registry key not found etc, or the value in an</span>
            <span class="s2"># unexpected format.</span>
            <span class="s2"># proxies already set up to be empty so nothing to do</span>
            <span class="s3">pass</span>
        <span class="s3">return </span><span class="s1">proxies</span>

    <span class="s3">def </span><span class="s1">getproxies():</span>
        <span class="s0">&quot;&quot;&quot;Return a dictionary of scheme -&gt; proxy server URL mappings. 
 
        Returns settings gathered from the environment, if specified, 
        or the registry. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">getproxies_environment() </span><span class="s3">or </span><span class="s1">getproxies_registry()</span>

    <span class="s3">def </span><span class="s1">proxy_bypass_registry(host):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">import </span><span class="s1">winreg</span>
        <span class="s3">except </span><span class="s1">ImportError:</span>
            <span class="s2"># Std modules, so should be around - but you never know!</span>
            <span class="s3">return </span><span class="s5">0</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">internetSettings = winreg.OpenKey(winreg.HKEY_CURRENT_USER</span><span class="s3">,</span>
                <span class="s4">r'Software\Microsoft\Windows\CurrentVersion\Internet Settings'</span><span class="s1">)</span>
            <span class="s1">proxyEnable = winreg.QueryValueEx(internetSettings</span><span class="s3">,</span>
                                               <span class="s4">'ProxyEnable'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">proxyOverride = str(winreg.QueryValueEx(internetSettings</span><span class="s3">,</span>
                                                     <span class="s4">'ProxyOverride'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s2"># ^^^^ Returned as Unicode but problems if not converted to ASCII</span>
        <span class="s3">except </span><span class="s1">WindowsError:</span>
            <span class="s3">return </span><span class="s5">0</span>
        <span class="s3">if not </span><span class="s1">proxyEnable </span><span class="s3">or not </span><span class="s1">proxyOverride:</span>
            <span class="s3">return </span><span class="s5">0</span>
        <span class="s2"># try to make a host list from name and IP address.</span>
        <span class="s1">rawHost</span><span class="s3">, </span><span class="s1">port = splitport(host)</span>
        <span class="s1">host = [rawHost]</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">addr = socket.gethostbyname(rawHost)</span>
            <span class="s3">if </span><span class="s1">addr != rawHost:</span>
                <span class="s1">host.append(addr)</span>
        <span class="s3">except </span><span class="s1">socket.error:</span>
            <span class="s3">pass</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">fqdn = socket.getfqdn(rawHost)</span>
            <span class="s3">if </span><span class="s1">fqdn != rawHost:</span>
                <span class="s1">host.append(fqdn)</span>
        <span class="s3">except </span><span class="s1">socket.error:</span>
            <span class="s3">pass</span>
        <span class="s2"># make a check value list from the registry entry: replace the</span>
        <span class="s2"># '&lt;local&gt;' string by the localhost entry and the corresponding</span>
        <span class="s2"># canonical entry.</span>
        <span class="s1">proxyOverride = proxyOverride.split(</span><span class="s4">';'</span><span class="s1">)</span>
        <span class="s2"># now check if we match one of the registry values.</span>
        <span class="s3">for </span><span class="s1">test </span><span class="s3">in </span><span class="s1">proxyOverride:</span>
            <span class="s3">if </span><span class="s1">test == </span><span class="s4">'&lt;local&gt;'</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s4">'.' </span><span class="s3">not in </span><span class="s1">rawHost:</span>
                    <span class="s3">return </span><span class="s5">1</span>
            <span class="s1">test = test.replace(</span><span class="s4">&quot;.&quot;</span><span class="s3">, </span><span class="s4">r&quot;\.&quot;</span><span class="s1">)     </span><span class="s2"># mask dots</span>
            <span class="s1">test = test.replace(</span><span class="s4">&quot;*&quot;</span><span class="s3">, </span><span class="s4">r&quot;.*&quot;</span><span class="s1">)     </span><span class="s2"># change glob sequence</span>
            <span class="s1">test = test.replace(</span><span class="s4">&quot;?&quot;</span><span class="s3">, </span><span class="s4">r&quot;.&quot;</span><span class="s1">)      </span><span class="s2"># change glob char</span>
            <span class="s3">for </span><span class="s1">val </span><span class="s3">in </span><span class="s1">host:</span>
                <span class="s3">if </span><span class="s1">re.match(test</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">re.I):</span>
                    <span class="s3">return </span><span class="s5">1</span>
        <span class="s3">return </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">proxy_bypass(host):</span>
        <span class="s0">&quot;&quot;&quot;Return a dictionary of scheme -&gt; proxy server URL mappings. 
 
        Returns settings gathered from the environment, if specified, 
        or the registry. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">getproxies_environment():</span>
            <span class="s3">return </span><span class="s1">proxy_bypass_environment(host)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">proxy_bypass_registry(host)</span>

<span class="s3">else</span><span class="s1">:</span>
    <span class="s2"># By default use environment variables</span>
    <span class="s1">getproxies = getproxies_environment</span>
    <span class="s1">proxy_bypass = proxy_bypass_environment</span>
</pre>
</body>
</html>