<html>
<head>
<title>_zope_interface_coptimizations.c</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #0f9795;}
.s5 { color: #6897bb;}
.s6 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_zope_interface_coptimizations.c</font>
</center></td></tr></table>
<pre><span class="s0">/*########################################################################### 
 # 
 # Copyright (c) 2003 Zope Foundation and Contributors. 
 # All Rights Reserved. 
 # 
 # This software is subject to the provisions of the Zope Public License, 
 # Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution. 
 # THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY AND ALL EXPRESS OR IMPLIED 
 # WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 # WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS 
 # FOR A PARTICULAR PURPOSE. 
 # 
 ############################################################################*/</span>

<span class="s2">#include </span><span class="s3">&quot;Python.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;structmember.h&quot;</span>

<span class="s2">#ifdef </span><span class="s1">__clang__</span>
<span class="s1">#pragma clang diagnostic push</span>
<span class="s1">#pragma clang diagnostic ignored </span><span class="s3">&quot;-Wunused-parameter&quot;</span>
<span class="s1">#pragma clang diagnostic ignored </span><span class="s3">&quot;-Wmissing-field-initializers&quot;</span>
<span class="s2">#endif</span>

<span class="s2">#define </span><span class="s1">TYPE(O) ((PyTypeObject*)(O))</span>
<span class="s2">#define </span><span class="s1">OBJECT(O) ((PyObject*)(O))</span>
<span class="s2">#define </span><span class="s1">CLASSIC(O) ((PyClassObject*)(O))</span>
<span class="s2">#ifndef </span><span class="s1">PyVarObject_HEAD_INIT</span>
<span class="s2">#define </span><span class="s1">PyVarObject_HEAD_INIT(a, b) PyObject_HEAD_INIT(a) b,</span>
<span class="s2">#endif</span>
<span class="s2">#ifndef </span><span class="s1">Py_TYPE</span>
<span class="s2">#define </span><span class="s1">Py_TYPE(o) ((o)</span><span class="s4">-&gt;</span><span class="s1">ob_type)</span>
<span class="s2">#endif</span>

<span class="s2">#if </span><span class="s1">PY_MAJOR_VERSION &gt;= </span><span class="s5">3</span>
<span class="s2">#define </span><span class="s1">PY3K</span>
<span class="s2">#define </span><span class="s1">PyNative_FromString PyUnicode_FromString</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">PyNative_FromString PyString_FromString</span>
<span class="s2">#endif</span>

<span class="s2">static </span><span class="s1">PyObject *str__dict__, *str__implemented__, *strextends;</span>
<span class="s2">static </span><span class="s1">PyObject *BuiltinImplementationSpecifications, *str__provides__;</span>
<span class="s2">static </span><span class="s1">PyObject *str__class__, *str__providedBy__;</span>
<span class="s2">static </span><span class="s1">PyObject *empty, *fallback;</span>
<span class="s2">static </span><span class="s1">PyObject *str__conform__, *str_call_conform, *adapter_hooks;</span>
<span class="s2">static </span><span class="s1">PyObject *str_uncached_lookup, *str_uncached_lookupAll;</span>
<span class="s2">static </span><span class="s1">PyObject *str_uncached_subscriptions;</span>
<span class="s2">static </span><span class="s1">PyObject *str_registry, *strro, *str_generation, *strchanged;</span>
<span class="s2">static </span><span class="s1">PyObject *str__self__;</span>
<span class="s2">static </span><span class="s1">PyObject *str__module__;</span>
<span class="s2">static </span><span class="s1">PyObject *str__name__;</span>
<span class="s2">static </span><span class="s1">PyObject *str__adapt__;</span>
<span class="s2">static </span><span class="s1">PyObject *str_CALL_CUSTOM_ADAPT;</span>

<span class="s2">static </span><span class="s1">PyTypeObject *Implements;</span>

<span class="s2">static int </span><span class="s1">imported_declarations = </span><span class="s5">0</span><span class="s1">;</span>

<span class="s2">static int</span>
<span class="s1">import_declarations(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *declarations, *i;</span>

  <span class="s1">declarations = PyImport_ImportModule(</span><span class="s3">&quot;zope.interface.declarations&quot;</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(declarations == NULL)</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>

  <span class="s1">BuiltinImplementationSpecifications = PyObject_GetAttrString(</span>
                    <span class="s1">declarations, </span><span class="s3">&quot;BuiltinImplementationSpecifications&quot;</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(BuiltinImplementationSpecifications == NULL)</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>

  <span class="s1">empty = PyObject_GetAttrString(declarations, </span><span class="s3">&quot;_empty&quot;</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(empty == NULL)</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>

  <span class="s1">fallback = PyObject_GetAttrString(declarations, </span><span class="s3">&quot;implementedByFallback&quot;</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(fallback == NULL)</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>



  <span class="s1">i = PyObject_GetAttrString(declarations, </span><span class="s3">&quot;Implements&quot;</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(i == NULL)</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(! PyType_Check(i))</span>
    <span class="s1">{</span>
      <span class="s1">PyErr_SetString(PyExc_TypeError,</span>
                      <span class="s3">&quot;zope.interface.declarations.Implements is not a type&quot;</span><span class="s1">);</span>
      <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>
    <span class="s1">}</span>

  <span class="s1">Implements = (PyTypeObject *)i;</span>

  <span class="s1">Py_DECREF(declarations);</span>

  <span class="s1">imported_declarations = </span><span class="s5">1</span><span class="s1">;</span>
  <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s2">static </span><span class="s1">PyTypeObject SpecificationBaseType;   </span><span class="s0">/* Forward */</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">implementedByFallback(PyObject *cls)</span>
<span class="s1">{</span>
  <span class="s2">if </span><span class="s1">(imported_declarations == </span><span class="s5">0 </span><span class="s1">&amp;&amp; import_declarations() &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">PyObject_CallFunctionObjArgs(fallback, cls, NULL);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">implementedBy(PyObject *ignored, PyObject *cls)</span>
<span class="s1">{</span>
  <span class="s0">/* Fast retrieval of implements spec, if possible, to optimize 
     common case.  Use fallback code if we get stuck. 
  */</span>

  <span class="s1">PyObject *dict = NULL, *spec;</span>

  <span class="s2">if </span><span class="s1">(PyObject_TypeCheck(cls, &amp;PySuper_Type))</span>
  <span class="s1">{</span>
      <span class="s0">// Let merging be handled by Python.</span>
      <span class="s2">return </span><span class="s1">implementedByFallback(cls);</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(PyType_Check(cls))</span>
    <span class="s1">{</span>
      <span class="s1">dict = TYPE(cls)</span><span class="s4">-&gt;</span><span class="s1">tp_dict;</span>
      <span class="s1">Py_XINCREF(dict);</span>
    <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(dict == NULL)</span>
    <span class="s1">dict = PyObject_GetAttr(cls, str__dict__);</span>

  <span class="s2">if </span><span class="s1">(dict == NULL)</span>
    <span class="s1">{</span>
      <span class="s0">/* Probably a security proxied class, use more expensive fallback code */</span>
      <span class="s1">PyErr_Clear();</span>
      <span class="s2">return </span><span class="s1">implementedByFallback(cls);</span>
    <span class="s1">}</span>

  <span class="s1">spec = PyObject_GetItem(dict, str__implemented__);</span>
  <span class="s1">Py_DECREF(dict);</span>
  <span class="s2">if </span><span class="s1">(spec)</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(imported_declarations == </span><span class="s5">0 </span><span class="s1">&amp;&amp; import_declarations() &lt; </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">NULL;</span>

      <span class="s2">if </span><span class="s1">(PyObject_TypeCheck(spec, Implements))</span>
        <span class="s2">return </span><span class="s1">spec;</span>

      <span class="s0">/* Old-style declaration, use more expensive fallback code */</span>
      <span class="s1">Py_DECREF(spec);</span>
      <span class="s2">return </span><span class="s1">implementedByFallback(cls);</span>
    <span class="s1">}</span>

  <span class="s1">PyErr_Clear();</span>

  <span class="s0">/* Maybe we have a builtin */</span>
  <span class="s2">if </span><span class="s1">(imported_declarations == </span><span class="s5">0 </span><span class="s1">&amp;&amp; import_declarations() &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">spec = PyDict_GetItem(BuiltinImplementationSpecifications, cls);</span>
  <span class="s2">if </span><span class="s1">(spec != NULL)</span>
    <span class="s1">{</span>
      <span class="s1">Py_INCREF(spec);</span>
      <span class="s2">return </span><span class="s1">spec;</span>
    <span class="s1">}</span>

  <span class="s0">/* We're stuck, use fallback */</span>
  <span class="s2">return </span><span class="s1">implementedByFallback(cls);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">getObjectSpecification(PyObject *ignored, PyObject *ob)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *cls, *result;</span>

  <span class="s1">result = PyObject_GetAttr(ob, str__provides__);</span>
  <span class="s2">if </span><span class="s1">(!result)</span>
  <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!PyErr_ExceptionMatches(PyExc_AttributeError))</span>
      <span class="s1">{</span>
          <span class="s0">/* Propagate non AttributeError exceptions. */</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
      <span class="s1">}</span>
      <span class="s1">PyErr_Clear();</span>
  <span class="s1">}</span>
  <span class="s2">else</span>
  <span class="s1">{</span>
      <span class="s2">int </span><span class="s1">is_instance = -</span><span class="s5">1</span><span class="s1">;</span>
      <span class="s1">is_instance = PyObject_IsInstance(result, (PyObject*)&amp;SpecificationBaseType);</span>
      <span class="s2">if </span><span class="s1">(is_instance &lt; </span><span class="s5">0</span><span class="s1">)</span>
      <span class="s1">{</span>
          <span class="s0">/* Propagate all errors */</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(is_instance)</span>
      <span class="s1">{</span>
          <span class="s2">return </span><span class="s1">result;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/* We do a getattr here so as not to be defeated by proxies */</span>
  <span class="s1">cls = PyObject_GetAttr(ob, str__class__);</span>
  <span class="s2">if </span><span class="s1">(cls == NULL)</span>
  <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!PyErr_ExceptionMatches(PyExc_AttributeError))</span>
      <span class="s1">{</span>
          <span class="s0">/* Propagate non-AttributeErrors */</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
      <span class="s1">}</span>
      <span class="s1">PyErr_Clear();</span>
      <span class="s2">if </span><span class="s1">(imported_declarations == </span><span class="s5">0 </span><span class="s1">&amp;&amp; import_declarations() &lt; </span><span class="s5">0</span><span class="s1">)</span>
          <span class="s2">return </span><span class="s1">NULL;</span>

      <span class="s1">Py_INCREF(empty);</span>
      <span class="s2">return </span><span class="s1">empty;</span>
  <span class="s1">}</span>
  <span class="s1">result = implementedBy(NULL, cls);</span>
  <span class="s1">Py_DECREF(cls);</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">providedBy(PyObject *ignored, PyObject *ob)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *result, *cls, *cp;</span>
  <span class="s2">int </span><span class="s1">is_instance = -</span><span class="s5">1</span><span class="s1">;</span>
  <span class="s1">result = NULL;</span>

  <span class="s1">is_instance = PyObject_IsInstance(ob, (PyObject*)&amp;PySuper_Type);</span>
  <span class="s2">if </span><span class="s1">(is_instance &lt; </span><span class="s5">0</span><span class="s1">)</span>
  <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!PyErr_ExceptionMatches(PyExc_AttributeError))</span>
      <span class="s1">{</span>
          <span class="s0">/* Propagate non-AttributeErrors */</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
      <span class="s1">}</span>
      <span class="s1">PyErr_Clear();</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(is_instance)</span>
  <span class="s1">{</span>
      <span class="s2">return </span><span class="s1">implementedBy(NULL, ob);</span>
  <span class="s1">}</span>

  <span class="s1">result = PyObject_GetAttr(ob, str__providedBy__);</span>

  <span class="s2">if </span><span class="s1">(result == NULL)</span>
  <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!PyErr_ExceptionMatches(PyExc_AttributeError))</span>
      <span class="s1">{</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
      <span class="s1">}</span>

      <span class="s1">PyErr_Clear();</span>
      <span class="s2">return </span><span class="s1">getObjectSpecification(NULL, ob);</span>
  <span class="s1">}</span>


  <span class="s0">/* We want to make sure we have a spec. We can't do a type check 
     because we may have a proxy, so we'll just try to get the 
     only attribute. 
  */</span>
  <span class="s2">if </span><span class="s1">(PyObject_TypeCheck(result, &amp;SpecificationBaseType)</span>
      <span class="s1">||</span>
      <span class="s1">PyObject_HasAttr(result, strextends)</span>
      <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">result;</span>

  <span class="s0">/* 
    The object's class doesn't understand descriptors. 
    Sigh. We need to get an object descriptor, but we have to be 
    careful.  We want to use the instance's __provides__,l if 
    there is one, but only if it didn't come from the class. 
  */</span>
  <span class="s1">Py_DECREF(result);</span>

  <span class="s1">cls = PyObject_GetAttr(ob, str__class__);</span>
  <span class="s2">if </span><span class="s1">(cls == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">result = PyObject_GetAttr(ob, str__provides__);</span>
  <span class="s2">if </span><span class="s1">(result == NULL)</span>
    <span class="s1">{</span>
      <span class="s0">/* No __provides__, so just fall back to implementedBy */</span>
      <span class="s1">PyErr_Clear();</span>
      <span class="s1">result = implementedBy(NULL, cls);</span>
      <span class="s1">Py_DECREF(cls);</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

  <span class="s1">cp = PyObject_GetAttr(cls, str__provides__);</span>
  <span class="s2">if </span><span class="s1">(cp == NULL)</span>
    <span class="s1">{</span>
      <span class="s0">/* The the class has no provides, assume we're done: */</span>
      <span class="s1">PyErr_Clear();</span>
      <span class="s1">Py_DECREF(cls);</span>
      <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(cp == result)</span>
    <span class="s1">{</span>
      <span class="s0">/* 
        Oops, we got the provides from the class. This means 
        the object doesn't have it's own. We should use implementedBy 
      */</span>
      <span class="s1">Py_DECREF(result);</span>
      <span class="s1">result = implementedBy(NULL, cls);</span>
    <span class="s1">}</span>

  <span class="s1">Py_DECREF(cls);</span>
  <span class="s1">Py_DECREF(cp);</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s1">PyObject_HEAD</span>
    <span class="s1">PyObject* weakreflist;</span>
    <span class="s0">/* 
      In the past, these fields were stored in the __dict__ 
      and were technically allowed to contain any Python object, though 
      other type checks would fail or fall back to generic code paths if 
      they didn't have the expected type. We preserve that behaviour and don't 
      make any assumptions about contents. 
    */</span>
    <span class="s1">PyObject* _implied;</span>
    <span class="s0">/* 
      The remainder aren't used in C code but must be stored here 
      to prevent instance layout conflicts. 
    */</span>
    <span class="s1">PyObject* _dependents;</span>
    <span class="s1">PyObject* _bases;</span>
    <span class="s1">PyObject* _v_attrs;</span>
    <span class="s1">PyObject* __iro__;</span>
    <span class="s1">PyObject* __sro__;</span>
<span class="s1">} Spec;</span>

<span class="s0">/* 
  We know what the fields are *supposed* to define, but 
  they could have anything, so we need to traverse them. 
*/</span>
<span class="s2">static int</span>
<span class="s1">Spec_traverse(Spec* self, visitproc visit, </span><span class="s2">void</span><span class="s1">* arg)</span>
<span class="s1">{</span>
    <span class="s1">Py_VISIT(self</span><span class="s4">-&gt;</span><span class="s1">_implied);</span>
    <span class="s1">Py_VISIT(self</span><span class="s4">-&gt;</span><span class="s1">_dependents);</span>
    <span class="s1">Py_VISIT(self</span><span class="s4">-&gt;</span><span class="s1">_bases);</span>
    <span class="s1">Py_VISIT(self</span><span class="s4">-&gt;</span><span class="s1">_v_attrs);</span>
    <span class="s1">Py_VISIT(self</span><span class="s4">-&gt;</span><span class="s1">__iro__);</span>
    <span class="s1">Py_VISIT(self</span><span class="s4">-&gt;</span><span class="s1">__sro__);</span>
    <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">Spec_clear(Spec* self)</span>
<span class="s1">{</span>
    <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">_implied);</span>
    <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">_dependents);</span>
    <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">_bases);</span>
    <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">_v_attrs);</span>
    <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">__iro__);</span>
    <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">__sro__);</span>
    <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static void</span>
<span class="s1">Spec_dealloc(Spec* self)</span>
<span class="s1">{</span>
    <span class="s0">/* PyType_GenericAlloc that you get when you don't 
       specify a tp_alloc always tracks the object. */</span>
    <span class="s1">PyObject_GC_UnTrack((PyObject *)self);</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">weakreflist != NULL) {</span>
        <span class="s1">PyObject_ClearWeakRefs(OBJECT(self));</span>
    <span class="s1">}</span>
    <span class="s1">Spec_clear(self);</span>
    <span class="s1">Py_TYPE(self)</span><span class="s4">-&gt;</span><span class="s1">tp_free(OBJECT(self));</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">Spec_extends(Spec *self, PyObject *other)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *implied;</span>

  <span class="s1">implied = self</span><span class="s4">-&gt;</span><span class="s1">_implied;</span>
  <span class="s2">if </span><span class="s1">(implied == NULL) {</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(PyDict_GetItem(implied, other) != NULL)</span>
    <span class="s1">Py_RETURN_TRUE;</span>
  <span class="s1">Py_RETURN_FALSE;</span>
<span class="s1">}</span>

<span class="s2">static char </span><span class="s1">Spec_extends__doc__[] =</span>
<span class="s3">&quot;Test whether a specification is or extends another&quot;</span>
<span class="s1">;</span>

<span class="s2">static char </span><span class="s1">Spec_providedBy__doc__[] =</span>
<span class="s3">&quot;Test whether an interface is implemented by the specification&quot;</span>
<span class="s1">;</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">Spec_call(Spec *self, PyObject *args, PyObject *kw)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *spec;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTuple(args, </span><span class="s3">&quot;O&quot;</span><span class="s1">, &amp;spec))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s2">return </span><span class="s1">Spec_extends(self, spec);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">Spec_providedBy(PyObject *self, PyObject *ob)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *decl, *item;</span>

  <span class="s1">decl = providedBy(NULL, ob);</span>
  <span class="s2">if </span><span class="s1">(decl == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(PyObject_TypeCheck(decl, &amp;SpecificationBaseType))</span>
    <span class="s1">item = Spec_extends((Spec*)decl, self);</span>
  <span class="s2">else</span>
    <span class="s0">/* decl is probably a security proxy.  We have to go the long way 
       around. 
    */</span>
    <span class="s1">item = PyObject_CallFunctionObjArgs(decl, self, NULL);</span>

  <span class="s1">Py_DECREF(decl);</span>
  <span class="s2">return </span><span class="s1">item;</span>
<span class="s1">}</span>


<span class="s2">static char </span><span class="s1">Spec_implementedBy__doc__[] =</span>
<span class="s3">&quot;Test whether the specification is implemented by a class or factory.</span><span class="s6">\n</span><span class="s3">&quot;</span>
<span class="s3">&quot;Raise TypeError if argument is neither a class nor a callable.&quot;</span>
<span class="s1">;</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">Spec_implementedBy(PyObject *self, PyObject *cls)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *decl, *item;</span>

  <span class="s1">decl = implementedBy(NULL, cls);</span>
  <span class="s2">if </span><span class="s1">(decl == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(PyObject_TypeCheck(decl, &amp;SpecificationBaseType))</span>
    <span class="s1">item = Spec_extends((Spec*)decl, self);</span>
  <span class="s2">else</span>
    <span class="s1">item = PyObject_CallFunctionObjArgs(decl, self, NULL);</span>

  <span class="s1">Py_DECREF(decl);</span>
  <span class="s2">return </span><span class="s1">item;</span>
<span class="s1">}</span>

<span class="s2">static struct </span><span class="s1">PyMethodDef Spec_methods[] = {</span>
        <span class="s1">{</span><span class="s3">&quot;providedBy&quot;</span><span class="s1">,</span>
         <span class="s1">(PyCFunction)Spec_providedBy,          METH_O,</span>
         <span class="s1">Spec_providedBy__doc__},</span>
        <span class="s1">{</span><span class="s3">&quot;implementedBy&quot;</span><span class="s1">,</span>
         <span class="s1">(PyCFunction)Spec_implementedBy,       METH_O,</span>
         <span class="s1">Spec_implementedBy__doc__},</span>
        <span class="s1">{</span><span class="s3">&quot;isOrExtends&quot;</span><span class="s1">, (PyCFunction)Spec_extends,      METH_O,</span>
         <span class="s1">Spec_extends__doc__},</span>

        <span class="s1">{NULL,          NULL}           </span><span class="s0">/* sentinel */</span>
<span class="s1">};</span>

<span class="s2">static </span><span class="s1">PyMemberDef Spec_members[] = {</span>
  <span class="s1">{</span><span class="s3">&quot;_implied&quot;</span><span class="s1">, T_OBJECT_EX, offsetof(Spec, _implied), </span><span class="s5">0</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;_dependents&quot;</span><span class="s1">, T_OBJECT_EX, offsetof(Spec, _dependents), </span><span class="s5">0</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;_bases&quot;</span><span class="s1">, T_OBJECT_EX, offsetof(Spec, _bases), </span><span class="s5">0</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;_v_attrs&quot;</span><span class="s1">, T_OBJECT_EX, offsetof(Spec, _v_attrs), </span><span class="s5">0</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;__iro__&quot;</span><span class="s1">, T_OBJECT_EX, offsetof(Spec, __iro__), </span><span class="s5">0</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;__sro__&quot;</span><span class="s1">, T_OBJECT_EX, offsetof(Spec, __sro__), </span><span class="s5">0</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{NULL},</span>
<span class="s1">};</span>


<span class="s2">static </span><span class="s1">PyTypeObject SpecificationBaseType = {</span>
        <span class="s1">PyVarObject_HEAD_INIT(NULL, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">/* tp_name           */ </span><span class="s3">&quot;_interface_coptimizations.&quot;</span>
                                <span class="s3">&quot;SpecificationBase&quot;</span><span class="s1">,</span>
        <span class="s0">/* tp_basicsize      */ </span><span class="s2">sizeof</span><span class="s1">(Spec),</span>
        <span class="s0">/* tp_itemsize       */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_dealloc        */ </span><span class="s1">(destructor)Spec_dealloc,</span>
        <span class="s0">/* tp_print          */ </span><span class="s1">(printfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getattr        */ </span><span class="s1">(getattrfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_setattr        */ </span><span class="s1">(setattrfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_compare        */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_repr           */ </span><span class="s1">(reprfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_number      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_sequence    */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_mapping     */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_hash           */ </span><span class="s1">(hashfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_call           */ </span><span class="s1">(ternaryfunc)Spec_call,</span>
        <span class="s0">/* tp_str            */ </span><span class="s1">(reprfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getattro       */ </span><span class="s1">(getattrofunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_setattro       */ </span><span class="s1">(setattrofunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_buffer      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_flags          */ </span><span class="s1">Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,</span>
        <span class="s3">&quot;Base type for Specification objects&quot;</span><span class="s1">,</span>
        <span class="s0">/* tp_traverse       */ </span><span class="s1">(traverseproc)Spec_traverse,</span>
        <span class="s0">/* tp_clear          */ </span><span class="s1">(inquiry)Spec_clear,</span>
        <span class="s0">/* tp_richcompare    */ </span><span class="s1">(richcmpfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_weaklistoffset */ </span><span class="s1">offsetof(Spec, weakreflist),</span>
        <span class="s0">/* tp_iter           */ </span><span class="s1">(getiterfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_iternext       */ </span><span class="s1">(iternextfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_methods        */ </span><span class="s1">Spec_methods,</span>
        <span class="s0">/* tp_members        */ </span><span class="s1">Spec_members,</span>
<span class="s1">};</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">OSD_descr_get(PyObject *self, PyObject *inst, PyObject *cls)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *provides;</span>

  <span class="s2">if </span><span class="s1">(inst == NULL)</span>
    <span class="s2">return </span><span class="s1">getObjectSpecification(NULL, cls);</span>

  <span class="s1">provides = PyObject_GetAttr(inst, str__provides__);</span>
  <span class="s0">/* Return __provides__ if we got it, or return NULL and propagate non-AttributeError. */</span>
  <span class="s2">if </span><span class="s1">(provides != NULL || !PyErr_ExceptionMatches(PyExc_AttributeError))</span>
    <span class="s2">return </span><span class="s1">provides;</span>

  <span class="s1">PyErr_Clear();</span>
  <span class="s2">return </span><span class="s1">implementedBy(NULL, cls);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyTypeObject OSDType = {</span>
        <span class="s1">PyVarObject_HEAD_INIT(NULL, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">/* tp_name           */ </span><span class="s3">&quot;_interface_coptimizations.&quot;</span>
                                <span class="s3">&quot;ObjectSpecificationDescriptor&quot;</span><span class="s1">,</span>
        <span class="s0">/* tp_basicsize      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_itemsize       */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_dealloc        */ </span><span class="s1">(destructor)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_print          */ </span><span class="s1">(printfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getattr        */ </span><span class="s1">(getattrfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_setattr        */ </span><span class="s1">(setattrfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_compare        */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_repr           */ </span><span class="s1">(reprfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_number      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_sequence    */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_mapping     */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_hash           */ </span><span class="s1">(hashfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_call           */ </span><span class="s1">(ternaryfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_str            */ </span><span class="s1">(reprfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getattro       */ </span><span class="s1">(getattrofunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_setattro       */ </span><span class="s1">(setattrofunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_buffer      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_flags          */ </span><span class="s1">Py_TPFLAGS_DEFAULT</span>
                                <span class="s1">| Py_TPFLAGS_BASETYPE ,</span>
        <span class="s3">&quot;Object Specification Descriptor&quot;</span><span class="s1">,</span>
        <span class="s0">/* tp_traverse       */ </span><span class="s1">(traverseproc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_clear          */ </span><span class="s1">(inquiry)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_richcompare    */ </span><span class="s1">(richcmpfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_weaklistoffset */ </span><span class="s1">(</span><span class="s2">long</span><span class="s1">)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_iter           */ </span><span class="s1">(getiterfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_iternext       */ </span><span class="s1">(iternextfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_methods        */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_members        */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getset         */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_base           */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_dict           */ </span><span class="s5">0</span><span class="s1">, </span><span class="s0">/* internal use */</span>
        <span class="s0">/* tp_descr_get      */ </span><span class="s1">(descrgetfunc)OSD_descr_get,</span>
<span class="s1">};</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s1">Spec spec;</span>
    <span class="s0">/* These members are handled generically, as for Spec members. */</span>
    <span class="s1">PyObject* _cls;</span>
    <span class="s1">PyObject* _implements;</span>
<span class="s1">} CPB;</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">CPB_descr_get(CPB *self, PyObject *inst, PyObject *cls)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *implements;</span>

  <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">_cls == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(cls == self</span><span class="s4">-&gt;</span><span class="s1">_cls)</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(inst == NULL)</span>
        <span class="s1">{</span>
          <span class="s1">Py_INCREF(self);</span>
          <span class="s2">return </span><span class="s1">OBJECT(self);</span>
        <span class="s1">}</span>

      <span class="s1">implements = self</span><span class="s4">-&gt;</span><span class="s1">_implements;</span>
      <span class="s1">Py_XINCREF(implements);</span>
      <span class="s2">return </span><span class="s1">implements;</span>
    <span class="s1">}</span>

  <span class="s1">PyErr_SetObject(PyExc_AttributeError, str__provides__);</span>
  <span class="s2">return </span><span class="s1">NULL;</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">CPB_traverse(CPB* self, visitproc visit, </span><span class="s2">void</span><span class="s1">* arg)</span>
<span class="s1">{</span>
    <span class="s1">Py_VISIT(self</span><span class="s4">-&gt;</span><span class="s1">_cls);</span>
    <span class="s1">Py_VISIT(self</span><span class="s4">-&gt;</span><span class="s1">_implements);</span>
    <span class="s2">return </span><span class="s1">Spec_traverse((Spec*)self, visit, arg);</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">CPB_clear(CPB* self)</span>
<span class="s1">{</span>
    <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">_cls);</span>
    <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">_implements);</span>
    <span class="s1">Spec_clear((Spec*)self);</span>
    <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static void</span>
<span class="s1">CPB_dealloc(CPB* self)</span>
<span class="s1">{</span>
    <span class="s1">PyObject_GC_UnTrack((PyObject *)self);</span>
    <span class="s1">CPB_clear(self);</span>
    <span class="s1">Spec_dealloc((Spec*)self);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyMemberDef CPB_members[] = {</span>
  <span class="s1">{</span><span class="s3">&quot;_cls&quot;</span><span class="s1">, T_OBJECT_EX, offsetof(CPB, _cls), </span><span class="s5">0</span><span class="s1">, </span><span class="s3">&quot;Defining class.&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;_implements&quot;</span><span class="s1">, T_OBJECT_EX, offsetof(CPB, _implements), </span><span class="s5">0</span><span class="s1">, </span><span class="s3">&quot;Result of implementedBy.&quot;</span><span class="s1">},</span>
  <span class="s1">{NULL}</span>
<span class="s1">};</span>

<span class="s2">static </span><span class="s1">PyTypeObject CPBType = {</span>
        <span class="s1">PyVarObject_HEAD_INIT(NULL, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">/* tp_name           */ </span><span class="s3">&quot;_interface_coptimizations.&quot;</span>
                                <span class="s3">&quot;ClassProvidesBase&quot;</span><span class="s1">,</span>
        <span class="s0">/* tp_basicsize      */ </span><span class="s2">sizeof</span><span class="s1">(CPB),</span>
        <span class="s0">/* tp_itemsize       */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_dealloc        */ </span><span class="s1">(destructor)CPB_dealloc,</span>
        <span class="s0">/* tp_print          */ </span><span class="s1">(printfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getattr        */ </span><span class="s1">(getattrfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_setattr        */ </span><span class="s1">(setattrfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_compare        */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_repr           */ </span><span class="s1">(reprfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_number      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_sequence    */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_mapping     */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_hash           */ </span><span class="s1">(hashfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_call           */ </span><span class="s1">(ternaryfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_str            */ </span><span class="s1">(reprfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getattro       */ </span><span class="s1">(getattrofunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_setattro       */ </span><span class="s1">(setattrofunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_buffer      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_flags          */ </span><span class="s1">Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,</span>
        <span class="s3">&quot;C Base class for ClassProvides&quot;</span><span class="s1">,</span>
        <span class="s0">/* tp_traverse       */ </span><span class="s1">(traverseproc)CPB_traverse,</span>
        <span class="s0">/* tp_clear          */ </span><span class="s1">(inquiry)CPB_clear,</span>
        <span class="s0">/* tp_richcompare    */ </span><span class="s1">(richcmpfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_weaklistoffset */ </span><span class="s1">(</span><span class="s2">long</span><span class="s1">)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_iter           */ </span><span class="s1">(getiterfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_iternext       */ </span><span class="s1">(iternextfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_methods        */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_members        */ </span><span class="s1">CPB_members,</span>
        <span class="s0">/* tp_getset         */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_base           */ </span><span class="s1">&amp;SpecificationBaseType,</span>
        <span class="s0">/* tp_dict           */ </span><span class="s5">0</span><span class="s1">, </span><span class="s0">/* internal use */</span>
        <span class="s0">/* tp_descr_get      */ </span><span class="s1">(descrgetfunc)CPB_descr_get,</span>
        <span class="s0">/* tp_descr_set      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_dictoffset     */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_init           */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_alloc          */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_new            */ </span><span class="s5">0</span><span class="s1">,</span>
<span class="s1">};</span>

<span class="s0">/* ==================================================================== */</span>
<span class="s0">/* ========== Begin: __call__ and __adapt__ =========================== */</span>

<span class="s0">/* 
    def __adapt__(self, obj): 
        &quot;&quot;&quot;Adapt an object to the receiver 
        &quot;&quot;&quot; 
        if self.providedBy(obj): 
            return obj 
 
        for hook in adapter_hooks: 
            adapter = hook(self, obj) 
            if adapter is not None: 
                return adapter 
 
 
*/</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">__adapt__(PyObject *self, PyObject *obj)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *decl, *args, *adapter;</span>
  <span class="s2">int </span><span class="s1">implements, i, l;</span>

  <span class="s1">decl = providedBy(NULL, obj);</span>
  <span class="s2">if </span><span class="s1">(decl == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(PyObject_TypeCheck(decl, &amp;SpecificationBaseType))</span>
    <span class="s1">{</span>
      <span class="s1">PyObject *implied;</span>

      <span class="s1">implied = ((Spec*)decl)</span><span class="s4">-&gt;</span><span class="s1">_implied;</span>
      <span class="s2">if </span><span class="s1">(implied == NULL)</span>
        <span class="s1">{</span>
          <span class="s1">Py_DECREF(decl);</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>

      <span class="s1">implements = PyDict_GetItem(implied, self) != NULL;</span>
      <span class="s1">Py_DECREF(decl);</span>
    <span class="s1">}</span>
  <span class="s2">else</span>
    <span class="s1">{</span>
      <span class="s0">/* decl is probably a security proxy.  We have to go the long way 
         around. 
      */</span>
      <span class="s1">PyObject *r;</span>
      <span class="s1">r = PyObject_CallFunctionObjArgs(decl, self, NULL);</span>
      <span class="s1">Py_DECREF(decl);</span>
      <span class="s2">if </span><span class="s1">(r == NULL)</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
      <span class="s1">implements = PyObject_IsTrue(r);</span>
      <span class="s1">Py_DECREF(r);</span>
    <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(implements)</span>
    <span class="s1">{</span>
      <span class="s1">Py_INCREF(obj);</span>
      <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>

  <span class="s1">l = PyList_GET_SIZE(adapter_hooks);</span>
  <span class="s1">args = PyTuple_New(</span><span class="s5">2</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(args == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s1">Py_INCREF(self);</span>
  <span class="s1">PyTuple_SET_ITEM(args, </span><span class="s5">0</span><span class="s1">, self);</span>
  <span class="s1">Py_INCREF(obj);</span>
  <span class="s1">PyTuple_SET_ITEM(args, </span><span class="s5">1</span><span class="s1">, obj);</span>
  <span class="s2">for </span><span class="s1">(i = </span><span class="s5">0</span><span class="s1">; i &lt; l; i++)</span>
    <span class="s1">{</span>
      <span class="s1">adapter = PyObject_CallObject(PyList_GET_ITEM(adapter_hooks, i), args);</span>
      <span class="s2">if </span><span class="s1">(adapter == NULL || adapter != Py_None)</span>
        <span class="s1">{</span>
          <span class="s1">Py_DECREF(args);</span>
          <span class="s2">return </span><span class="s1">adapter;</span>
        <span class="s1">}</span>
      <span class="s1">Py_DECREF(adapter);</span>
    <span class="s1">}</span>

  <span class="s1">Py_DECREF(args);</span>

  <span class="s1">Py_INCREF(Py_None);</span>
  <span class="s2">return </span><span class="s1">Py_None;</span>
<span class="s1">}</span>

<span class="s2">#ifndef </span><span class="s1">PY3K</span>
<span class="s2">typedef long </span><span class="s1">Py_hash_t;</span>
<span class="s2">#endif</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
    <span class="s1">Spec spec;</span>
    <span class="s1">PyObject* __name__;</span>
    <span class="s1">PyObject* __module__;</span>
    <span class="s1">Py_hash_t _v_cached_hash;</span>
<span class="s1">} IB;</span>

<span class="s2">static struct </span><span class="s1">PyMethodDef ib_methods[] = {</span>
  <span class="s1">{</span><span class="s3">&quot;__adapt__&quot;</span><span class="s1">, (PyCFunction)__adapt__, METH_O,</span>
   <span class="s3">&quot;Adapt an object to the receiver&quot;</span><span class="s1">},</span>
  <span class="s1">{NULL,                NULL}           </span><span class="s0">/* sentinel */</span>
<span class="s1">};</span>

<span class="s0">/* 
    def __call__(self, obj, alternate=_marker): 
        try: 
            conform = obj.__conform__ 
        except AttributeError: # pylint:disable=bare-except 
            conform = None 
 
        if conform is not None: 
            adapter = self._call_conform(conform) 
            if adapter is not None: 
                return adapter 
 
        adapter = self.__adapt__(obj) 
 
        if adapter is not None: 
            return adapter 
        if alternate is not _marker: 
            return alternate 
        raise TypeError(&quot;Could not adapt&quot;, obj, self) 
 
*/</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">IB_call(PyObject *self, PyObject *args, PyObject *kwargs)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *conform, *obj, *alternate, *adapter;</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;obj&quot;</span><span class="s1">, </span><span class="s3">&quot;alternate&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">conform = obj = alternate = adapter = NULL;</span>


  <span class="s2">if </span><span class="s1">(!PyArg_ParseTupleAndKeywords(args, kwargs, </span><span class="s3">&quot;O|O&quot;</span><span class="s1">, kwlist,</span>
                                   <span class="s1">&amp;obj, &amp;alternate))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">conform = PyObject_GetAttr(obj, str__conform__);</span>
  <span class="s2">if </span><span class="s1">(conform == NULL)</span>
  <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!PyErr_ExceptionMatches(PyExc_AttributeError))</span>
      <span class="s1">{</span>
          <span class="s0">/* Propagate non-AttributeErrors */</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
      <span class="s1">}</span>
      <span class="s1">PyErr_Clear();</span>

      <span class="s1">Py_INCREF(Py_None);</span>
      <span class="s1">conform = Py_None;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(conform != Py_None)</span>
  <span class="s1">{</span>
      <span class="s1">adapter = PyObject_CallMethodObjArgs(self, str_call_conform,</span>
                                           <span class="s1">conform, NULL);</span>
      <span class="s1">Py_DECREF(conform);</span>
      <span class="s2">if </span><span class="s1">(adapter == NULL || adapter != Py_None)</span>
          <span class="s2">return </span><span class="s1">adapter;</span>
      <span class="s1">Py_DECREF(adapter);</span>
  <span class="s1">}</span>
  <span class="s2">else</span>
  <span class="s1">{</span>
      <span class="s1">Py_DECREF(conform);</span>
  <span class="s1">}</span>

  <span class="s0">/* We differ from the Python code here. For speed, instead of always calling 
     self.__adapt__(), we check to see if the type has defined it. Checking in 
     the dict for __adapt__ isn't sufficient because there's no cheap way to 
     tell if it's the __adapt__ that InterfaceBase itself defines (our type 
     will *never* be InterfaceBase, we're always subclassed by 
     InterfaceClass). Instead, we cooperate with InterfaceClass in Python to 
     set a flag in a new subclass when this is necessary. */</span>
  <span class="s2">if </span><span class="s1">(PyDict_GetItem(self</span><span class="s4">-&gt;</span><span class="s1">ob_type</span><span class="s4">-&gt;</span><span class="s1">tp_dict, str_CALL_CUSTOM_ADAPT))</span>
  <span class="s1">{</span>
      <span class="s0">/* Doesn't matter what the value is. Simply being present is enough. */</span>
      <span class="s1">adapter = PyObject_CallMethodObjArgs(self, str__adapt__, obj, NULL);</span>
  <span class="s1">}</span>
  <span class="s2">else</span>
  <span class="s1">{</span>
      <span class="s1">adapter = __adapt__(self, obj);</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(adapter == NULL || adapter != Py_None)</span>
  <span class="s1">{</span>
      <span class="s2">return </span><span class="s1">adapter;</span>
  <span class="s1">}</span>
  <span class="s1">Py_DECREF(adapter);</span>

  <span class="s2">if </span><span class="s1">(alternate != NULL)</span>
  <span class="s1">{</span>
      <span class="s1">Py_INCREF(alternate);</span>
      <span class="s2">return </span><span class="s1">alternate;</span>
  <span class="s1">}</span>

  <span class="s1">adapter = Py_BuildValue(</span><span class="s3">&quot;sOO&quot;</span><span class="s1">, </span><span class="s3">&quot;Could not adapt&quot;</span><span class="s1">, obj, self);</span>
  <span class="s2">if </span><span class="s1">(adapter != NULL)</span>
  <span class="s1">{</span>
      <span class="s1">PyErr_SetObject(PyExc_TypeError, adapter);</span>
      <span class="s1">Py_DECREF(adapter);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">NULL;</span>
<span class="s1">}</span>


<span class="s2">static int</span>
<span class="s1">IB_traverse(IB* self, visitproc visit, </span><span class="s2">void</span><span class="s1">* arg)</span>
<span class="s1">{</span>
    <span class="s1">Py_VISIT(self</span><span class="s4">-&gt;</span><span class="s1">__name__);</span>
    <span class="s1">Py_VISIT(self</span><span class="s4">-&gt;</span><span class="s1">__module__);</span>
    <span class="s2">return </span><span class="s1">Spec_traverse((Spec*)self, visit, arg);</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">IB_clear(IB* self)</span>
<span class="s1">{</span>
    <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">__name__);</span>
    <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">__module__);</span>
    <span class="s2">return </span><span class="s1">Spec_clear((Spec*)self);</span>
<span class="s1">}</span>

<span class="s2">static void</span>
<span class="s1">IB_dealloc(IB* self)</span>
<span class="s1">{</span>
    <span class="s1">PyObject_GC_UnTrack((PyObject *)self);</span>
    <span class="s1">IB_clear(self);</span>
    <span class="s1">Spec_dealloc((Spec*)self);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyMemberDef IB_members[] = {</span>
  <span class="s1">{</span><span class="s3">&quot;__name__&quot;</span><span class="s1">, T_OBJECT_EX, offsetof(IB, __name__), </span><span class="s5">0</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s0">// The redundancy between __module__ and __ibmodule__ is because</span>
  <span class="s0">// __module__ is often shadowed by subclasses.</span>
  <span class="s1">{</span><span class="s3">&quot;__module__&quot;</span><span class="s1">, T_OBJECT_EX, offsetof(IB, __module__), READONLY, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;__ibmodule__&quot;</span><span class="s1">, T_OBJECT_EX, offsetof(IB, __module__), </span><span class="s5">0</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{NULL}</span>
<span class="s1">};</span>

<span class="s2">static </span><span class="s1">Py_hash_t</span>
<span class="s1">IB_hash(IB* self)</span>
<span class="s1">{</span>
    <span class="s1">PyObject* tuple;</span>
    <span class="s2">if </span><span class="s1">(!self</span><span class="s4">-&gt;</span><span class="s1">__module__) {</span>
        <span class="s1">PyErr_SetString(PyExc_AttributeError, </span><span class="s3">&quot;__module__&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!self</span><span class="s4">-&gt;</span><span class="s1">__name__) {</span>
        <span class="s1">PyErr_SetString(PyExc_AttributeError, </span><span class="s3">&quot;__name__&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">_v_cached_hash) {</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">_v_cached_hash;</span>
    <span class="s1">}</span>

    <span class="s1">tuple = PyTuple_Pack(</span><span class="s5">2</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">__name__, self</span><span class="s4">-&gt;</span><span class="s1">__module__);</span>
    <span class="s2">if </span><span class="s1">(!tuple) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">_v_cached_hash = PyObject_Hash(tuple);</span>
    <span class="s1">Py_CLEAR(tuple);</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">_v_cached_hash;</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyTypeObject InterfaceBaseType;</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">IB_richcompare(IB* self, PyObject* other, </span><span class="s2">int </span><span class="s1">op)</span>
<span class="s1">{</span>
    <span class="s1">PyObject* othername;</span>
    <span class="s1">PyObject* othermod;</span>
    <span class="s1">PyObject* oresult;</span>
    <span class="s1">IB* otherib;</span>
    <span class="s2">int </span><span class="s1">result;</span>

    <span class="s1">otherib = NULL;</span>
    <span class="s1">oresult = othername = othermod = NULL;</span>

    <span class="s2">if </span><span class="s1">(OBJECT(self) == other) {</span>
        <span class="s2">switch</span><span class="s1">(op) {</span>
        <span class="s2">case </span><span class="s1">Py_EQ:</span>
        <span class="s2">case </span><span class="s1">Py_LE:</span>
        <span class="s2">case </span><span class="s1">Py_GE:</span>
            <span class="s1">Py_RETURN_TRUE;</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s1">Py_NE:</span>
            <span class="s1">Py_RETURN_FALSE;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(other == Py_None) {</span>
        <span class="s2">switch</span><span class="s1">(op) {</span>
        <span class="s2">case </span><span class="s1">Py_LT:</span>
        <span class="s2">case </span><span class="s1">Py_LE:</span>
        <span class="s2">case </span><span class="s1">Py_NE:</span>
            <span class="s1">Py_RETURN_TRUE;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">Py_RETURN_FALSE;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(PyObject_TypeCheck(other, &amp;InterfaceBaseType)) {</span>
        <span class="s0">// This branch borrows references. No need to clean</span>
        <span class="s0">// up if otherib is not null.</span>
        <span class="s1">otherib = (IB*)other;</span>
        <span class="s1">othername = otherib</span><span class="s4">-&gt;</span><span class="s1">__name__;</span>
        <span class="s1">othermod = otherib</span><span class="s4">-&gt;</span><span class="s1">__module__;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">othername = PyObject_GetAttrString(other, </span><span class="s3">&quot;__name__&quot;</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(othername) {</span>
            <span class="s1">othermod = PyObject_GetAttrString(other, </span><span class="s3">&quot;__module__&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!othername || !othermod) {</span>
            <span class="s2">if </span><span class="s1">(PyErr_Occurred() &amp;&amp; PyErr_ExceptionMatches(PyExc_AttributeError)) {</span>
                <span class="s1">PyErr_Clear();</span>
                <span class="s1">oresult = Py_NotImplemented;</span>
            <span class="s1">}</span>
            <span class="s2">goto </span><span class="s1">cleanup;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s2">#if </span><span class="s5">0</span>
<span class="s0">// This is the simple, straightforward version of what Python does.</span>
    <span class="s1">PyObject* pt1 = PyTuple_Pack(</span><span class="s5">2</span><span class="s1">, self</span><span class="s4">-&gt;</span><span class="s1">__name__, self</span><span class="s4">-&gt;</span><span class="s1">__module__);</span>
    <span class="s1">PyObject* pt2 = PyTuple_Pack(</span><span class="s5">2</span><span class="s1">, othername, othermod);</span>
    <span class="s1">oresult = PyObject_RichCompare(pt1, pt2, op);</span>
<span class="s2">#endif</span>

    <span class="s0">// tuple comparison is decided by the first non-equal element.</span>
    <span class="s1">result = PyObject_RichCompareBool(self</span><span class="s4">-&gt;</span><span class="s1">__name__, othername, Py_EQ);</span>
    <span class="s2">if </span><span class="s1">(result == </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">result = PyObject_RichCompareBool(self</span><span class="s4">-&gt;</span><span class="s1">__name__, othername, op);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(result == </span><span class="s5">1</span><span class="s1">) {</span>
        <span class="s1">result = PyObject_RichCompareBool(self</span><span class="s4">-&gt;</span><span class="s1">__module__, othermod, op);</span>
    <span class="s1">}</span>
    <span class="s0">// If either comparison failed, we have an error set.</span>
    <span class="s0">// Leave oresult NULL so we raise it.</span>
    <span class="s2">if </span><span class="s1">(result == -</span><span class="s5">1</span><span class="s1">) {</span>
        <span class="s2">goto </span><span class="s1">cleanup;</span>
    <span class="s1">}</span>

    <span class="s1">oresult = result ? Py_True : Py_False;</span>


<span class="s1">cleanup:</span>
    <span class="s1">Py_XINCREF(oresult);</span>

    <span class="s2">if </span><span class="s1">(!otherib) {</span>
        <span class="s1">Py_XDECREF(othername);</span>
        <span class="s1">Py_XDECREF(othermod);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">oresult;</span>

<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">IB_init(IB* self, PyObject* args, PyObject* kwargs)</span>
<span class="s1">{</span>
    <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;__name__&quot;</span><span class="s1">, </span><span class="s3">&quot;__module__&quot;</span><span class="s1">, NULL};</span>
    <span class="s1">PyObject* module = NULL;</span>
    <span class="s1">PyObject* name = NULL;</span>

    <span class="s2">if </span><span class="s1">(!PyArg_ParseTupleAndKeywords(args, kwargs, </span><span class="s3">&quot;|OO:InterfaceBase.__init__&quot;</span><span class="s1">, kwlist,</span>
                                      <span class="s1">&amp;name, &amp;module)) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">IB_clear(self);</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">__module__ = module ? module : Py_None;</span>
    <span class="s1">Py_INCREF(self</span><span class="s4">-&gt;</span><span class="s1">__module__);</span>
    <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">__name__ = name ? name : Py_None;</span>
    <span class="s1">Py_INCREF(self</span><span class="s4">-&gt;</span><span class="s1">__name__);</span>
    <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s2">static </span><span class="s1">PyTypeObject InterfaceBaseType = {</span>
        <span class="s1">PyVarObject_HEAD_INIT(NULL, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">/* tp_name           */ </span><span class="s3">&quot;_zope_interface_coptimizations.&quot;</span>
                                <span class="s3">&quot;InterfaceBase&quot;</span><span class="s1">,</span>
        <span class="s0">/* tp_basicsize      */ </span><span class="s2">sizeof</span><span class="s1">(IB),</span>
        <span class="s0">/* tp_itemsize       */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_dealloc        */ </span><span class="s1">(destructor)IB_dealloc,</span>
        <span class="s0">/* tp_print          */ </span><span class="s1">(printfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getattr        */ </span><span class="s1">(getattrfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_setattr        */ </span><span class="s1">(setattrfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_compare        */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_repr           */ </span><span class="s1">(reprfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_number      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_sequence    */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_mapping     */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_hash           */ </span><span class="s1">(hashfunc)IB_hash,</span>
        <span class="s0">/* tp_call           */ </span><span class="s1">(ternaryfunc)IB_call,</span>
        <span class="s0">/* tp_str            */ </span><span class="s1">(reprfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getattro       */ </span><span class="s1">(getattrofunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_setattro       */ </span><span class="s1">(setattrofunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_buffer      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_flags          */ </span><span class="s1">Py_TPFLAGS_DEFAULT</span>
                                <span class="s1">| Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,</span>
        <span class="s0">/* tp_doc */ </span><span class="s3">&quot;Interface base type providing __call__ and __adapt__&quot;</span><span class="s1">,</span>
        <span class="s0">/* tp_traverse       */ </span><span class="s1">(traverseproc)IB_traverse,</span>
        <span class="s0">/* tp_clear          */ </span><span class="s1">(inquiry)IB_clear,</span>
        <span class="s0">/* tp_richcompare    */ </span><span class="s1">(richcmpfunc)IB_richcompare,</span>
        <span class="s0">/* tp_weaklistoffset */ </span><span class="s1">(</span><span class="s2">long</span><span class="s1">)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_iter           */ </span><span class="s1">(getiterfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_iternext       */ </span><span class="s1">(iternextfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_methods        */ </span><span class="s1">ib_methods,</span>
        <span class="s0">/* tp_members        */ </span><span class="s1">IB_members,</span>
        <span class="s0">/* tp_getset         */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_base           */ </span><span class="s1">&amp;SpecificationBaseType,</span>
        <span class="s0">/* tp_dict           */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_descr_get      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_descr_set      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_dictoffset     */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_init           */ </span><span class="s1">(initproc)IB_init,</span>
<span class="s1">};</span>

<span class="s0">/* =================== End: __call__ and __adapt__ ==================== */</span>
<span class="s0">/* ==================================================================== */</span>

<span class="s0">/* ==================================================================== */</span>
<span class="s0">/* ========================== Begin: Lookup Bases ===================== */</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
  <span class="s1">PyObject_HEAD</span>
  <span class="s1">PyObject *_cache;</span>
  <span class="s1">PyObject *_mcache;</span>
  <span class="s1">PyObject *_scache;</span>
<span class="s1">} lookup;</span>

<span class="s2">typedef struct </span><span class="s1">{</span>
  <span class="s1">PyObject_HEAD</span>
  <span class="s1">PyObject *_cache;</span>
  <span class="s1">PyObject *_mcache;</span>
  <span class="s1">PyObject *_scache;</span>
  <span class="s1">PyObject *_verify_ro;</span>
  <span class="s1">PyObject *_verify_generations;</span>
<span class="s1">} verify;</span>

<span class="s2">static int</span>
<span class="s1">lookup_traverse(lookup *self, visitproc visit, </span><span class="s2">void </span><span class="s1">*arg)</span>
<span class="s1">{</span>
  <span class="s2">int </span><span class="s1">vret;</span>

  <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">_cache) {</span>
    <span class="s1">vret = visit(self</span><span class="s4">-&gt;</span><span class="s1">_cache, arg);</span>
    <span class="s2">if </span><span class="s1">(vret != </span><span class="s5">0</span><span class="s1">)</span>
      <span class="s2">return </span><span class="s1">vret;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">_mcache) {</span>
    <span class="s1">vret = visit(self</span><span class="s4">-&gt;</span><span class="s1">_mcache, arg);</span>
    <span class="s2">if </span><span class="s1">(vret != </span><span class="s5">0</span><span class="s1">)</span>
      <span class="s2">return </span><span class="s1">vret;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">_scache) {</span>
    <span class="s1">vret = visit(self</span><span class="s4">-&gt;</span><span class="s1">_scache, arg);</span>
    <span class="s2">if </span><span class="s1">(vret != </span><span class="s5">0</span><span class="s1">)</span>
      <span class="s2">return </span><span class="s1">vret;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">lookup_clear(lookup *self)</span>
<span class="s1">{</span>
  <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">_cache);</span>
  <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">_mcache);</span>
  <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">_scache);</span>
  <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static void</span>
<span class="s1">lookup_dealloc(lookup *self)</span>
<span class="s1">{</span>
  <span class="s1">PyObject_GC_UnTrack((PyObject *)self);</span>
  <span class="s1">lookup_clear(self);</span>
  <span class="s1">Py_TYPE(self)</span><span class="s4">-&gt;</span><span class="s1">tp_free((PyObject*)self);</span>
<span class="s1">}</span>

<span class="s0">/* 
    def changed(self, ignored=None): 
        self._cache.clear() 
        self._mcache.clear() 
        self._scache.clear() 
*/</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">lookup_changed(lookup *self, PyObject *ignored)</span>
<span class="s1">{</span>
  <span class="s1">lookup_clear(self);</span>
  <span class="s1">Py_INCREF(Py_None);</span>
  <span class="s2">return </span><span class="s1">Py_None;</span>
<span class="s1">}</span>

<span class="s2">#define </span><span class="s1">ASSURE_DICT(N) </span><span class="s2">if </span><span class="s1">(N == NULL) { N = PyDict_New(); \</span>
                                        <span class="s2">if </span><span class="s1">(N == NULL) </span><span class="s2">return </span><span class="s1">NULL; \</span>
                                       <span class="s1">}</span>

<span class="s0">/* 
    def _getcache(self, provided, name): 
        cache = self._cache.get(provided) 
        if cache is None: 
            cache = {} 
            self._cache[provided] = cache 
        if name: 
            c = cache.get(name) 
            if c is None: 
                c = {} 
                cache[name] = c 
            cache = c 
        return cache 
*/</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">_subcache(PyObject *cache, PyObject *key)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *subcache;</span>

  <span class="s1">subcache = PyDict_GetItem(cache, key);</span>
  <span class="s2">if </span><span class="s1">(subcache == NULL)</span>
    <span class="s1">{</span>
      <span class="s2">int </span><span class="s1">status;</span>

      <span class="s1">subcache = PyDict_New();</span>
      <span class="s2">if </span><span class="s1">(subcache == NULL)</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
      <span class="s1">status = PyDict_SetItem(cache, key, subcache);</span>
      <span class="s1">Py_DECREF(subcache);</span>
      <span class="s2">if </span><span class="s1">(status &lt; </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">subcache;</span>
<span class="s1">}</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">_getcache(lookup *self, PyObject *provided, PyObject *name)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *cache;</span>

  <span class="s1">ASSURE_DICT(self</span><span class="s4">-&gt;</span><span class="s1">_cache);</span>
  <span class="s1">cache = _subcache(self</span><span class="s4">-&gt;</span><span class="s1">_cache, provided);</span>
  <span class="s2">if </span><span class="s1">(cache == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(name != NULL &amp;&amp; PyObject_IsTrue(name))</span>
    <span class="s1">cache = _subcache(cache, name);</span>

  <span class="s2">return </span><span class="s1">cache;</span>
<span class="s1">}</span>


<span class="s0">/* 
    def lookup(self, required, provided, name=u'', default=None): 
        cache = self._getcache(provided, name) 
        if len(required) == 1: 
            result = cache.get(required[0], _not_in_mapping) 
        else: 
            result = cache.get(tuple(required), _not_in_mapping) 
 
        if result is _not_in_mapping: 
            result = self._uncached_lookup(required, provided, name) 
            if len(required) == 1: 
                cache[required[0]] = result 
            else: 
                cache[tuple(required)] = result 
 
        if result is None: 
            return default 
 
        return result 
*/</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">_lookup(lookup *self,</span>
        <span class="s1">PyObject *required, PyObject *provided, PyObject *name,</span>
        <span class="s1">PyObject *default_)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *result, *key, *cache;</span>
  <span class="s1">result = key = cache = NULL;</span>
<span class="s2">#ifdef </span><span class="s1">PY3K</span>
  <span class="s2">if </span><span class="s1">( name &amp;&amp; !PyUnicode_Check(name) )</span>
<span class="s2">#else</span>
  <span class="s2">if </span><span class="s1">( name &amp;&amp; !PyString_Check(name) &amp;&amp; !PyUnicode_Check(name) )</span>
<span class="s2">#endif</span>
  <span class="s1">{</span>
    <span class="s1">PyErr_SetString(PyExc_ValueError,</span>
                    <span class="s3">&quot;name is not a string or unicode&quot;</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s1">}</span>

  <span class="s0">/* If `required` is a lazy sequence, it could have arbitrary side-effects, 
     such as clearing our caches. So we must not retrieve the cache until 
     after resolving it. */</span>
  <span class="s1">required = PySequence_Tuple(required);</span>
  <span class="s2">if </span><span class="s1">(required == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>


  <span class="s1">cache = _getcache(self, provided, name);</span>
  <span class="s2">if </span><span class="s1">(cache == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(PyTuple_GET_SIZE(required) == </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">key = PyTuple_GET_ITEM(required, </span><span class="s5">0</span><span class="s1">);</span>
  <span class="s2">else</span>
    <span class="s1">key = required;</span>

  <span class="s1">result = PyDict_GetItem(cache, key);</span>
  <span class="s2">if </span><span class="s1">(result == NULL)</span>
    <span class="s1">{</span>
      <span class="s2">int </span><span class="s1">status;</span>

      <span class="s1">result = PyObject_CallMethodObjArgs(OBJECT(self), str_uncached_lookup,</span>
                                          <span class="s1">required, provided, name, NULL);</span>
      <span class="s2">if </span><span class="s1">(result == NULL)</span>
        <span class="s1">{</span>
          <span class="s1">Py_DECREF(required);</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>
      <span class="s1">status = PyDict_SetItem(cache, key, result);</span>
      <span class="s1">Py_DECREF(required);</span>
      <span class="s2">if </span><span class="s1">(status &lt; </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">{</span>
          <span class="s1">Py_DECREF(result);</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s2">else</span>
    <span class="s1">{</span>
      <span class="s1">Py_INCREF(result);</span>
      <span class="s1">Py_DECREF(required);</span>
    <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(result == Py_None &amp;&amp; default_ != NULL)</span>
    <span class="s1">{</span>
      <span class="s1">Py_DECREF(Py_None);</span>
      <span class="s1">Py_INCREF(default_);</span>
      <span class="s2">return </span><span class="s1">default_;</span>
    <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">lookup_lookup(lookup *self, PyObject *args, PyObject *kwds)</span>
<span class="s1">{</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;required&quot;</span><span class="s1">, </span><span class="s3">&quot;provided&quot;</span><span class="s1">, </span><span class="s3">&quot;name&quot;</span><span class="s1">, </span><span class="s3">&quot;default&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">PyObject *required, *provided, *name=NULL, *default_=NULL;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTupleAndKeywords(args, kwds, </span><span class="s3">&quot;OO|OO:LookupBase.lookup&quot;</span><span class="s1">, kwlist,</span>
                                    <span class="s1">&amp;required, &amp;provided, &amp;name, &amp;default_))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">_lookup(self, required, provided, name, default_);</span>
<span class="s1">}</span>


<span class="s0">/* 
    def lookup1(self, required, provided, name=u'', default=None): 
        cache = self._getcache(provided, name) 
        result = cache.get(required, _not_in_mapping) 
        if result is _not_in_mapping: 
            return self.lookup((required, ), provided, name, default) 
 
        if result is None: 
            return default 
 
        return result 
*/</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">_lookup1(lookup *self,</span>
        <span class="s1">PyObject *required, PyObject *provided, PyObject *name,</span>
        <span class="s1">PyObject *default_)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *result, *cache;</span>

<span class="s2">#ifdef </span><span class="s1">PY3K</span>
  <span class="s2">if </span><span class="s1">( name &amp;&amp; !PyUnicode_Check(name) )</span>
<span class="s2">#else</span>
  <span class="s2">if </span><span class="s1">( name &amp;&amp; !PyString_Check(name) &amp;&amp; !PyUnicode_Check(name) )</span>
<span class="s2">#endif</span>
  <span class="s1">{</span>
    <span class="s1">PyErr_SetString(PyExc_ValueError,</span>
                    <span class="s3">&quot;name is not a string or unicode&quot;</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s1">}</span>

  <span class="s1">cache = _getcache(self, provided, name);</span>
  <span class="s2">if </span><span class="s1">(cache == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">result = PyDict_GetItem(cache, required);</span>
  <span class="s2">if </span><span class="s1">(result == NULL)</span>
    <span class="s1">{</span>
      <span class="s1">PyObject *tup;</span>

      <span class="s1">tup = PyTuple_New(</span><span class="s5">1</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(tup == NULL)</span>
        <span class="s2">return </span><span class="s1">NULL;</span>
      <span class="s1">Py_INCREF(required);</span>
      <span class="s1">PyTuple_SET_ITEM(tup, </span><span class="s5">0</span><span class="s1">, required);</span>
      <span class="s1">result = _lookup(self, tup, provided, name, default_);</span>
      <span class="s1">Py_DECREF(tup);</span>
    <span class="s1">}</span>
  <span class="s2">else</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(result == Py_None &amp;&amp; default_ != NULL)</span>
        <span class="s1">{</span>
          <span class="s1">result = default_;</span>
        <span class="s1">}</span>
      <span class="s1">Py_INCREF(result);</span>
    <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">lookup_lookup1(lookup *self, PyObject *args, PyObject *kwds)</span>
<span class="s1">{</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;required&quot;</span><span class="s1">, </span><span class="s3">&quot;provided&quot;</span><span class="s1">, </span><span class="s3">&quot;name&quot;</span><span class="s1">, </span><span class="s3">&quot;default&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">PyObject *required, *provided, *name=NULL, *default_=NULL;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTupleAndKeywords(args, kwds, </span><span class="s3">&quot;OO|OO:LookupBase.lookup1&quot;</span><span class="s1">, kwlist,</span>
                                    <span class="s1">&amp;required, &amp;provided, &amp;name, &amp;default_))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">_lookup1(self, required, provided, name, default_);</span>
<span class="s1">}</span>

<span class="s0">/* 
    def adapter_hook(self, provided, object, name=u'', default=None): 
        required = providedBy(object) 
        cache = self._getcache(provided, name) 
        factory = cache.get(required, _not_in_mapping) 
        if factory is _not_in_mapping: 
            factory = self.lookup((required, ), provided, name) 
 
        if factory is not None: 
            if isinstance(object, super): 
                object = object.__self__ 
            result = factory(object) 
            if result is not None: 
                return result 
 
        return default 
*/</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">_adapter_hook(lookup *self,</span>
              <span class="s1">PyObject *provided, PyObject *object,  PyObject *name,</span>
              <span class="s1">PyObject *default_)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *required, *factory, *result;</span>

<span class="s2">#ifdef </span><span class="s1">PY3K</span>
  <span class="s2">if </span><span class="s1">( name &amp;&amp; !PyUnicode_Check(name) )</span>
<span class="s2">#else</span>
  <span class="s2">if </span><span class="s1">( name &amp;&amp; !PyString_Check(name) &amp;&amp; !PyUnicode_Check(name) )</span>
<span class="s2">#endif</span>
  <span class="s1">{</span>
    <span class="s1">PyErr_SetString(PyExc_ValueError,</span>
                    <span class="s3">&quot;name is not a string or unicode&quot;</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s1">}</span>

  <span class="s1">required = providedBy(NULL, object);</span>
  <span class="s2">if </span><span class="s1">(required == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">factory = _lookup1(self, required, provided, name, Py_None);</span>
  <span class="s1">Py_DECREF(required);</span>
  <span class="s2">if </span><span class="s1">(factory == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(factory != Py_None)</span>
  <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(PyObject_TypeCheck(object, &amp;PySuper_Type)) {</span>
          <span class="s1">PyObject* self = PyObject_GetAttr(object, str__self__);</span>
          <span class="s2">if </span><span class="s1">(self == NULL)</span>
          <span class="s1">{</span>
              <span class="s1">Py_DECREF(factory);</span>
              <span class="s2">return </span><span class="s1">NULL;</span>
          <span class="s1">}</span>
          <span class="s0">// Borrow the reference to self</span>
          <span class="s1">Py_DECREF(self);</span>
          <span class="s1">object = self;</span>
      <span class="s1">}</span>
      <span class="s1">result = PyObject_CallFunctionObjArgs(factory, object, NULL);</span>
      <span class="s1">Py_DECREF(factory);</span>
      <span class="s2">if </span><span class="s1">(result == NULL || result != Py_None)</span>
        <span class="s2">return </span><span class="s1">result;</span>
  <span class="s1">}</span>
  <span class="s2">else</span>
    <span class="s1">result = factory; </span><span class="s0">/* None */</span>

  <span class="s2">if </span><span class="s1">(default_ == NULL || default_ == result) </span><span class="s0">/* No default specified, */</span>
    <span class="s2">return </span><span class="s1">result;   </span><span class="s0">/* Return None.  result is owned None */</span>

  <span class="s1">Py_DECREF(result);</span>
  <span class="s1">Py_INCREF(default_);</span>

  <span class="s2">return </span><span class="s1">default_;</span>
<span class="s1">}</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">lookup_adapter_hook(lookup *self, PyObject *args, PyObject *kwds)</span>
<span class="s1">{</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;provided&quot;</span><span class="s1">, </span><span class="s3">&quot;object&quot;</span><span class="s1">, </span><span class="s3">&quot;name&quot;</span><span class="s1">, </span><span class="s3">&quot;default&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">PyObject *object, *provided, *name=NULL, *default_=NULL;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTupleAndKeywords(args, kwds, </span><span class="s3">&quot;OO|OO:LookupBase.adapter_hook&quot;</span><span class="s1">, kwlist,</span>
                                    <span class="s1">&amp;provided, &amp;object, &amp;name, &amp;default_))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">_adapter_hook(self, provided, object, name, default_);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">lookup_queryAdapter(lookup *self, PyObject *args, PyObject *kwds)</span>
<span class="s1">{</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;object&quot;</span><span class="s1">, </span><span class="s3">&quot;provided&quot;</span><span class="s1">, </span><span class="s3">&quot;name&quot;</span><span class="s1">, </span><span class="s3">&quot;default&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">PyObject *object, *provided, *name=NULL, *default_=NULL;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTupleAndKeywords(args, kwds, </span><span class="s3">&quot;OO|OO:LookupBase.queryAdapter&quot;</span><span class="s1">, kwlist,</span>
                                    <span class="s1">&amp;object, &amp;provided, &amp;name, &amp;default_))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">_adapter_hook(self, provided, object, name, default_);</span>
<span class="s1">}</span>

<span class="s0">/* 
    def lookupAll(self, required, provided): 
        cache = self._mcache.get(provided) 
        if cache is None: 
            cache = {} 
            self._mcache[provided] = cache 
 
        required = tuple(required) 
        result = cache.get(required, _not_in_mapping) 
        if result is _not_in_mapping: 
            result = self._uncached_lookupAll(required, provided) 
            cache[required] = result 
 
        return result 
*/</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">_lookupAll(lookup *self, PyObject *required, PyObject *provided)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *cache, *result;</span>

  <span class="s0">/* resolve before getting cache. See note in _lookup. */</span>
  <span class="s1">required = PySequence_Tuple(required);</span>
  <span class="s2">if </span><span class="s1">(required == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">ASSURE_DICT(self</span><span class="s4">-&gt;</span><span class="s1">_mcache);</span>
  <span class="s1">cache = _subcache(self</span><span class="s4">-&gt;</span><span class="s1">_mcache, provided);</span>
  <span class="s2">if </span><span class="s1">(cache == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">result = PyDict_GetItem(cache, required);</span>
  <span class="s2">if </span><span class="s1">(result == NULL)</span>
    <span class="s1">{</span>
      <span class="s2">int </span><span class="s1">status;</span>

      <span class="s1">result = PyObject_CallMethodObjArgs(OBJECT(self), str_uncached_lookupAll,</span>
                                          <span class="s1">required, provided, NULL);</span>
      <span class="s2">if </span><span class="s1">(result == NULL)</span>
        <span class="s1">{</span>
          <span class="s1">Py_DECREF(required);</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>
      <span class="s1">status = PyDict_SetItem(cache, required, result);</span>
      <span class="s1">Py_DECREF(required);</span>
      <span class="s2">if </span><span class="s1">(status &lt; </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">{</span>
          <span class="s1">Py_DECREF(result);</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s2">else</span>
    <span class="s1">{</span>
      <span class="s1">Py_INCREF(result);</span>
      <span class="s1">Py_DECREF(required);</span>
    <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">lookup_lookupAll(lookup *self, PyObject *args, PyObject *kwds)</span>
<span class="s1">{</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;required&quot;</span><span class="s1">, </span><span class="s3">&quot;provided&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">PyObject *required, *provided;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTupleAndKeywords(args, kwds, </span><span class="s3">&quot;OO:LookupBase.lookupAll&quot;</span><span class="s1">, kwlist,</span>
                                    <span class="s1">&amp;required, &amp;provided))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">_lookupAll(self, required, provided);</span>
<span class="s1">}</span>

<span class="s0">/* 
    def subscriptions(self, required, provided): 
        cache = self._scache.get(provided) 
        if cache is None: 
            cache = {} 
            self._scache[provided] = cache 
 
        required = tuple(required) 
        result = cache.get(required, _not_in_mapping) 
        if result is _not_in_mapping: 
            result = self._uncached_subscriptions(required, provided) 
            cache[required] = result 
 
        return result 
*/</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">_subscriptions(lookup *self, PyObject *required, PyObject *provided)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *cache, *result;</span>

  <span class="s0">/* resolve before getting cache. See note in _lookup. */</span>
  <span class="s1">required = PySequence_Tuple(required);</span>
  <span class="s2">if </span><span class="s1">(required == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">ASSURE_DICT(self</span><span class="s4">-&gt;</span><span class="s1">_scache);</span>
  <span class="s1">cache = _subcache(self</span><span class="s4">-&gt;</span><span class="s1">_scache, provided);</span>
  <span class="s2">if </span><span class="s1">(cache == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">result = PyDict_GetItem(cache, required);</span>
  <span class="s2">if </span><span class="s1">(result == NULL)</span>
    <span class="s1">{</span>
      <span class="s2">int </span><span class="s1">status;</span>

      <span class="s1">result = PyObject_CallMethodObjArgs(</span>
                                 <span class="s1">OBJECT(self), str_uncached_subscriptions,</span>
                                 <span class="s1">required, provided, NULL);</span>
      <span class="s2">if </span><span class="s1">(result == NULL)</span>
        <span class="s1">{</span>
          <span class="s1">Py_DECREF(required);</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>
      <span class="s1">status = PyDict_SetItem(cache, required, result);</span>
      <span class="s1">Py_DECREF(required);</span>
      <span class="s2">if </span><span class="s1">(status &lt; </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">{</span>
          <span class="s1">Py_DECREF(result);</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s2">else</span>
    <span class="s1">{</span>
      <span class="s1">Py_INCREF(result);</span>
      <span class="s1">Py_DECREF(required);</span>
    <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">lookup_subscriptions(lookup *self, PyObject *args, PyObject *kwds)</span>
<span class="s1">{</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;required&quot;</span><span class="s1">, </span><span class="s3">&quot;provided&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">PyObject *required, *provided;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTupleAndKeywords(args, kwds, </span><span class="s3">&quot;OO&quot;</span><span class="s1">, kwlist,</span>
                                    <span class="s1">&amp;required, &amp;provided))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">_subscriptions(self, required, provided);</span>
<span class="s1">}</span>

<span class="s2">static struct </span><span class="s1">PyMethodDef lookup_methods[] = {</span>
  <span class="s1">{</span><span class="s3">&quot;changed&quot;</span><span class="s1">,       (PyCFunction)lookup_changed,       METH_O,        </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;lookup&quot;</span><span class="s1">,        (PyCFunction)lookup_lookup,        METH_KEYWORDS | METH_VARARGS, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;lookup1&quot;</span><span class="s1">,       (PyCFunction)lookup_lookup1,       METH_KEYWORDS | METH_VARARGS, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;queryAdapter&quot;</span><span class="s1">,  (PyCFunction)lookup_queryAdapter,  METH_KEYWORDS | METH_VARARGS, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;adapter_hook&quot;</span><span class="s1">,  (PyCFunction)lookup_adapter_hook,  METH_KEYWORDS | METH_VARARGS, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;lookupAll&quot;</span><span class="s1">,     (PyCFunction)lookup_lookupAll,     METH_KEYWORDS | METH_VARARGS, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;subscriptions&quot;</span><span class="s1">, (PyCFunction)lookup_subscriptions, METH_KEYWORDS | METH_VARARGS, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{NULL,            NULL}               </span><span class="s0">/* sentinel */</span>
<span class="s1">};</span>

<span class="s2">static </span><span class="s1">PyTypeObject LookupBase = {</span>
        <span class="s1">PyVarObject_HEAD_INIT(NULL, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">/* tp_name           */ </span><span class="s3">&quot;_zope_interface_coptimizations.&quot;</span>
                                <span class="s3">&quot;LookupBase&quot;</span><span class="s1">,</span>
        <span class="s0">/* tp_basicsize      */ </span><span class="s2">sizeof</span><span class="s1">(lookup),</span>
        <span class="s0">/* tp_itemsize       */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_dealloc        */ </span><span class="s1">(destructor)&amp;lookup_dealloc,</span>
        <span class="s0">/* tp_print          */ </span><span class="s1">(printfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getattr        */ </span><span class="s1">(getattrfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_setattr        */ </span><span class="s1">(setattrfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_compare        */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_repr           */ </span><span class="s1">(reprfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_number      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_sequence    */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_mapping     */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_hash           */ </span><span class="s1">(hashfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_call           */ </span><span class="s1">(ternaryfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_str            */ </span><span class="s1">(reprfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getattro       */ </span><span class="s1">(getattrofunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_setattro       */ </span><span class="s1">(setattrofunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_buffer      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_flags          */ </span><span class="s1">Py_TPFLAGS_DEFAULT</span>
                                <span class="s1">| Py_TPFLAGS_BASETYPE</span>
                                <span class="s1">| Py_TPFLAGS_HAVE_GC,</span>
        <span class="s0">/* tp_doc            */ </span><span class="s3">&quot;&quot;</span><span class="s1">,</span>
        <span class="s0">/* tp_traverse       */ </span><span class="s1">(traverseproc)lookup_traverse,</span>
        <span class="s0">/* tp_clear          */ </span><span class="s1">(inquiry)lookup_clear,</span>
        <span class="s0">/* tp_richcompare    */ </span><span class="s1">(richcmpfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_weaklistoffset */ </span><span class="s1">(</span><span class="s2">long</span><span class="s1">)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_iter           */ </span><span class="s1">(getiterfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_iternext       */ </span><span class="s1">(iternextfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_methods        */ </span><span class="s1">lookup_methods,</span>
<span class="s1">};</span>

<span class="s2">static int</span>
<span class="s1">verifying_traverse(verify *self, visitproc visit, </span><span class="s2">void </span><span class="s1">*arg)</span>
<span class="s1">{</span>
  <span class="s2">int </span><span class="s1">vret;</span>

  <span class="s1">vret = lookup_traverse((lookup *)self, visit, arg);</span>
  <span class="s2">if </span><span class="s1">(vret != </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">vret;</span>

  <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">_verify_ro) {</span>
    <span class="s1">vret = visit(self</span><span class="s4">-&gt;</span><span class="s1">_verify_ro, arg);</span>
    <span class="s2">if </span><span class="s1">(vret != </span><span class="s5">0</span><span class="s1">)</span>
      <span class="s2">return </span><span class="s1">vret;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">_verify_generations) {</span>
    <span class="s1">vret = visit(self</span><span class="s4">-&gt;</span><span class="s1">_verify_generations, arg);</span>
    <span class="s2">if </span><span class="s1">(vret != </span><span class="s5">0</span><span class="s1">)</span>
      <span class="s2">return </span><span class="s1">vret;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">verifying_clear(verify *self)</span>
<span class="s1">{</span>
  <span class="s1">lookup_clear((lookup *)self);</span>
  <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">_verify_generations);</span>
  <span class="s1">Py_CLEAR(self</span><span class="s4">-&gt;</span><span class="s1">_verify_ro);</span>
  <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s2">static void</span>
<span class="s1">verifying_dealloc(verify *self)</span>
<span class="s1">{</span>
  <span class="s1">PyObject_GC_UnTrack((PyObject *)self);</span>
  <span class="s1">verifying_clear(self);</span>
  <span class="s1">Py_TYPE(self)</span><span class="s4">-&gt;</span><span class="s1">tp_free((PyObject*)self);</span>
<span class="s1">}</span>

<span class="s0">/* 
    def changed(self, originally_changed): 
        super(VerifyingBasePy, self).changed(originally_changed) 
        self._verify_ro = self._registry.ro[1:] 
        self._verify_generations = [r._generation for r in self._verify_ro] 
*/</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">_generations_tuple(PyObject *ro)</span>
<span class="s1">{</span>
  <span class="s2">int </span><span class="s1">i, l;</span>
  <span class="s1">PyObject *generations;</span>

  <span class="s1">l = PyTuple_GET_SIZE(ro);</span>
  <span class="s1">generations = PyTuple_New(l);</span>
  <span class="s2">for </span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i &lt; l; i++)</span>
    <span class="s1">{</span>
      <span class="s1">PyObject *generation;</span>

      <span class="s1">generation = PyObject_GetAttr(PyTuple_GET_ITEM(ro, i), str_generation);</span>
      <span class="s2">if </span><span class="s1">(generation == NULL)</span>
        <span class="s1">{</span>
          <span class="s1">Py_DECREF(generations);</span>
          <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>
      <span class="s1">PyTuple_SET_ITEM(generations, i, generation);</span>
    <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">generations;</span>
<span class="s1">}</span>
<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">verifying_changed(verify *self, PyObject *ignored)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *t, *ro;</span>

  <span class="s1">verifying_clear(self);</span>

  <span class="s1">t = PyObject_GetAttr(OBJECT(self), str_registry);</span>
  <span class="s2">if </span><span class="s1">(t == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s1">ro = PyObject_GetAttr(t, strro);</span>
  <span class="s1">Py_DECREF(t);</span>
  <span class="s2">if </span><span class="s1">(ro == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">t = PyObject_CallFunctionObjArgs(OBJECT(&amp;PyTuple_Type), ro, NULL);</span>
  <span class="s1">Py_DECREF(ro);</span>
  <span class="s2">if </span><span class="s1">(t == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">ro = PyTuple_GetSlice(t, </span><span class="s5">1</span><span class="s1">, PyTuple_GET_SIZE(t));</span>
  <span class="s1">Py_DECREF(t);</span>
  <span class="s2">if </span><span class="s1">(ro == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">_verify_generations = _generations_tuple(ro);</span>
  <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">_verify_generations == NULL)</span>
    <span class="s1">{</span>
      <span class="s1">Py_DECREF(ro);</span>
      <span class="s2">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>

  <span class="s1">self</span><span class="s4">-&gt;</span><span class="s1">_verify_ro = ro;</span>

  <span class="s1">Py_INCREF(Py_None);</span>
  <span class="s2">return </span><span class="s1">Py_None;</span>
<span class="s1">}</span>

<span class="s0">/* 
    def _verify(self): 
        if ([r._generation for r in self._verify_ro] 
            != self._verify_generations): 
            self.changed(None) 
*/</span>
<span class="s2">static int</span>
<span class="s1">_verify(verify *self)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *changed_result;</span>

  <span class="s2">if </span><span class="s1">(self</span><span class="s4">-&gt;</span><span class="s1">_verify_ro != NULL &amp;&amp; self</span><span class="s4">-&gt;</span><span class="s1">_verify_generations != NULL)</span>
    <span class="s1">{</span>
      <span class="s1">PyObject *generations;</span>
      <span class="s2">int </span><span class="s1">changed;</span>

      <span class="s1">generations = _generations_tuple(self</span><span class="s4">-&gt;</span><span class="s1">_verify_ro);</span>
      <span class="s2">if </span><span class="s1">(generations == NULL)</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>

      <span class="s1">changed = PyObject_RichCompareBool(self</span><span class="s4">-&gt;</span><span class="s1">_verify_generations,</span>
                                         <span class="s1">generations, Py_NE);</span>
      <span class="s1">Py_DECREF(generations);</span>
      <span class="s2">if </span><span class="s1">(changed == -</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(changed == </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">}</span>

  <span class="s1">changed_result = PyObject_CallMethodObjArgs(OBJECT(self), strchanged,</span>
                                              <span class="s1">Py_None, NULL);</span>
  <span class="s2">if </span><span class="s1">(changed_result == NULL)</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>

  <span class="s1">Py_DECREF(changed_result);</span>
  <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">verifying_lookup(verify *self, PyObject *args, PyObject *kwds)</span>
<span class="s1">{</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;required&quot;</span><span class="s1">, </span><span class="s3">&quot;provided&quot;</span><span class="s1">, </span><span class="s3">&quot;name&quot;</span><span class="s1">, </span><span class="s3">&quot;default&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">PyObject *required, *provided, *name=NULL, *default_=NULL;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTupleAndKeywords(args, kwds, </span><span class="s3">&quot;OO|OO&quot;</span><span class="s1">, kwlist,</span>
                                    <span class="s1">&amp;required, &amp;provided, &amp;name, &amp;default_))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(_verify(self) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">_lookup((lookup *)self, required, provided, name, default_);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">verifying_lookup1(verify *self, PyObject *args, PyObject *kwds)</span>
<span class="s1">{</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;required&quot;</span><span class="s1">, </span><span class="s3">&quot;provided&quot;</span><span class="s1">, </span><span class="s3">&quot;name&quot;</span><span class="s1">, </span><span class="s3">&quot;default&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">PyObject *required, *provided, *name=NULL, *default_=NULL;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTupleAndKeywords(args, kwds, </span><span class="s3">&quot;OO|OO&quot;</span><span class="s1">, kwlist,</span>
                                    <span class="s1">&amp;required, &amp;provided, &amp;name, &amp;default_))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(_verify(self) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">_lookup1((lookup *)self, required, provided, name, default_);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">verifying_adapter_hook(verify *self, PyObject *args, PyObject *kwds)</span>
<span class="s1">{</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;provided&quot;</span><span class="s1">, </span><span class="s3">&quot;object&quot;</span><span class="s1">, </span><span class="s3">&quot;name&quot;</span><span class="s1">, </span><span class="s3">&quot;default&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">PyObject *object, *provided, *name=NULL, *default_=NULL;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTupleAndKeywords(args, kwds, </span><span class="s3">&quot;OO|OO&quot;</span><span class="s1">, kwlist,</span>
                                    <span class="s1">&amp;provided, &amp;object, &amp;name, &amp;default_))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(_verify(self) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">_adapter_hook((lookup *)self, provided, object, name, default_);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">verifying_queryAdapter(verify *self, PyObject *args, PyObject *kwds)</span>
<span class="s1">{</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;object&quot;</span><span class="s1">, </span><span class="s3">&quot;provided&quot;</span><span class="s1">, </span><span class="s3">&quot;name&quot;</span><span class="s1">, </span><span class="s3">&quot;default&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">PyObject *object, *provided, *name=NULL, *default_=NULL;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTupleAndKeywords(args, kwds, </span><span class="s3">&quot;OO|OO&quot;</span><span class="s1">, kwlist,</span>
                                    <span class="s1">&amp;object, &amp;provided, &amp;name, &amp;default_))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(_verify(self) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">_adapter_hook((lookup *)self, provided, object, name, default_);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">verifying_lookupAll(verify *self, PyObject *args, PyObject *kwds)</span>
<span class="s1">{</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;required&quot;</span><span class="s1">, </span><span class="s3">&quot;provided&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">PyObject *required, *provided;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTupleAndKeywords(args, kwds, </span><span class="s3">&quot;OO&quot;</span><span class="s1">, kwlist,</span>
                                    <span class="s1">&amp;required, &amp;provided))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(_verify(self) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">_lookupAll((lookup *)self, required, provided);</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">verifying_subscriptions(verify *self, PyObject *args, PyObject *kwds)</span>
<span class="s1">{</span>
  <span class="s2">static char </span><span class="s1">*kwlist[] = {</span><span class="s3">&quot;required&quot;</span><span class="s1">, </span><span class="s3">&quot;provided&quot;</span><span class="s1">, NULL};</span>
  <span class="s1">PyObject *required, *provided;</span>

  <span class="s2">if </span><span class="s1">(! PyArg_ParseTupleAndKeywords(args, kwds, </span><span class="s3">&quot;OO&quot;</span><span class="s1">, kwlist,</span>
                                    <span class="s1">&amp;required, &amp;provided))</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">if </span><span class="s1">(_verify(self) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">return </span><span class="s1">_subscriptions((lookup *)self, required, provided);</span>
<span class="s1">}</span>

<span class="s2">static struct </span><span class="s1">PyMethodDef verifying_methods[] = {</span>
  <span class="s1">{</span><span class="s3">&quot;changed&quot;</span><span class="s1">,      (PyCFunction)verifying_changed,        METH_O,        </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;lookup&quot;</span><span class="s1">,       (PyCFunction)verifying_lookup,         METH_KEYWORDS | METH_VARARGS, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;lookup1&quot;</span><span class="s1">,      (PyCFunction)verifying_lookup1,        METH_KEYWORDS | METH_VARARGS, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;queryAdapter&quot;</span><span class="s1">,  (PyCFunction)verifying_queryAdapter,  METH_KEYWORDS | METH_VARARGS, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;adapter_hook&quot;</span><span class="s1">,  (PyCFunction)verifying_adapter_hook,  METH_KEYWORDS | METH_VARARGS, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;lookupAll&quot;</span><span class="s1">,    (PyCFunction)verifying_lookupAll,      METH_KEYWORDS | METH_VARARGS, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;subscriptions&quot;</span><span class="s1">, (PyCFunction)verifying_subscriptions, METH_KEYWORDS | METH_VARARGS, </span><span class="s3">&quot;&quot;</span><span class="s1">},</span>
  <span class="s1">{NULL,            NULL}               </span><span class="s0">/* sentinel */</span>
<span class="s1">};</span>

<span class="s2">static </span><span class="s1">PyTypeObject VerifyingBase = {</span>
        <span class="s1">PyVarObject_HEAD_INIT(NULL, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">/* tp_name           */ </span><span class="s3">&quot;_zope_interface_coptimizations.&quot;</span>
                                <span class="s3">&quot;VerifyingBase&quot;</span><span class="s1">,</span>
        <span class="s0">/* tp_basicsize      */ </span><span class="s2">sizeof</span><span class="s1">(verify),</span>
        <span class="s0">/* tp_itemsize       */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_dealloc        */ </span><span class="s1">(destructor)&amp;verifying_dealloc,</span>
        <span class="s0">/* tp_print          */ </span><span class="s1">(printfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getattr        */ </span><span class="s1">(getattrfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_setattr        */ </span><span class="s1">(setattrfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_compare        */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_repr           */ </span><span class="s1">(reprfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_number      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_sequence    */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_mapping     */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_hash           */ </span><span class="s1">(hashfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_call           */ </span><span class="s1">(ternaryfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_str            */ </span><span class="s1">(reprfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getattro       */ </span><span class="s1">(getattrofunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_setattro       */ </span><span class="s1">(setattrofunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_as_buffer      */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_flags          */ </span><span class="s1">Py_TPFLAGS_DEFAULT</span>
                                <span class="s1">| Py_TPFLAGS_BASETYPE</span>
                                <span class="s1">| Py_TPFLAGS_HAVE_GC,</span>
        <span class="s0">/* tp_doc            */ </span><span class="s3">&quot;&quot;</span><span class="s1">,</span>
        <span class="s0">/* tp_traverse       */ </span><span class="s1">(traverseproc)verifying_traverse,</span>
        <span class="s0">/* tp_clear          */ </span><span class="s1">(inquiry)verifying_clear,</span>
        <span class="s0">/* tp_richcompare    */ </span><span class="s1">(richcmpfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_weaklistoffset */ </span><span class="s1">(</span><span class="s2">long</span><span class="s1">)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_iter           */ </span><span class="s1">(getiterfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_iternext       */ </span><span class="s1">(iternextfunc)</span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_methods        */ </span><span class="s1">verifying_methods,</span>
        <span class="s0">/* tp_members        */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_getset         */ </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s0">/* tp_base           */ </span><span class="s1">&amp;LookupBase,</span>
<span class="s1">};</span>

<span class="s0">/* ========================== End: Lookup Bases ======================= */</span>
<span class="s0">/* ==================================================================== */</span>



<span class="s2">static struct </span><span class="s1">PyMethodDef m_methods[] = {</span>
  <span class="s1">{</span><span class="s3">&quot;implementedBy&quot;</span><span class="s1">, (PyCFunction)implementedBy, METH_O,</span>
   <span class="s3">&quot;Interfaces implemented by a class or factory.</span><span class="s6">\n</span><span class="s3">&quot;</span>
   <span class="s3">&quot;Raises TypeError if argument is neither a class nor a callable.&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;getObjectSpecification&quot;</span><span class="s1">, (PyCFunction)getObjectSpecification, METH_O,</span>
   <span class="s3">&quot;Get an object's interfaces (internal api)&quot;</span><span class="s1">},</span>
  <span class="s1">{</span><span class="s3">&quot;providedBy&quot;</span><span class="s1">, (PyCFunction)providedBy, METH_O,</span>
   <span class="s3">&quot;Get an object's interfaces&quot;</span><span class="s1">},</span>

  <span class="s1">{NULL,         (PyCFunction)NULL, </span><span class="s5">0</span><span class="s1">, NULL}            </span><span class="s0">/* sentinel */</span>
<span class="s1">};</span>

<span class="s2">#if  </span><span class="s1">PY_MAJOR_VERSION &gt;= </span><span class="s5">3</span>
<span class="s2">static char </span><span class="s1">module_doc[] = </span><span class="s3">&quot;C optimizations for zope.interface</span><span class="s6">\n\n</span><span class="s3">&quot;</span><span class="s1">;</span>

<span class="s2">static struct </span><span class="s1">PyModuleDef _zic_module = {</span>
        <span class="s1">PyModuleDef_HEAD_INIT,</span>
        <span class="s3">&quot;_zope_interface_coptimizations&quot;</span><span class="s1">,</span>
        <span class="s1">module_doc,</span>
        <span class="s1">-</span><span class="s5">1</span><span class="s1">,</span>
        <span class="s1">m_methods,</span>
        <span class="s1">NULL,</span>
        <span class="s1">NULL,</span>
        <span class="s1">NULL,</span>
        <span class="s1">NULL</span>
<span class="s1">};</span>
<span class="s2">#endif</span>

<span class="s2">static </span><span class="s1">PyObject *</span>
<span class="s1">init(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
  <span class="s1">PyObject *m;</span>

<span class="s2">#if  </span><span class="s1">PY_MAJOR_VERSION &lt; </span><span class="s5">3</span>
<span class="s2">#define </span><span class="s1">DEFINE_STRING(S) \</span>
  <span class="s2">if</span><span class="s1">(! (str ## S = PyString_FromString(# S))) </span><span class="s2">return </span><span class="s1">NULL</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">DEFINE_STRING(S) \</span>
  <span class="s2">if</span><span class="s1">(! (str ## S = PyUnicode_FromString(# S))) </span><span class="s2">return </span><span class="s1">NULL</span>
<span class="s2">#endif</span>

  <span class="s1">DEFINE_STRING(__dict__);</span>
  <span class="s1">DEFINE_STRING(__implemented__);</span>
  <span class="s1">DEFINE_STRING(__provides__);</span>
  <span class="s1">DEFINE_STRING(__class__);</span>
  <span class="s1">DEFINE_STRING(__providedBy__);</span>
  <span class="s1">DEFINE_STRING(extends);</span>
  <span class="s1">DEFINE_STRING(__conform__);</span>
  <span class="s1">DEFINE_STRING(_call_conform);</span>
  <span class="s1">DEFINE_STRING(_uncached_lookup);</span>
  <span class="s1">DEFINE_STRING(_uncached_lookupAll);</span>
  <span class="s1">DEFINE_STRING(_uncached_subscriptions);</span>
  <span class="s1">DEFINE_STRING(_registry);</span>
  <span class="s1">DEFINE_STRING(_generation);</span>
  <span class="s1">DEFINE_STRING(ro);</span>
  <span class="s1">DEFINE_STRING(changed);</span>
  <span class="s1">DEFINE_STRING(__self__);</span>
  <span class="s1">DEFINE_STRING(__name__);</span>
  <span class="s1">DEFINE_STRING(__module__);</span>
  <span class="s1">DEFINE_STRING(__adapt__);</span>
  <span class="s1">DEFINE_STRING(_CALL_CUSTOM_ADAPT);</span>
<span class="s2">#undef </span><span class="s1">DEFINE_STRING</span>
  <span class="s1">adapter_hooks = PyList_New(</span><span class="s5">0</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(adapter_hooks == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s0">/* Initialize types: */</span>
  <span class="s1">SpecificationBaseType.tp_new = PyBaseObject_Type.tp_new;</span>
  <span class="s2">if </span><span class="s1">(PyType_Ready(&amp;SpecificationBaseType) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s1">OSDType.tp_new = PyBaseObject_Type.tp_new;</span>
  <span class="s2">if </span><span class="s1">(PyType_Ready(&amp;OSDType) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s1">CPBType.tp_new = PyBaseObject_Type.tp_new;</span>
  <span class="s2">if </span><span class="s1">(PyType_Ready(&amp;CPBType) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">InterfaceBaseType.tp_new = PyBaseObject_Type.tp_new;</span>
  <span class="s2">if </span><span class="s1">(PyType_Ready(&amp;InterfaceBaseType) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">LookupBase.tp_new = PyBaseObject_Type.tp_new;</span>
  <span class="s2">if </span><span class="s1">(PyType_Ready(&amp;LookupBase) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s1">VerifyingBase.tp_new = PyBaseObject_Type.tp_new;</span>
  <span class="s2">if </span><span class="s1">(PyType_Ready(&amp;VerifyingBase) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s2">#if </span><span class="s1">PY_MAJOR_VERSION &lt; </span><span class="s5">3</span>
  <span class="s0">/* Create the module and add the functions */</span>
  <span class="s1">m = Py_InitModule3(</span><span class="s3">&quot;_zope_interface_coptimizations&quot;</span><span class="s1">, m_methods,</span>
                     <span class="s3">&quot;C optimizations for zope.interface</span><span class="s6">\n\n</span><span class="s3">&quot;</span><span class="s1">);</span>
  <span class="s2">#else</span>
  <span class="s1">m = PyModule_Create(&amp;_zic_module);</span>
  <span class="s2">#endif</span>
  <span class="s2">if </span><span class="s1">(m == NULL)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>

  <span class="s0">/* Add types: */</span>
  <span class="s2">if </span><span class="s1">(PyModule_AddObject(m, </span><span class="s3">&quot;SpecificationBase&quot;</span><span class="s1">, OBJECT(&amp;SpecificationBaseType)) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s2">if </span><span class="s1">(PyModule_AddObject(m, </span><span class="s3">&quot;ObjectSpecificationDescriptor&quot;</span><span class="s1">,</span>
                         <span class="s1">(PyObject *)&amp;OSDType) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s2">if </span><span class="s1">(PyModule_AddObject(m, </span><span class="s3">&quot;ClassProvidesBase&quot;</span><span class="s1">, OBJECT(&amp;CPBType)) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s2">if </span><span class="s1">(PyModule_AddObject(m, </span><span class="s3">&quot;InterfaceBase&quot;</span><span class="s1">, OBJECT(&amp;InterfaceBaseType)) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s2">if </span><span class="s1">(PyModule_AddObject(m, </span><span class="s3">&quot;LookupBase&quot;</span><span class="s1">, OBJECT(&amp;LookupBase)) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s2">if </span><span class="s1">(PyModule_AddObject(m, </span><span class="s3">&quot;VerifyingBase&quot;</span><span class="s1">, OBJECT(&amp;VerifyingBase)) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s2">if </span><span class="s1">(PyModule_AddObject(m, </span><span class="s3">&quot;adapter_hooks&quot;</span><span class="s1">, adapter_hooks) &lt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">NULL;</span>
  <span class="s2">return </span><span class="s1">m;</span>
<span class="s1">}</span>

<span class="s1">PyMODINIT_FUNC</span>
<span class="s2">#if </span><span class="s1">PY_MAJOR_VERSION &lt; </span><span class="s5">3</span>
<span class="s1">init_zope_interface_coptimizations(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
  <span class="s1">init();</span>
<span class="s1">}</span>
<span class="s2">#else</span>
<span class="s1">PyInit__zope_interface_coptimizations(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
  <span class="s2">return </span><span class="s1">init();</span>
<span class="s1">}</span>
<span class="s2">#endif</span>

<span class="s2">#ifdef </span><span class="s1">__clang__</span>
<span class="s1">#pragma clang diagnostic pop</span>
<span class="s2">#endif</span>
</pre>
</body>
</html>