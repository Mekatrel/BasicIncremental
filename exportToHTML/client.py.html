<html>
<head>
<title>client.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
client.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># XML-RPC CLIENT LIBRARY</span>
<span class="s0"># $Id$</span>
<span class="s0">#</span>
<span class="s0"># an XML-RPC client interface for Python.</span>
<span class="s0">#</span>
<span class="s0"># the marshalling and response parser code can also be used to</span>
<span class="s0"># implement XML-RPC servers.</span>
<span class="s0">#</span>
<span class="s0"># Notes:</span>
<span class="s0"># this version is designed to work with Python 2.1 or newer.</span>
<span class="s0">#</span>
<span class="s0"># History:</span>
<span class="s0"># 1999-01-14 fl  Created</span>
<span class="s0"># 1999-01-15 fl  Changed dateTime to use localtime</span>
<span class="s0"># 1999-01-16 fl  Added Binary/base64 element, default to RPC2 service</span>
<span class="s0"># 1999-01-19 fl  Fixed array data element (from Skip Montanaro)</span>
<span class="s0"># 1999-01-21 fl  Fixed dateTime constructor, etc.</span>
<span class="s0"># 1999-02-02 fl  Added fault handling, handle empty sequences, etc.</span>
<span class="s0"># 1999-02-10 fl  Fixed problem with empty responses (from Skip Montanaro)</span>
<span class="s0"># 1999-06-20 fl  Speed improvements, pluggable parsers/transports (0.9.8)</span>
<span class="s0"># 2000-11-28 fl  Changed boolean to check the truth value of its argument</span>
<span class="s0"># 2001-02-24 fl  Added encoding/Unicode/SafeTransport patches</span>
<span class="s0"># 2001-02-26 fl  Added compare support to wrappers (0.9.9/1.0b1)</span>
<span class="s0"># 2001-03-28 fl  Make sure response tuple is a singleton</span>
<span class="s0"># 2001-03-29 fl  Don't require empty params element (from Nicholas Riley)</span>
<span class="s0"># 2001-06-10 fl  Folded in _xmlrpclib accelerator support (1.0b2)</span>
<span class="s0"># 2001-08-20 fl  Base xmlrpclib.Error on built-in Exception (from Paul Prescod)</span>
<span class="s0"># 2001-09-03 fl  Allow Transport subclass to override getparser</span>
<span class="s0"># 2001-09-10 fl  Lazy import of urllib, cgi, xmllib (20x import speedup)</span>
<span class="s0"># 2001-10-01 fl  Remove containers from memo cache when done with them</span>
<span class="s0"># 2001-10-01 fl  Use faster escape method (80% dumps speedup)</span>
<span class="s0"># 2001-10-02 fl  More dumps microtuning</span>
<span class="s0"># 2001-10-04 fl  Make sure import expat gets a parser (from Guido van Rossum)</span>
<span class="s0"># 2001-10-10 sm  Allow long ints to be passed as ints if they don't overflow</span>
<span class="s0"># 2001-10-17 sm  Test for int and long overflow (allows use on 64-bit systems)</span>
<span class="s0"># 2001-11-12 fl  Use repr() to marshal doubles (from Paul Felix)</span>
<span class="s0"># 2002-03-17 fl  Avoid buffered read when possible (from James Rucker)</span>
<span class="s0"># 2002-04-07 fl  Added pythondoc comments</span>
<span class="s0"># 2002-04-16 fl  Added __str__ methods to datetime/binary wrappers</span>
<span class="s0"># 2002-05-15 fl  Added error constants (from Andrew Kuchling)</span>
<span class="s0"># 2002-06-27 fl  Merged with Python CVS version</span>
<span class="s0"># 2002-10-22 fl  Added basic authentication (based on code from Phillip Eby)</span>
<span class="s0"># 2003-01-22 sm  Add support for the bool type</span>
<span class="s0"># 2003-02-27 gvr Remove apply calls</span>
<span class="s0"># 2003-04-24 sm  Use cStringIO if available</span>
<span class="s0"># 2003-04-25 ak  Add support for nil</span>
<span class="s0"># 2003-06-15 gn  Add support for time.struct_time</span>
<span class="s0"># 2003-07-12 gp  Correct marshalling of Faults</span>
<span class="s0"># 2003-10-31 mvl Add multicall support</span>
<span class="s0"># 2004-08-20 mvl Bump minimum supported Python version to 2.1</span>
<span class="s0">#</span>
<span class="s0"># Copyright (c) 1999-2002 by Secret Labs AB.</span>
<span class="s0"># Copyright (c) 1999-2002 by Fredrik Lundh.</span>
<span class="s0">#</span>
<span class="s0"># info@pythonware.com</span>
<span class="s0"># http://www.pythonware.com</span>
<span class="s0">#</span>
<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># The XML-RPC client interface is</span>
<span class="s0">#</span>
<span class="s0"># Copyright (c) 1999-2002 by Secret Labs AB</span>
<span class="s0"># Copyright (c) 1999-2002 by Fredrik Lundh</span>
<span class="s0">#</span>
<span class="s0"># By obtaining, using, and/or copying this software and/or its</span>
<span class="s0"># associated documentation, you agree that you have read, understood,</span>
<span class="s0"># and will comply with the following terms and conditions:</span>
<span class="s0">#</span>
<span class="s0"># Permission to use, copy, modify, and distribute this software and</span>
<span class="s0"># its associated documentation for any purpose and without fee is</span>
<span class="s0"># hereby granted, provided that the above copyright notice appears in</span>
<span class="s0"># all copies, and that both that copyright notice and this permission</span>
<span class="s0"># notice appear in supporting documentation, and that the name of</span>
<span class="s0"># Secret Labs AB or the author not be used in advertising or publicity</span>
<span class="s0"># pertaining to distribution of the software without specific, written</span>
<span class="s0"># prior permission.</span>
<span class="s0">#</span>
<span class="s0"># SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD</span>
<span class="s0"># TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-</span>
<span class="s0"># ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR</span>
<span class="s0"># BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY</span>
<span class="s0"># DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</span>
<span class="s0"># WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS</span>
<span class="s0"># ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE</span>
<span class="s0"># OF THIS SOFTWARE.</span>
<span class="s0"># --------------------------------------------------------------------</span>

<span class="s2">&quot;&quot;&quot; 
Ported using Python-Future from the Python 3.3 standard library. 
 
An XML-RPC client interface for Python. 
 
The marshalling and response parser code can also be used to 
implement XML-RPC servers. 
 
Exported exceptions: 
 
  Error          Base class for client errors 
  ProtocolError  Indicates an HTTP protocol error 
  ResponseError  Indicates a broken response package 
  Fault          Indicates an XML-RPC fault package 
 
Exported classes: 
 
  ServerProxy    Represents a logical connection to an XML-RPC server 
 
  MultiCall      Executor of boxcared xmlrpc requests 
  DateTime       dateTime wrapper for an ISO 8601 string or time tuple or 
                 localtime integer value to generate a &quot;dateTime.iso8601&quot; 
                 XML-RPC value 
  Binary         binary data wrapper 
 
  Marshaller     Generate an XML-RPC params chunk from a Python data structure 
  Unmarshaller   Unmarshal an XML-RPC response from incoming XML event message 
  Transport      Handles an HTTP transaction to an XML-RPC server 
  SafeTransport  Handles an HTTPS transaction to an XML-RPC server 
 
Exported constants: 
 
  (none) 
 
Exported functions: 
 
  getparser      Create instance of the fastest available parser &amp; attach 
                 to an unmarshalling object 
  dumps          Convert an argument tuple or a Fault instance to an XML-RPC 
                 request (or response, if the methodresponse option is used). 
  loads          Convert an XML-RPC packet to unmarshalled data plus a method 
                 name (None if not present). 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">(absolute_import</span><span class="s3">, </span><span class="s1">division</span><span class="s3">, </span><span class="s1">print_function</span><span class="s3">,</span>
                        <span class="s1">unicode_literals)</span>
<span class="s3">from </span><span class="s1">future.builtins </span><span class="s3">import </span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">range</span><span class="s3">, </span><span class="s1">str</span>

<span class="s3">import </span><span class="s1">base64</span>
<span class="s0"># Py2.7 compatibility hack</span>
<span class="s1">base64.encodebytes = base64.encodestring</span>
<span class="s1">base64.decodebytes = base64.decodestring</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">from </span><span class="s1">datetime </span><span class="s3">import </span><span class="s1">datetime</span>
<span class="s3">from </span><span class="s1">future.backports.http </span><span class="s3">import </span><span class="s1">client </span><span class="s3">as </span><span class="s1">http_client</span>
<span class="s3">from </span><span class="s1">future.backports.urllib </span><span class="s3">import </span><span class="s1">parse </span><span class="s3">as </span><span class="s1">urllib_parse</span>
<span class="s3">from </span><span class="s1">future.utils </span><span class="s3">import </span><span class="s1">ensure_new_type</span>
<span class="s3">from </span><span class="s1">xml.parsers </span><span class="s3">import </span><span class="s1">expat</span>
<span class="s3">import </span><span class="s1">socket</span>
<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">from </span><span class="s1">io </span><span class="s3">import </span><span class="s1">BytesIO</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">import </span><span class="s1">gzip</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s1">gzip = </span><span class="s3">None </span><span class="s0">#python can be built without zlib/gzip support</span>

<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Internal stuff</span>

<span class="s3">def </span><span class="s1">escape(s):</span>
    <span class="s1">s = s.replace(</span><span class="s4">&quot;&amp;&quot;</span><span class="s3">, </span><span class="s4">&quot;&amp;amp;&quot;</span><span class="s1">)</span>
    <span class="s1">s = s.replace(</span><span class="s4">&quot;&lt;&quot;</span><span class="s3">, </span><span class="s4">&quot;&amp;lt;&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">s.replace(</span><span class="s4">&quot;&gt;&quot;</span><span class="s3">, </span><span class="s4">&quot;&amp;gt;&quot;</span><span class="s3">,</span><span class="s1">)</span>

<span class="s0"># used in User-Agent header sent</span>
<span class="s1">__version__ = sys.version[:</span><span class="s5">3</span><span class="s1">]</span>

<span class="s0"># xmlrpc integer limits</span>
<span class="s1">MAXINT =  </span><span class="s5">2</span><span class="s1">**</span><span class="s5">31</span><span class="s1">-</span><span class="s5">1</span>
<span class="s1">MININT = -</span><span class="s5">2</span><span class="s1">**</span><span class="s5">31</span>

<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Error constants (from Dan Libby's specification at</span>
<span class="s0"># http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php)</span>

<span class="s0"># Ranges of errors</span>
<span class="s1">PARSE_ERROR       = -</span><span class="s5">32700</span>
<span class="s1">SERVER_ERROR      = -</span><span class="s5">32600</span>
<span class="s1">APPLICATION_ERROR = -</span><span class="s5">32500</span>
<span class="s1">SYSTEM_ERROR      = -</span><span class="s5">32400</span>
<span class="s1">TRANSPORT_ERROR   = -</span><span class="s5">32300</span>

<span class="s0"># Specific errors</span>
<span class="s1">NOT_WELLFORMED_ERROR  = -</span><span class="s5">32700</span>
<span class="s1">UNSUPPORTED_ENCODING  = -</span><span class="s5">32701</span>
<span class="s1">INVALID_ENCODING_CHAR = -</span><span class="s5">32702</span>
<span class="s1">INVALID_XMLRPC        = -</span><span class="s5">32600</span>
<span class="s1">METHOD_NOT_FOUND      = -</span><span class="s5">32601</span>
<span class="s1">INVALID_METHOD_PARAMS = -</span><span class="s5">32602</span>
<span class="s1">INTERNAL_ERROR        = -</span><span class="s5">32603</span>

<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Exceptions</span>

<span class="s0">##</span>
<span class="s0"># Base class for all kinds of client-side errors.</span>

<span class="s3">class </span><span class="s1">Error(Exception):</span>
    <span class="s2">&quot;&quot;&quot;Base class for client errors.&quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s1">repr(self)</span>

<span class="s0">##</span>
<span class="s0"># Indicates an HTTP-level protocol error.  This is raised by the HTTP</span>
<span class="s0"># transport layer, if the server returns an error code other than 200</span>
<span class="s0"># (OK).</span>
<span class="s0">#</span>
<span class="s0"># @param url The target URL.</span>
<span class="s0"># @param errcode The HTTP error code.</span>
<span class="s0"># @param errmsg The HTTP error message.</span>
<span class="s0"># @param headers The HTTP header dictionary.</span>

<span class="s3">class </span><span class="s1">ProtocolError(Error):</span>
    <span class="s2">&quot;&quot;&quot;Indicates an HTTP protocol error.&quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">, </span><span class="s1">errmsg</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s1">Error.__init__(self)</span>
        <span class="s1">self.url = url</span>
        <span class="s1">self.errcode = errcode</span>
        <span class="s1">self.errmsg = errmsg</span>
        <span class="s1">self.headers = headers</span>
    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;ProtocolError for %s: %s %s&gt;&quot; </span><span class="s1">%</span>
            <span class="s1">(self.url</span><span class="s3">, </span><span class="s1">self.errcode</span><span class="s3">, </span><span class="s1">self.errmsg)</span>
            <span class="s1">)</span>

<span class="s0">##</span>
<span class="s0"># Indicates a broken XML-RPC response package.  This exception is</span>
<span class="s0"># raised by the unmarshalling layer, if the XML-RPC response is</span>
<span class="s0"># malformed.</span>

<span class="s3">class </span><span class="s1">ResponseError(Error):</span>
    <span class="s2">&quot;&quot;&quot;Indicates a broken response package.&quot;&quot;&quot;</span>
    <span class="s3">pass</span>

<span class="s0">##</span>
<span class="s0"># Indicates an XML-RPC fault response package.  This exception is</span>
<span class="s0"># raised by the unmarshalling layer, if the XML-RPC response contains</span>
<span class="s0"># a fault string.  This exception can also be used as a class, to</span>
<span class="s0"># generate a fault XML-RPC message.</span>
<span class="s0">#</span>
<span class="s0"># @param faultCode The XML-RPC fault code.</span>
<span class="s0"># @param faultString The XML-RPC fault string.</span>

<span class="s3">class </span><span class="s1">Fault(Error):</span>
    <span class="s2">&quot;&quot;&quot;Indicates an XML-RPC fault package.&quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">faultCode</span><span class="s3">, </span><span class="s1">faultString</span><span class="s3">, </span><span class="s1">**extra):</span>
        <span class="s1">Error.__init__(self)</span>
        <span class="s1">self.faultCode = faultCode</span>
        <span class="s1">self.faultString = faultString</span>
    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">&quot;&lt;Fault %s: %r&gt;&quot; </span><span class="s1">% (ensure_new_type(self.faultCode)</span><span class="s3">,</span>
                                   <span class="s1">ensure_new_type(self.faultString))</span>

<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># Special values</span>

<span class="s0">##</span>
<span class="s0"># Backwards compatibility</span>

<span class="s1">boolean = Boolean = bool</span>

<span class="s0">##</span>
<span class="s0"># Wrapper for XML-RPC DateTime values.  This converts a time value to</span>
<span class="s0"># the format used by XML-RPC.</span>
<span class="s0"># &lt;p&gt;</span>
<span class="s0"># The value can be given as a datetime object, as a string in the</span>
<span class="s0"># format &quot;yyyymmddThh:mm:ss&quot;, as a 9-item time tuple (as returned by</span>
<span class="s0"># time.localtime()), or an integer value (as returned by time.time()).</span>
<span class="s0"># The wrapper uses time.localtime() to convert an integer to a time</span>
<span class="s0"># tuple.</span>
<span class="s0">#</span>
<span class="s0"># @param value The time, given as a datetime object, an ISO 8601 string,</span>
<span class="s0">#              a time tuple, or an integer time value.</span>


<span class="s0">### For Python-Future:</span>
<span class="s3">def </span><span class="s1">_iso8601_format(value):</span>
    <span class="s3">return </span><span class="s4">&quot;%04d%02d%02dT%02d:%02d:%02d&quot; </span><span class="s1">% (</span>
                <span class="s1">value.year</span><span class="s3">, </span><span class="s1">value.month</span><span class="s3">, </span><span class="s1">value.day</span><span class="s3">,</span>
                <span class="s1">value.hour</span><span class="s3">, </span><span class="s1">value.minute</span><span class="s3">, </span><span class="s1">value.second)</span>
<span class="s0">###</span>
<span class="s0"># Issue #13305: different format codes across platforms</span>
<span class="s0"># _day0 = datetime(1, 1, 1)</span>
<span class="s0"># if _day0.strftime('%Y') == '0001':      # Mac OS X</span>
<span class="s0">#     def _iso8601_format(value):</span>
<span class="s0">#         return value.strftime(&quot;%Y%m%dT%H:%M:%S&quot;)</span>
<span class="s0"># elif _day0.strftime('%4Y') == '0001':   # Linux</span>
<span class="s0">#     def _iso8601_format(value):</span>
<span class="s0">#         return value.strftime(&quot;%4Y%m%dT%H:%M:%S&quot;)</span>
<span class="s0"># else:</span>
<span class="s0">#     def _iso8601_format(value):</span>
<span class="s0">#         return value.strftime(&quot;%Y%m%dT%H:%M:%S&quot;).zfill(17)</span>
<span class="s0"># del _day0</span>


<span class="s3">def </span><span class="s1">_strftime(value):</span>
    <span class="s3">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">datetime):</span>
        <span class="s3">return </span><span class="s1">_iso8601_format(value)</span>

    <span class="s3">if not </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">time.struct_time)):</span>
        <span class="s3">if </span><span class="s1">value == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">value = time.time()</span>
        <span class="s1">value = time.localtime(value)</span>

    <span class="s3">return </span><span class="s4">&quot;%04d%02d%02dT%02d:%02d:%02d&quot; </span><span class="s1">% value[:</span><span class="s5">6</span><span class="s1">]</span>

<span class="s3">class </span><span class="s1">DateTime(object):</span>
    <span class="s2">&quot;&quot;&quot;DateTime wrapper for an ISO 8601 string or time tuple or 
    localtime integer value to generate 'dateTime.iso8601' XML-RPC 
    value. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">value=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">self.value = value</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.value = _strftime(value)</span>

    <span class="s3">def </span><span class="s1">make_comparable(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">DateTime):</span>
            <span class="s1">s = self.value</span>
            <span class="s1">o = other.value</span>
        <span class="s3">elif </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">datetime):</span>
            <span class="s1">s = self.value</span>
            <span class="s1">o = _iso8601_format(other)</span>
        <span class="s3">elif </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">s = self.value</span>
            <span class="s1">o = other</span>
        <span class="s3">elif </span><span class="s1">hasattr(other</span><span class="s3">, </span><span class="s4">&quot;timetuple&quot;</span><span class="s1">):</span>
            <span class="s1">s = self.timetuple()</span>
            <span class="s1">o = other.timetuple()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">otype = (hasattr(other</span><span class="s3">, </span><span class="s4">&quot;__class__&quot;</span><span class="s1">)</span>
                     <span class="s3">and </span><span class="s1">other.__class__.__name__</span>
                     <span class="s3">or </span><span class="s1">type(other))</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Can't compare %s and %s&quot; </span><span class="s1">%</span>
                            <span class="s1">(self.__class__.__name__</span><span class="s3">, </span><span class="s1">otype))</span>
        <span class="s3">return </span><span class="s1">s</span><span class="s3">, </span><span class="s1">o</span>

    <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">s</span><span class="s3">, </span><span class="s1">o = self.make_comparable(other)</span>
        <span class="s3">return </span><span class="s1">s &lt; o</span>

    <span class="s3">def </span><span class="s1">__le__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">s</span><span class="s3">, </span><span class="s1">o = self.make_comparable(other)</span>
        <span class="s3">return </span><span class="s1">s &lt;= o</span>

    <span class="s3">def </span><span class="s1">__gt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">s</span><span class="s3">, </span><span class="s1">o = self.make_comparable(other)</span>
        <span class="s3">return </span><span class="s1">s &gt; o</span>

    <span class="s3">def </span><span class="s1">__ge__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">s</span><span class="s3">, </span><span class="s1">o = self.make_comparable(other)</span>
        <span class="s3">return </span><span class="s1">s &gt;= o</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">s</span><span class="s3">, </span><span class="s1">o = self.make_comparable(other)</span>
        <span class="s3">return </span><span class="s1">s == o</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">s</span><span class="s3">, </span><span class="s1">o = self.make_comparable(other)</span>
        <span class="s3">return </span><span class="s1">s != o</span>

    <span class="s3">def </span><span class="s1">timetuple(self):</span>
        <span class="s3">return </span><span class="s1">time.strptime(self.value</span><span class="s3">, </span><span class="s4">&quot;%Y%m%dT%H:%M:%S&quot;</span><span class="s1">)</span>

    <span class="s0">##</span>
    <span class="s0"># Get date/time value.</span>
    <span class="s0">#</span>
    <span class="s0"># @return Date/time value, as an ISO 8601 string.</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s1">self.value</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">&quot;&lt;DateTime %r at %x&gt;&quot; </span><span class="s1">% (ensure_new_type(self.value)</span><span class="s3">, </span><span class="s1">id(self))</span>

    <span class="s3">def </span><span class="s1">decode(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">self.value = str(data).strip()</span>

    <span class="s3">def </span><span class="s1">encode(self</span><span class="s3">, </span><span class="s1">out):</span>
        <span class="s1">out.write(</span><span class="s4">&quot;&lt;value&gt;&lt;dateTime.iso8601&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">out.write(self.value)</span>
        <span class="s1">out.write(</span><span class="s4">&quot;&lt;/dateTime.iso8601&gt;&lt;/value&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_datetime(data):</span>
    <span class="s0"># decode xml element contents into a DateTime structure.</span>
    <span class="s1">value = DateTime()</span>
    <span class="s1">value.decode(data)</span>
    <span class="s3">return </span><span class="s1">value</span>

<span class="s3">def </span><span class="s1">_datetime_type(data):</span>
    <span class="s3">return </span><span class="s1">datetime.strptime(data</span><span class="s3">, </span><span class="s4">&quot;%Y%m%dT%H:%M:%S&quot;</span><span class="s1">)</span>

<span class="s0">##</span>
<span class="s0"># Wrapper for binary data.  This can be used to transport any kind</span>
<span class="s0"># of binary data over XML-RPC, using BASE64 encoding.</span>
<span class="s0">#</span>
<span class="s0"># @param data An 8-bit string containing arbitrary data.</span>

<span class="s3">class </span><span class="s1">Binary(object):</span>
    <span class="s2">&quot;&quot;&quot;Wrapper for binary data.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">data </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">data = </span><span class="s6">b&quot;&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">isinstance(data</span><span class="s3">, </span><span class="s1">(bytes</span><span class="s3">, </span><span class="s1">bytearray)):</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;expected bytes or bytearray, not %s&quot; </span><span class="s1">%</span>
                                <span class="s1">data.__class__.__name__)</span>
            <span class="s1">data = bytes(data)  </span><span class="s0"># Make a copy of the bytes!</span>
        <span class="s1">self.data = data</span>

    <span class="s0">##</span>
    <span class="s0"># Get buffer contents.</span>
    <span class="s0">#</span>
    <span class="s0"># @return Buffer contents, as an 8-bit string.</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s1">str(self.data</span><span class="s3">, </span><span class="s4">&quot;latin-1&quot;</span><span class="s1">)  </span><span class="s0"># XXX encoding?!</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Binary):</span>
            <span class="s1">other = other.data</span>
        <span class="s3">return </span><span class="s1">self.data == other</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Binary):</span>
            <span class="s1">other = other.data</span>
        <span class="s3">return </span><span class="s1">self.data != other</span>

    <span class="s3">def </span><span class="s1">decode(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">self.data = base64.decodebytes(data)</span>

    <span class="s3">def </span><span class="s1">encode(self</span><span class="s3">, </span><span class="s1">out):</span>
        <span class="s1">out.write(</span><span class="s4">&quot;&lt;value&gt;&lt;base64&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">encoded = base64.encodebytes(self.data)</span>
        <span class="s1">out.write(encoded.decode(</span><span class="s4">'ascii'</span><span class="s1">))</span>
        <span class="s1">out.write(</span><span class="s4">&quot;&lt;/base64&gt;&lt;/value&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">_binary(data):</span>
    <span class="s0"># decode xml element contents into a Binary structure</span>
    <span class="s1">value = Binary()</span>
    <span class="s1">value.decode(data)</span>
    <span class="s3">return </span><span class="s1">value</span>

<span class="s1">WRAPPERS = (DateTime</span><span class="s3">, </span><span class="s1">Binary)</span>

<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># XML parsers</span>

<span class="s3">class </span><span class="s1">ExpatParser(object):</span>
    <span class="s0"># fast expat parser for Python 2.0 and later.</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">target):</span>
        <span class="s1">self._parser = parser = expat.ParserCreate(</span><span class="s3">None, None</span><span class="s1">)</span>
        <span class="s1">self._target = target</span>
        <span class="s1">parser.StartElementHandler = target.start</span>
        <span class="s1">parser.EndElementHandler = target.end</span>
        <span class="s1">parser.CharacterDataHandler = target.data</span>
        <span class="s1">encoding = </span><span class="s3">None</span>
        <span class="s1">target.xml(encoding</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">feed(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">self._parser.Parse(data</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s1">self._parser.Parse(</span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s5">1</span><span class="s1">) </span><span class="s0"># end of data</span>
        <span class="s3">del </span><span class="s1">self._target</span><span class="s3">, </span><span class="s1">self._parser </span><span class="s0"># get rid of circular references</span>

<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># XML-RPC marshalling and unmarshalling code</span>

<span class="s0">##</span>
<span class="s0"># XML-RPC marshaller.</span>
<span class="s0">#</span>
<span class="s0"># @param encoding Default encoding for 8-bit strings.  The default</span>
<span class="s0">#     value is None (interpreted as UTF-8).</span>
<span class="s0"># @see dumps</span>

<span class="s3">class </span><span class="s1">Marshaller(object):</span>
    <span class="s2">&quot;&quot;&quot;Generate an XML-RPC params chunk from a Python data structure. 
 
    Create a Marshaller instance for each set of parameters, and use 
    the &quot;dumps&quot; method to convert your data (represented as a tuple) 
    to an XML-RPC params chunk.  To write a fault response, pass a 
    Fault instance instead.  You may prefer to use the &quot;dumps&quot; module 
    function for this purpose. 
    &quot;&quot;&quot;</span>

    <span class="s0"># by the way, if you don't understand what's going on in here,</span>
    <span class="s0"># that's perfectly ok.</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s3">None, </span><span class="s1">allow_none=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">self.memo = {}</span>
        <span class="s1">self.data = </span><span class="s3">None</span>
        <span class="s1">self.encoding = encoding</span>
        <span class="s1">self.allow_none = allow_none</span>

    <span class="s1">dispatch = {}</span>

    <span class="s3">def </span><span class="s1">dumps(self</span><span class="s3">, </span><span class="s1">values):</span>
        <span class="s1">out = []</span>
        <span class="s1">write = out.append</span>
        <span class="s1">dump = self.__dump</span>
        <span class="s3">if </span><span class="s1">isinstance(values</span><span class="s3">, </span><span class="s1">Fault):</span>
            <span class="s0"># fault instance</span>
            <span class="s1">write(</span><span class="s4">&quot;&lt;fault&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s1">dump({</span><span class="s4">'faultCode'</span><span class="s1">: values.faultCode</span><span class="s3">,</span>
                  <span class="s4">'faultString'</span><span class="s1">: values.faultString}</span><span class="s3">,</span>
                 <span class="s1">write)</span>
            <span class="s1">write(</span><span class="s4">&quot;&lt;/fault&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># parameter block</span>
            <span class="s0"># FIXME: the xml-rpc specification allows us to leave out</span>
            <span class="s0"># the entire &lt;params&gt; block if there are no parameters.</span>
            <span class="s0"># however, changing this may break older code (including</span>
            <span class="s0"># old versions of xmlrpclib.py), so this is better left as</span>
            <span class="s0"># is for now.  See @XMLRPC3 for more information. /F</span>
            <span class="s1">write(</span><span class="s4">&quot;&lt;params&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">values:</span>
                <span class="s1">write(</span><span class="s4">&quot;&lt;param&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
                <span class="s1">dump(v</span><span class="s3">, </span><span class="s1">write)</span>
                <span class="s1">write(</span><span class="s4">&quot;&lt;/param&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s1">write(</span><span class="s4">&quot;&lt;/params&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">result = </span><span class="s4">&quot;&quot;</span><span class="s1">.join(out)</span>
        <span class="s3">return </span><span class="s1">str(result)</span>

    <span class="s3">def </span><span class="s1">__dump(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">write):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">f = self.dispatch[type(ensure_new_type(value))]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s0"># check if this object can be marshalled as a structure</span>
            <span class="s3">if not </span><span class="s1">hasattr(value</span><span class="s3">, </span><span class="s4">'__dict__'</span><span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;cannot marshal %s objects&quot; </span><span class="s1">% type(value))</span>
            <span class="s0"># check if this class is a sub-class of a basic type,</span>
            <span class="s0"># because we don't know how to marshal these types</span>
            <span class="s0"># (e.g. a string sub-class)</span>
            <span class="s3">for </span><span class="s1">type_ </span><span class="s3">in </span><span class="s1">type(value).__mro__:</span>
                <span class="s3">if </span><span class="s1">type_ </span><span class="s3">in </span><span class="s1">self.dispatch.keys():</span>
                    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;cannot marshal %s objects&quot; </span><span class="s1">% type(value))</span>
            <span class="s0"># XXX(twouters): using &quot;_arbitrary_instance&quot; as key as a quick-fix</span>
            <span class="s0"># for the p3yk merge, this should probably be fixed more neatly.</span>
            <span class="s1">f = self.dispatch[</span><span class="s4">&quot;_arbitrary_instance&quot;</span><span class="s1">]</span>
        <span class="s1">f(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">write)</span>

    <span class="s3">def </span><span class="s1">dump_nil (self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">write):</span>
        <span class="s3">if not </span><span class="s1">self.allow_none:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;cannot marshal None unless allow_none is enabled&quot;</span><span class="s1">)</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;value&gt;&lt;nil/&gt;&lt;/value&gt;&quot;</span><span class="s1">)</span>
    <span class="s1">dispatch[type(</span><span class="s3">None</span><span class="s1">)] = dump_nil</span>

    <span class="s3">def </span><span class="s1">dump_bool(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">write):</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;value&gt;&lt;boolean&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">write(value </span><span class="s3">and </span><span class="s4">&quot;1&quot; </span><span class="s3">or </span><span class="s4">&quot;0&quot;</span><span class="s1">)</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;/boolean&gt;&lt;/value&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">dispatch[bool] = dump_bool</span>

    <span class="s3">def </span><span class="s1">dump_long(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">write):</span>
        <span class="s3">if </span><span class="s1">value &gt; MAXINT </span><span class="s3">or </span><span class="s1">value &lt; MININT:</span>
            <span class="s3">raise </span><span class="s1">OverflowError(</span><span class="s4">&quot;long int exceeds XML-RPC limits&quot;</span><span class="s1">)</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;value&gt;&lt;int&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">write(str(int(value)))</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;/int&gt;&lt;/value&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">dispatch[int] = dump_long</span>

    <span class="s0"># backward compatible</span>
    <span class="s1">dump_int = dump_long</span>

    <span class="s3">def </span><span class="s1">dump_double(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">write):</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;value&gt;&lt;double&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">write(repr(ensure_new_type(value)))</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;/double&gt;&lt;/value&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">dispatch[float] = dump_double</span>

    <span class="s3">def </span><span class="s1">dump_unicode(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">write</span><span class="s3">, </span><span class="s1">escape=escape):</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;value&gt;&lt;string&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">write(escape(value))</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;/string&gt;&lt;/value&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">dispatch[str] = dump_unicode</span>

    <span class="s3">def </span><span class="s1">dump_bytes(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">write):</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;value&gt;&lt;base64&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">encoded = base64.encodebytes(value)</span>
        <span class="s1">write(encoded.decode(</span><span class="s4">'ascii'</span><span class="s1">))</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;/base64&gt;&lt;/value&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">dispatch[bytes] = dump_bytes</span>
    <span class="s1">dispatch[bytearray] = dump_bytes</span>

    <span class="s3">def </span><span class="s1">dump_array(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">write):</span>
        <span class="s1">i = id(value)</span>
        <span class="s3">if </span><span class="s1">i </span><span class="s3">in </span><span class="s1">self.memo:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;cannot marshal recursive sequences&quot;</span><span class="s1">)</span>
        <span class="s1">self.memo[i] = </span><span class="s3">None</span>
        <span class="s1">dump = self.__dump</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;value&gt;&lt;array&gt;&lt;data&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">value:</span>
            <span class="s1">dump(v</span><span class="s3">, </span><span class="s1">write)</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;/data&gt;&lt;/array&gt;&lt;/value&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">del </span><span class="s1">self.memo[i]</span>
    <span class="s1">dispatch[tuple] = dump_array</span>
    <span class="s1">dispatch[list] = dump_array</span>

    <span class="s3">def </span><span class="s1">dump_struct(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">write</span><span class="s3">, </span><span class="s1">escape=escape):</span>
        <span class="s1">i = id(value)</span>
        <span class="s3">if </span><span class="s1">i </span><span class="s3">in </span><span class="s1">self.memo:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;cannot marshal recursive dictionaries&quot;</span><span class="s1">)</span>
        <span class="s1">self.memo[i] = </span><span class="s3">None</span>
        <span class="s1">dump = self.__dump</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;value&gt;&lt;struct&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">value.items():</span>
            <span class="s1">write(</span><span class="s4">&quot;&lt;member&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">isinstance(k</span><span class="s3">, </span><span class="s1">str):</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;dictionary key must be string&quot;</span><span class="s1">)</span>
            <span class="s1">write(</span><span class="s4">&quot;&lt;name&gt;%s&lt;/name&gt;</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">% escape(k))</span>
            <span class="s1">dump(v</span><span class="s3">, </span><span class="s1">write)</span>
            <span class="s1">write(</span><span class="s4">&quot;&lt;/member&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;/struct&gt;&lt;/value&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">del </span><span class="s1">self.memo[i]</span>
    <span class="s1">dispatch[dict] = dump_struct</span>

    <span class="s3">def </span><span class="s1">dump_datetime(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">write):</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;value&gt;&lt;dateTime.iso8601&gt;&quot;</span><span class="s1">)</span>
        <span class="s1">write(_strftime(value))</span>
        <span class="s1">write(</span><span class="s4">&quot;&lt;/dateTime.iso8601&gt;&lt;/value&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s1">dispatch[datetime] = dump_datetime</span>

    <span class="s3">def </span><span class="s1">dump_instance(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">write):</span>
        <span class="s0"># check for special wrappers</span>
        <span class="s3">if </span><span class="s1">value.__class__ </span><span class="s3">in </span><span class="s1">WRAPPERS:</span>
            <span class="s1">self.write = write</span>
            <span class="s1">value.encode(self)</span>
            <span class="s3">del </span><span class="s1">self.write</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># store instance attributes as a struct (really?)</span>
            <span class="s1">self.dump_struct(value.__dict__</span><span class="s3">, </span><span class="s1">write)</span>
    <span class="s1">dispatch[DateTime] = dump_instance</span>
    <span class="s1">dispatch[Binary] = dump_instance</span>
    <span class="s0"># XXX(twouters): using &quot;_arbitrary_instance&quot; as key as a quick-fix</span>
    <span class="s0"># for the p3yk merge, this should probably be fixed more neatly.</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;_arbitrary_instance&quot;</span><span class="s1">] = dump_instance</span>

<span class="s0">##</span>
<span class="s0"># XML-RPC unmarshaller.</span>
<span class="s0">#</span>
<span class="s0"># @see loads</span>

<span class="s3">class </span><span class="s1">Unmarshaller(object):</span>
    <span class="s2">&quot;&quot;&quot;Unmarshal an XML-RPC response, based on incoming XML event 
    messages (start, data, end).  Call close() to get the resulting 
    data structure. 
 
    Note that this reader is fairly tolerant, and gladly accepts bogus 
    XML-RPC data without complaining (but not bogus XML). 
    &quot;&quot;&quot;</span>

    <span class="s0"># and again, if you don't understand what's going on in here,</span>
    <span class="s0"># that's perfectly ok.</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">use_datetime=</span><span class="s3">False, </span><span class="s1">use_builtin_types=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">self._type = </span><span class="s3">None</span>
        <span class="s1">self._stack = []</span>
        <span class="s1">self._marks = []</span>
        <span class="s1">self._data = []</span>
        <span class="s1">self._methodname = </span><span class="s3">None</span>
        <span class="s1">self._encoding = </span><span class="s4">&quot;utf-8&quot;</span>
        <span class="s1">self.append = self._stack.append</span>
        <span class="s1">self._use_datetime = use_builtin_types </span><span class="s3">or </span><span class="s1">use_datetime</span>
        <span class="s1">self._use_bytes = use_builtin_types</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s0"># return response tuple and target method</span>
        <span class="s3">if </span><span class="s1">self._type </span><span class="s3">is None or </span><span class="s1">self._marks:</span>
            <span class="s3">raise </span><span class="s1">ResponseError()</span>
        <span class="s3">if </span><span class="s1">self._type == </span><span class="s4">&quot;fault&quot;</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">Fault(**self._stack[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s3">return </span><span class="s1">tuple(self._stack)</span>

    <span class="s3">def </span><span class="s1">getmethodname(self):</span>
        <span class="s3">return </span><span class="s1">self._methodname</span>

    <span class="s0">#</span>
    <span class="s0"># event handlers</span>

    <span class="s3">def </span><span class="s1">xml(self</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">standalone):</span>
        <span class="s1">self._encoding = encoding</span>
        <span class="s0"># FIXME: assert standalone == 1 ???</span>

    <span class="s3">def </span><span class="s1">start(self</span><span class="s3">, </span><span class="s1">tag</span><span class="s3">, </span><span class="s1">attrs):</span>
        <span class="s0"># prepare to handle this element</span>
        <span class="s3">if </span><span class="s1">tag == </span><span class="s4">&quot;array&quot; </span><span class="s3">or </span><span class="s1">tag == </span><span class="s4">&quot;struct&quot;</span><span class="s1">:</span>
            <span class="s1">self._marks.append(len(self._stack))</span>
        <span class="s1">self._data = []</span>
        <span class="s1">self._value = (tag == </span><span class="s4">&quot;value&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">data(self</span><span class="s3">, </span><span class="s1">text):</span>
        <span class="s1">self._data.append(text)</span>

    <span class="s3">def </span><span class="s1">end(self</span><span class="s3">, </span><span class="s1">tag):</span>
        <span class="s0"># call the appropriate end tag handler</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">f = self.dispatch[tag]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">pass </span><span class="s0"># unknown tag ?</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">f(self</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">.join(self._data))</span>

    <span class="s0">#</span>
    <span class="s0"># accelerator support</span>

    <span class="s3">def </span><span class="s1">end_dispatch(self</span><span class="s3">, </span><span class="s1">tag</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s0"># dispatch data</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">f = self.dispatch[tag]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">pass </span><span class="s0"># unknown tag ?</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">f(self</span><span class="s3">, </span><span class="s1">data)</span>

    <span class="s0">#</span>
    <span class="s0"># element decoders</span>

    <span class="s1">dispatch = {}</span>

    <span class="s3">def </span><span class="s1">end_nil (self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">self.append(</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">self._value = </span><span class="s5">0</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;nil&quot;</span><span class="s1">] = end_nil</span>

    <span class="s3">def </span><span class="s1">end_boolean(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s3">if </span><span class="s1">data == </span><span class="s4">&quot;0&quot;</span><span class="s1">:</span>
            <span class="s1">self.append(</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">data == </span><span class="s4">&quot;1&quot;</span><span class="s1">:</span>
            <span class="s1">self.append(</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;bad boolean value&quot;</span><span class="s1">)</span>
        <span class="s1">self._value = </span><span class="s5">0</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;boolean&quot;</span><span class="s1">] = end_boolean</span>

    <span class="s3">def </span><span class="s1">end_int(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">self.append(int(data))</span>
        <span class="s1">self._value = </span><span class="s5">0</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;i4&quot;</span><span class="s1">] = end_int</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;i8&quot;</span><span class="s1">] = end_int</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;int&quot;</span><span class="s1">] = end_int</span>

    <span class="s3">def </span><span class="s1">end_double(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">self.append(float(data))</span>
        <span class="s1">self._value = </span><span class="s5">0</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;double&quot;</span><span class="s1">] = end_double</span>

    <span class="s3">def </span><span class="s1">end_string(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s3">if </span><span class="s1">self._encoding:</span>
            <span class="s1">data = data.decode(self._encoding)</span>
        <span class="s1">self.append(data)</span>
        <span class="s1">self._value = </span><span class="s5">0</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;string&quot;</span><span class="s1">] = end_string</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;name&quot;</span><span class="s1">] = end_string </span><span class="s0"># struct keys are always strings</span>

    <span class="s3">def </span><span class="s1">end_array(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">mark = self._marks.pop()</span>
        <span class="s0"># map arrays to Python lists</span>
        <span class="s1">self._stack[mark:] = [self._stack[mark:]]</span>
        <span class="s1">self._value = </span><span class="s5">0</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;array&quot;</span><span class="s1">] = end_array</span>

    <span class="s3">def </span><span class="s1">end_struct(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">mark = self._marks.pop()</span>
        <span class="s0"># map structs to Python dictionaries</span>
        <span class="s1">dict = {}</span>
        <span class="s1">items = self._stack[mark:]</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">len(items)</span><span class="s3">, </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s1">dict[items[i]] = items[i+</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">self._stack[mark:] = [dict]</span>
        <span class="s1">self._value = </span><span class="s5">0</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;struct&quot;</span><span class="s1">] = end_struct</span>

    <span class="s3">def </span><span class="s1">end_base64(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">value = Binary()</span>
        <span class="s1">value.decode(data.encode(</span><span class="s4">&quot;ascii&quot;</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">self._use_bytes:</span>
            <span class="s1">value = value.data</span>
        <span class="s1">self.append(value)</span>
        <span class="s1">self._value = </span><span class="s5">0</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;base64&quot;</span><span class="s1">] = end_base64</span>

    <span class="s3">def </span><span class="s1">end_dateTime(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">value = DateTime()</span>
        <span class="s1">value.decode(data)</span>
        <span class="s3">if </span><span class="s1">self._use_datetime:</span>
            <span class="s1">value = _datetime_type(data)</span>
        <span class="s1">self.append(value)</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;dateTime.iso8601&quot;</span><span class="s1">] = end_dateTime</span>

    <span class="s3">def </span><span class="s1">end_value(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s0"># if we stumble upon a value element with no internal</span>
        <span class="s0"># elements, treat it as a string element</span>
        <span class="s3">if </span><span class="s1">self._value:</span>
            <span class="s1">self.end_string(data)</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;value&quot;</span><span class="s1">] = end_value</span>

    <span class="s3">def </span><span class="s1">end_params(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">self._type = </span><span class="s4">&quot;params&quot;</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;params&quot;</span><span class="s1">] = end_params</span>

    <span class="s3">def </span><span class="s1">end_fault(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">self._type = </span><span class="s4">&quot;fault&quot;</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;fault&quot;</span><span class="s1">] = end_fault</span>

    <span class="s3">def </span><span class="s1">end_methodName(self</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s3">if </span><span class="s1">self._encoding:</span>
            <span class="s1">data = data.decode(self._encoding)</span>
        <span class="s1">self._methodname = data</span>
        <span class="s1">self._type = </span><span class="s4">&quot;methodName&quot; </span><span class="s0"># no params</span>
    <span class="s1">dispatch[</span><span class="s4">&quot;methodName&quot;</span><span class="s1">] = end_methodName</span>

<span class="s0">## Multicall support</span>
<span class="s0">#</span>

<span class="s3">class </span><span class="s1">_MultiCallMethod(object):</span>
    <span class="s0"># some lesser magic to store calls made to a MultiCall object</span>
    <span class="s0"># for batch execution</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">call_list</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s1">self.__call_list = call_list</span>
        <span class="s1">self.__name = name</span>
    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">return </span><span class="s1">_MultiCallMethod(self.__call_list</span><span class="s3">, </span><span class="s4">&quot;%s.%s&quot; </span><span class="s1">% (self.__name</span><span class="s3">, </span><span class="s1">name))</span>
    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s1">self.__call_list.append((self.__name</span><span class="s3">, </span><span class="s1">args))</span>

<span class="s3">class </span><span class="s1">MultiCallIterator(object):</span>
    <span class="s2">&quot;&quot;&quot;Iterates over the results of a multicall. Exceptions are 
    raised in response to xmlrpc faults.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">results):</span>
        <span class="s1">self.results = results</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">i):</span>
        <span class="s1">item = self.results[i]</span>
        <span class="s3">if </span><span class="s1">isinstance(type(item)</span><span class="s3">, </span><span class="s1">dict):</span>
            <span class="s3">raise </span><span class="s1">Fault(item[</span><span class="s4">'faultCode'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">item[</span><span class="s4">'faultString'</span><span class="s1">])</span>
        <span class="s3">elif </span><span class="s1">type(item) == type([]):</span>
            <span class="s3">return </span><span class="s1">item[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;unexpected type in multicall result&quot;</span><span class="s1">)</span>

<span class="s3">class </span><span class="s1">MultiCall(object):</span>
    <span class="s2">&quot;&quot;&quot;server -&gt; a object used to boxcar method calls 
 
    server should be a ServerProxy object. 
 
    Methods can be added to the MultiCall using normal 
    method call syntax e.g.: 
 
    multicall = MultiCall(server_proxy) 
    multicall.add(2,3) 
    multicall.get_address(&quot;Guido&quot;) 
 
    To execute the multicall, call the MultiCall object e.g.: 
 
    add_result, address = multicall() 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">server):</span>
        <span class="s1">self.__server = server</span>
        <span class="s1">self.__call_list = []</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">&quot;&lt;MultiCall at %x&gt;&quot; </span><span class="s1">% id(self)</span>

    <span class="s1">__str__ = __repr__</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">return </span><span class="s1">_MultiCallMethod(self.__call_list</span><span class="s3">, </span><span class="s1">name)</span>

    <span class="s3">def </span><span class="s1">__call__(self):</span>
        <span class="s1">marshalled_list = []</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">args </span><span class="s3">in </span><span class="s1">self.__call_list:</span>
            <span class="s1">marshalled_list.append({</span><span class="s4">'methodName' </span><span class="s1">: name</span><span class="s3">, </span><span class="s4">'params' </span><span class="s1">: args})</span>

        <span class="s3">return </span><span class="s1">MultiCallIterator(self.__server.system.multicall(marshalled_list))</span>

<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># convenience functions</span>

<span class="s1">FastMarshaller = FastParser = FastUnmarshaller = </span><span class="s3">None</span>

<span class="s0">##</span>
<span class="s0"># Create a parser object, and connect it to an unmarshalling instance.</span>
<span class="s0"># This function picks the fastest available XML parser.</span>
<span class="s0">#</span>
<span class="s0"># return A (parser, unmarshaller) tuple.</span>

<span class="s3">def </span><span class="s1">getparser(use_datetime=</span><span class="s3">False, </span><span class="s1">use_builtin_types=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;getparser() -&gt; parser, unmarshaller 
 
    Create an instance of the fastest available parser, and attach it 
    to an unmarshalling object.  Return both objects. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">FastParser </span><span class="s3">and </span><span class="s1">FastUnmarshaller:</span>
        <span class="s3">if </span><span class="s1">use_builtin_types:</span>
            <span class="s1">mkdatetime = _datetime_type</span>
            <span class="s1">mkbytes = base64.decodebytes</span>
        <span class="s3">elif </span><span class="s1">use_datetime:</span>
            <span class="s1">mkdatetime = _datetime_type</span>
            <span class="s1">mkbytes = _binary</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">mkdatetime = _datetime</span>
            <span class="s1">mkbytes = _binary</span>
        <span class="s1">target = FastUnmarshaller(</span><span class="s3">True, False, </span><span class="s1">mkbytes</span><span class="s3">, </span><span class="s1">mkdatetime</span><span class="s3">, </span><span class="s1">Fault)</span>
        <span class="s1">parser = FastParser(target)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">target = Unmarshaller(use_datetime=use_datetime</span><span class="s3">, </span><span class="s1">use_builtin_types=use_builtin_types)</span>
        <span class="s3">if </span><span class="s1">FastParser:</span>
            <span class="s1">parser = FastParser(target)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">parser = ExpatParser(target)</span>
    <span class="s3">return </span><span class="s1">parser</span><span class="s3">, </span><span class="s1">target</span>

<span class="s0">##</span>
<span class="s0"># Convert a Python tuple or a Fault instance to an XML-RPC packet.</span>
<span class="s0">#</span>
<span class="s0"># @def dumps(params, **options)</span>
<span class="s0"># @param params A tuple or Fault instance.</span>
<span class="s0"># @keyparam methodname If given, create a methodCall request for</span>
<span class="s0">#     this method name.</span>
<span class="s0"># @keyparam methodresponse If given, create a methodResponse packet.</span>
<span class="s0">#     If used with a tuple, the tuple must be a singleton (that is,</span>
<span class="s0">#     it must contain exactly one element).</span>
<span class="s0"># @keyparam encoding The packet encoding.</span>
<span class="s0"># @return A string containing marshalled data.</span>

<span class="s3">def </span><span class="s1">dumps(params</span><span class="s3">, </span><span class="s1">methodname=</span><span class="s3">None, </span><span class="s1">methodresponse=</span><span class="s3">None, </span><span class="s1">encoding=</span><span class="s3">None,</span>
          <span class="s1">allow_none=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;data [,options] -&gt; marshalled data 
 
    Convert an argument tuple or a Fault instance to an XML-RPC 
    request (or response, if the methodresponse option is used). 
 
    In addition to the data object, the following options can be given 
    as keyword arguments: 
 
        methodname: the method name for a methodCall packet 
 
        methodresponse: true to create a methodResponse packet. 
        If this option is used with a tuple, the tuple must be 
        a singleton (i.e. it can contain only one element). 
 
        encoding: the packet encoding (default is UTF-8) 
 
    All byte strings in the data structure are assumed to use the 
    packet encoding.  Unicode strings are automatically converted, 
    where necessary. 
    &quot;&quot;&quot;</span>

    <span class="s3">assert </span><span class="s1">isinstance(params</span><span class="s3">, </span><span class="s1">(tuple</span><span class="s3">, </span><span class="s1">Fault))</span><span class="s3">, </span><span class="s4">&quot;argument must be tuple or Fault instance&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(params</span><span class="s3">, </span><span class="s1">Fault):</span>
        <span class="s1">methodresponse = </span><span class="s5">1</span>
    <span class="s3">elif </span><span class="s1">methodresponse </span><span class="s3">and </span><span class="s1">isinstance(params</span><span class="s3">, </span><span class="s1">tuple):</span>
        <span class="s3">assert </span><span class="s1">len(params) == </span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;response tuple must be a singleton&quot;</span>

    <span class="s3">if not </span><span class="s1">encoding:</span>
        <span class="s1">encoding = </span><span class="s4">&quot;utf-8&quot;</span>

    <span class="s3">if </span><span class="s1">FastMarshaller:</span>
        <span class="s1">m = FastMarshaller(encoding)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">m = Marshaller(encoding</span><span class="s3">, </span><span class="s1">allow_none)</span>

    <span class="s1">data = m.dumps(params)</span>

    <span class="s3">if </span><span class="s1">encoding != </span><span class="s4">&quot;utf-8&quot;</span><span class="s1">:</span>
        <span class="s1">xmlheader = </span><span class="s4">&quot;&lt;?xml version='1.0' encoding='%s'?&gt;</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">% str(encoding)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">xmlheader = </span><span class="s4">&quot;&lt;?xml version='1.0'?&gt;</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s0"># utf-8 is default</span>

    <span class="s0"># standard XML-RPC wrappings</span>
    <span class="s3">if </span><span class="s1">methodname:</span>
        <span class="s0"># a method call</span>
        <span class="s3">if not </span><span class="s1">isinstance(methodname</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">methodname = methodname.encode(encoding)</span>
        <span class="s1">data = (</span>
            <span class="s1">xmlheader</span><span class="s3">,</span>
            <span class="s4">&quot;&lt;methodCall&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;&lt;methodName&gt;&quot;</span><span class="s3">, </span><span class="s1">methodname</span><span class="s3">, </span><span class="s4">&quot;&lt;/methodName&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s3">,</span>
            <span class="s1">data</span><span class="s3">,</span>
            <span class="s4">&quot;&lt;/methodCall&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span>
            <span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">methodresponse:</span>
        <span class="s0"># a method response, or a fault structure</span>
        <span class="s1">data = (</span>
            <span class="s1">xmlheader</span><span class="s3">,</span>
            <span class="s4">&quot;&lt;methodResponse&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s3">,</span>
            <span class="s1">data</span><span class="s3">,</span>
            <span class="s4">&quot;&lt;/methodResponse&gt;</span><span class="s3">\n</span><span class="s4">&quot;</span>
            <span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">data </span><span class="s0"># return as is</span>
    <span class="s3">return </span><span class="s1">str(</span><span class="s4">&quot;&quot;</span><span class="s1">).join(data)</span>

<span class="s0">##</span>
<span class="s0"># Convert an XML-RPC packet to a Python object.  If the XML-RPC packet</span>
<span class="s0"># represents a fault condition, this function raises a Fault exception.</span>
<span class="s0">#</span>
<span class="s0"># @param data An XML-RPC packet, given as an 8-bit string.</span>
<span class="s0"># @return A tuple containing the unpacked data, and the method name</span>
<span class="s0">#     (None if not present).</span>
<span class="s0"># @see Fault</span>

<span class="s3">def </span><span class="s1">loads(data</span><span class="s3">, </span><span class="s1">use_datetime=</span><span class="s3">False, </span><span class="s1">use_builtin_types=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;data -&gt; unmarshalled data, method name 
 
    Convert an XML-RPC packet to unmarshalled data plus a method 
    name (None if not present). 
 
    If the XML-RPC packet represents a fault condition, this function 
    raises a Fault exception. 
    &quot;&quot;&quot;</span>
    <span class="s1">p</span><span class="s3">, </span><span class="s1">u = getparser(use_datetime=use_datetime</span><span class="s3">, </span><span class="s1">use_builtin_types=use_builtin_types)</span>
    <span class="s1">p.feed(data)</span>
    <span class="s1">p.close()</span>
    <span class="s3">return </span><span class="s1">u.close()</span><span class="s3">, </span><span class="s1">u.getmethodname()</span>

<span class="s0">##</span>
<span class="s0"># Encode a string using the gzip content encoding such as specified by the</span>
<span class="s0"># Content-Encoding: gzip</span>
<span class="s0"># in the HTTP header, as described in RFC 1952</span>
<span class="s0">#</span>
<span class="s0"># @param data the unencoded data</span>
<span class="s0"># @return the encoded data</span>

<span class="s3">def </span><span class="s1">gzip_encode(data):</span>
    <span class="s2">&quot;&quot;&quot;data -&gt; gzip encoded data 
 
    Encode data using the gzip content encoding as described in RFC 1952 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">gzip:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>
    <span class="s1">f = BytesIO()</span>
    <span class="s1">gzf = gzip.GzipFile(mode=</span><span class="s4">&quot;wb&quot;</span><span class="s3">, </span><span class="s1">fileobj=f</span><span class="s3">, </span><span class="s1">compresslevel=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">gzf.write(data)</span>
    <span class="s1">gzf.close()</span>
    <span class="s1">encoded = f.getvalue()</span>
    <span class="s1">f.close()</span>
    <span class="s3">return </span><span class="s1">encoded</span>

<span class="s0">##</span>
<span class="s0"># Decode a string using the gzip content encoding such as specified by the</span>
<span class="s0"># Content-Encoding: gzip</span>
<span class="s0"># in the HTTP header, as described in RFC 1952</span>
<span class="s0">#</span>
<span class="s0"># @param data The encoded data</span>
<span class="s0"># @return the unencoded data</span>
<span class="s0"># @raises ValueError if data is not correctly coded.</span>

<span class="s3">def </span><span class="s1">gzip_decode(data):</span>
    <span class="s2">&quot;&quot;&quot;gzip encoded data -&gt; unencoded data 
 
    Decode data using the gzip content encoding as described in RFC 1952 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">gzip:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>
    <span class="s1">f = BytesIO(data)</span>
    <span class="s1">gzf = gzip.GzipFile(mode=</span><span class="s4">&quot;rb&quot;</span><span class="s3">, </span><span class="s1">fileobj=f)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">decoded = gzf.read()</span>
    <span class="s3">except </span><span class="s1">IOError:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;invalid data&quot;</span><span class="s1">)</span>
    <span class="s1">f.close()</span>
    <span class="s1">gzf.close()</span>
    <span class="s3">return </span><span class="s1">decoded</span>

<span class="s0">##</span>
<span class="s0"># Return a decoded file-like object for the gzip encoding</span>
<span class="s0"># as described in RFC 1952.</span>
<span class="s0">#</span>
<span class="s0"># @param response A stream supporting a read() method</span>
<span class="s0"># @return a file-like object that the decoded data can be read() from</span>

<span class="s3">class </span><span class="s1">GzipDecodedResponse(gzip.GzipFile </span><span class="s3">if </span><span class="s1">gzip </span><span class="s3">else </span><span class="s1">object):</span>
    <span class="s2">&quot;&quot;&quot;a file-like object to decode a response encoded with the gzip 
    method, as described in RFC 1952. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">response):</span>
        <span class="s0">#response doesn't support tell() and read(), required by</span>
        <span class="s0">#GzipFile</span>
        <span class="s3">if not </span><span class="s1">gzip:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError</span>
        <span class="s1">self.io = BytesIO(response.read())</span>
        <span class="s1">gzip.GzipFile.__init__(self</span><span class="s3">, </span><span class="s1">mode=</span><span class="s4">&quot;rb&quot;</span><span class="s3">, </span><span class="s1">fileobj=self.io)</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s1">gzip.GzipFile.close(self)</span>
        <span class="s1">self.io.close()</span>


<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># request dispatcher</span>

<span class="s3">class </span><span class="s1">_Method(object):</span>
    <span class="s0"># some magic to bind an XML-RPC method to an RPC server.</span>
    <span class="s0"># supports &quot;nested&quot; methods (e.g. examples.getStateName)</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">send</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s1">self.__send = send</span>
        <span class="s1">self.__name = name</span>
    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">return </span><span class="s1">_Method(self.__send</span><span class="s3">, </span><span class="s4">&quot;%s.%s&quot; </span><span class="s1">% (self.__name</span><span class="s3">, </span><span class="s1">name))</span>
    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s3">return </span><span class="s1">self.__send(self.__name</span><span class="s3">, </span><span class="s1">args)</span>

<span class="s0">##</span>
<span class="s0"># Standard transport class for XML-RPC over HTTP.</span>
<span class="s0"># &lt;p&gt;</span>
<span class="s0"># You can create custom transports by subclassing this method, and</span>
<span class="s0"># overriding selected methods.</span>

<span class="s3">class </span><span class="s1">Transport(object):</span>
    <span class="s2">&quot;&quot;&quot;Handles an HTTP transaction to an XML-RPC server.&quot;&quot;&quot;</span>

    <span class="s0"># client identifier (may be overridden)</span>
    <span class="s1">user_agent = </span><span class="s4">&quot;Python-xmlrpc/%s&quot; </span><span class="s1">% __version__</span>

    <span class="s0">#if true, we'll request gzip encoding</span>
    <span class="s1">accept_gzip_encoding = </span><span class="s3">True</span>

    <span class="s0"># if positive, encode request using gzip if it exceeds this threshold</span>
    <span class="s0"># note that many server will get confused, so only use it if you know</span>
    <span class="s0"># that they can decode such a request</span>
    <span class="s1">encode_threshold = </span><span class="s3">None </span><span class="s0">#None = don't encode</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">use_datetime=</span><span class="s3">False, </span><span class="s1">use_builtin_types=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">self._use_datetime = use_datetime</span>
        <span class="s1">self._use_builtin_types = use_builtin_types</span>
        <span class="s1">self._connection = (</span><span class="s3">None, None</span><span class="s1">)</span>
        <span class="s1">self._extra_headers = []</span>

    <span class="s0">##</span>
    <span class="s0"># Send a complete request, and parse the response.</span>
    <span class="s0"># Retry request if a cached connection has disconnected.</span>
    <span class="s0">#</span>
    <span class="s0"># @param host Target host.</span>
    <span class="s0"># @param handler Target PRC handler.</span>
    <span class="s0"># @param request_body XML-RPC request body.</span>
    <span class="s0"># @param verbose Debugging flag.</span>
    <span class="s0"># @return Parsed response.</span>

    <span class="s3">def </span><span class="s1">request(self</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s1">request_body</span><span class="s3">, </span><span class="s1">verbose=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">#retry request once if cached connection has gone cold</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self.single_request(host</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s1">request_body</span><span class="s3">, </span><span class="s1">verbose)</span>
            <span class="s3">except </span><span class="s1">socket.error </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">if </span><span class="s1">i </span><span class="s3">or </span><span class="s1">e.errno </span><span class="s3">not in </span><span class="s1">(errno.ECONNRESET</span><span class="s3">, </span><span class="s1">errno.ECONNABORTED</span><span class="s3">, </span><span class="s1">errno.EPIPE):</span>
                    <span class="s3">raise</span>
            <span class="s3">except </span><span class="s1">http_client.BadStatusLine: </span><span class="s0">#close after we sent request</span>
                <span class="s3">if </span><span class="s1">i:</span>
                    <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">single_request(self</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s1">request_body</span><span class="s3">, </span><span class="s1">verbose=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0"># issue XML-RPC request</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">http_conn = self.send_request(host</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s1">request_body</span><span class="s3">, </span><span class="s1">verbose)</span>
            <span class="s1">resp = http_conn.getresponse()</span>
            <span class="s3">if </span><span class="s1">resp.status == </span><span class="s5">200</span><span class="s1">:</span>
                <span class="s1">self.verbose = verbose</span>
                <span class="s3">return </span><span class="s1">self.parse_response(resp)</span>

        <span class="s3">except </span><span class="s1">Fault:</span>
            <span class="s3">raise</span>
        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s0">#All unexpected errors leave connection in</span>
            <span class="s0"># a strange state, so we clear it.</span>
            <span class="s1">self.close()</span>
            <span class="s3">raise</span>

        <span class="s0">#We got an error response.</span>
        <span class="s0">#Discard any response data and raise exception</span>
        <span class="s3">if </span><span class="s1">resp.getheader(</span><span class="s4">&quot;content-length&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">):</span>
            <span class="s1">resp.read()</span>
        <span class="s3">raise </span><span class="s1">ProtocolError(</span>
            <span class="s1">host + handler</span><span class="s3">,</span>
            <span class="s1">resp.status</span><span class="s3">, </span><span class="s1">resp.reason</span><span class="s3">,</span>
            <span class="s1">dict(resp.getheaders())</span>
            <span class="s1">)</span>


    <span class="s0">##</span>
    <span class="s0"># Create parser.</span>
    <span class="s0">#</span>
    <span class="s0"># @return A 2-tuple containing a parser and a unmarshaller.</span>

    <span class="s3">def </span><span class="s1">getparser(self):</span>
        <span class="s0"># get parser and unmarshaller</span>
        <span class="s3">return </span><span class="s1">getparser(use_datetime=self._use_datetime</span><span class="s3">,</span>
                         <span class="s1">use_builtin_types=self._use_builtin_types)</span>

    <span class="s0">##</span>
    <span class="s0"># Get authorization info from host parameter</span>
    <span class="s0"># Host may be a string, or a (host, x509-dict) tuple; if a string,</span>
    <span class="s0"># it is checked for a &quot;user:pw@host&quot; format, and a &quot;Basic</span>
    <span class="s0"># Authentication&quot; header is added if appropriate.</span>
    <span class="s0">#</span>
    <span class="s0"># @param host Host descriptor (URL or (URL, x509 info) tuple).</span>
    <span class="s0"># @return A 3-tuple containing (actual host, extra headers,</span>
    <span class="s0">#     x509 info).  The header and x509 fields may be None.</span>

    <span class="s3">def </span><span class="s1">get_host_info(self</span><span class="s3">, </span><span class="s1">host):</span>

        <span class="s1">x509 = {}</span>
        <span class="s3">if </span><span class="s1">isinstance(host</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s1">host</span><span class="s3">, </span><span class="s1">x509 = host</span>

        <span class="s1">auth</span><span class="s3">, </span><span class="s1">host = urllib_parse.splituser(host)</span>

        <span class="s3">if </span><span class="s1">auth:</span>
            <span class="s1">auth = urllib_parse.unquote_to_bytes(auth)</span>
            <span class="s1">auth = base64.encodebytes(auth).decode(</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">)</span>
            <span class="s1">auth = </span><span class="s4">&quot;&quot;</span><span class="s1">.join(auth.split()) </span><span class="s0"># get rid of whitespace</span>
            <span class="s1">extra_headers = [</span>
                <span class="s1">(</span><span class="s4">&quot;Authorization&quot;</span><span class="s3">, </span><span class="s4">&quot;Basic &quot; </span><span class="s1">+ auth)</span>
                <span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">extra_headers = []</span>

        <span class="s3">return </span><span class="s1">host</span><span class="s3">, </span><span class="s1">extra_headers</span><span class="s3">, </span><span class="s1">x509</span>

    <span class="s0">##</span>
    <span class="s0"># Connect to server.</span>
    <span class="s0">#</span>
    <span class="s0"># @param host Target host.</span>
    <span class="s0"># @return An HTTPConnection object</span>

    <span class="s3">def </span><span class="s1">make_connection(self</span><span class="s3">, </span><span class="s1">host):</span>
        <span class="s0">#return an existing connection if possible.  This allows</span>
        <span class="s0">#HTTP/1.1 keep-alive.</span>
        <span class="s3">if </span><span class="s1">self._connection </span><span class="s3">and </span><span class="s1">host == self._connection[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s3">return </span><span class="s1">self._connection[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0"># create a HTTP connection object from a host descriptor</span>
        <span class="s1">chost</span><span class="s3">, </span><span class="s1">self._extra_headers</span><span class="s3">, </span><span class="s1">x509 = self.get_host_info(host)</span>
        <span class="s1">self._connection = host</span><span class="s3">, </span><span class="s1">http_client.HTTPConnection(chost)</span>
        <span class="s3">return </span><span class="s1">self._connection[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s0">##</span>
    <span class="s0"># Clear any cached connection object.</span>
    <span class="s0"># Used in the event of socket errors.</span>
    <span class="s0">#</span>
    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s3">if </span><span class="s1">self._connection[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s1">self._connection[</span><span class="s5">1</span><span class="s1">].close()</span>
            <span class="s1">self._connection = (</span><span class="s3">None, None</span><span class="s1">)</span>

    <span class="s0">##</span>
    <span class="s0"># Send HTTP request.</span>
    <span class="s0">#</span>
    <span class="s0"># @param host Host descriptor (URL or (URL, x509 info) tuple).</span>
    <span class="s0"># @param handler Targer RPC handler (a path relative to host)</span>
    <span class="s0"># @param request_body The XML-RPC request body</span>
    <span class="s0"># @param debug Enable debugging if debug is true.</span>
    <span class="s0"># @return An HTTPConnection.</span>

    <span class="s3">def </span><span class="s1">send_request(self</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s1">request_body</span><span class="s3">, </span><span class="s1">debug):</span>
        <span class="s1">connection = self.make_connection(host)</span>
        <span class="s1">headers = self._extra_headers[:]</span>
        <span class="s3">if </span><span class="s1">debug:</span>
            <span class="s1">connection.set_debuglevel(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.accept_gzip_encoding </span><span class="s3">and </span><span class="s1">gzip:</span>
            <span class="s1">connection.putrequest(</span><span class="s4">&quot;POST&quot;</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s1">skip_accept_encoding=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">headers.append((</span><span class="s4">&quot;Accept-Encoding&quot;</span><span class="s3">, </span><span class="s4">&quot;gzip&quot;</span><span class="s1">))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">connection.putrequest(</span><span class="s4">&quot;POST&quot;</span><span class="s3">, </span><span class="s1">handler)</span>
        <span class="s1">headers.append((</span><span class="s4">&quot;Content-Type&quot;</span><span class="s3">, </span><span class="s4">&quot;text/xml&quot;</span><span class="s1">))</span>
        <span class="s1">headers.append((</span><span class="s4">&quot;User-Agent&quot;</span><span class="s3">, </span><span class="s1">self.user_agent))</span>
        <span class="s1">self.send_headers(connection</span><span class="s3">, </span><span class="s1">headers)</span>
        <span class="s1">self.send_content(connection</span><span class="s3">, </span><span class="s1">request_body)</span>
        <span class="s3">return </span><span class="s1">connection</span>

    <span class="s0">##</span>
    <span class="s0"># Send request headers.</span>
    <span class="s0"># This function provides a useful hook for subclassing</span>
    <span class="s0">#</span>
    <span class="s0"># @param connection httpConnection.</span>
    <span class="s0"># @param headers list of key,value pairs for HTTP headers</span>

    <span class="s3">def </span><span class="s1">send_headers(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">headers):</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">headers:</span>
            <span class="s1">connection.putheader(key</span><span class="s3">, </span><span class="s1">val)</span>

    <span class="s0">##</span>
    <span class="s0"># Send request body.</span>
    <span class="s0"># This function provides a useful hook for subclassing</span>
    <span class="s0">#</span>
    <span class="s0"># @param connection httpConnection.</span>
    <span class="s0"># @param request_body XML-RPC request body.</span>

    <span class="s3">def </span><span class="s1">send_content(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">request_body):</span>
        <span class="s0">#optionally encode the request</span>
        <span class="s3">if </span><span class="s1">(self.encode_threshold </span><span class="s3">is not None and</span>
            <span class="s1">self.encode_threshold &lt; len(request_body) </span><span class="s3">and</span>
            <span class="s1">gzip):</span>
            <span class="s1">connection.putheader(</span><span class="s4">&quot;Content-Encoding&quot;</span><span class="s3">, </span><span class="s4">&quot;gzip&quot;</span><span class="s1">)</span>
            <span class="s1">request_body = gzip_encode(request_body)</span>

        <span class="s1">connection.putheader(</span><span class="s4">&quot;Content-Length&quot;</span><span class="s3">, </span><span class="s1">str(len(request_body)))</span>
        <span class="s1">connection.endheaders(request_body)</span>

    <span class="s0">##</span>
    <span class="s0"># Parse response.</span>
    <span class="s0">#</span>
    <span class="s0"># @param file Stream.</span>
    <span class="s0"># @return Response tuple and target method.</span>

    <span class="s3">def </span><span class="s1">parse_response(self</span><span class="s3">, </span><span class="s1">response):</span>
        <span class="s0"># read response data from httpresponse, and parse it</span>
        <span class="s0"># Check for new http response object, otherwise it is a file object.</span>
        <span class="s3">if </span><span class="s1">hasattr(response</span><span class="s3">, </span><span class="s4">'getheader'</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">response.getheader(</span><span class="s4">&quot;Content-Encoding&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">) == </span><span class="s4">&quot;gzip&quot;</span><span class="s1">:</span>
                <span class="s1">stream = GzipDecodedResponse(response)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">stream = response</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">stream = response</span>

        <span class="s1">p</span><span class="s3">, </span><span class="s1">u = self.getparser()</span>

        <span class="s3">while </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">data = stream.read(</span><span class="s5">1024</span><span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">data:</span>
                <span class="s3">break</span>
            <span class="s3">if </span><span class="s1">self.verbose:</span>
                <span class="s1">print(</span><span class="s4">&quot;body:&quot;</span><span class="s3">, </span><span class="s1">repr(data))</span>
            <span class="s1">p.feed(data)</span>

        <span class="s3">if </span><span class="s1">stream </span><span class="s3">is not </span><span class="s1">response:</span>
            <span class="s1">stream.close()</span>
        <span class="s1">p.close()</span>

        <span class="s3">return </span><span class="s1">u.close()</span>

<span class="s0">##</span>
<span class="s0"># Standard transport class for XML-RPC over HTTPS.</span>

<span class="s3">class </span><span class="s1">SafeTransport(Transport):</span>
    <span class="s2">&quot;&quot;&quot;Handles an HTTPS transaction to an XML-RPC server.&quot;&quot;&quot;</span>

    <span class="s0"># FIXME: mostly untested</span>

    <span class="s3">def </span><span class="s1">make_connection(self</span><span class="s3">, </span><span class="s1">host):</span>
        <span class="s3">if </span><span class="s1">self._connection </span><span class="s3">and </span><span class="s1">host == self._connection[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s3">return </span><span class="s1">self._connection[</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s3">if not </span><span class="s1">hasattr(http_client</span><span class="s3">, </span><span class="s4">&quot;HTTPSConnection&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">&quot;your version of http.client doesn't support HTTPS&quot;</span><span class="s1">)</span>
        <span class="s0"># create a HTTPS connection object from a host descriptor</span>
        <span class="s0"># host may be a string, or a (host, x509-dict) tuple</span>
        <span class="s1">chost</span><span class="s3">, </span><span class="s1">self._extra_headers</span><span class="s3">, </span><span class="s1">x509 = self.get_host_info(host)</span>
        <span class="s1">self._connection = host</span><span class="s3">, </span><span class="s1">http_client.HTTPSConnection(chost</span><span class="s3">,</span>
            <span class="s3">None, </span><span class="s1">**(x509 </span><span class="s3">or </span><span class="s1">{}))</span>
        <span class="s3">return </span><span class="s1">self._connection[</span><span class="s5">1</span><span class="s1">]</span>

<span class="s0">##</span>
<span class="s0"># Standard server proxy.  This class establishes a virtual connection</span>
<span class="s0"># to an XML-RPC server.</span>
<span class="s0"># &lt;p&gt;</span>
<span class="s0"># This class is available as ServerProxy and Server.  New code should</span>
<span class="s0"># use ServerProxy, to avoid confusion.</span>
<span class="s0">#</span>
<span class="s0"># @def ServerProxy(uri, **options)</span>
<span class="s0"># @param uri The connection point on the server.</span>
<span class="s0"># @keyparam transport A transport factory, compatible with the</span>
<span class="s0">#    standard transport class.</span>
<span class="s0"># @keyparam encoding The default encoding used for 8-bit strings</span>
<span class="s0">#    (default is UTF-8).</span>
<span class="s0"># @keyparam verbose Use a true value to enable debugging output.</span>
<span class="s0">#    (printed to standard output).</span>
<span class="s0"># @see Transport</span>

<span class="s3">class </span><span class="s1">ServerProxy(object):</span>
    <span class="s2">&quot;&quot;&quot;uri [,options] -&gt; a logical connection to an XML-RPC server 
 
    uri is the connection point on the server, given as 
    scheme://host/target. 
 
    The standard implementation always supports the &quot;http&quot; scheme.  If 
    SSL socket support is available (Python 2.0), it also supports 
    &quot;https&quot;. 
 
    If the target part and the slash preceding it are both omitted, 
    &quot;/RPC2&quot; is assumed. 
 
    The following options can be given as keyword arguments: 
 
        transport: a transport factory 
        encoding: the request encoding (default is UTF-8) 
 
    All 8-bit strings passed to the server proxy are assumed to use 
    the given encoding. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">uri</span><span class="s3">, </span><span class="s1">transport=</span><span class="s3">None, </span><span class="s1">encoding=</span><span class="s3">None, </span><span class="s1">verbose=</span><span class="s3">False,</span>
                 <span class="s1">allow_none=</span><span class="s3">False, </span><span class="s1">use_datetime=</span><span class="s3">False, </span><span class="s1">use_builtin_types=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0"># establish a &quot;logical&quot; server connection</span>

        <span class="s0"># get the url</span>
        <span class="s1">type</span><span class="s3">, </span><span class="s1">uri = urllib_parse.splittype(uri)</span>
        <span class="s3">if </span><span class="s1">type </span><span class="s3">not in </span><span class="s1">(</span><span class="s4">&quot;http&quot;</span><span class="s3">, </span><span class="s4">&quot;https&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">IOError(</span><span class="s4">&quot;unsupported XML-RPC protocol&quot;</span><span class="s1">)</span>
        <span class="s1">self.__host</span><span class="s3">, </span><span class="s1">self.__handler = urllib_parse.splithost(uri)</span>
        <span class="s3">if not </span><span class="s1">self.__handler:</span>
            <span class="s1">self.__handler = </span><span class="s4">&quot;/RPC2&quot;</span>

        <span class="s3">if </span><span class="s1">transport </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">type == </span><span class="s4">&quot;https&quot;</span><span class="s1">:</span>
                <span class="s1">handler = SafeTransport</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">handler = Transport</span>
            <span class="s1">transport = handler(use_datetime=use_datetime</span><span class="s3">,</span>
                                <span class="s1">use_builtin_types=use_builtin_types)</span>
        <span class="s1">self.__transport = transport</span>

        <span class="s1">self.__encoding = encoding </span><span class="s3">or </span><span class="s4">'utf-8'</span>
        <span class="s1">self.__verbose = verbose</span>
        <span class="s1">self.__allow_none = allow_none</span>

    <span class="s3">def </span><span class="s1">__close(self):</span>
        <span class="s1">self.__transport.close()</span>

    <span class="s3">def </span><span class="s1">__request(self</span><span class="s3">, </span><span class="s1">methodname</span><span class="s3">, </span><span class="s1">params):</span>
        <span class="s0"># call a method on the remote server</span>

        <span class="s1">request = dumps(params</span><span class="s3">, </span><span class="s1">methodname</span><span class="s3">, </span><span class="s1">encoding=self.__encoding</span><span class="s3">,</span>
                        <span class="s1">allow_none=self.__allow_none).encode(self.__encoding)</span>

        <span class="s1">response = self.__transport.request(</span>
            <span class="s1">self.__host</span><span class="s3">,</span>
            <span class="s1">self.__handler</span><span class="s3">,</span>
            <span class="s1">request</span><span class="s3">,</span>
            <span class="s1">verbose=self.__verbose</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">len(response) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">response = response[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s3">return </span><span class="s1">response</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;ServerProxy for %s%s&gt;&quot; </span><span class="s1">%</span>
            <span class="s1">(self.__host</span><span class="s3">, </span><span class="s1">self.__handler)</span>
            <span class="s1">)</span>

    <span class="s1">__str__ = __repr__</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s0"># magic method dispatcher</span>
        <span class="s3">return </span><span class="s1">_Method(self.__request</span><span class="s3">, </span><span class="s1">name)</span>

    <span class="s0"># note: to call a remote object with an non-standard name, use</span>
    <span class="s0"># result getattr(server, &quot;strange-python-name&quot;)(args)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">attr):</span>
        <span class="s2">&quot;&quot;&quot;A workaround to get special attributes on the ServerProxy 
           without interfering with the magic __getattr__ 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">attr == </span><span class="s4">&quot;close&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.__close</span>
        <span class="s3">elif </span><span class="s1">attr == </span><span class="s4">&quot;transport&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.__transport</span>
        <span class="s3">raise </span><span class="s1">AttributeError(</span><span class="s4">&quot;Attribute %r not found&quot; </span><span class="s1">% (attr</span><span class="s3">,</span><span class="s1">))</span>

<span class="s0"># compatibility</span>

<span class="s1">Server = ServerProxy</span>

<span class="s0"># --------------------------------------------------------------------</span>
<span class="s0"># test code</span>

<span class="s3">if </span><span class="s1">__name__ == </span><span class="s4">&quot;__main__&quot;</span><span class="s1">:</span>

    <span class="s0"># simple test program (from the XML-RPC specification)</span>

    <span class="s0"># local server, available from Lib/xmlrpc/server.py</span>
    <span class="s1">server = ServerProxy(</span><span class="s4">&quot;http://localhost:8000&quot;</span><span class="s1">)</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">print(server.currentTime.getCurrentTime())</span>
    <span class="s3">except </span><span class="s1">Error </span><span class="s3">as </span><span class="s1">v:</span>
        <span class="s1">print(</span><span class="s4">&quot;ERROR&quot;</span><span class="s3">, </span><span class="s1">v)</span>

    <span class="s1">multi = MultiCall(server)</span>
    <span class="s1">multi.getData()</span>
    <span class="s1">multi.pow(</span><span class="s5">2</span><span class="s3">,</span><span class="s5">9</span><span class="s1">)</span>
    <span class="s1">multi.add(</span><span class="s5">1</span><span class="s3">,</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">response </span><span class="s3">in </span><span class="s1">multi():</span>
            <span class="s1">print(response)</span>
    <span class="s3">except </span><span class="s1">Error </span><span class="s3">as </span><span class="s1">v:</span>
        <span class="s1">print(</span><span class="s4">&quot;ERROR&quot;</span><span class="s3">, </span><span class="s1">v)</span>
</pre>
</body>
</html>