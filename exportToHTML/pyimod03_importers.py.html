<html>
<head>
<title>pyimod03_importers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pyimod03_importers.py</font>
</center></td></tr></table>
<pre><span class="s0">#-----------------------------------------------------------------------------</span>
<span class="s0"># Copyright (c) 2005-2021, PyInstaller Development Team.</span>
<span class="s0">#</span>
<span class="s0"># Distributed under the terms of the GNU General Public License (version 2</span>
<span class="s0"># or later) with exception for distributing the bootloader.</span>
<span class="s0">#</span>
<span class="s0"># The full license is in the file COPYING.txt, distributed with this software.</span>
<span class="s0">#</span>
<span class="s0"># SPDX-License-Identifier: (GPL-2.0-or-later WITH Bootloader-exception)</span>
<span class="s0">#-----------------------------------------------------------------------------</span>
<span class="s2">&quot;&quot;&quot; 
PEP-302 and PEP-451 importers for frozen applications. 
&quot;&quot;&quot;</span>

<span class="s0"># **NOTE** This module is used during bootstrap.</span>
<span class="s0"># Import *ONLY* builtin modules.</span>
<span class="s0"># List of built-in modules: sys.builtin_module_names</span>

<span class="s3">import </span><span class="s1">sys</span>

<span class="s3">import </span><span class="s1">_frozen_importlib</span>
<span class="s3">import </span><span class="s1">pyimod01_os_path </span><span class="s3">as </span><span class="s1">pyi_os_path</span>
<span class="s3">from </span><span class="s1">pyimod02_archive </span><span class="s3">import </span><span class="s1">ArchiveReadError</span><span class="s3">, </span><span class="s1">ZlibArchiveReader</span>

<span class="s1">SYS_PREFIX = sys._MEIPASS + pyi_os_path.os_sep</span>
<span class="s1">SYS_PREFIXLEN = len(SYS_PREFIX)</span>

<span class="s0"># In Python 3, it is recommended to use class 'types.ModuleType' to create a new module. However, 'types' module is</span>
<span class="s0"># not a built-in module. The 'types' module uses this trick with using type() function:</span>
<span class="s1">imp_new_module = type(sys)</span>

<span class="s3">if </span><span class="s1">sys.flags.verbose </span><span class="s3">and </span><span class="s1">sys.stderr:</span>

    <span class="s3">def </span><span class="s1">trace(msg</span><span class="s3">, </span><span class="s1">*a):</span>
        <span class="s1">sys.stderr.write(msg % a)</span>
        <span class="s1">sys.stderr.write(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
<span class="s3">else</span><span class="s1">:</span>

    <span class="s3">def </span><span class="s1">trace(msg</span><span class="s3">, </span><span class="s1">*a):</span>
        <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">FrozenPackageImporter(object):</span>
    <span class="s2">&quot;&quot;&quot; 
    Wrapper class for FrozenImporter that imports one specific fullname from a module named by an alternate fullname. 
    The alternate fullname is derived from the __path__ of the package module containing that module. 
 
    This is called by FrozenImporter.find_module whenever a module is found as a result of searching module.__path__ 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">importer</span><span class="s3">, </span><span class="s1">entry_name):</span>
        <span class="s1">self._entry_name = entry_name</span>
        <span class="s1">self._importer = importer</span>

    <span class="s3">def </span><span class="s1">load_module(self</span><span class="s3">, </span><span class="s1">fullname):</span>
        <span class="s0"># Deprecated in Python 3.4, see PEP-451.</span>
        <span class="s3">return </span><span class="s1">self._importer.load_module(fullname</span><span class="s3">, </span><span class="s1">self._entry_name)</span>


<span class="s3">def </span><span class="s1">_decode_source(source_bytes):</span>
    <span class="s2">&quot;&quot;&quot; 
    Decode bytes representing source code and return the string. Universal newline support is used in the decoding. 
    Based on CPython's implementation of the same functionality: 
    https://github.com/python/cpython/blob/3.9/Lib/importlib/_bootstrap_external.py#L679-L688 
    &quot;&quot;&quot;</span>
    <span class="s0"># Local imports to avoid bootstrap issues</span>
    <span class="s0"># NOTE: both modules are listed in compat.PY3_BASE_MODULES and collected into base_library.zip.</span>
    <span class="s3">import </span><span class="s1">io</span>
    <span class="s3">import </span><span class="s1">tokenize</span>

    <span class="s1">source_bytes_readline = io.BytesIO(source_bytes).readline</span>
    <span class="s1">encoding = tokenize.detect_encoding(source_bytes_readline)</span>
    <span class="s1">newline_decoder = io.IncrementalNewlineDecoder(decoder=</span><span class="s3">None, </span><span class="s1">translate=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">newline_decoder.decode(source_bytes.decode(encoding[</span><span class="s5">0</span><span class="s1">]))</span>


<span class="s3">class </span><span class="s1">FrozenImporter(object):</span>
    <span class="s2">&quot;&quot;&quot; 
    Load bytecode of Python modules from the executable created by PyInstaller. 
 
    Python bytecode is zipped and appended to the executable. 
 
    NOTE: PYZ format cannot be replaced by zipimport module. 
 
    The problem is that we have no control over zipimport; for instance, it does not work if the zip file is embedded 
    into a PKG that is appended to an executable, like we create in one-file mode. 
 
    This is PEP-302 finder and loader class for the ``sys.meta_path`` hook. A PEP-302 finder requires method 
    find_module() to return loader class with method load_module(). Both these methods are implemented in one class. 
 
    This is also a PEP-451 finder and loader class for the ModuleSpec type import system. A PEP-451 finder requires 
    method find_spec(), a PEP-451 loader requires methods exec_module(), load_module(9 and (optionally) create_module(). 
    All these methods are implemented in this one class. 
 
    To use this class just call: 
        FrozenImporter.install() 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Load, unzip and initialize the Zip archive bundled with the executable. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Examine all items in sys.path and the one like /path/executable_name?117568 is the correct executable with</span>
        <span class="s0"># the bundled zip archive. Use this value for the ZlibArchiveReader class, and remove this item from sys.path.</span>
        <span class="s0"># It was needed only for FrozenImporter class. Wrong path from sys.path raises an ArchiveReadError exception.</span>
        <span class="s3">for </span><span class="s1">pyz_filepath </span><span class="s3">in </span><span class="s1">sys.path:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s0"># Unzip zip archive bundled with the executable.</span>
                <span class="s1">self._pyz_archive = ZlibArchiveReader(pyz_filepath)</span>
                <span class="s0"># Verify the integrity of the zip archive with Python modules.</span>
                <span class="s0"># This is already done when creating the ZlibArchiveReader instance.</span>
                <span class="s0">#self._pyz_archive.checkmagic()</span>

                <span class="s0"># As no Exception was raised, we can assume that ZlibArchiveReader was successfully loaded.</span>
                <span class="s0"># Let's remove 'pyz_filepath' from sys.path.</span>
                <span class="s1">sys.path.remove(pyz_filepath)</span>
                <span class="s0"># Some runtime hook might need access to the list of available frozen modules. Let's make them</span>
                <span class="s0"># accessible as a set().</span>
                <span class="s1">self.toc = set(self._pyz_archive.toc.keys())</span>
                <span class="s0"># Return - no error was raised.</span>
                <span class="s1">trace(</span><span class="s4">&quot;# PyInstaller: FrozenImporter(%s)&quot;</span><span class="s3">, </span><span class="s1">pyz_filepath)</span>
                <span class="s3">return</span>
            <span class="s3">except </span><span class="s1">IOError:</span>
                <span class="s0"># Item from sys.path is not ZlibArchiveReader; let's try next one.</span>
                <span class="s3">continue</span>
            <span class="s3">except </span><span class="s1">ArchiveReadError:</span>
                <span class="s0"># Item from sys.path is not ZlibArchiveReader; let's try next one.</span>
                <span class="s3">continue</span>
        <span class="s0"># sys.path does not contain the filename of the executable with the bundled zip archive. Raise import error.</span>
        <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s4">&quot;Cannot load frozen modules.&quot;</span><span class="s1">)</span>

    <span class="s0"># Private helper</span>
    <span class="s3">def </span><span class="s1">_is_pep420_namespace_package(self</span><span class="s3">, </span><span class="s1">fullname):</span>
        <span class="s3">if </span><span class="s1">fullname </span><span class="s3">in </span><span class="s1">self.toc:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._pyz_archive.is_pep420_namespace_package(fullname)</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s4">'Loader FrozenImporter cannot handle module ' </span><span class="s1">+ fullname) </span><span class="s3">from </span><span class="s1">e</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s4">'Loader FrozenImporter cannot handle module ' </span><span class="s1">+ fullname)</span>

    <span class="s3">def </span><span class="s1">find_module(self</span><span class="s3">, </span><span class="s1">fullname</span><span class="s3">, </span><span class="s1">path=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># Deprecated in Python 3.4, see PEP-451</span>
        <span class="s2">&quot;&quot;&quot; 
        PEP-302 finder.find_module() method for the ``sys.meta_path`` hook. 
 
        fullname     fully qualified name of the module 
        path         None for a top-level module, or package.__path__ for submodules or subpackages. 
 
        Return a loader object if the module was found, or None if it was not. If find_module() raises an exception, 
        it will be propagated to the caller, aborting the import. 
        &quot;&quot;&quot;</span>
        <span class="s1">module_loader = </span><span class="s3">None  </span><span class="s0"># None means - no module found in this importer.</span>

        <span class="s3">if </span><span class="s1">fullname </span><span class="s3">in </span><span class="s1">self.toc:</span>
            <span class="s0"># Tell the import machinery to use self.load_module() to load the module.</span>
            <span class="s1">module_loader = self</span>
            <span class="s1">trace(</span><span class="s4">&quot;import %s # PyInstaller PYZ&quot;</span><span class="s3">, </span><span class="s1">fullname)</span>
        <span class="s3">elif </span><span class="s1">path </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># Try to handle module.__path__ modifications by the modules themselves.</span>
            <span class="s0"># Reverse the fake __path__ we added to the package module to a dotted module name, and add the tail module</span>
            <span class="s0"># from fullname onto that to synthesize a new fullname.</span>
            <span class="s1">modname = fullname.split(</span><span class="s4">'.'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>

            <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">path:</span>
                <span class="s3">if not </span><span class="s1">p.startswith(SYS_PREFIX):</span>
                    <span class="s3">continue</span>
                <span class="s1">p = p[SYS_PREFIXLEN:]</span>
                <span class="s1">parts = p.split(pyi_os_path.os_sep)</span>
                <span class="s3">if not </span><span class="s1">parts:</span>
                    <span class="s3">continue</span>
                <span class="s3">if not </span><span class="s1">parts[</span><span class="s5">0</span><span class="s1">]:</span>
                    <span class="s1">parts = parts[</span><span class="s5">1</span><span class="s1">:]</span>
                <span class="s1">parts.append(modname)</span>
                <span class="s1">entry_name = </span><span class="s4">&quot;.&quot;</span><span class="s1">.join(parts)</span>
                <span class="s3">if </span><span class="s1">entry_name </span><span class="s3">in </span><span class="s1">self.toc:</span>
                    <span class="s1">module_loader = FrozenPackageImporter(self</span><span class="s3">, </span><span class="s1">entry_name)</span>
                    <span class="s1">trace(</span><span class="s4">&quot;import %s as %s # PyInstaller PYZ (__path__ override: %s)&quot;</span><span class="s3">, </span><span class="s1">entry_name</span><span class="s3">, </span><span class="s1">fullname</span><span class="s3">, </span><span class="s1">p)</span>
                    <span class="s3">break</span>
        <span class="s0"># Release the interpreter's import lock.</span>
        <span class="s3">if </span><span class="s1">module_loader </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">trace(</span><span class="s4">&quot;# %s not found in PYZ&quot;</span><span class="s3">, </span><span class="s1">fullname)</span>
        <span class="s3">return </span><span class="s1">module_loader</span>

    <span class="s3">def </span><span class="s1">load_module(self</span><span class="s3">, </span><span class="s1">fullname</span><span class="s3">, </span><span class="s1">entry_name=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># Deprecated in Python 3.4, see PEP-451</span>
        <span class="s2">&quot;&quot;&quot; 
        PEP-302 loader.load_module() method for the ``sys.meta_path`` hook. 
 
        Return the loaded module (instance of imp_new_module()) or raise an exception, preferably ImportError if an 
        existing exception is not being propagated. 
 
        When called from FrozenPackageImporter, `entry_name` is the name of the module as it is stored in the archive. 
        This module will be loaded and installed into sys.modules using `fullname` as its name. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Acquire the interpreter's import lock.</span>
        <span class="s1">module = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">entry_name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">entry_name = fullname</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s0"># PEP302: if there is an existing module object named 'fullname' in sys.modules, the loader must use that</span>
            <span class="s0"># existing module.</span>
            <span class="s1">module = sys.modules.get(fullname)</span>

            <span class="s0"># Module not in sys.modules - load it and add it to sys.modules.</span>
            <span class="s3">if </span><span class="s1">module </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s0"># Load code object from the bundled ZIP archive.</span>
                <span class="s1">is_pkg</span><span class="s3">, </span><span class="s1">bytecode = self._pyz_archive.extract(entry_name)</span>
                <span class="s0"># Create new empty 'module' object.</span>
                <span class="s1">module = imp_new_module(fullname)</span>

                <span class="s0"># TODO: replace bytecode.co_filename by something more meaningful:</span>
                <span class="s0"># e.g., /absolute/path/frozen_executable/path/to/module/module_name.pyc</span>
                <span class="s0"># Paths from developer machine are masked.</span>

                <span class="s0"># Set __file__ attribute of a module relative to the executable, so that data files can be found.</span>
                <span class="s1">module.__file__ = self.get_filename(entry_name)</span>

                <span class="s0">#-- Set __path__  if 'fullname' is a package.</span>
                <span class="s0"># Python has modules and packages. A Python package is a container for several modules or packages.</span>
                <span class="s3">if </span><span class="s1">is_pkg:</span>
                    <span class="s0"># If a module has a __path__ attribute, the import mechanism will treat it as a package.</span>
                    <span class="s0">#</span>
                    <span class="s0"># Since PYTHONHOME is set in bootloader, 'sys.prefix' points to the correct path where PyInstaller</span>
                    <span class="s0"># should find bundled dynamic libraries. In one-file mode it points to the tmp directory where</span>
                    <span class="s0"># bundled files are extracted at execution time.</span>
                    <span class="s0">#</span>
                    <span class="s0"># __path__ cannot be empty list because 'wx' module prepends something to it. It cannot contain</span>
                    <span class="s0"># value 'sys.prefix' because 'xml.etree.cElementTree' fails otherwise.</span>
                    <span class="s0">#</span>
                    <span class="s0"># Set __path__ to point to 'sys.prefix/package/subpackage'.</span>
                    <span class="s1">module.__path__ = [pyi_os_path.os_path_dirname(module.__file__)]</span>

                <span class="s0">#-- Set __loader__</span>
                <span class="s0"># The attribute __loader__ improves support for module 'pkg_resources' and enables the following</span>
                <span class="s0"># functions within the frozen app: pkg_resources.resource_string(), pkg_resources.resource_stream().</span>
                <span class="s1">module.__loader__ = self</span>

                <span class="s0">#-- Set __package__</span>
                <span class="s0"># Accoring to PEP302, this attribute must be set. When it is present, relative imports will be based</span>
                <span class="s0"># on this attribute rather than the module __name__ attribute. More details can be found in PEP366.</span>
                <span class="s0"># For ordinary modules, this is set like: 'aa.bb.cc.dd' -&gt; 'aa.bb.cc'</span>
                <span class="s3">if </span><span class="s1">is_pkg:</span>
                    <span class="s1">module.__package__ = fullname</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">module.__package__ = fullname.rsplit(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>

                <span class="s0">#-- Set __spec__</span>
                <span class="s0"># Python 3.4 introduced module attribute __spec__ to consolidate all module attributes.</span>
                <span class="s1">module.__spec__ = _frozen_importlib.ModuleSpec(entry_name</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">is_package=is_pkg)</span>

                <span class="s0">#-- Add module object to sys.modules dictionary.</span>
                <span class="s0"># Module object must be in sys.modules before the loader executes the module code. This is crucial</span>
                <span class="s0"># because the module code may (directly or indirectly) import itself; adding it to sys.modules</span>
                <span class="s0"># beforehand prevents unbounded recursion in the worst case and multiple loading in the best.</span>
                <span class="s1">sys.modules[fullname] = module</span>

                <span class="s0"># Run the module code.</span>
                <span class="s1">exec(bytecode</span><span class="s3">, </span><span class="s1">module.__dict__)</span>
                <span class="s0"># Reread the module from sys.modules in case it has changed itself.</span>
                <span class="s1">module = sys.modules[fullname]</span>

        <span class="s3">except </span><span class="s1">Exception:</span>
            <span class="s0"># Remove 'fullname' from sys.modules if it was appended there.</span>
            <span class="s3">if </span><span class="s1">fullname </span><span class="s3">in </span><span class="s1">sys.modules:</span>
                <span class="s1">sys.modules.pop(fullname)</span>
            <span class="s0"># TODO: do we need to raise different types of Exceptions for better debugging?</span>
            <span class="s0"># PEP302 requires to raise ImportError exception.</span>
            <span class="s0">#raise ImportError(&quot;Can't load frozen module: %s&quot; % fullname)</span>
            <span class="s3">raise</span>

        <span class="s0"># Module returned only in case of no exception.</span>
        <span class="s3">return </span><span class="s1">module</span>

    <span class="s0">#-- Optional Extensions to the PEP-302 Importer Protocol --</span>

    <span class="s3">def </span><span class="s1">is_package(self</span><span class="s3">, </span><span class="s1">fullname):</span>
        <span class="s3">if </span><span class="s1">fullname </span><span class="s3">in </span><span class="s1">self.toc:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._pyz_archive.is_package(fullname)</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s4">'Loader FrozenImporter cannot handle module ' </span><span class="s1">+ fullname) </span><span class="s3">from </span><span class="s1">e</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s4">'Loader FrozenImporter cannot handle module ' </span><span class="s1">+ fullname)</span>

    <span class="s3">def </span><span class="s1">get_code(self</span><span class="s3">, </span><span class="s1">fullname):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the code object associated with the module. 
 
        ImportError should be raised if module not found. 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">fullname == </span><span class="s4">'__main__'</span><span class="s1">:</span>
                <span class="s0"># Special handling for __main__ module; the bootloader should store code object to _pyi_main_co</span>
                <span class="s0"># attribute of the module.</span>
                <span class="s3">return </span><span class="s1">sys.modules[</span><span class="s4">'__main__'</span><span class="s1">]._pyi_main_co</span>

            <span class="s0"># extract() returns None if fullname is not in the archive, and the subsequent subscription attempt raises</span>
            <span class="s0"># exception, which is turned into ImportError.</span>
            <span class="s3">return </span><span class="s1">self._pyz_archive.extract(fullname)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s4">'Loader FrozenImporter cannot handle module ' </span><span class="s1">+ fullname) </span><span class="s3">from </span><span class="s1">e</span>

    <span class="s3">def </span><span class="s1">get_source(self</span><span class="s3">, </span><span class="s1">fullname):</span>
        <span class="s2">&quot;&quot;&quot; 
        Method should return the source code for the module as a string. 
        But frozen modules does not contain source code. 
 
        Return None, unless the corresponding source file was explicitly collected to the filesystem. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">fullname </span><span class="s3">in </span><span class="s1">self.toc:</span>
            <span class="s0"># Try loading the .py file from the filesystem (only for collected modules)</span>
            <span class="s3">if </span><span class="s1">self.is_package(fullname):</span>
                <span class="s1">fullname += </span><span class="s4">'.__init__'</span>
            <span class="s1">filename = pyi_os_path.os_path_join(SYS_PREFIX</span><span class="s3">, </span><span class="s1">fullname.replace(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s1">pyi_os_path.os_sep) + </span><span class="s4">'.py'</span><span class="s1">)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s0"># Read in binary mode, then decode</span>
                <span class="s3">with </span><span class="s1">open(filename</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">fp:</span>
                    <span class="s1">source_bytes = fp.read()</span>
                <span class="s3">return </span><span class="s1">_decode_source(source_bytes)</span>
            <span class="s3">except </span><span class="s1">FileNotFoundError:</span>
                <span class="s3">pass</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># ImportError should be raised if module not found.</span>
            <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s4">'No module named ' </span><span class="s1">+ fullname)</span>

    <span class="s3">def </span><span class="s1">get_data(self</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns the data as a string, or raises IOError if the &quot;file&quot; was not found. The data is always returned as if 
        &quot;binary&quot; mode was used. 
 
        This method is useful for getting resources with 'pkg_resources' that are bundled with Python modules in the 
        PYZ archive. 
 
        The 'path' argument is a path that can be constructed by munging module.__file__ (or pkg.__path__ items). 
        &quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">path.startswith(SYS_PREFIX)</span>
        <span class="s1">fullname = path[SYS_PREFIXLEN:]</span>
        <span class="s3">if </span><span class="s1">fullname </span><span class="s3">in </span><span class="s1">self.toc:</span>
            <span class="s0"># If the file is in the archive, return this</span>
            <span class="s3">return </span><span class="s1">self._pyz_archive.extract(fullname)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Otherwise try to fetch it from the filesystem. Since __file__ attribute works properly, just try to open</span>
            <span class="s0"># and read it.</span>
            <span class="s3">with </span><span class="s1">open(path</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">fp:</span>
                <span class="s3">return </span><span class="s1">fp.read()</span>

    <span class="s3">def </span><span class="s1">get_filename(self</span><span class="s3">, </span><span class="s1">fullname):</span>
        <span class="s2">&quot;&quot;&quot; 
        This method should return the value that __file__ would be set to if the named module was loaded. If the module 
        is not found, an ImportError should be raised. 
        &quot;&quot;&quot;</span>
        <span class="s0"># The absolute absolute path to the executable is taken from sys.prefix. In onefile mode it points to the temp</span>
        <span class="s0"># directory where files are unpacked by PyInstaller. Then, append the appropriate suffix (__init__.pyc for a</span>
        <span class="s0"># package, or just .pyc for a module).</span>
        <span class="s0"># Method is_package() will raise ImportError if module not found.</span>
        <span class="s3">if </span><span class="s1">self.is_package(fullname):</span>
            <span class="s1">filename = pyi_os_path.os_path_join(</span>
                <span class="s1">pyi_os_path.os_path_join(SYS_PREFIX</span><span class="s3">, </span><span class="s1">fullname.replace(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s1">pyi_os_path.os_sep))</span><span class="s3">, </span><span class="s4">'__init__.pyc'</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">filename = pyi_os_path.os_path_join(SYS_PREFIX</span><span class="s3">, </span><span class="s1">fullname.replace(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s1">pyi_os_path.os_sep) + </span><span class="s4">'.pyc'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">filename</span>

    <span class="s3">def </span><span class="s1">find_spec(self</span><span class="s3">, </span><span class="s1">fullname</span><span class="s3">, </span><span class="s1">path=</span><span class="s3">None, </span><span class="s1">target=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        PEP-451 finder.find_spec() method for the ``sys.meta_path`` hook. 
 
        fullname     fully qualified name of the module 
        path         None for a top-level module, or package.__path__ for 
                     submodules or subpackages. 
        target       unused by this Finder 
 
        Finders are still responsible for identifying, and typically creating, the loader that should be used to load a 
        module. That loader will now be stored in the module spec returned by find_spec() rather than returned directly. 
        As is currently the case without the PEP-452, if a loader would be costly to create, that loader can be designed 
        to defer the cost until later. 
 
        Finders must return ModuleSpec objects when find_spec() is called. This new method replaces find_module() and 
        find_loader() (in the PathEntryFinder case). If a loader does not have find_spec(), find_module() and 
        find_loader() are used instead, for backward-compatibility. 
        &quot;&quot;&quot;</span>
        <span class="s1">entry_name = </span><span class="s3">None  </span><span class="s0"># None means - no module found in this importer.</span>

        <span class="s3">if </span><span class="s1">fullname </span><span class="s3">in </span><span class="s1">self.toc:</span>
            <span class="s1">entry_name = fullname</span>
            <span class="s1">trace(</span><span class="s4">&quot;import %s # PyInstaller PYZ&quot;</span><span class="s3">, </span><span class="s1">fullname)</span>
        <span class="s3">elif </span><span class="s1">path </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># Try to handle module.__path__ modifications by the modules themselves.</span>
            <span class="s0"># Reverse the fake __path__ we added to the package module into a dotted module name, and add the tail</span>
            <span class="s0"># module from fullname onto that to synthesize a new fullname.</span>
            <span class="s1">modname = fullname.rsplit(</span><span class="s4">'.'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>

            <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">path:</span>
                <span class="s3">if not </span><span class="s1">p.startswith(SYS_PREFIX):</span>
                    <span class="s3">continue</span>
                <span class="s1">p = p[SYS_PREFIXLEN:]</span>
                <span class="s1">parts = p.split(pyi_os_path.os_sep)</span>
                <span class="s3">if not </span><span class="s1">parts:</span>
                    <span class="s3">continue</span>
                <span class="s3">if not </span><span class="s1">parts[</span><span class="s5">0</span><span class="s1">]:</span>
                    <span class="s1">parts = parts[</span><span class="s5">1</span><span class="s1">:]</span>
                <span class="s1">parts.append(modname)</span>
                <span class="s1">entry_name = </span><span class="s4">&quot;.&quot;</span><span class="s1">.join(parts)</span>
                <span class="s3">if </span><span class="s1">entry_name </span><span class="s3">in </span><span class="s1">self.toc:</span>
                    <span class="s1">trace(</span><span class="s4">&quot;import %s as %s # PyInstaller PYZ (__path__ override: %s)&quot;</span><span class="s3">, </span><span class="s1">entry_name</span><span class="s3">, </span><span class="s1">fullname</span><span class="s3">, </span><span class="s1">p)</span>
                    <span class="s3">break</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">entry_name = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">entry_name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">trace(</span><span class="s4">&quot;# %s not found in PYZ&quot;</span><span class="s3">, </span><span class="s1">fullname)</span>
            <span class="s3">return None</span>

        <span class="s3">if </span><span class="s1">self._is_pep420_namespace_package(entry_name):</span>
            <span class="s0"># PEP-420 namespace package; as per PEP 451, we need to return a spec with &quot;loader&quot; set to None</span>
            <span class="s0"># (a.k.a. not set)</span>
            <span class="s1">spec = _frozen_importlib.ModuleSpec(fullname</span><span class="s3">, None, </span><span class="s1">is_package=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s0"># Set submodule_search_locations, which seems to fill the __path__ attribute.</span>
            <span class="s1">spec.submodule_search_locations = [pyi_os_path.os_path_dirname(self.get_filename(entry_name))]</span>
            <span class="s3">return </span><span class="s1">spec</span>

        <span class="s0"># origin has to be the filename</span>
        <span class="s1">origin = self.get_filename(entry_name)</span>
        <span class="s1">is_pkg = self.is_package(entry_name)</span>

        <span class="s1">spec = _frozen_importlib.ModuleSpec(</span>
            <span class="s1">fullname</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">is_package=is_pkg</span><span class="s3">,</span>
            <span class="s1">origin=origin</span><span class="s3">,</span>
            <span class="s0"># Provide the entry_name for the loader to use during loading.</span>
            <span class="s1">loader_state=entry_name</span>
        <span class="s1">)</span>

        <span class="s0"># Make the import machinery set __file__.</span>
        <span class="s0"># PEP 451 says: &quot;has_location&quot; is true if the module is locatable. In that case the spec's origin is used</span>
        <span class="s0"># as the location and __file__ is set to spec.origin. If additional location information is required</span>
        <span class="s0"># (e.g., zipimport), that information may be stored in spec.loader_state.</span>
        <span class="s1">spec.has_location = </span><span class="s3">True</span>

        <span class="s0"># Set submodule_search_locations for packages. Seems to be required for importlib_resources from 3.2.0;</span>
        <span class="s0"># see issue #5395.</span>
        <span class="s3">if </span><span class="s1">is_pkg:</span>
            <span class="s1">spec.submodule_search_locations = [pyi_os_path.os_path_dirname(self.get_filename(entry_name))]</span>

        <span class="s3">return </span><span class="s1">spec</span>

    <span class="s3">def </span><span class="s1">create_module(self</span><span class="s3">, </span><span class="s1">spec):</span>
        <span class="s2">&quot;&quot;&quot; 
        PEP-451 loader.create_module() method for the ``sys.meta_path`` hook. 
 
        Loaders may also implement create_module() that will return a new module to exec. It may return None to indicate 
        that the default module creation code should be used. One use case, though atypical, for create_module() is to 
        provide a module that is a subclass of the builtin module type. Most loaders will not need to implement 
        create_module(). 
 
        create_module() should properly handle the case where it is called more than once for the same spec/module. This 
        may include returning None or raising ImportError. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Contrary to what is defined in PEP-451, this method is not optional. We want the default results, so we simply</span>
        <span class="s0"># return None (which is handled for su my the import machinery).</span>
        <span class="s0"># See https://bugs.python.org/issue23014 for more information.</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">exec_module(self</span><span class="s3">, </span><span class="s1">module):</span>
        <span class="s2">&quot;&quot;&quot; 
        PEP-451 loader.exec_module() method for the ``sys.meta_path`` hook. 
 
        Loaders will have a new method, exec_module(). Its only job is to &quot;exec&quot; the module and consequently populate 
        the module's namespace. It is not responsible for creating or preparing the module object, nor for any cleanup 
        afterward. It has no return value. exec_module() will be used during both loading and reloading. 
 
        exec_module() should properly handle the case where it is called more than once. For some kinds of modules this 
        may mean raising ImportError every time after the first time the method is called. This is particularly relevant 
        for reloading, where some kinds of modules do not support in-place reloading. 
        &quot;&quot;&quot;</span>
        <span class="s1">spec = module.__spec__</span>
        <span class="s1">bytecode = self.get_code(spec.loader_state)</span>

        <span class="s0"># Set by the import machinery</span>
        <span class="s3">assert </span><span class="s1">hasattr(module</span><span class="s3">, </span><span class="s4">'__file__'</span><span class="s1">)</span>

        <span class="s0"># If `submodule_search_locations` is not None, this is a package; set __path__.</span>
        <span class="s3">if </span><span class="s1">spec.submodule_search_locations </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># Since PYTHONHOME is set in bootloader, 'sys.prefix' points to the correct path where PyInstaller should</span>
            <span class="s0"># find bundled dynamic libraries. In one-file mode it points to the tmp directory where bundled files are</span>
            <span class="s0"># extracted at execution time.</span>
            <span class="s0">#</span>
            <span class="s0"># __path__ cannot be empty list because 'wx' module prepends something to it. It cannot contain value</span>
            <span class="s0"># 'sys.prefix' because 'xml.etree.cElementTree' fails otherwise.</span>
            <span class="s0">#</span>
            <span class="s0"># Set __path__ to point to 'sys.prefix/package/subpackage'.</span>
            <span class="s1">module.__path__ = [pyi_os_path.os_path_dirname(module.__file__)]</span>

        <span class="s1">exec(bytecode</span><span class="s3">, </span><span class="s1">module.__dict__)</span>

    <span class="s3">def </span><span class="s1">get_resource_reader(self</span><span class="s3">, </span><span class="s1">fullname):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return importlib.resource-compatible resource reader. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">FrozenResourceReader(self</span><span class="s3">, </span><span class="s1">fullname)</span>


<span class="s3">class </span><span class="s1">FrozenResourceReader:</span>
    <span class="s2">&quot;&quot;&quot; 
    Resource reader for importlib.resources / importlib_resources support. 
 
    Currently supports only on-disk resources (support for resources from the embedded archive is missing). 
    However, this should cover the typical use cases (access to data files), as PyInstaller collects data files onto 
    filesystem, and only .pyc modules are collected into embedded archive. One exception are resources collected from 
    zipped eggs (which end up collected into embedded archive), but those should be rare anyway. 
 
    When listing resources, source .py files will not be listed as they are not collected by default. Similarly, 
    sub-directories that contained only .py files are not reconstructed on filesystem, so they will not be listed, 
    either. If access to .py files is required for whatever reason, they need to be explicitly collected as data files 
    anyway, which will place them on filesystem and make them appear as resources. 
 
    For on-disk resources, we *must* return path compatible with pathlib.Path() in order to avoid copy to a temporary 
    file, which might break under some circumstances, e.g., metpy with importlib_resources back-port, due to: 
    https://github.com/Unidata/MetPy/blob/a3424de66a44bf3a92b0dcacf4dff82ad7b86712/src/metpy/plots/wx_symbols.py#L24-L25 
    (importlib_resources tries to use 'fonts/wx_symbols.ttf' as a temporary filename suffix, which fails as it contains 
    a separator). 
 
    Furthermore, some packages expect files() to return either pathlib.Path or zipfile.Path, e.g., 
    https://github.com/tensorflow/datasets/blob/master/tensorflow_datasets/core/utils/resource_utils.py#L81-L97 
    This makes implementation of mixed support for on-disk and embedded resources using importlib.abc.Traversable 
    protocol rather difficult. 
 
    So in order to maximize compatibility with unfrozen behavior, the below implementation is basically equivalent of 
    importlib.readers.FileReader from python 3.10: 
      https://github.com/python/cpython/blob/839d7893943782ee803536a47f1d4de160314f85/Lib/importlib/readers.py#L11 
    and its underlying classes, importlib.abc.TraversableResources and importlib.abc.ResourceReader: 
      https://github.com/python/cpython/blob/839d7893943782ee803536a47f1d4de160314f85/Lib/importlib/abc.py#L422 
      https://github.com/python/cpython/blob/839d7893943782ee803536a47f1d4de160314f85/Lib/importlib/abc.py#L312 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">importer</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">import </span><span class="s1">pathlib  </span><span class="s0"># Local import to avoid bootstrap issues.</span>
        <span class="s1">self.importer = importer</span>
        <span class="s1">self.path = pathlib.Path(sys._MEIPASS).joinpath(*name.split(</span><span class="s4">'.'</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">open_resource(self</span><span class="s3">, </span><span class="s1">resource):</span>
        <span class="s3">return </span><span class="s1">self.files().joinpath(resource).open(</span><span class="s4">'rb'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">resource_path(self</span><span class="s3">, </span><span class="s1">resource):</span>
        <span class="s3">return </span><span class="s1">str(self.path.joinpath(resource))</span>

    <span class="s3">def </span><span class="s1">is_resource(self</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s3">return </span><span class="s1">self.files().joinpath(path).is_file()</span>

    <span class="s3">def </span><span class="s1">contents(self):</span>
        <span class="s3">return </span><span class="s1">(item.name </span><span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">self.files().iterdir())</span>

    <span class="s3">def </span><span class="s1">files(self):</span>
        <span class="s3">return </span><span class="s1">self.path</span>


<span class="s3">def </span><span class="s1">install():</span>
    <span class="s2">&quot;&quot;&quot; 
    Install FrozenImporter class and other classes into the import machinery. 
 
    This function installs the FrozenImporter class into the import machinery of the running process. The importer is 
    added to sys.meta_path. It could be added to sys.path_hooks, but sys.meta_path is processed by Python before 
    looking at sys.path! 
 
    The order of processing import hooks in sys.meta_path: 
 
    1. built-in modules 
    2. modules from the bundled ZIP archive 
    3. C extension modules 
    4. Modules from sys.path 
    &quot;&quot;&quot;</span>
    <span class="s0"># Ensure Python looks in the bundled zip archive for modules before any other places.</span>
    <span class="s1">fimp = FrozenImporter()</span>
    <span class="s1">sys.meta_path.append(fimp)</span>

    <span class="s0"># On Windows there is importer _frozen_importlib.WindowsRegistryFinder that looks for Python modules in Windows</span>
    <span class="s0"># registry. The frozen executable should not look for anything in the Windows registry. Remove this importer</span>
    <span class="s0"># from sys.meta_path.</span>
    <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">sys.meta_path:</span>
        <span class="s3">if </span><span class="s1">hasattr(item</span><span class="s3">, </span><span class="s4">'__name__'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">item.__name__ == </span><span class="s4">'WindowsRegistryFinder'</span><span class="s1">:</span>
            <span class="s1">sys.meta_path.remove(item)</span>
            <span class="s3">break</span>
    <span class="s0"># _frozen_importlib.PathFinder is also able to handle Python C extensions. However, PyInstaller needs its own</span>
    <span class="s0"># importer as it uses extension names like 'module.submodle.so' (instead of paths). As of Python 3.7.0b2, there</span>
    <span class="s0"># are several PathFinder instances (and duplicate ones) on sys.meta_path. This propobly is a bug, see</span>
    <span class="s0"># https://bugs.python.org/issue33128. Thus we need to move all of them to the end, and eliminate the duplicates.</span>
    <span class="s1">pathFinders = []</span>
    <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">reversed(sys.meta_path):</span>
        <span class="s3">if </span><span class="s1">getattr(item</span><span class="s3">, </span><span class="s4">'__name__'</span><span class="s3">, None</span><span class="s1">) == </span><span class="s4">'PathFinder'</span><span class="s1">:</span>
            <span class="s1">sys.meta_path.remove(item)</span>
            <span class="s3">if </span><span class="s1">item </span><span class="s3">not in </span><span class="s1">pathFinders:</span>
                <span class="s1">pathFinders.append(item)</span>
    <span class="s1">sys.meta_path.extend(reversed(pathFinders))</span>
    <span class="s0"># TODO: do we need _frozen_importlib.FrozenImporter in Python 3? Could it be also removed?</span>

    <span class="s0"># Set the FrozenImporter as loader for __main__, in order for python to treat __main__ as a module instead of</span>
    <span class="s0"># a built-in.</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">sys.modules[</span><span class="s4">'__main__'</span><span class="s1">].__loader__ = fimp</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s3">pass</span>
</pre>
</body>
</html>