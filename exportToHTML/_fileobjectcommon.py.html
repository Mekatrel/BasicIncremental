<html>
<head>
<title>_fileobjectcommon.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_fileobjectcommon.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
gevent internals. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">absolute_import</span><span class="s2">, </span><span class="s1">print_function</span><span class="s2">, </span><span class="s1">division</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">errno </span><span class="s2">import </span><span class="s1">EBADF</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">EBADF = </span><span class="s3">9</span>

<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os</span>

<span class="s2">from </span><span class="s1">gevent.hub </span><span class="s2">import </span><span class="s1">_get_hub_noargs </span><span class="s2">as </span><span class="s1">get_hub</span>
<span class="s2">from </span><span class="s1">gevent._compat </span><span class="s2">import </span><span class="s1">PY2</span>
<span class="s2">from </span><span class="s1">gevent._compat </span><span class="s2">import </span><span class="s1">integer_types</span>
<span class="s2">from </span><span class="s1">gevent._compat </span><span class="s2">import </span><span class="s1">reraise</span>
<span class="s2">from </span><span class="s1">gevent._compat </span><span class="s2">import </span><span class="s1">fspath</span>
<span class="s2">from </span><span class="s1">gevent.lock </span><span class="s2">import </span><span class="s1">Semaphore</span><span class="s2">, </span><span class="s1">DummySemaphore</span>

<span class="s2">class </span><span class="s1">cancel_wait_ex(IOError):</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">IOError.__init__(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">EBADF</span><span class="s2">, </span><span class="s4">'File descriptor was closed in another greenlet'</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">FileObjectClosed(IOError):</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">IOError.__init__(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">EBADF</span><span class="s2">, </span><span class="s4">'Bad file descriptor (FileObject was closed)'</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">UniversalNewlineBytesWrapper(io.TextIOWrapper):</span>
    <span class="s0">&quot;&quot;&quot; 
    Uses TextWrapper to decode universal newlines, but returns the 
    results as bytes. 
 
    This is for Python 2 where the 'rU' mode did that. 
    &quot;&quot;&quot;</span>
    <span class="s1">mode = </span><span class="s2">None</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fobj</span><span class="s2">, </span><span class="s1">line_buffering):</span>
        <span class="s5"># latin-1 has the ability to round-trip arbitrary bytes.</span>
        <span class="s1">io.TextIOWrapper.__init__(self</span><span class="s2">, </span><span class="s1">fobj</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s4">'latin-1'</span><span class="s2">,</span>
                                  <span class="s1">newline=</span><span class="s2">None,</span>
                                  <span class="s1">line_buffering=line_buffering)</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">result = io.TextIOWrapper.read(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">result.encode(</span><span class="s4">'latin-1'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">readline(self</span><span class="s2">, </span><span class="s1">limit=-</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">result = io.TextIOWrapper.readline(self</span><span class="s2">, </span><span class="s1">limit)</span>
        <span class="s2">return </span><span class="s1">result.encode(</span><span class="s4">'latin-1'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s5"># readlines() is implemented in terms of __iter__</span>
        <span class="s5"># and TextIOWrapper.__iter__ checks that readline returns</span>
        <span class="s5"># a unicode object, which we don't, so we override</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__next__(self):</span>
        <span class="s1">line = self.readline()</span>
        <span class="s2">if not </span><span class="s1">line:</span>
            <span class="s2">raise </span><span class="s1">StopIteration</span>
        <span class="s2">return </span><span class="s1">line</span>

    <span class="s1">next = __next__</span>


<span class="s2">class </span><span class="s1">FlushingBufferedWriter(io.BufferedWriter):</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s1">ret = io.BufferedWriter.write(self</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">self.flush()</span>
        <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">class </span><span class="s1">WriteallMixin(object):</span>

    <span class="s2">def </span><span class="s1">writeall(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot; 
        Similar to :meth:`socket.socket.sendall`, ensures that all the contents of 
        *value* have been written (though not necessarily flushed) before returning. 
 
        Returns the length of *value*. 
 
        .. versionadded:: 20.12.0 
        &quot;&quot;&quot;</span>
        <span class="s5"># Do we need to play the same get_memory games we do with sockets?</span>
        <span class="s5"># And what about chunking for large values? See _socketcommon.py</span>
        <span class="s1">write = super(WriteallMixin</span><span class="s2">, </span><span class="s1">self).write</span>

        <span class="s1">total = len(value)</span>
        <span class="s2">while </span><span class="s1">value:</span>
            <span class="s1">l = len(value)</span>
            <span class="s1">w = write(value)</span>
            <span class="s2">if </span><span class="s1">w == l:</span>
                <span class="s2">break</span>
            <span class="s1">value = value[w:]</span>
        <span class="s2">return </span><span class="s1">total</span>


<span class="s2">class </span><span class="s1">FileIO(io.FileIO):</span>
    <span class="s0">&quot;&quot;&quot;A subclass that we can dynamically assign __class__ for.&quot;&quot;&quot;</span>
    <span class="s1">__slots__ = ()</span>


<span class="s2">class </span><span class="s1">WriteIsWriteallMixin(WriteallMixin):</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">return </span><span class="s1">self.writeall(value)</span>


<span class="s2">class </span><span class="s1">WriteallFileIO(WriteIsWriteallMixin</span><span class="s2">, </span><span class="s1">io.FileIO):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">OpenDescriptor(object): </span><span class="s5"># pylint:disable=too-many-instance-attributes</span>
    <span class="s0">&quot;&quot;&quot; 
    Interprets the arguments to `open`. Internal use only. 
 
    Originally based on code in the stdlib's _pyio.py (Python implementation of 
    the :mod:`io` module), but modified for gevent: 
 
    - Native strings are returned on Python 2 when neither 
      'b' nor 't' are in the mode string and no encoding is specified. 
    - Universal newlines work in that mode. 
    - Allows externally unbuffered text IO. 
 
    :keyword bool atomic_write: If true, then if the opened, wrapped, stream 
        is unbuffered (meaning that ``write`` can produce short writes and the return 
        value needs to be checked), then the implementation will be adjusted so that 
        ``write`` behaves like Python 2 on a built-in file object and writes the 
        entire value. Only set this on Python 2; the only intended user is 
        :class:`gevent.subprocess.Popen`. 
    &quot;&quot;&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_collapse_arg(pref_name</span><span class="s2">, </span><span class="s1">preferred_val</span><span class="s2">, </span><span class="s1">old_name</span><span class="s2">, </span><span class="s1">old_val</span><span class="s2">, </span><span class="s1">default):</span>
        <span class="s5"># We could play tricks with the callers ``locals()`` to avoid having to specify</span>
        <span class="s5"># the name (which we only use for error handling) but ``locals()`` may be slow and</span>
        <span class="s5"># inhibit JIT (on PyPy), so we just write it out long hand.</span>
        <span class="s2">if </span><span class="s1">preferred_val </span><span class="s2">is not None and </span><span class="s1">old_val </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot specify both %s=%s and %s=%s&quot; </span><span class="s1">% (</span>
                <span class="s1">pref_name</span><span class="s2">, </span><span class="s1">preferred_val</span><span class="s2">,</span>
                <span class="s1">old_name</span><span class="s2">, </span><span class="s1">old_val</span>
            <span class="s1">))</span>
        <span class="s2">if </span><span class="s1">preferred_val </span><span class="s2">is None and </span><span class="s1">old_val </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">default</span>
        <span class="s2">return </span><span class="s1">preferred_val </span><span class="s2">if </span><span class="s1">preferred_val </span><span class="s2">is not None else </span><span class="s1">old_val</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fobj</span><span class="s2">, </span><span class="s1">mode=</span><span class="s4">'r'</span><span class="s2">, </span><span class="s1">bufsize=</span><span class="s2">None, </span><span class="s1">close=</span><span class="s2">None,</span>
                 <span class="s1">encoding=</span><span class="s2">None, </span><span class="s1">errors=</span><span class="s2">None, </span><span class="s1">newline=</span><span class="s2">None,</span>
                 <span class="s1">buffering=</span><span class="s2">None, </span><span class="s1">closefd=</span><span class="s2">None,</span>
                 <span class="s1">atomic_write=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s5"># Based on code in the stdlib's _pyio.py from 3.8.</span>
        <span class="s5"># pylint:disable=too-many-locals,too-many-branches,too-many-statements</span>

        <span class="s1">closefd = self._collapse_arg(</span><span class="s4">'closefd'</span><span class="s2">, </span><span class="s1">closefd</span><span class="s2">, </span><span class="s4">'close'</span><span class="s2">, </span><span class="s1">close</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s2">del </span><span class="s1">close</span>
        <span class="s1">buffering = self._collapse_arg(</span><span class="s4">'buffering'</span><span class="s2">, </span><span class="s1">buffering</span><span class="s2">, </span><span class="s4">'bufsize'</span><span class="s2">, </span><span class="s1">bufsize</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s2">del </span><span class="s1">bufsize</span>

        <span class="s2">if not </span><span class="s1">hasattr(fobj</span><span class="s2">, </span><span class="s4">'fileno'</span><span class="s1">):</span>
            <span class="s2">if not </span><span class="s1">isinstance(fobj</span><span class="s2">, </span><span class="s1">integer_types):</span>
                <span class="s5"># Not a fd. Support PathLike on Python 2 and Python &lt;= 3.5.</span>
                <span class="s1">fobj = fspath(fobj)</span>
            <span class="s2">if not </span><span class="s1">isinstance(fobj</span><span class="s2">, </span><span class="s1">(str</span><span class="s2">, </span><span class="s1">bytes) + integer_types): </span><span class="s5"># pragma: no cover</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;invalid file: %r&quot; </span><span class="s1">% fobj)</span>
            <span class="s2">if </span><span class="s1">isinstance(fobj</span><span class="s2">, </span><span class="s1">(str</span><span class="s2">, </span><span class="s1">bytes)):</span>
                <span class="s1">closefd = </span><span class="s2">True</span>

        <span class="s2">if not </span><span class="s1">isinstance(mode</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;invalid mode: %r&quot; </span><span class="s1">% mode)</span>
        <span class="s2">if not </span><span class="s1">isinstance(buffering</span><span class="s2">, </span><span class="s1">integer_types):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;invalid buffering: %r&quot; </span><span class="s1">% buffering)</span>
        <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is not None and not </span><span class="s1">isinstance(encoding</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;invalid encoding: %r&quot; </span><span class="s1">% encoding)</span>
        <span class="s2">if </span><span class="s1">errors </span><span class="s2">is not None and not </span><span class="s1">isinstance(errors</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;invalid errors: %r&quot; </span><span class="s1">% errors)</span>

        <span class="s1">modes = set(mode)</span>
        <span class="s2">if </span><span class="s1">modes - set(</span><span class="s4">&quot;axrwb+tU&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">len(mode) &gt; len(modes):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;invalid mode: %r&quot; </span><span class="s1">% mode)</span>

        <span class="s1">creating = </span><span class="s4">&quot;x&quot; </span><span class="s2">in </span><span class="s1">modes</span>
        <span class="s1">reading = </span><span class="s4">&quot;r&quot; </span><span class="s2">in </span><span class="s1">modes</span>
        <span class="s1">writing = </span><span class="s4">&quot;w&quot; </span><span class="s2">in </span><span class="s1">modes</span>
        <span class="s1">appending = </span><span class="s4">&quot;a&quot; </span><span class="s2">in </span><span class="s1">modes</span>
        <span class="s1">updating = </span><span class="s4">&quot;+&quot; </span><span class="s2">in </span><span class="s1">modes</span>
        <span class="s1">text = </span><span class="s4">&quot;t&quot; </span><span class="s2">in </span><span class="s1">modes</span>
        <span class="s1">binary = </span><span class="s4">&quot;b&quot; </span><span class="s2">in </span><span class="s1">modes</span>
        <span class="s1">universal = </span><span class="s4">'U' </span><span class="s2">in </span><span class="s1">modes</span>

        <span class="s1">can_write = creating </span><span class="s2">or </span><span class="s1">writing </span><span class="s2">or </span><span class="s1">appending </span><span class="s2">or </span><span class="s1">updating</span>

        <span class="s2">if </span><span class="s1">universal:</span>
            <span class="s2">if </span><span class="s1">can_write:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;mode U cannot be combined with 'x', 'w', 'a', or '+'&quot;</span><span class="s1">)</span>
            <span class="s5"># Just because the stdlib deprecates this, no need for us to do so as well.</span>
            <span class="s5"># Especially not while we still support Python 2.</span>
            <span class="s5"># import warnings</span>
            <span class="s5"># warnings.warn(&quot;'U' mode is deprecated&quot;,</span>
            <span class="s5">#               DeprecationWarning, 4)</span>
            <span class="s1">reading = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">text </span><span class="s2">and </span><span class="s1">binary:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;can't have text and binary mode at once&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">creating + reading + writing + appending &gt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;can't have read/write/append mode at once&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">(creating </span><span class="s2">or </span><span class="s1">reading </span><span class="s2">or </span><span class="s1">writing </span><span class="s2">or </span><span class="s1">appending):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;must have exactly one of read/write/append mode&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">binary </span><span class="s2">and </span><span class="s1">encoding </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;binary mode doesn't take an encoding argument&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">binary </span><span class="s2">and </span><span class="s1">errors </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;binary mode doesn't take an errors argument&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">binary </span><span class="s2">and </span><span class="s1">newline </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;binary mode doesn't take a newline argument&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">binary </span><span class="s2">and </span><span class="s1">buffering == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">warnings</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;line buffering (buffering=1) isn't supported in binary &quot;</span>
                          <span class="s4">&quot;mode, the default buffer size will be used&quot;</span><span class="s2">,</span>
                          <span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>

        <span class="s1">self._fobj = fobj</span>
        <span class="s1">self.fileio_mode = (</span>
            <span class="s1">(creating </span><span class="s2">and </span><span class="s4">&quot;x&quot; </span><span class="s2">or </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">+ (reading </span><span class="s2">and </span><span class="s4">&quot;r&quot; </span><span class="s2">or </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">+ (writing </span><span class="s2">and </span><span class="s4">&quot;w&quot; </span><span class="s2">or </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">+ (appending </span><span class="s2">and </span><span class="s4">&quot;a&quot; </span><span class="s2">or </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">+ (updating </span><span class="s2">and </span><span class="s4">&quot;+&quot; </span><span class="s2">or </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">self.mode = self.fileio_mode + (</span><span class="s4">'t' </span><span class="s2">if </span><span class="s1">text </span><span class="s2">else </span><span class="s4">''</span><span class="s1">) + (</span><span class="s4">'b' </span><span class="s2">if </span><span class="s1">binary </span><span class="s2">else </span><span class="s4">''</span><span class="s1">)</span>

        <span class="s1">self.creating = creating</span>
        <span class="s1">self.reading = reading</span>
        <span class="s1">self.writing = writing</span>
        <span class="s1">self.appending = appending</span>
        <span class="s1">self.updating = updating</span>
        <span class="s1">self.text = text</span>
        <span class="s1">self.binary = binary</span>
        <span class="s1">self.can_write = can_write</span>
        <span class="s1">self.can_read = reading </span><span class="s2">or </span><span class="s1">updating</span>
        <span class="s1">self.native = (</span>
            <span class="s2">not </span><span class="s1">self.text </span><span class="s2">and not </span><span class="s1">self.binary </span><span class="s5"># Neither t nor b given.</span>
            <span class="s2">and not </span><span class="s1">encoding </span><span class="s2">and not </span><span class="s1">errors </span><span class="s5"># And no encoding or error handling either.</span>
        <span class="s1">)</span>
        <span class="s1">self.universal = universal</span>

        <span class="s1">self.buffering = buffering</span>
        <span class="s1">self.encoding = encoding</span>
        <span class="s1">self.errors = errors</span>
        <span class="s1">self.newline = newline</span>
        <span class="s1">self.closefd = closefd</span>
        <span class="s1">self.atomic_write = atomic_write</span>

    <span class="s1">default_buffer_size = io.DEFAULT_BUFFER_SIZE</span>

    <span class="s1">_opened = </span><span class="s2">None</span>
    <span class="s1">_opened_raw = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">is_fd(self):</span>
        <span class="s2">return </span><span class="s1">isinstance(self._fobj</span><span class="s2">, </span><span class="s1">integer_types)</span>

    <span class="s2">def </span><span class="s1">opened(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the :meth:`wrapped` file object. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._opened </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">raw = self.opened_raw()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self._opened = self.__wrapped(raw)</span>
            <span class="s2">except</span><span class="s1">:</span>
                <span class="s5"># XXX: This might be a bug? Could we wind up closing</span>
                <span class="s5"># something we shouldn't close?</span>
                <span class="s1">raw.close()</span>
                <span class="s2">raise</span>
        <span class="s2">return </span><span class="s1">self._opened</span>

    <span class="s2">def </span><span class="s1">_raw_object_is_new(self</span><span class="s2">, </span><span class="s1">raw):</span>
        <span class="s2">return </span><span class="s1">self._fobj </span><span class="s2">is not </span><span class="s1">raw</span>

    <span class="s2">def </span><span class="s1">opened_raw(self):</span>
        <span class="s2">if </span><span class="s1">self._opened_raw </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._opened_raw = self._do_open_raw()</span>
        <span class="s2">return </span><span class="s1">self._opened_raw</span>

    <span class="s2">def </span><span class="s1">_do_open_raw(self):</span>
        <span class="s2">if </span><span class="s1">hasattr(self._fobj</span><span class="s2">, </span><span class="s4">'fileno'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self._fobj</span>
        <span class="s5"># io.FileIO doesn't allow assigning to its __class__,</span>
        <span class="s5"># and we can't know for sure here whether we need the atomic write()</span>
        <span class="s5"># method or not (it depends on the layers on top of us),</span>
        <span class="s5"># so we use a subclass that *does* allow assigning.</span>
        <span class="s2">return </span><span class="s1">FileIO(self._fobj</span><span class="s2">, </span><span class="s1">self.fileio_mode</span><span class="s2">, </span><span class="s1">self.closefd)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">is_buffered(stream):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s5"># buffering happens internally in the text codecs</span>
            <span class="s1">isinstance(stream</span><span class="s2">, </span><span class="s1">(io.BufferedIOBase</span><span class="s2">, </span><span class="s1">io.TextIOBase))</span>
            <span class="s2">or </span><span class="s1">(hasattr(stream</span><span class="s2">, </span><span class="s4">'buffer'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">stream.buffer </span><span class="s2">is not None</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">buffer_size_for_stream(cls</span><span class="s2">, </span><span class="s1">stream):</span>
        <span class="s1">result = cls.default_buffer_size</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">bs = os.fstat(stream.fileno()).st_blksize</span>
        <span class="s2">except </span><span class="s1">(OSError</span><span class="s2">, </span><span class="s1">AttributeError):</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">bs &gt; </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">result = bs</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">__buffered(self</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">buffering):</span>
        <span class="s2">if </span><span class="s1">self.updating:</span>
            <span class="s1">Buffer = io.BufferedRandom</span>
        <span class="s2">elif </span><span class="s1">self.creating </span><span class="s2">or </span><span class="s1">self.writing </span><span class="s2">or </span><span class="s1">self.appending:</span>
            <span class="s1">Buffer = io.BufferedWriter</span>
        <span class="s2">elif </span><span class="s1">self.reading:</span>
            <span class="s1">Buffer = io.BufferedReader</span>
        <span class="s2">else</span><span class="s1">: </span><span class="s5"># prgama: no cover</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;unknown mode: %r&quot; </span><span class="s1">% self.mode)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">result = Buffer(stream</span><span class="s2">, </span><span class="s1">buffering)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s5"># Python 2 file() objects don't have the readable/writable</span>
            <span class="s5"># attributes. But they handle their own buffering.</span>
            <span class="s1">result = stream</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_make_atomic_write(self</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">raw):</span>
        <span class="s5"># The idea was to swizzle the class with one that defines</span>
        <span class="s5"># write() to call writeall(). This avoids setting any</span>
        <span class="s5"># attribute on the return object, avoids an additional layer</span>
        <span class="s5"># of proxying, and avoids any reference cycles (if setting a</span>
        <span class="s5"># method on the object).</span>
        <span class="s5">#</span>
        <span class="s5"># However, this is not possible with the built-in io classes</span>
        <span class="s5"># (static types defined in C cannot have __class__ assigned).</span>
        <span class="s5"># Fortunately, we need this only for the specific case of</span>
        <span class="s5"># opening a file descriptor (subprocess.py) on Python 2, in</span>
        <span class="s5"># which we fully control the types involved.</span>
        <span class="s5">#</span>
        <span class="s5"># So rather than attempt that, we only implement exactly what we need.</span>
        <span class="s2">if </span><span class="s1">result </span><span class="s2">is not </span><span class="s1">raw </span><span class="s2">or </span><span class="s1">self._raw_object_is_new(raw):</span>
            <span class="s2">if </span><span class="s1">result.__class__ </span><span class="s2">is </span><span class="s1">FileIO:</span>
                <span class="s1">result.__class__ = WriteallFileIO</span>
            <span class="s2">else</span><span class="s1">: </span><span class="s5"># pragma: no cover</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s4">&quot;Don't know how to make %s have atomic write. &quot;</span>
                    <span class="s4">&quot;Please open a gevent issue with your use-case.&quot; </span><span class="s1">% (</span>
                        <span class="s1">result</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">__wrapped(self</span><span class="s2">, </span><span class="s1">raw):</span>
        <span class="s0">&quot;&quot;&quot; 
        Wraps the raw IO object (`RawIOBase` or `io.TextIOBase`) in 
        buffers, text decoding, and newline handling. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.binary </span><span class="s2">and </span><span class="s1">isinstance(raw</span><span class="s2">, </span><span class="s1">io.TextIOBase):</span>
            <span class="s5"># Can't do it. The TextIO object will have its own buffer, and</span>
            <span class="s5"># trying to read from the raw stream or the buffer without going through</span>
            <span class="s5"># the TextIO object is likely to lead to problems with the codec.</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unable to perform binary IO on top of text IO stream&quot;</span><span class="s1">)</span>

        <span class="s1">result = raw</span>
        <span class="s1">buffering = self.buffering</span>

        <span class="s1">line_buffering = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">buffering == </span><span class="s3">1 </span><span class="s2">or </span><span class="s1">buffering &lt; </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">raw.isatty():</span>
            <span class="s1">buffering = -</span><span class="s3">1</span>
            <span class="s1">line_buffering = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">buffering &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">buffering = self.buffer_size_for_stream(result)</span>

        <span class="s2">if </span><span class="s1">buffering &lt; </span><span class="s3">0</span><span class="s1">: </span><span class="s5"># pragma: no cover</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;invalid buffering size&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">buffering != </span><span class="s3">0 </span><span class="s2">and not </span><span class="s1">self.is_buffered(result):</span>
            <span class="s5"># Need to wrap our own buffering around it. If it</span>
            <span class="s5"># is already buffered, don't do so.</span>
            <span class="s1">result = self.__buffered(result</span><span class="s2">, </span><span class="s1">buffering)</span>

        <span class="s2">if not </span><span class="s1">self.binary:</span>
            <span class="s5"># Either native or text at this point.</span>
            <span class="s2">if </span><span class="s1">PY2 </span><span class="s2">and </span><span class="s1">self.native:</span>
                <span class="s5"># Neither text mode nor binary mode specified.</span>
                <span class="s2">if </span><span class="s1">self.universal:</span>
                    <span class="s5"># universal was requested, e.g., 'rU'</span>
                    <span class="s1">result = UniversalNewlineBytesWrapper(result</span><span class="s2">, </span><span class="s1">line_buffering)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s5"># Python 2 and text mode, or Python 3 and either text or native (both are the same)</span>
                <span class="s2">if not </span><span class="s1">isinstance(raw</span><span class="s2">, </span><span class="s1">io.TextIOBase):</span>
                    <span class="s5"># Avoid double-wrapping a TextIOBase in another TextIOWrapper.</span>
                    <span class="s5"># That tends not to work. See https://github.com/gevent/gevent/issues/1542</span>
                    <span class="s1">result = io.TextIOWrapper(result</span><span class="s2">, </span><span class="s1">self.encoding</span><span class="s2">, </span><span class="s1">self.errors</span><span class="s2">, </span><span class="s1">self.newline</span><span class="s2">,</span>
                                              <span class="s1">line_buffering)</span>

        <span class="s2">if </span><span class="s1">result </span><span class="s2">is not </span><span class="s1">raw </span><span class="s2">or </span><span class="s1">self._raw_object_is_new(raw):</span>
            <span class="s5"># Set the mode, if possible, but only if we created a new</span>
            <span class="s5"># object.</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">result.mode = self.mode</span>
            <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">TypeError):</span>
                <span class="s5"># AttributeError: No such attribute</span>
                <span class="s5"># TypeError: Readonly attribute (py2)</span>
                <span class="s2">pass</span>

        <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">self.atomic_write</span>
                <span class="s2">and not </span><span class="s1">self.is_buffered(result)</span>
                <span class="s2">and not </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">WriteIsWriteallMixin)</span>
        <span class="s1">):</span>
            <span class="s5"># Let subclasses have a say in how they make this atomic, and</span>
            <span class="s5"># whether or not they do so even if we're actually returning the raw object.</span>
            <span class="s1">result = self._make_atomic_write(result</span><span class="s2">, </span><span class="s1">raw)</span>

        <span class="s2">return </span><span class="s1">result</span>


<span class="s2">class </span><span class="s1">_ClosedIO(object):</span>
    <span class="s5"># Used for FileObjectBase._io when FOB.close()</span>
    <span class="s5"># is called. Lets us drop references to ``_io``</span>
    <span class="s5"># for GC/resource cleanup reasons, but keeps some useful</span>
    <span class="s5"># information around.</span>
    <span class="s1">__slots__ = (</span><span class="s4">'name'</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">io_obj):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.name = io_obj.name</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s4">'name'</span><span class="s1">:</span>
            <span class="s5"># We didn't set it in __init__ because there wasn't one</span>
            <span class="s2">raise </span><span class="s1">AttributeError</span>
        <span class="s2">raise </span><span class="s1">FileObjectClosed</span>

    <span class="s2">def </span><span class="s1">__bool__(self):</span>
        <span class="s2">return False</span>
    <span class="s1">__nonzero__ = __bool__</span>


<span class="s2">class </span><span class="s1">FileObjectBase(object):</span>
    <span class="s0">&quot;&quot;&quot; 
    Internal base class to ensure a level of consistency 
    between :class:`~.FileObjectPosix`, :class:`~.FileObjectThread` 
    and :class:`~.FileObjectBlock`. 
    &quot;&quot;&quot;</span>

    <span class="s5"># List of methods we delegate to the wrapping IO object, if they</span>
    <span class="s5"># implement them and we do not.</span>
    <span class="s1">_delegate_methods = (</span>
        <span class="s5"># General methods</span>
        <span class="s4">'flush'</span><span class="s2">,</span>
        <span class="s4">'fileno'</span><span class="s2">,</span>
        <span class="s4">'writable'</span><span class="s2">,</span>
        <span class="s4">'readable'</span><span class="s2">,</span>
        <span class="s4">'seek'</span><span class="s2">,</span>
        <span class="s4">'seekable'</span><span class="s2">,</span>
        <span class="s4">'tell'</span><span class="s2">,</span>

        <span class="s5"># Read</span>
        <span class="s4">'read'</span><span class="s2">,</span>
        <span class="s4">'readline'</span><span class="s2">,</span>
        <span class="s4">'readlines'</span><span class="s2">,</span>
        <span class="s4">'read1'</span><span class="s2">,</span>

        <span class="s5"># Write.</span>
        <span class="s5"># Note that we do not extend WriteallMixin,</span>
        <span class="s5"># so writeall will be copied, if it exists, and</span>
        <span class="s5"># wrapped.</span>
        <span class="s4">'write'</span><span class="s2">,</span>
        <span class="s4">'writeall'</span><span class="s2">,</span>
        <span class="s4">'writelines'</span><span class="s2">,</span>
        <span class="s4">'truncate'</span><span class="s2">,</span>
    <span class="s1">)</span>


    <span class="s1">_io = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">descriptor):</span>
        <span class="s5"># type: (OpenDescriptor) -&gt; None</span>
        <span class="s1">self._io = descriptor.opened()</span>
        <span class="s5"># We don't actually use this property ourself, but we save it (and</span>
        <span class="s5"># pass it along) for compatibility.</span>
        <span class="s1">self._close = descriptor.closefd</span>
        <span class="s1">self._do_delegate_methods()</span>


    <span class="s1">io = property(</span><span class="s2">lambda </span><span class="s1">s: s._io</span><span class="s2">,</span>
                  <span class="s5"># Historically we either hand-wrote all the delegation methods</span>
                  <span class="s5"># to use self.io, or we simply used __getattr__ to look them up at</span>
                  <span class="s5"># runtime. This meant people could change the io attribute on the fly</span>
                  <span class="s5"># and it would mostly work (subprocess.py used to do that). We don't recommend</span>
                  <span class="s5"># that, but we still support it.</span>
                  <span class="s2">lambda </span><span class="s1">s</span><span class="s2">, </span><span class="s1">nv: setattr(s</span><span class="s2">, </span><span class="s4">'_io'</span><span class="s2">, </span><span class="s1">nv) </span><span class="s2">or </span><span class="s1">s._do_delegate_methods())</span>

    <span class="s2">def </span><span class="s1">_do_delegate_methods(self):</span>
        <span class="s2">for </span><span class="s1">meth_name </span><span class="s2">in </span><span class="s1">self._delegate_methods:</span>
            <span class="s1">meth = getattr(self._io</span><span class="s2">, </span><span class="s1">meth_name</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">implemented_by_class = hasattr(type(self)</span><span class="s2">, </span><span class="s1">meth_name)</span>
            <span class="s2">if </span><span class="s1">meth </span><span class="s2">and not </span><span class="s1">implemented_by_class:</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">meth_name</span><span class="s2">, </span><span class="s1">self._wrap_method(meth))</span>
            <span class="s2">elif </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s1">meth_name) </span><span class="s2">and not </span><span class="s1">implemented_by_class:</span>
                <span class="s1">delattr(self</span><span class="s2">, </span><span class="s1">meth_name)</span>

    <span class="s2">def </span><span class="s1">_wrap_method(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s0">&quot;&quot;&quot; 
        Wrap a method we're copying into our dictionary from the underlying 
        io object to do something special or different, if necessary. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">method</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">closed(self):</span>
        <span class="s0">&quot;&quot;&quot;True if the file is closed&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isinstance(self._io</span><span class="s2">, </span><span class="s1">_ClosedIO)</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s2">if </span><span class="s1">isinstance(self._io</span><span class="s2">, </span><span class="s1">_ClosedIO):</span>
            <span class="s2">return</span>

        <span class="s1">fobj = self._io</span>
        <span class="s1">self._io = _ClosedIO(self._io)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._do_close(fobj</span><span class="s2">, </span><span class="s1">self._close)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">fobj = </span><span class="s2">None</span>
            <span class="s5"># Remove delegate methods to drop remaining references to</span>
            <span class="s5"># _io.</span>
            <span class="s1">d = self.__dict__</span>
            <span class="s2">for </span><span class="s1">meth_name </span><span class="s2">in </span><span class="s1">self._delegate_methods:</span>
                <span class="s1">d.pop(meth_name</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_do_close(self</span><span class="s2">, </span><span class="s1">fobj</span><span class="s2">, </span><span class="s1">closefd):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">return </span><span class="s1">getattr(self._io</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'&lt;%s at 0x%x %s_fobj=%r%s&gt;' </span><span class="s1">% (</span>
            <span class="s1">self.__class__.__name__</span><span class="s2">,</span>
            <span class="s1">id(self)</span><span class="s2">,</span>
            <span class="s4">'closed' </span><span class="s2">if </span><span class="s1">self.closed </span><span class="s2">else </span><span class="s4">''</span><span class="s2">,</span>
            <span class="s1">self.io</span><span class="s2">,</span>
            <span class="s1">self._extra_repr()</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_extra_repr(self):</span>
        <span class="s2">return </span><span class="s4">''</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">self.close()</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__next__(self):</span>
        <span class="s1">line = self.readline()</span>
        <span class="s2">if not </span><span class="s1">line:</span>
            <span class="s2">raise </span><span class="s1">StopIteration</span>
        <span class="s2">return </span><span class="s1">line</span>

    <span class="s1">next = __next__</span>

    <span class="s2">def </span><span class="s1">__bool__(self):</span>
        <span class="s2">return True</span>

    <span class="s1">__nonzero__ = __bool__</span>


<span class="s2">class </span><span class="s1">FileObjectBlock(FileObjectBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    FileObjectBlock() 
 
    A simple synchronous wrapper around a file object. 
 
    Adds no concurrency or gevent compatibility. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fobj</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">descriptor = OpenDescriptor(fobj</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">FileObjectBase.__init__(self</span><span class="s2">, </span><span class="s1">descriptor)</span>

    <span class="s2">def </span><span class="s1">_do_close(self</span><span class="s2">, </span><span class="s1">fobj</span><span class="s2">, </span><span class="s1">closefd):</span>
        <span class="s1">fobj.close()</span>


<span class="s2">class </span><span class="s1">FileObjectThread(FileObjectBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    FileObjectThread() 
 
    A file-like object wrapping another file-like object, performing all blocking 
    operations on that object in a background thread. 
 
    .. caution:: 
        Attempting to change the threadpool or lock of an existing FileObjectThread 
        has undefined consequences. 
 
    .. versionchanged:: 1.1b1 
       The file object is closed using the threadpool. Note that whether or 
       not this action is synchronous or asynchronous is not documented. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        :keyword bool lock: If True (the default) then all operations will 
           be performed one-by-one. Note that this does not guarantee that, if using 
           this file object from multiple threads/greenlets, operations will be performed 
           in any particular order, only that no two operations will be attempted at the 
           same time. You can also pass your own :class:`gevent.lock.Semaphore` to synchronize 
           file operations with an external resource. 
        :keyword bool closefd: If True (the default) then when this object is closed, 
           the underlying object is closed as well. If *fobj* is a path, then 
           *closefd* must be True. 
        &quot;&quot;&quot;</span>
        <span class="s1">lock = kwargs.pop(</span><span class="s4">'lock'</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">threadpool = kwargs.pop(</span><span class="s4">'threadpool'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">descriptor = OpenDescriptor(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s1">self.threadpool = threadpool </span><span class="s2">or </span><span class="s1">get_hub().threadpool</span>
        <span class="s1">self.lock = lock</span>
        <span class="s2">if </span><span class="s1">self.lock </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s1">self.lock = Semaphore()</span>
        <span class="s2">elif not </span><span class="s1">self.lock:</span>
            <span class="s1">self.lock = DummySemaphore()</span>
        <span class="s2">if not </span><span class="s1">hasattr(self.lock</span><span class="s2">, </span><span class="s4">'__enter__'</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">'Expected a Semaphore or boolean, got %r' </span><span class="s1">% type(self.lock))</span>

        <span class="s1">self.__io_holder = [descriptor.opened()] </span><span class="s5"># signal for _wrap_method</span>
        <span class="s1">FileObjectBase.__init__(self</span><span class="s2">, </span><span class="s1">descriptor)</span>

    <span class="s2">def </span><span class="s1">_do_close(self</span><span class="s2">, </span><span class="s1">fobj</span><span class="s2">, </span><span class="s1">closefd):</span>
        <span class="s1">self.__io_holder[</span><span class="s3">0</span><span class="s1">] = </span><span class="s2">None </span><span class="s5"># for _wrap_method</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">self.lock:</span>
                <span class="s1">self.threadpool.apply(fobj.flush)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">closefd:</span>
                <span class="s5"># Note that we're not taking the lock; older code</span>
                <span class="s5"># did fobj.close() without going through the threadpool at all,</span>
                <span class="s5"># so acquiring the lock could potentially introduce deadlocks</span>
                <span class="s5"># that weren't present before. Avoiding the lock doesn't make</span>
                <span class="s5"># the existing race condition any worse.</span>
                <span class="s5"># We wrap the close in an exception handler and re-raise directly</span>
                <span class="s5"># to avoid the (common, expected) IOError from being logged by the pool</span>
                <span class="s2">def </span><span class="s1">close(_fobj=fobj):</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">_fobj.close()</span>
                    <span class="s2">except</span><span class="s1">: </span><span class="s5"># pylint:disable=bare-except</span>
                        <span class="s2">return </span><span class="s1">sys.exc_info()</span>
                    <span class="s2">finally</span><span class="s1">:</span>
                        <span class="s1">_fobj = </span><span class="s2">None</span>
                <span class="s2">del </span><span class="s1">fobj</span>

                <span class="s1">exc_info = self.threadpool.apply(close)</span>
                <span class="s2">del </span><span class="s1">close</span>

                <span class="s2">if </span><span class="s1">exc_info:</span>
                    <span class="s1">reraise(*exc_info)</span>

    <span class="s2">def </span><span class="s1">_do_delegate_methods(self):</span>
        <span class="s1">FileObjectBase._do_delegate_methods(self)</span>
        <span class="s1">self.__io_holder[</span><span class="s3">0</span><span class="s1">] = self._io</span>

    <span class="s2">def </span><span class="s1">_extra_repr(self):</span>
        <span class="s2">return </span><span class="s4">' threadpool=%r' </span><span class="s1">% (self.threadpool</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_wrap_method(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s5"># NOTE: We are careful to avoid introducing a refcycle</span>
        <span class="s5"># within self. Our wrapper cannot refer to self.</span>
        <span class="s1">io_holder = self.__io_holder</span>
        <span class="s1">lock = self.lock</span>
        <span class="s1">threadpool = self.threadpool</span>

        <span class="s1">@functools.wraps(method)</span>
        <span class="s2">def </span><span class="s1">thread_method(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
            <span class="s2">if </span><span class="s1">io_holder[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s5"># This is different than FileObjectPosix, etc,</span>
                <span class="s5"># because we want to save the expensive trip through</span>
                <span class="s5"># the threadpool.</span>
                <span class="s2">raise </span><span class="s1">FileObjectClosed</span>
            <span class="s2">with </span><span class="s1">lock:</span>
                <span class="s2">return </span><span class="s1">threadpool.apply(method</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs)</span>

        <span class="s2">return </span><span class="s1">thread_method</span>
</pre>
</body>
</html>